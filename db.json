{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"700ec67224fab5638bebbb0b908cf4ec19fd0a8f","modified":1553703910298},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1553703910311},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1553703910311},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1553703910312},{"_id":"themes/next/_config.yml","hash":"c918def4171a386c388ca47d90cf1cdb9ecddcdb","modified":1553703910312},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1553703910312},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1553703910312},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1553703910318},{"_id":"source/_posts/3-areas-to-drive-DevOps-change.md","hash":"e8452f8b6bbb9ec24bf8b720eb8e15ac97999e16","modified":1553776171327},{"_id":"source/_posts/3-implications-of-serverless.md","hash":"bb05321e60ba88e3a2237bad3b0ffca5a107d611","modified":1553778735791},{"_id":"source/_posts/5-Easy-Tips-for-Linux-Web-Browser-Security.md","hash":"f30e6958b55c8fcbf5af99e2c2338b9306c5a274","modified":1553778451264},{"_id":"source/_posts/5-Essential-Tools-for-Linux-Development.md","hash":"6e2fec2855aeca5e08230e144942d25801a398a3","modified":1553771693742},{"_id":"source/_posts/5-Ways-to-Take-Screenshot-in-Linux-GUI-and-Terminal.md","hash":"1bd55c0de578da217f6377ad779305a63449429d","modified":1553770964983},{"_id":"source/_posts/5-alerting-and-visualization-tools-for-sysadmins.md","hash":"bdb5edc6e320c07217f8659224158d356afb8152","modified":1553776523204},{"_id":"source/_posts/5-tips-for-choosing-the-right-open-source-database.md","hash":"f66c10f43d2eaff41bd38559af86ca9436914169","modified":1553775891600},{"_id":"source/_posts/7-Python-libraries-for-more-maintainable-code.md","hash":"6c96468308c52091f12aedd61ebb250b86eb2a1f","modified":1553752673830},{"_id":"source/_posts/75-Most-Used-Essential-Linux-Applications-of-2018.md","hash":"093f0b607cd9f119b03fb0c1bded9e2673144228","modified":1553771909987},{"_id":"source/_posts/Aliases-DIY-Shell-Commands.md","hash":"ca8319e05199d849901900acb56bdc0f0417889a","modified":1553779063318},{"_id":"source/_posts/An-Overview-of-Android-Pie.md","hash":"013a0838508bec754a8335b4959547a3ff4681d9","modified":1553778346691},{"_id":"source/_posts/Ansible-Inventory-file.md","hash":"dd255e89c32668762c72e7f841e2c17ee92f0b09","modified":1553703910298},{"_id":"source/_posts/Bash-Variables-Environmental-and-Otherwise.md","hash":"6a89239d6a99135580eb983bd1cb5981a3907080","modified":1553778967836},{"_id":"source/_posts/Browsing-the-web-with-Min-a-minimalist-open-source-web-browser.md","hash":"dd2ab24317361414ad4fb13528f285e181c26add","modified":1553776080186},{"_id":"source/_posts/Check-Linux-Distribution-Name-and-Version.md","hash":"5ea0647a6e4c4c0d89bf1a6dd032d8307f0882f8","modified":1553751814516},{"_id":"source/_posts/Gitbase-Exploring-git-repos-with-SQL.md","hash":"e3c12f460cad7415c70953b953594b9c9ea8da32","modified":1553777371705},{"_id":"source/_posts/How-To-Customize-Bash-Prompt-In-Linux.md","hash":"dd64a8986db8274a648d950ca6d84b26328c180f","modified":1553778149677},{"_id":"source/_posts/How-To-Easily-And-Safely-Manage-Cron-Jobs-In-Linux.md","hash":"296461fa110b331a70d160a189c2704239b14a66","modified":1553771275054},{"_id":"source/_posts/How-To-Find-Out-Which-Port-Number-A-Process-Is-Using-In-Linux.md","hash":"84a70eea373d1db3fc17389261104a6f620b9e93","modified":1553771120341},{"_id":"source/_posts/How-To-Limit-Network-Bandwidth-In-Linux-Using-Wondershaper.md","hash":"a8ba96a7d25d03e1f671e412ca2783a30823dac2","modified":1553771562752},{"_id":"source/_posts/How-To-List-An-Available-Package-Groups-In-Linux.md","hash":"d0145a7e4ff57be53e6cbcc973edba044845ef67","modified":1553774226016},{"_id":"source/_posts/How-to-Replace-one-Linux-Distro-With-Another-in-Dual-Boot-Guide.md","hash":"29ea459f9688c4d76a0e5eff76e5a1a8bf1cbc2f","modified":1553774414181},{"_id":"source/_posts/How-to-Use-RAR-files-in-Ubuntu-Linux.md","hash":"3c66dd3611cb5d7aebcc911b5a095438770068fd","modified":1553771459417},{"_id":"source/_posts/How-to-measure-particulate-matter-with-a-Raspberry-Pi.md","hash":"73b6335fa084d0e237d981563361345394e469a2","modified":1553751848543},{"_id":"source/_posts/How-to-use-Ansible-to-patch-systems-and-install-applications.md","hash":"8e2b588f4a464d218b50b5e6a1e64607b7f4d940","modified":1553752334220},{"_id":"source/_posts/Introducing-pydbgen-A-random-dataframe-database-table-generator.md","hash":"1e744d83277a908299300425d833c9c406f32b17","modified":1553777268324},{"_id":"source/_posts/Linux-tricks-that-can-save-you-time-and-trouble.md","hash":"c1e6665d2689e785a8f1ba1689a9a7d97d19aa52","modified":1553752653332},{"_id":"source/_posts/Machine-learning-with-Python-Essential-hacks-and-tricks.md","hash":"c8f2a6d11d2d94bf242dfb5b2166070e7de80751","modified":1553776315216},{"_id":"source/_posts/Make-The-Output-Of-Ping-Command-Prettier-And-Easier-To-Read.md","hash":"5223a705e6115bfdbce9b06105bb2d0ff6a9f8c5","modified":1553752782843},{"_id":"source/_posts/ProtectedText-A-Free-Encrypted-Notepad-To-Save-Your-Notes-Online.md","hash":"ac0d554033aa9a7a38717ad6c340afcda1298200","modified":1553777947772},{"_id":"source/_posts/Python-at-the-pump-A-script-for-filling-your-gas-tank.md","hash":"0aa07fd87c64f1570610a4c934bc8ebeb8e97229","modified":1553774326882},{"_id":"source/_posts/Randomize-your-MAC-address-using-NetworkManager.md","hash":"4bb6ce76a957592ca1ec05643eb427b7334d6b8c","modified":1553752320845},{"_id":"source/_posts/Running-DOS-on-the-Raspberry-Pi.md","hash":"e540375a0b2a9ef64ef17055c2fae9f4c6c31671","modified":1553751349428},{"_id":"source/_posts/Some-Alternatives-To-top-Command-line-Utility-You-Might-Want-To-Know.md","hash":"0c0002d084aef01f5cecf7654603d17fe2307859","modified":1553778565664},{"_id":"source/_posts/Some-Good-Alternatives-To-du-Command.md","hash":"75935c48d9db025773248aba0a679fe9b7c55270","modified":1553776948475},{"_id":"source/_posts/The-Difference-Between-more-less-And-most-Commands.md","hash":"49f3e3d416f6236e3dcaab1907b391e0eba937ff","modified":1553777853176},{"_id":"source/_posts/Ultimate-Plumber-Writing-Linux-Pipes-With-Instant-Live-Preview.md","hash":"9846ce6d093c4d4f07aedf839752e0c02df3934e","modified":1553776419113},{"_id":"source/_posts/Understand-Fedora-memory-usage-with-top.md","hash":"f54d4b90c0353a27de5b535f7c66b4c0621623e8","modified":1553752304587},{"_id":"source/_posts/What-you-need-to-know-about-the-GPL-Cooperation-Commitment.md","hash":"9528f960828cc4877e1dea96fe9b58aba6d6862c","modified":1553778264258},{"_id":"source/_posts/Why-is-Python-so-slow.md","hash":"a964c01596b3c2dabeeb8670864917f0b6439ad4","modified":1553774942102},{"_id":"source/_posts/YAML-grammar.md","hash":"695afb3ceeb3bf9c011b00daab6edb95db11236c","modified":1553703910298},{"_id":"source/_posts/a-pitfall-of-connecting-failure-to-mysql-in-docker.md","hash":"7c8734f1ba478f368a9d6bb767e79ddec43da6a3","modified":1553703910298},{"_id":"source/_posts/a-pitfall-of-re-findall-with-brackets-in-Python.md","hash":"5b39e309b2b280491942d8bc17cbba66eb588be0","modified":1553703910298},{"_id":"source/_posts/docs.md","hash":"44aa4a399bf27b640bac7d697f379b1807a2f249","modified":1553703910298},{"_id":"source/_posts/filting-data-in-dictionaries-in-Python.md","hash":"78b6f2903fd2613097fb5d089b795b756ab9fb55","modified":1553703910298},{"_id":"source/_posts/how-to-SSH-with-sshekeys.md","hash":"c689378252e53eca9a626c776de0efeb97a64126","modified":1553703910299},{"_id":"source/_posts/how-to-build-LAMP-environment-on-CentOS-7.md","hash":"6e025c0ecc74cdb6fdf7886ddacc3333d5aeed7b","modified":1553703910299},{"_id":"source/_posts/how-to-find-duplicated-lines-in-files.md","hash":"6b9f4cfcfcb918ca2c2ebfb83fc8e5fefb99896f","modified":1553703910299},{"_id":"source/_posts/how-to-fix-Python-UnicodeEncodeError-on-Windows.md","hash":"008ea10a54ab37ef085922f6eb62de2bd5aa3b9c","modified":1553703910299},{"_id":"source/_posts/how-to-grant-sudo-privilege-to-a-normal-user.md","hash":"d411428e8ab253ab9f2ca003c5f1737bc0bbc551","modified":1553703910299},{"_id":"source/_posts/how-to-install-Python-3-quickly.md","hash":"0187291446a1e9a27b5bfdb7f2ebd60528c2d387","modified":1553703910299},{"_id":"source/_posts/how-to-install-and-manage-ruby.md","hash":"44b84c0b343ee1363f7b0a9968820102898ecfa2","modified":1553703910299},{"_id":"source/_posts/how-to-install-zsh-quickly.md","hash":"4b31021fb59848b6aef823a3a1c471d1bf5be6bf","modified":1553703910299},{"_id":"source/_posts/how-to-return-dictionary-when-using-pymysql-module-for-querying.md","hash":"b7dc165001075e0ff47935a2dd0d6c81c5b5f2cd","modified":1553703910299},{"_id":"source/_posts/how-to-save-files-using-sudo-without-quitting-vim.md","hash":"d11a15ff0d75f8cbc873b23f950b4ae062c77172","modified":1553703910299},{"_id":"source/_posts/how-to-use-headless-browser-of-firefox.md","hash":"da6a09c00a1aa1a99ce4886d5b8777678c7c62b6","modified":1553703910299},{"_id":"source/_posts/how-to-use-mysqldump-without-password.md","hash":"514be3997025f3c22abac3014d7701ef8d15a7d6","modified":1553703910299},{"_id":"source/_posts/initiation-of-saltstack.md","hash":"9bd5defce4a6443870c69258feb7c731c865f321","modified":1553703910299},{"_id":"source/_posts/list-deduplication-in-Python.md","hash":"a29e3ae01392be066c1ede5f62288acff4936d14","modified":1553703910299},{"_id":"source/_posts/methods-and-pitfalls-on-maintaining-hexo-github-blog-from-multiple-devices.md","hash":"00b9d6daa5a200279db66e1eaf53744bb0f0046b","modified":1553703910299},{"_id":"source/_posts/new-class-and-classic-class-in-Python.md","hash":"560a5a75b66c13072bf151be11b0c858ed4c6e4f","modified":1553703910300},{"_id":"source/_posts/pitfalls-of-online-installing-plugin-in-WordPress.md","hash":"cd5bc4e73baaa4c8338997e1da4128354fc274a3","modified":1553703910300},{"_id":"source/_posts/set-alias-for-remote-hosts.md","hash":"f8e56e895e26aa382046d764e381775ec5e0c059","modified":1553703910300},{"_id":"source/_posts/some-modules-and-related-parameters-in-Ansible.md","hash":"b8e5eff1a9b899f9672b8b0706f08fb6e30899ac","modified":1553703910300},{"_id":"source/_posts/sorting-with-multi-keys-in-Python.md","hash":"1f604f24a6e16d392b6406ef61f218e66c6a85fe","modified":1553703910300},{"_id":"source/_posts/systemctl-configurations-on-CentOS-7.md","hash":"5de74c82b16b48264798e1953173de924bb65b04","modified":1553703910300},{"_id":"source/_posts/the-difference-between-MyISAM-and-InnoDB-in-MySQL.md","hash":"882330b8c1481c646a8597ab93c95b1151f877f6","modified":1553703910300},{"_id":"source/_posts/the-parameter-ensure-ascii-in-json-dumps.md","hash":"c466c944b961db5a43d77401868c1c9100319089","modified":1553703910300},{"_id":"source/_posts/the-transformation-among-timestamp-formatted-time-datetime-and-time-tuple-in-Python.md","hash":"43be1d7b5677c3f539b687c47f79ed77d1ea71da","modified":1553703910300},{"_id":"source/_posts/why-WITH-block-is-recommended-for-reading-and-writing-files.md","hash":"a67f8573ec0b8d754185866a8ae2435340ad11f6","modified":1553703910300},{"_id":"source/about/index.md","hash":"1f944c81a537d6fde276563b34b75404b404f459","modified":1553703910300},{"_id":"source/images/avatar.jpg","hash":"9861f6998162acab25cf673f35bb439dfe8b964e","modified":1553703910300},{"_id":"source/tags/index.md","hash":"d6f3a9aff6e2fc978ff1409d8f149ae6d83251a9","modified":1553703910301},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1553703910312},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1553703910312},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1553703910312},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1553703910312},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1553703910313},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1553703910313},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1553703910313},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1553703910313},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1553703910313},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1553703910313},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1553703910313},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1553703910313},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1553703910313},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1553703910313},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1553703910313},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1553703910313},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1553703910313},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1553703910317},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1553703910317},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1553703910317},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1553703910317},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1553703910317},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1553703910317},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1553703910317},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1553703910318},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1553703910318},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1553703910364},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1553703910364},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1553703910364},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910325},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553703910313},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553703910313},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1553703910313},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1553703910313},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1553703910314},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1553703910314},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1553703910314},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1553703910314},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1553703910314},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1553703910314},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1553703910314},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1553703910314},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1553703910314},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1553703910314},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1553703910314},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1553703910315},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1553703910315},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1553703910315},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1553703910316},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1553703910316},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1553703910316},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1553703910316},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1553703910317},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1553703910317},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1553703910317},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1553703910318},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1553703910318},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1553703910318},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1553703910318},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1553703910318},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1553703910319},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1553703910319},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1553703910319},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1553703910319},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1553703910325},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553703910325},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1553703910325},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1553703910325},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1553703910325},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1553703910325},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1553703910325},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1553703910326},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1553703910326},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1553703910326},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1553703910326},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1553703910326},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1553703910326},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553703910326},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1553703910326},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553703910326},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1553703910326},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1553703910326},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1553703910326},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910315},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910315},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910323},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910323},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910323},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910324},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553703910325},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1553703910314},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1553703910314},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1553703910314},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1553703910314},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1553703910314},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1553703910315},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1553703910315},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1553703910315},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1553703910315},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1553703910315},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553703910315},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1553703910315},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1553703910316},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1553703910316},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1553703910316},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1553703910317},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1553703910317},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1553703910317},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1553703910317},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1553703910323},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1553703910323},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1553703910323},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1553703910323},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1553703910324},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1553703910324},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1553703910324},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1553703910325},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1553703910326},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553703910326},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1553703910326},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553703910327},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1553703910327},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553703910327},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1553703910327},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1553703910327},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553703910327},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1553703910327},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1553703910327},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553703910330},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553703910333},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1553703910333},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1553703910333},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1553703910333},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1553703910335},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553703910335},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1553703910335},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1553703910335},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1553703910336},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1553703910341},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1553703910342},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1553703910342},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1553703910342},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1553703910342},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553703910342},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553703910342},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1553703910355},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1553703910355},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553703910355},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553703910356},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553703910356},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1553703910357},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1553703910357},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553703910357},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1553703910361},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1553703910361},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553703910363},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553703910364},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553703910364},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553703910342},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1553703910317},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1553703910317},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1553703910321},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1553703910322},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1553703910322},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1553703910323},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1553703910323},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1553703910323},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1553703910323},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553703910323},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1553703910324},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1553703910327},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553703910328},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553703910329},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553703910330},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553703910333},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553703910333},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553703910335},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553703910335},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553703910336},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553703910336},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553703910337},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553703910361},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553703910361},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553703910329},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553703910341},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553703910341},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553703910363},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1553703910319},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1553703910320},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1553703910321},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1553703910322},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1553703910322},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553703910324},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553703910324},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553703910328},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553703910328},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553703910328},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553703910328},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1553703910328},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553703910334},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553703910334},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553703910337},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553703910339},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553703910340},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553703910333},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553703910361},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553703910340},{"_id":"public/search.xml","hash":"15650b0bc9bcc749b68de20e0d315f7f81f869db","modified":1553779152018},{"_id":"public/about/index.html","hash":"f91b6d1920c26893fcb2e66ff2c103c409a595b6","modified":1553779152346},{"_id":"public/tags/index.html","hash":"82ba41c2c073d1d5e2a1eeabdc724c4f0d614cb8","modified":1553779152346},{"_id":"public/2019/03/27/methods-and-pitfalls-on-maintaining-hexo-github-blog-from-multiple-devices/index.html","hash":"13113b74d55e8c1823f5a5f4e41c314b41fb6479","modified":1553779152346},{"_id":"public/2018/12/25/how-to-install-and-manage-ruby/index.html","hash":"ddeed1ef3313382f58a216484066cdba6d0cac97","modified":1553779152346},{"_id":"public/2018/12/24/Aliases-DIY-Shell-Commands/index.html","hash":"a199cfc1bcd1c66ca24305e4b6e452f2b569b51e","modified":1553779152346},{"_id":"public/2018/12/23/Bash-Variables-Environmental-and-Otherwise/index.html","hash":"fdaf9016ac2f58dfaa29fd08a1a445eb9220c904","modified":1553779152346},{"_id":"public/2018/12/11/3-implications-of-serverless/index.html","hash":"43b03358a53338a60f86959800815ade50f08844","modified":1553779152346},{"_id":"public/2018/12/08/Some-Alternatives-To-top-Command-line-Utility-You-Might-Want-To-Know/index.html","hash":"4e2135db9299113db04f2871dadbf3bdee18cc8b","modified":1553779152346},{"_id":"public/2018/12/03/5-Easy-Tips-for-Linux-Web-Browser-Security/index.html","hash":"96cc4d2d3d5bd1662c84448ccda8ded4af3615ab","modified":1553779152346},{"_id":"public/2018/11/29/An-Overview-of-Android-Pie/index.html","hash":"ecbfce8c58d13f82bac6764d5d4f4c1b2638f14d","modified":1553779152346},{"_id":"public/2018/11/28/What-you-need-to-know-about-the-GPL-Cooperation-Commitment/index.html","hash":"48e7d4b2147df0d4a75bdc2fe3ba651f71cbc9ff","modified":1553779152347},{"_id":"public/2018/11/26/How-To-Customize-Bash-Prompt-In-Linux/index.html","hash":"cef674927e3786c3956abb16c94369fbe7ecf9e3","modified":1553779152347},{"_id":"public/2018/11/25/ProtectedText-A-Free-Encrypted-Notepad-To-Save-Your-Notes-Online/index.html","hash":"593e8aa3aa99395bca79b8ef7d5f9629945b847e","modified":1553779152347},{"_id":"public/2018/11/21/a-pitfall-of-connecting-failure-to-mysql-in-docker/index.html","hash":"d902d5530e5ff240d07b0c8e6dc87e2f1d5f4e36","modified":1553779152347},{"_id":"public/2018/11/19/The-Difference-Between-more-less-And-most-Commands/index.html","hash":"980f4bd984855eaef6a8531d919e7ba5adf48760","modified":1553779152347},{"_id":"public/2018/11/19/Gitbase-Exploring-git-repos-with-SQL/index.html","hash":"e279f92b31c3feea53b38a2cfba2f9ce68661a68","modified":1553779152347},{"_id":"public/2018/11/17/Introducing-pydbgen-A-random-dataframe-database-table-generator/index.html","hash":"950096279b3ca99237d91cc99d35f7f363b83e5c","modified":1553779152347},{"_id":"public/2018/11/16/Some-Good-Alternatives-To-du-Command/index.html","hash":"27b00302996ec6d1bde262fc74e1f38a3b3f34e7","modified":1553779152347},{"_id":"public/2018/11/11/5-alerting-and-visualization-tools-for-sysadmins/index.html","hash":"ab0683aa763b9ddb5ab0086683c1570f35490a9c","modified":1553779152347},{"_id":"public/2018/11/08/Ultimate-Plumber-Writing-Linux-Pipes-With-Instant-Live-Preview/index.html","hash":"755e49ec54822fde7ad66abe2385622d222041c6","modified":1553779152347},{"_id":"public/2018/11/08/Machine-learning-with-Python-Essential-hacks-and-tricks/index.html","hash":"aa6e1eba459cba7017312429bb3307d60d3ec7f0","modified":1553779152347},{"_id":"public/2018/11/05/3-areas-to-drive-DevOps-change/index.html","hash":"b3565033e0a0fcdb8193368fe6023cc7faf3c9dc","modified":1553779152348},{"_id":"public/2018/11/04/Browsing-the-web-with-Min-a-minimalist-open-source-web-browser/index.html","hash":"dbe3f63f39c3a71b4234b9f9a4ca4ee4196669b1","modified":1553779152348},{"_id":"public/2018/11/01/5-tips-for-choosing-the-right-open-source-database/index.html","hash":"9517d077f8403ecbaa650c8efb734d4516cb2eac","modified":1553779152348},{"_id":"public/2018/10/27/Why-is-Python-so-slow/index.html","hash":"6b5846eb343a7cd2e794ea7dc71934fe394d5d20","modified":1553779152348},{"_id":"public/2018/10/20/How-to-Replace-one-Linux-Distro-With-Another-in-Dual-Boot-Guide/index.html","hash":"b650050354431b81cc9195d4f81381fbde831d76","modified":1553779152348},{"_id":"public/2018/10/20/the-parameter-ensure-ascii-in-json-dumps/index.html","hash":"3340f219c781a42311d4022c83a05c617344c618","modified":1553779152348},{"_id":"public/2018/10/17/Python-at-the-pump-A-script-for-filling-your-gas-tank/index.html","hash":"da78f301f3173233567722c5fc8d0d24eb9f1ecd","modified":1553779152348},{"_id":"public/2018/10/14/How-To-List-An-Available-Package-Groups-In-Linux/index.html","hash":"5e8948315104b469c3167b80fd3edf28de857bcb","modified":1553779152348},{"_id":"public/2018/10/10/75-Most-Used-Essential-Linux-Applications-of-2018/index.html","hash":"12b02be7fc3fc9e374b8f52889b73bc23cc71f0b","modified":1553779152348},{"_id":"public/2018/10/08/5-Essential-Tools-for-Linux-Development/index.html","hash":"c502139ad48e08cf1e8db349fc9d11fc05ad7900","modified":1553779152349},{"_id":"public/2018/10/05/How-To-Limit-Network-Bandwidth-In-Linux-Using-Wondershaper/index.html","hash":"7948a5180e9d6948e58e4a3526131002cdc4507c","modified":1553779152349},{"_id":"public/2018/10/03/How-to-Use-RAR-files-in-Ubuntu-Linux/index.html","hash":"5d928fb881dbc49893b2c370d30d00199141390a","modified":1553779152349},{"_id":"public/2018/10/03/How-To-Easily-And-Safely-Manage-Cron-Jobs-In-Linux/index.html","hash":"29de2b73d0c74de48e5d836dc057a36e422c0e06","modified":1553779152349},{"_id":"public/2018/10/02/How-To-Find-Out-Which-Port-Number-A-Process-Is-Using-In-Linux/index.html","hash":"0db5f34d2d62ca1d02d4eb991dececf13fcb2837","modified":1553779152349},{"_id":"public/2018/10/01/5-Ways-to-Take-Screenshot-in-Linux-GUI-and-Terminal/index.html","hash":"c1afd287793d292cc711422b019f8fbf38a3b529","modified":1553779152349},{"_id":"public/2018/09/30/Make-The-Output-Of-Ping-Command-Prettier-And-Easier-To-Read/index.html","hash":"6b4dd9034fc13174babef63e5f8e53816eb724b2","modified":1553779152349},{"_id":"public/2018/09/29/Linux-tricks-that-can-save-you-time-and-trouble/index.html","hash":"864648296bcf767c84c6f8e0f7afd9349fad4e45","modified":1553779152349},{"_id":"public/2018/09/29/7-Python-libraries-for-more-maintainable-code/index.html","hash":"820cc061e6f3ddbe5b782fe4019dce6e8d24b50c","modified":1553779152349},{"_id":"public/2018/09/26/Understand-Fedora-memory-usage-with-top/index.html","hash":"06992369ce6e12ba58ca08db66ac1bec7405e4a9","modified":1553779152349},{"_id":"public/2018/09/19/Randomize-your-MAC-address-using-NetworkManager/index.html","hash":"ed3e1ca3e67c415d53ec0922accae646244a467f","modified":1553779152350},{"_id":"public/2018/08/11/a-pitfall-of-re-findall-with-brackets-in-Python/index.html","hash":"81d976eb7d6f1ef32a91a3fed9d002e16454423c","modified":1553779152350},{"_id":"public/2018/07/11/filting-data-in-dictionaries-in-Python/index.html","hash":"dd62f12f9a2b88070a234fa938250fac939c064e","modified":1553779152350},{"_id":"public/2018/07/10/initiation-of-saltstack/index.html","hash":"a0dce55ec1ca75d04615c8a871ef8840392f0d81","modified":1553779152350},{"_id":"public/2018/05/19/How-to-use-Ansible-to-patch-systems-and-install-applications/index.html","hash":"c568b91f68d0b94d17ceed43a8104ca3607e96ec","modified":1553779152350},{"_id":"public/2018/05/08/How-to-measure-particulate-matter-with-a-Raspberry-Pi/index.html","hash":"0bc2d6c9334fab5a3dedd864aaddfe69155bbef8","modified":1553779152350},{"_id":"public/2018/04/28/Check-Linux-Distribution-Name-and-Version/index.html","hash":"6fab85e46e3100f06eff01e3b1dd03deb92a20e3","modified":1553779152350},{"_id":"public/2018/04/14/Running-DOS-on-the-Raspberry-Pi/index.html","hash":"30dec690a99fb0b63fe3c473d5bdf4f43f4235fd","modified":1553779152350},{"_id":"public/2018/04/09/how-to-use-mysqldump-without-password/index.html","hash":"5626b3093dca7123325ee2cec2d1f0509e67e961","modified":1553779152350},{"_id":"public/2017/08/16/sorting-with-multi-keys-in-Python/index.html","hash":"029e6160ff8c824d563e78fb61b6fa5b08cff3e8","modified":1553779152350},{"_id":"public/2017/04/28/how-to-install-zsh-quickly/index.html","hash":"239e893ee402422ce4edbec66c5c96350a278ad7","modified":1553779152351},{"_id":"public/2017/04/01/how-to-grant-sudo-privilege-to-a-normal-user/index.html","hash":"85a7b56367090822c158bb5865e279273ca56abe","modified":1553779152351},{"_id":"public/2017/03/04/how-to-use-headless-browser-of-firefox/index.html","hash":"a3ed1ad9e12c501983577ef0023d3d43ae2a84d6","modified":1553779152351},{"_id":"public/2017/02/16/some-modules-and-related-parameters-in-Ansible/index.html","hash":"e37a31710284413ea05bde7ee6e8cc859d851676","modified":1553779152351},{"_id":"public/2016/12/12/how-to-find-duplicated-lines-in-files/index.html","hash":"eca73c8a31d1d8c7760d954de1a0daec588d0551","modified":1553779152351},{"_id":"public/2016/12/01/how-to-return-dictionary-when-using-pymysql-module-for-querying/index.html","hash":"dddcbc3182d6debc6bd3021e37581eaeecc30a97","modified":1553779152351},{"_id":"public/2016/09/09/systemctl-configurations-on-CentOS-7/index.html","hash":"fdf8e5e6b637ebc17f4968571d6af64b394913e4","modified":1553779152351},{"_id":"public/2016/07/20/YAML-grammar/index.html","hash":"d0dd58413489535185b1ade2b99365279eb5d810","modified":1553779152351},{"_id":"public/2016/07/18/Ansible-Inventory-file/index.html","hash":"0665fcda122ca183a167cb1b8d7de76ae3315a19","modified":1553779152351},{"_id":"public/2016/03/01/docs/index.html","hash":"11981289841ba6070f42d670e61bd7f48c76bac1","modified":1553779152351},{"_id":"public/2016/02/14/how-to-install-Python-3-quickly/index.html","hash":"8964c622da954c0ae77d7d50f547dbf64cfe1aeb","modified":1553779152351},{"_id":"public/2016/01/29/how-to-save-files-using-sudo-without-quitting-vim/index.html","hash":"664299b4cbf2c64972f0a6400036461d054627a5","modified":1553779152351},{"_id":"public/2015/12/13/the-difference-between-MyISAM-and-InnoDB-in-MySQL/index.html","hash":"b2935a3769b172f1aa8ca0650914c36219572101","modified":1553779152352},{"_id":"public/2015/10/13/list-deduplication-in-Python/index.html","hash":"9849ec054959944d504045e161b96a6423a18605","modified":1553779152352},{"_id":"public/2015/10/11/why-WITH-block-is-recommended-for-reading-and-writing-files/index.html","hash":"a1b3ce53240c0566ee7e9dbc102304635bd48922","modified":1553779152352},{"_id":"public/2015/08/19/new-class-and-classic-class-in-Python/index.html","hash":"3f4dad32a771694d50583ef4fc9c92c1f6732c8c","modified":1553779152352},{"_id":"public/2015/06/28/how-to-fix-Python-UnicodeEncodeError-on-Windows/index.html","hash":"3a883f7075cfd1a346659f7eb65bba096da70149","modified":1553779152352},{"_id":"public/2015/03/15/how-to-SSH-with-sshekeys/index.html","hash":"c94a592a897678d2acca3ffccddc830eb03aa552","modified":1553779152352},{"_id":"public/2015/03/01/set-alias-for-remote-hosts/index.html","hash":"74698c4120d8e10746703ee12901ac65296828b3","modified":1553779152352},{"_id":"public/2015/02/13/pitfalls-of-online-installing-plugin-in-WordPress/index.html","hash":"59e0f3b029a1c7e6ecae1b1b3593e02aaf051756","modified":1553779152352},{"_id":"public/2014/12/03/the-transformation-among-timestamp-formatted-time-datetime-and-time-tuple-in-Python/index.html","hash":"6f001a751ebc6bb106d3f5d677ad758553670a6a","modified":1553779152352},{"_id":"public/2014/11/29/how-to-build-LAMP-environment-on-CentOS-7/index.html","hash":"3f4a9a6e93ba21af54f3b362db7f9a02185988cf","modified":1553779152352},{"_id":"public/archives/index.html","hash":"2447c2902c7c908ae84fded64e942949bead61b4","modified":1553779152352},{"_id":"public/archives/page/2/index.html","hash":"0b7cf54f355bbfb6149bbbb3c9d412781c51d184","modified":1553779152353},{"_id":"public/archives/page/3/index.html","hash":"cb2c0094d59707859b7a622f0dc0f0657aac63f2","modified":1553779152353},{"_id":"public/archives/page/4/index.html","hash":"4ce9cfe25a6e7f881ec5b48b559eec96612b0886","modified":1553779152353},{"_id":"public/archives/page/5/index.html","hash":"735faf187d933aa010d7741de793b4ee7a6367e4","modified":1553779152353},{"_id":"public/archives/page/6/index.html","hash":"ca418754f4a10c888c96b4cac1eeb90a9cdcce30","modified":1553779152353},{"_id":"public/archives/page/7/index.html","hash":"a1b21d108207f05b6cef191a26771fec8cb3564f","modified":1553779152353},{"_id":"public/archives/2014/index.html","hash":"0ca719f405995b3432ac5f2afc63128ee81ccf62","modified":1553779152353},{"_id":"public/archives/2014/11/index.html","hash":"28a0a21a63208bb045d5a6895c3c595a5ad404aa","modified":1553779152353},{"_id":"public/archives/2014/12/index.html","hash":"f175b625f15b0bd43547701af30e65995905e012","modified":1553779152353},{"_id":"public/archives/2015/index.html","hash":"2f9ec292c757381ed5af4822bc322209509e0b3c","modified":1553779152353},{"_id":"public/archives/2015/02/index.html","hash":"2a40c21cba432cac12488ff7e3d75c408c8c70f7","modified":1553779152354},{"_id":"public/archives/2015/03/index.html","hash":"ff1afb605f327fed407e386d79faa60798c92b5d","modified":1553779152354},{"_id":"public/archives/2015/06/index.html","hash":"d06a40cd9fe8bf49fcff5a6aa27ee2fc87aa001a","modified":1553779152354},{"_id":"public/archives/2015/08/index.html","hash":"a26b01432e668a038b44481875ba4a061e6d67f1","modified":1553779152354},{"_id":"public/archives/2015/10/index.html","hash":"d696048f28a89234884bf0db9cce3aaf17ccd064","modified":1553779152354},{"_id":"public/archives/2015/12/index.html","hash":"fc0ae3a9809906d4f1fb14b373143196221f773c","modified":1553779152354},{"_id":"public/archives/2016/index.html","hash":"37a1a5dc934e3378540b98233e0ba1d6690a70f6","modified":1553779152354},{"_id":"public/archives/2016/01/index.html","hash":"3d51bde748233bfbcdf0cf62f08d109beabd8168","modified":1553779152354},{"_id":"public/archives/2016/02/index.html","hash":"92b91e0bd7965025f2d0c59682e2d49fe32c0086","modified":1553779152354},{"_id":"public/archives/2016/03/index.html","hash":"e15e83f5ea10fb0955c8bc66b31e0d1b39a14f22","modified":1553779152354},{"_id":"public/archives/2016/07/index.html","hash":"9648c1793788021beb1d53cb2c149a1d541d5dca","modified":1553779152354},{"_id":"public/archives/2016/09/index.html","hash":"e7ff427ae1f0458896422da61884361915719b15","modified":1553779152355},{"_id":"public/archives/2016/12/index.html","hash":"a92a08664a7ea9516eda0795e002ab694baea448","modified":1553779152355},{"_id":"public/archives/2017/index.html","hash":"9de8b6d48b30ca06bcf564ebdeafa2ffc6d37192","modified":1553779152355},{"_id":"public/archives/2017/02/index.html","hash":"ac10c9a583066dfb3c7a40c03dd07ea8ddc57c99","modified":1553779152355},{"_id":"public/archives/2017/03/index.html","hash":"8574b95122e1bf456895d9289d8f42d0c2cb6900","modified":1553779152355},{"_id":"public/archives/2017/04/index.html","hash":"61610ddb396709141be18fdc158b579ea704e5dd","modified":1553779152355},{"_id":"public/archives/2017/08/index.html","hash":"b883837d3ddcc35c08b92f81db730a8f8e1c3077","modified":1553779152355},{"_id":"public/archives/2018/index.html","hash":"3037ac24907e45c94c72823a79cc876a4504d877","modified":1553779152355},{"_id":"public/archives/2018/page/2/index.html","hash":"e4816e79f147ba92dff70dbb15bf4bb4d1fa387a","modified":1553779152356},{"_id":"public/archives/2018/page/3/index.html","hash":"d6c39c66df625d968c1e2475e885129a168899eb","modified":1553779152356},{"_id":"public/archives/2018/page/4/index.html","hash":"d6401914f51b02bd85a57b128b65a784cff46751","modified":1553779152356},{"_id":"public/archives/2018/page/5/index.html","hash":"1e36b1047acae360abffb33a473bb63bf875dbc1","modified":1553779152356},{"_id":"public/archives/2018/04/index.html","hash":"0f6b1ee01944bd872166f1888386514a306f29af","modified":1553779152356},{"_id":"public/archives/2018/05/index.html","hash":"d5fb3e29ca0dc07f014f4d3593b9696a67f37610","modified":1553779152356},{"_id":"public/archives/2018/07/index.html","hash":"62d1d386444094c340fd147fd4ce965851cdcd86","modified":1553779152356},{"_id":"public/archives/2018/08/index.html","hash":"004c83eb978b0a79c1e440c48418ae07de0a58c5","modified":1553779152356},{"_id":"public/archives/2018/09/index.html","hash":"59c008d2aae89a1fa4dbc3027c82e85b2b98bf08","modified":1553779152356},{"_id":"public/archives/2018/10/index.html","hash":"c2c92d3d6e6c4ae1c1b41d7a15d421f2f841ad33","modified":1553779152356},{"_id":"public/archives/2018/10/page/2/index.html","hash":"f3397db0f391099a2c7bc4187564d6aa4c8a3505","modified":1553779152357},{"_id":"public/archives/2018/11/index.html","hash":"2c7bb43a9c0d675590966cf50675c7727e5ed69a","modified":1553779152357},{"_id":"public/archives/2018/11/page/2/index.html","hash":"7a1a58b58601136357b6e448f81bda9844f8b3fe","modified":1553779152357},{"_id":"public/archives/2018/12/index.html","hash":"a016d6740fa36a14312d234347a89867b8e6be24","modified":1553779152357},{"_id":"public/archives/2019/index.html","hash":"9802fb85e219d9d225778647f8611b76dfa7e89d","modified":1553779152357},{"_id":"public/archives/2019/03/index.html","hash":"fb94a44ee1cdf849a1580645391e52f5f2f87fab","modified":1553779152357},{"_id":"public/index.html","hash":"7671a4cc9aef37c25ce009daa1ccbae0516cfb8f","modified":1553779152357},{"_id":"public/page/2/index.html","hash":"7ce4fdf48843489b8333540318746a370347524b","modified":1553779152357},{"_id":"public/page/3/index.html","hash":"adbf425b697d10f19560b4c8ee7f7fe6856a6e4b","modified":1553779152357},{"_id":"public/page/4/index.html","hash":"d9aaa74eda7b165290591f6fbd12501aef8e78be","modified":1553779152358},{"_id":"public/page/5/index.html","hash":"d6fc98d2bd041ce0f6c274cf7a123bf566126424","modified":1553779152358},{"_id":"public/page/6/index.html","hash":"4f48d1be8ec9135026aee449e375017fe6954a98","modified":1553779152358},{"_id":"public/page/7/index.html","hash":"2ece7223c3570c2340764fa91704bc1b050de5cb","modified":1553779152358},{"_id":"public/page/8/index.html","hash":"58a0c3c4c6907e83b5acb00c9686632ee339040b","modified":1553779152358},{"_id":"public/page/9/index.html","hash":"7b0b3bda651ea837cb2963bf208a32257c910d7f","modified":1553779152359},{"_id":"public/page/10/index.html","hash":"8e8d5187f18c98861ca137e4cbf0493fc59c1ec3","modified":1553779152359},{"_id":"public/page/11/index.html","hash":"7a966357c117b553bb48f2116a3555d1113e6bac","modified":1553779152359},{"_id":"public/page/12/index.html","hash":"05de5f49690258e52246336979b0ea7811ca63d3","modified":1553779152359},{"_id":"public/page/13/index.html","hash":"c1b4e6fed9f34e83277a2bdc510a52de363a650c","modified":1553779152360},{"_id":"public/page/14/index.html","hash":"9419de168ae461f66de913063f53f41fcec58a8c","modified":1553779152360},{"_id":"public/tags/DevOps/index.html","hash":"91569aa14b91f458d599bd4617c642d6957cf341","modified":1553779152360},{"_id":"public/tags/LCTT-翻译/index.html","hash":"930931ab71e7d424abc56a96b53d2362eca5ef58","modified":1553779152360},{"_id":"public/tags/LCTT-翻译/page/2/index.html","hash":"f7f10b963c1bb7a61211e561552191010cf0a7cd","modified":1553779152360},{"_id":"public/tags/LCTT-翻译/page/3/index.html","hash":"51d91c96a191f8cfe2fcfd06087ece416d0035cd","modified":1553779152360},{"_id":"public/tags/LCTT-翻译/page/4/index.html","hash":"69dea883528dcb079e3e89c8e9158a78da958163","modified":1553779152360},{"_id":"public/tags/无服务器架构/index.html","hash":"4b6ff3d971e6be8fac124bb021603c021d7175ac","modified":1553779152360},{"_id":"public/tags/Linux/index.html","hash":"2fb012b7c9f1f2914f57cfac69c214b1f9452f6a","modified":1553779152361},{"_id":"public/tags/Linux/page/2/index.html","hash":"f8c886687b459adba9927372e45dfed9d7ac53f6","modified":1553779152361},{"_id":"public/tags/Linux/page/3/index.html","hash":"54a202848c4f68344575beda2828c2c93813579d","modified":1553779152361},{"_id":"public/tags/浏览器/index.html","hash":"d3cf306be1757f17d24ae9f417947299e008496c","modified":1553779152361},{"_id":"public/tags/安全/index.html","hash":"af9d88f6957fdc897f60838d12604528cfd0b440","modified":1553779152361},{"_id":"public/tags/截屏/index.html","hash":"dd748b72c2df14674f0c167508d1fc1d650bec75","modified":1553779152361},{"_id":"public/tags/可视化/index.html","hash":"e64ed583cb2177e83c40164394824f6493af4dd2","modified":1553779152361},{"_id":"public/tags/告警/index.html","hash":"d6d82e13c999d84c130edf25d8d74f506ed58819","modified":1553779152361},{"_id":"public/tags/数据库/index.html","hash":"50aad15c0176d9c0a9090be75014de2d8743dda7","modified":1553779152361},{"_id":"public/tags/Python/index.html","hash":"cc7684f0cc8ce2627768cb6bb564636f0413052d","modified":1553779152361},{"_id":"public/tags/Python/page/2/index.html","hash":"b00dfcfd7ffa8fc0fd318bd0d5f0f88aba79fed3","modified":1553779152361},{"_id":"public/tags/应用/index.html","hash":"76f283c85aa3563cd522eb0247dce491e5375873","modified":1553779152362},{"_id":"public/tags/命令/index.html","hash":"51a00d5ee856ce778ce47738bb0669b62e955a67","modified":1553779152362},{"_id":"public/tags/Android/index.html","hash":"ff9dc0f7ecc982d9541f5b23031a8b0ba6c85b7b","modified":1553779152362},{"_id":"public/tags/Ansible/index.html","hash":"202ef515499475eb8f5ee7d6b04e6b7deef31c30","modified":1553779152362},{"_id":"public/tags/Bash/index.html","hash":"4757831f9cee4413c100aeea7b3284cd7889f8ff","modified":1553779152362},{"_id":"public/tags/环境变量/index.html","hash":"9aaf8fade1fffe0614634a43872d7fb0c5750ddd","modified":1553779152362},{"_id":"public/tags/版本/index.html","hash":"0bbd2ebc6760dacd84c12261e0195aeedea63173","modified":1553779152362},{"_id":"public/tags/发行版/index.html","hash":"802d210fa6f372e34724afab46141ba4e71999a8","modified":1553779152362},{"_id":"public/tags/git/index.html","hash":"ad49aee39ed9ec1af28cf238d8ba4546246ca524","modified":1553779152362},{"_id":"public/tags/SQL/index.html","hash":"f828b617eca7f6f5afeddf99e7f59d5dfd51d93e","modified":1553779152362},{"_id":"public/tags/cron/index.html","hash":"d0a24cb3c9c9079d097e5392bf73bd8d189febad","modified":1553779152363},{"_id":"public/tags/端口/index.html","hash":"47c55bc49bcbd242e7592e3f33af105e85409a1b","modified":1553779152363},{"_id":"public/tags/网络/index.html","hash":"e57e75e4f4958bfe7d35c8281ac5f2378beb0065","modified":1553779152363},{"_id":"public/tags/软件包/index.html","hash":"677f8b1beee63ce895e8d25382032b2d67e8c5d6","modified":1553779152363},{"_id":"public/tags/双系统/index.html","hash":"53898c102be3529c1f8293dd4eca14969591088d","modified":1553779152363},{"_id":"public/tags/rar/index.html","hash":"926a4064c46b6a8f18b616446dbcd092608f8c63","modified":1553779152363},{"_id":"public/tags/树莓派/index.html","hash":"ee1a1fd6c4ad20821d319e9c476687207cd8b097","modified":1553779152363},{"_id":"public/tags/随机/index.html","hash":"85360055a50f584162d8a86b5c6cba35063629f9","modified":1553779152363},{"_id":"public/tags/机器学习/index.html","hash":"900fe305fc3900d1642a37adcd9b909f5176d1d2","modified":1553779152363},{"_id":"public/tags/ping/index.html","hash":"fc5a65349cfcb2871013826e6c97f366e938d0a1","modified":1553779152363},{"_id":"public/tags/加密/index.html","hash":"e5ce8439e628573e4067736247e236880b78ae86","modified":1553779152363},{"_id":"public/tags/Mac/index.html","hash":"c3ab932108155aa1a90bd916715782b09e012371","modified":1553779152364},{"_id":"public/tags/Wi-Fi/index.html","hash":"a90de89afc3da71ede6605cd22ff1e29229908ef","modified":1553779152364},{"_id":"public/tags/DoS/index.html","hash":"5b1fae7a22cc480687550cf852f95ded727b87b0","modified":1553779152364},{"_id":"public/tags/top/index.html","hash":"e666a5496da822e1b76957e31732c411d25b5318","modified":1553779152364},{"_id":"public/tags/管道/index.html","hash":"ac33f6f091db37238816c167ec18bae4dc0f7f49","modified":1553779152364},{"_id":"public/tags/内存/index.html","hash":"156413962ae23bdc9d4b40119ebe187c3ea6b40f","modified":1553779152364},{"_id":"public/tags/GPL/index.html","hash":"40a653f47621e65999a7d9eb290cdecfba14b635","modified":1553779152364},{"_id":"public/tags/YAML/index.html","hash":"caa4e20fd08ebf08c6dc39e00c4b4396bc05329f","modified":1553779152364},{"_id":"public/tags/Docker/index.html","hash":"dc03b3e471a2ed54cf8d3cf84c694ac4f7b1d5f3","modified":1553779152364},{"_id":"public/tags/MySQL/index.html","hash":"321c431629db42d57b43d9a933e88afa2f4e9f11","modified":1553779152364},{"_id":"public/tags/坑/index.html","hash":"6745ca4da2082b671d6c6357f22bbcc52c33f9df","modified":1553779152365},{"_id":"public/tags/正则表达式/index.html","hash":"fb1b50d9ffc00bbec0976196d50ebdb3172f0ee8","modified":1553779152365},{"_id":"public/tags/文档/index.html","hash":"7b43b224a911b854aaa242d5b19678eb5d5593a1","modified":1553779152365},{"_id":"public/tags/奇技淫巧/index.html","hash":"a10ceb679dfe194de54bd603d7067599d01f2a17","modified":1553779152365},{"_id":"public/tags/ssh/index.html","hash":"77fd123b133a24f9f8cbca78ad6f9981318e7465","modified":1553779152365},{"_id":"public/tags/Apache/index.html","hash":"c5649c1b6ed7ae10c846aeedf84c8bd0fe6aaae9","modified":1553779152365},{"_id":"public/tags/LAMP/index.html","hash":"e9e9cdf4834e77b35c6ef06796c5bbca959a0903","modified":1553779152365},{"_id":"public/tags/PHP/index.html","hash":"ec69ab54d43a267c826a9e5aa3c385453913fd4a","modified":1553779152365},{"_id":"public/tags/Windows/index.html","hash":"8f235b3f107bcebf3a9e6ec1b4ea0bde82e659be","modified":1553779152365},{"_id":"public/tags/编码/index.html","hash":"cf0946394a65bf67753edd01994126f28f47a7ac","modified":1553779152365},{"_id":"public/tags/快速安装/index.html","hash":"db5a11e0617a875d2e96eeec2d0ad4779291d491","modified":1553779152365},{"_id":"public/tags/Ruby/index.html","hash":"d0f3ad34b4c923dd35831bcba4fb1ac27a8c2735","modified":1553779152366},{"_id":"public/tags/zsh/index.html","hash":"5d6131065300734aa8f18c057ad85c1f02507a6d","modified":1553779152366},{"_id":"public/tags/vim/index.html","hash":"6fc53284de3ad1e370161e53fdefbee30202eb46","modified":1553779152366},{"_id":"public/tags/Firefox/index.html","hash":"f9414ecf54aea202d8ff795a4521ba77f905b4c2","modified":1553779152366},{"_id":"public/tags/PhantomJS/index.html","hash":"169b2ffce89b5a4da87e74fbee36776cd6fd3864","modified":1553779152367},{"_id":"public/tags/Selenium/index.html","hash":"48b38a74022bf9c120b951cb2df804f6b4ad3a47","modified":1553779152368},{"_id":"public/tags/Saltstack/index.html","hash":"e31890f821eb59ede49b7a0eb7c2a1192c439e7a","modified":1553779152368},{"_id":"public/tags/GitHub/index.html","hash":"f36eb12bf3ec7ce593b2b52d8a8a9861998c732b","modified":1553779152368},{"_id":"public/tags/hexo/index.html","hash":"67c51f7e3c70086316714f0ad561f9a81305868a","modified":1553779152368},{"_id":"public/tags/类/index.html","hash":"0161743cc2f39c57e9284357f2217ec8ea3c52fd","modified":1553779152368},{"_id":"public/tags/WordPress/index.html","hash":"4ecdeed87812f78c40e1ea07868bcd572bdc8555","modified":1553779152368},{"_id":"public/CNAME","hash":"700ec67224fab5638bebbb0b908cf4ec19fd0a8f","modified":1553779152370},{"_id":"public/images/avatar.jpg","hash":"9861f6998162acab25cf673f35bb439dfe8b964e","modified":1553779152370},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553779152371},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1553779152371},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1553779152371},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1553779152371},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1553779152371},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1553779152371},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1553779152371},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1553779152371},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1553779152371},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1553779152371},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1553779152371},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1553779152371},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553779152371},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1553779152371},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553779152372},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1553779152372},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1553779152372},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1553779152372},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553779152372},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553779152372},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553779152378},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553779152378},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553779152378},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553779152378},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553779152378},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553779152378},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553779152383},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553779152383},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553779152384},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553779152384},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553779154174},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1553779154185},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553779154197},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553779154198},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553779154199},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1553779154227},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553779154228},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1553779154239},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553779154239},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1553779154239},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553779154239},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1553779154240},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1553779154240},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553779154240},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1553779154240},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1553779154240},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553779154240},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1553779154241},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553779154241},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1553779154241},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1553779154241},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1553779154241},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553779154241},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553779154242},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1553779154242},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553779154242},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553779154242},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553779154242},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553779154243},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553779154244},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553779154244},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553779154246},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1553779154247},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553779154247},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1553779154247},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553779154247},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553779154247},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553779154247},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553779154247},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553779154248},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1553779154248},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1553779154248},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1553779154248},{"_id":"public/css/main.css","hash":"a773822cd3e0ea8d8f50c07655713f2014ba32c2","modified":1553779154248},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1553779154248},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1553779154248},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1553779154249},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1553779154249},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553779154249},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553779154249},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553779154249},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553779154249},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553779154249},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553779154250},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553779154250},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553779154250},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553779154250},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553779154251},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553779154251},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553779154251},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553779154251},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553779154270},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553779154270},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553779154271},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553779154271},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553779154271},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553779154271},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553779154272},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553779154272},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553779154276},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553779154277},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553779154322}],"Category":[],"Data":[],"Page":[{"title":"Something about this site...","date":"2018-11-29T01:51:31.000Z","_content":"\n## 2018.11\n\n阿里云越来越贵了，不得已只能将 [hankchow.net](http://hankchow.net) 迁移至此。\n\n反正对于博客来说基本都是静态内容，不会造成太大的影响。 \n\n## 2014.7\n\n[hankchow.net](http://hankchow.net) 开始部署在阿里云。\n","source":"about/index.md","raw":"---\ntitle: Something about this site...\ndate: 2018-11-29 09:51:31\n---\n\n## 2018.11\n\n阿里云越来越贵了，不得已只能将 [hankchow.net](http://hankchow.net) 迁移至此。\n\n反正对于博客来说基本都是静态内容，不会造成太大的影响。 \n\n## 2014.7\n\n[hankchow.net](http://hankchow.net) 开始部署在阿里云。\n","updated":"2019-03-27T16:25:10.300Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtsnz0bg0001lixuqrcaint5","content":"<h2 id=\"2018-11\"><a href=\"#2018-11\" class=\"headerlink\" title=\"2018.11\"></a>2018.11</h2><p>阿里云越来越贵了，不得已只能将 <a href=\"http://hankchow.net\" target=\"_blank\" rel=\"noopener\">hankchow.net</a> 迁移至此。</p>\n<p>反正对于博客来说基本都是静态内容，不会造成太大的影响。 </p>\n<h2 id=\"2014-7\"><a href=\"#2014-7\" class=\"headerlink\" title=\"2014.7\"></a>2014.7</h2><p><a href=\"http://hankchow.net\" target=\"_blank\" rel=\"noopener\">hankchow.net</a> 开始部署在阿里云。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2018-11\"><a href=\"#2018-11\" class=\"headerlink\" title=\"2018.11\"></a>2018.11</h2><p>阿里云越来越贵了，不得已只能将 <a href=\"http://hankchow.net\" target=\"_blank\" rel=\"noopener\">hankchow.net</a> 迁移至此。</p>\n<p>反正对于博客来说基本都是静态内容，不会造成太大的影响。 </p>\n<h2 id=\"2014-7\"><a href=\"#2014-7\" class=\"headerlink\" title=\"2014.7\"></a>2014.7</h2><p><a href=\"http://hankchow.net\" target=\"_blank\" rel=\"noopener\">hankchow.net</a> 开始部署在阿里云。</p>\n"},{"title":"tags","date":"2018-11-29T04:11:00.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-29 12:11:00\n---\n","updated":"2019-03-27T16:25:10.301Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjtsnz0bk0003lixur985nnwe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"推动 DevOps 变革的三个方面","date":"2018-11-05T02:22:17.000Z","_content":"\n> 推动大规模的组织变革是一个痛苦的过程。对于 DevOps 来说，尽管也有阵痛，但变革带来的价值则相当可观。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/diversity-inclusion-transformation-change_20180927.png?itok=2E-g10hJ)\n\n避免痛苦是一种强大的动力。一些研究表明，[植物也会通过遭受疼痛的过程][1]以采取措施来保护自己。我们人类有时也会刻意让自己受苦——在剧烈运动之后，身体可能会发生酸痛，但我们仍然坚持运动。那是因为当人认为整个过程利大于弊时，几乎可以忍受任何事情。\n\n推动大规模的组织变革的过程确实是痛苦的。有人可能会因难以改变价值观和行为而感到痛苦，有人可能会因难以带领团队而感到痛苦，也有人可能会因难以开展工作而感到痛苦。但就 DevOps 而言，我可以说这些痛苦都是值得的。\n\n我也曾经关注过一个团队耗费大量时间优化技术流程的过程，在这个过程中，团队逐渐将流程进行自动化改造，并最终获得了成功。\n\n![Improvements after DevOps transformation][3]\n\n图片来源：Lee Eason. CC BY-SA 4.0\n\n这张图表充分表明了变革的价值。一家公司在我主导实行了 DevOps 转型之后，60 多个团队每月提交了超过 900 个发布请求。这些工作量的原耗时高达每个月 350 人/天，而这么多的工作量对于任何公司来说都是不可忽视的。除此以外，他们每月的部署次数从 100 次增加到了 9000 次，高危 bug 减少了 24%，工程师们更轻松了，<ruby>净推荐值<rt>Net Promoter Score</rt></ruby>（NPS）也提高了，而 NPS 提高反过来也让团队的 DevOps 转型更加顺利。正如 [Puppet 发布的 DevOps 报告][4]所预测的，用在技术流程改进上的投入可以在业务成果上明显地体现出来。\n\n而 DevOps 主导者在推动变革时必须关注这三个方面：团队管理，团队文化和团队活力。\n\n### 团队管理\n\n最重要的是，改进对技术流程的投入可以转化为更好的业务成果。\n\n组织架构越大，业务领导与一线员工之间的距离就会越大，当然发生误解的可能性也会越大。而且各种技术工具和实际应用都在以日新月异的速度变化，这就导致业务领导几乎不可能对 DevOps 或敏捷开发的转型方向有一个亲身的了解。\n\nDevOps 主导者必须和管理层密切合作，在进行决策的时候给出相关的意见，以帮助他们做出正确的决策。\n\n公司的管理层只是知道 DevOps 会对产品部署的方式进行改进，而并不了解其中的具体过程。假设你正在帮助一个软件开发团队实现自动化部署，当管理层得知某次部署失败时（这种情况是有的），就会想要了解这件事情的细节。如果管理层了解到进行部署的是软件团队而不是专门的发布管理团队，就可能会坚持使用传统的变更流程来保证业务的正常运作。你可能会失去团队的信任，团队也可能不愿意做出进一步的改变。\n\n如果没有和管理层做好心理上的预期，一旦发生意外的生产事件，重建管理层的信任并得到他们的支持比事先对他们进行教育需要更长的时间。所以，最好事先和管理层在各方面协调好，这会让你在后续的工作中避免很多麻烦。\n\n对于和管理层之间的协调，这里有两条建议：\n\n* 一是**重视所有规章制度**。如果管理层对合同、安全等各方面有任何疑问，你都可以向法务或安全负责人咨询，这样做可以避免犯下后果严重的错误。\n* 二是**将管理层重点关注的方面输出为量化指标**。举个例子，如果公司的目标是减少客户流失，而你调查得出计划外的服务宕机是造成客户流失的主要原因，那么就可以让团队对故障的<ruby>平均排查时间<rt>Mean Time To Detection</rt></ruby>（MTTD）和<ruby>平均解决时间<rt>Mean Time To Resolution</rt></ruby>（MTTR）实行重点优化。你可以使用这些关键指标来量化团队的工作成果，而管理层对此也可以有一个直观的了解。\n\n### 团队文化\n\nDevOps 是一种专注于持续改进代码、构建、部署和操作流程的文化，而团队文化代表了团队的价值观和行为。从本质上说，团队文化是要塑造团队成员的行为方式，而这并不是一件容易的事。\n\n我推荐一本叫做《[披着狼皮的 CIO][5]》的书。另外，研究心理学、阅读《[Drive][6]》、观看 Daniel Pink 的 [TED 演讲][7]、阅读《[千面英雄][7]》、了解每个人的心路历程，以上这些都是你推动公司技术变革所应该尝试去做的事情。如果这些你都没兴趣，说明你不是那个推动公司变革的人。如果你想成为那个人，那就开始学习吧！\n\n从本质上说，改变一个人真不是件容易的事。\n\n理性的人大多都按照自己的价值观工作，然而团队通常没有让每个人都能达成共识的明确价值观。因此，你需要明确团队目前的价值观，包括价值观的形成过程和价值观的目标导向。但不能将这些价值观强加到团队成员身上，只需要让团队成员在现有条件下力所能及地做到最好就可以了。\n\n同时需要向团队成员阐明，公司正在发生组织和团队目标的变化，团队的价值观也随之改变，最好也厘清整个过程中将会作出什么变化。例如，公司以往或许是由于资金有限，一直将节约成本的原则放在首位，在研发新产品的时候，基础架构团队不得不共享数据库集群或服务器，从而导致了服务之间的紧密耦合。然而随着时间的推移，这种做法会产生难以维护的混乱，即使是一个小小的变化也可能造成无法预料的后果。这就导致交付团队难以执行变更控制流程，进而令变更停滞不前。\n\n如果这种状况持续几年，最终的结果将会是毫无创新、技术老旧、问题繁多以及产品品质低下，公司的发展到达了瓶颈，原本的价值观已经不再适用。所以，工作效率的优先级必须高于节约成本。如果一个选择能让团队运作更好，另一个选择只是短期来看成本便宜，那你应该选择前者。\n\n你必须反复强调团队的价值观。每当团队取得了一定的工作进展（即使探索创新时出现一些小的失误），都应该对团队作出激励。在团队部署出现失败时，鼓励他们承担风险、吸取教训，同时指导团队如何改进他们的工作并表示支持。长此下来，团队成员就会对你产生信任，不再顾虑为切合团队的价值观而做出改变。\n\n### 团队活力\n\n你有没有在会议上听过类似这样的话？“在张三度假回来之前，我们无法对这件事情做出评估。他是唯一一个了解代码的人”，或者是“我们完成不了这项任务，它在网络上需要跨团队合作，而防火墙管理员刚好请病假了”，又或者是“张三最清楚这个系统，他说是怎么样，通常就是怎么样”。那么如果团队在处理工作时，谁才是主力？就是张三。而且也一直会是他。\n\n我们一直都认为这就是软件开发的自带属性。但是如果我们不作出改变，这种循环就会一直持续下去。\n\n熵的存在会让团队自发地变得混乱和缺乏活力，团队的成员和主导者的都有责任控制这个熵并保持团队的活力。DevOps、敏捷开发、上云、代码重构这些行为都会令熵加速增长，这是因为转型让团队需要学习更多新技能和专业知识以开展新工作。\n\n我们来看一个产品团队重构历史代码的例子。像往常一样，他们在 AWS 上构建新的服务。而传统的系统则在数据中心部署，并由 IT 部门进行监控和备份。IT 部门会确保在基础架构的层面上满足应用的安全需求、进行灾难恢复测试、系统补丁、安装配置了入侵检测和防病毒代理，而且 IT 部门还保留了年度审计流程所需的变更控制记录。\n\n产品团队经常会犯一个致命的错误，就是认为 IT 是消耗资源的部门，是需要突破的瓶颈。他们希望脱离已有的 IT 部门并使用公有云，但实际上是他们忽视了 IT 部门提供的关键服务。迁移到云上只是以不同的方式实现这些关键服务，因为 AWS 也是一个数据中心，团队即使使用 AWS 也需要完成 IT 运维任务。\n\n实际上，产品团队在向云迁移的时候也必须学习如何使用这些 IT 服务。因此，当产品团队开始重构历史代码并部署到云上时，也需要学习大量的技能才能正常运作。这些技能不会无师自通，必须自行学习或者聘用相关的人员，团队的主导者也必须积极进行管理。\n\n在带领团队时，我找不到任何适合我的工具，因此我建立了 [Tekita.io][9] 这个项目。Tekata 免费而且容易使用。但相比起来，把注意力集中在人员和流程上更为重要，你需要不断学习，持续关注团队的短板，因为它们会影响团队的交付能力，而弥补这些短板往往需要学习大量的新知识，这就需要团队成员之间有一个很好的协作。因此 76％ 的年轻人都认为个人发展机会是公司文化[最重要的的一环][10]。\n\n### 效果就是最好的证明\n\nDevOps 转型会改变团队的工作方式和文化，这需要得到管理层的支持和理解。同时，工作方式的改变意味着新技术的引入，所以在管理上也必须谨慎。但转型的最终结果是团队变得更高效、成员变得更积极、产品变得更优质，客户也变得更满意。\n\nLee Eason 将于 10 月 21-23 日在北卡罗来纳州 Raleigh 举行的 [All Things Open][12] 上讲述 [DevOps 转型的故事][11]。\n\n免责声明：本文中的内容仅为 Lee Eason 的个人立场，不代表 Ipreo 或 IHS Markit。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/tales-devops-transformation\n\n[a]: https://opensource.com/users/leeeason\n[b]: https://github.com/lujun9972\n[1]: https://link.springer.com/article/10.1007%2Fs00442-014-2995-6\n[2]: /file/411061\n[3]: https://opensource.com/sites/default/files/uploads/devops-delays.png \"Improvements after DevOps transformation\"\n[4]: https://puppet.com/resources/whitepaper/state-of-devops-report\n[5]: https://www.gartner.com/en/publications/wolf-cio\n[6]: https://en.wikipedia.org/wiki/Drive:_The_Surprising_Truth_About_What_Motivates_Us\n[7]: https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\n[8]: https://en.wikipedia.org/wiki/The_Hero_with_a_Thousand_Faces\n[9]: https://tekata.io/\n[10]: https://www.execu-search.com/~/media/Resources/pdf/2017_Hiring_Outlook_eBook\n[11]: https://allthingsopen.org/talk/tales-from-a-devops-transformation/\n[12]: https://allthingsopen.org/\n","source":"_posts/3-areas-to-drive-DevOps-change.md","raw":"---\ntitle: 推动 DevOps 变革的三个方面\ndate: 2018-11-05 10:22:17\ntags:\n  - DevOps\n  - LCTT 翻译\n---\n\n> 推动大规模的组织变革是一个痛苦的过程。对于 DevOps 来说，尽管也有阵痛，但变革带来的价值则相当可观。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/diversity-inclusion-transformation-change_20180927.png?itok=2E-g10hJ)\n\n避免痛苦是一种强大的动力。一些研究表明，[植物也会通过遭受疼痛的过程][1]以采取措施来保护自己。我们人类有时也会刻意让自己受苦——在剧烈运动之后，身体可能会发生酸痛，但我们仍然坚持运动。那是因为当人认为整个过程利大于弊时，几乎可以忍受任何事情。\n\n推动大规模的组织变革的过程确实是痛苦的。有人可能会因难以改变价值观和行为而感到痛苦，有人可能会因难以带领团队而感到痛苦，也有人可能会因难以开展工作而感到痛苦。但就 DevOps 而言，我可以说这些痛苦都是值得的。\n\n我也曾经关注过一个团队耗费大量时间优化技术流程的过程，在这个过程中，团队逐渐将流程进行自动化改造，并最终获得了成功。\n\n![Improvements after DevOps transformation][3]\n\n图片来源：Lee Eason. CC BY-SA 4.0\n\n这张图表充分表明了变革的价值。一家公司在我主导实行了 DevOps 转型之后，60 多个团队每月提交了超过 900 个发布请求。这些工作量的原耗时高达每个月 350 人/天，而这么多的工作量对于任何公司来说都是不可忽视的。除此以外，他们每月的部署次数从 100 次增加到了 9000 次，高危 bug 减少了 24%，工程师们更轻松了，<ruby>净推荐值<rt>Net Promoter Score</rt></ruby>（NPS）也提高了，而 NPS 提高反过来也让团队的 DevOps 转型更加顺利。正如 [Puppet 发布的 DevOps 报告][4]所预测的，用在技术流程改进上的投入可以在业务成果上明显地体现出来。\n\n而 DevOps 主导者在推动变革时必须关注这三个方面：团队管理，团队文化和团队活力。\n\n### 团队管理\n\n最重要的是，改进对技术流程的投入可以转化为更好的业务成果。\n\n组织架构越大，业务领导与一线员工之间的距离就会越大，当然发生误解的可能性也会越大。而且各种技术工具和实际应用都在以日新月异的速度变化，这就导致业务领导几乎不可能对 DevOps 或敏捷开发的转型方向有一个亲身的了解。\n\nDevOps 主导者必须和管理层密切合作，在进行决策的时候给出相关的意见，以帮助他们做出正确的决策。\n\n公司的管理层只是知道 DevOps 会对产品部署的方式进行改进，而并不了解其中的具体过程。假设你正在帮助一个软件开发团队实现自动化部署，当管理层得知某次部署失败时（这种情况是有的），就会想要了解这件事情的细节。如果管理层了解到进行部署的是软件团队而不是专门的发布管理团队，就可能会坚持使用传统的变更流程来保证业务的正常运作。你可能会失去团队的信任，团队也可能不愿意做出进一步的改变。\n\n如果没有和管理层做好心理上的预期，一旦发生意外的生产事件，重建管理层的信任并得到他们的支持比事先对他们进行教育需要更长的时间。所以，最好事先和管理层在各方面协调好，这会让你在后续的工作中避免很多麻烦。\n\n对于和管理层之间的协调，这里有两条建议：\n\n* 一是**重视所有规章制度**。如果管理层对合同、安全等各方面有任何疑问，你都可以向法务或安全负责人咨询，这样做可以避免犯下后果严重的错误。\n* 二是**将管理层重点关注的方面输出为量化指标**。举个例子，如果公司的目标是减少客户流失，而你调查得出计划外的服务宕机是造成客户流失的主要原因，那么就可以让团队对故障的<ruby>平均排查时间<rt>Mean Time To Detection</rt></ruby>（MTTD）和<ruby>平均解决时间<rt>Mean Time To Resolution</rt></ruby>（MTTR）实行重点优化。你可以使用这些关键指标来量化团队的工作成果，而管理层对此也可以有一个直观的了解。\n\n### 团队文化\n\nDevOps 是一种专注于持续改进代码、构建、部署和操作流程的文化，而团队文化代表了团队的价值观和行为。从本质上说，团队文化是要塑造团队成员的行为方式，而这并不是一件容易的事。\n\n我推荐一本叫做《[披着狼皮的 CIO][5]》的书。另外，研究心理学、阅读《[Drive][6]》、观看 Daniel Pink 的 [TED 演讲][7]、阅读《[千面英雄][7]》、了解每个人的心路历程，以上这些都是你推动公司技术变革所应该尝试去做的事情。如果这些你都没兴趣，说明你不是那个推动公司变革的人。如果你想成为那个人，那就开始学习吧！\n\n从本质上说，改变一个人真不是件容易的事。\n\n理性的人大多都按照自己的价值观工作，然而团队通常没有让每个人都能达成共识的明确价值观。因此，你需要明确团队目前的价值观，包括价值观的形成过程和价值观的目标导向。但不能将这些价值观强加到团队成员身上，只需要让团队成员在现有条件下力所能及地做到最好就可以了。\n\n同时需要向团队成员阐明，公司正在发生组织和团队目标的变化，团队的价值观也随之改变，最好也厘清整个过程中将会作出什么变化。例如，公司以往或许是由于资金有限，一直将节约成本的原则放在首位，在研发新产品的时候，基础架构团队不得不共享数据库集群或服务器，从而导致了服务之间的紧密耦合。然而随着时间的推移，这种做法会产生难以维护的混乱，即使是一个小小的变化也可能造成无法预料的后果。这就导致交付团队难以执行变更控制流程，进而令变更停滞不前。\n\n如果这种状况持续几年，最终的结果将会是毫无创新、技术老旧、问题繁多以及产品品质低下，公司的发展到达了瓶颈，原本的价值观已经不再适用。所以，工作效率的优先级必须高于节约成本。如果一个选择能让团队运作更好，另一个选择只是短期来看成本便宜，那你应该选择前者。\n\n你必须反复强调团队的价值观。每当团队取得了一定的工作进展（即使探索创新时出现一些小的失误），都应该对团队作出激励。在团队部署出现失败时，鼓励他们承担风险、吸取教训，同时指导团队如何改进他们的工作并表示支持。长此下来，团队成员就会对你产生信任，不再顾虑为切合团队的价值观而做出改变。\n\n### 团队活力\n\n你有没有在会议上听过类似这样的话？“在张三度假回来之前，我们无法对这件事情做出评估。他是唯一一个了解代码的人”，或者是“我们完成不了这项任务，它在网络上需要跨团队合作，而防火墙管理员刚好请病假了”，又或者是“张三最清楚这个系统，他说是怎么样，通常就是怎么样”。那么如果团队在处理工作时，谁才是主力？就是张三。而且也一直会是他。\n\n我们一直都认为这就是软件开发的自带属性。但是如果我们不作出改变，这种循环就会一直持续下去。\n\n熵的存在会让团队自发地变得混乱和缺乏活力，团队的成员和主导者的都有责任控制这个熵并保持团队的活力。DevOps、敏捷开发、上云、代码重构这些行为都会令熵加速增长，这是因为转型让团队需要学习更多新技能和专业知识以开展新工作。\n\n我们来看一个产品团队重构历史代码的例子。像往常一样，他们在 AWS 上构建新的服务。而传统的系统则在数据中心部署，并由 IT 部门进行监控和备份。IT 部门会确保在基础架构的层面上满足应用的安全需求、进行灾难恢复测试、系统补丁、安装配置了入侵检测和防病毒代理，而且 IT 部门还保留了年度审计流程所需的变更控制记录。\n\n产品团队经常会犯一个致命的错误，就是认为 IT 是消耗资源的部门，是需要突破的瓶颈。他们希望脱离已有的 IT 部门并使用公有云，但实际上是他们忽视了 IT 部门提供的关键服务。迁移到云上只是以不同的方式实现这些关键服务，因为 AWS 也是一个数据中心，团队即使使用 AWS 也需要完成 IT 运维任务。\n\n实际上，产品团队在向云迁移的时候也必须学习如何使用这些 IT 服务。因此，当产品团队开始重构历史代码并部署到云上时，也需要学习大量的技能才能正常运作。这些技能不会无师自通，必须自行学习或者聘用相关的人员，团队的主导者也必须积极进行管理。\n\n在带领团队时，我找不到任何适合我的工具，因此我建立了 [Tekita.io][9] 这个项目。Tekata 免费而且容易使用。但相比起来，把注意力集中在人员和流程上更为重要，你需要不断学习，持续关注团队的短板，因为它们会影响团队的交付能力，而弥补这些短板往往需要学习大量的新知识，这就需要团队成员之间有一个很好的协作。因此 76％ 的年轻人都认为个人发展机会是公司文化[最重要的的一环][10]。\n\n### 效果就是最好的证明\n\nDevOps 转型会改变团队的工作方式和文化，这需要得到管理层的支持和理解。同时，工作方式的改变意味着新技术的引入，所以在管理上也必须谨慎。但转型的最终结果是团队变得更高效、成员变得更积极、产品变得更优质，客户也变得更满意。\n\nLee Eason 将于 10 月 21-23 日在北卡罗来纳州 Raleigh 举行的 [All Things Open][12] 上讲述 [DevOps 转型的故事][11]。\n\n免责声明：本文中的内容仅为 Lee Eason 的个人立场，不代表 Ipreo 或 IHS Markit。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/tales-devops-transformation\n\n[a]: https://opensource.com/users/leeeason\n[b]: https://github.com/lujun9972\n[1]: https://link.springer.com/article/10.1007%2Fs00442-014-2995-6\n[2]: /file/411061\n[3]: https://opensource.com/sites/default/files/uploads/devops-delays.png \"Improvements after DevOps transformation\"\n[4]: https://puppet.com/resources/whitepaper/state-of-devops-report\n[5]: https://www.gartner.com/en/publications/wolf-cio\n[6]: https://en.wikipedia.org/wiki/Drive:_The_Surprising_Truth_About_What_Motivates_Us\n[7]: https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\n[8]: https://en.wikipedia.org/wiki/The_Hero_with_a_Thousand_Faces\n[9]: https://tekata.io/\n[10]: https://www.execu-search.com/~/media/Resources/pdf/2017_Hiring_Outlook_eBook\n[11]: https://allthingsopen.org/talk/tales-from-a-devops-transformation/\n[12]: https://allthingsopen.org/\n","slug":"3-areas-to-drive-DevOps-change","published":1,"updated":"2019-03-28T12:29:31.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0b70000lixu8l7x7npn","content":"<blockquote>\n<p>推动大规模的组织变革是一个痛苦的过程。对于 DevOps 来说，尽管也有阵痛，但变革带来的价值则相当可观。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/diversity-inclusion-transformation-change_20180927.png?itok=2E-g10hJ\" alt=\"\"></p>\n<p>避免痛苦是一种强大的动力。一些研究表明，<a href=\"https://link.springer.com/article/10.1007%2Fs00442-014-2995-6\" target=\"_blank\" rel=\"noopener\">植物也会通过遭受疼痛的过程</a>以采取措施来保护自己。我们人类有时也会刻意让自己受苦——在剧烈运动之后，身体可能会发生酸痛，但我们仍然坚持运动。那是因为当人认为整个过程利大于弊时，几乎可以忍受任何事情。</p>\n<p>推动大规模的组织变革的过程确实是痛苦的。有人可能会因难以改变价值观和行为而感到痛苦，有人可能会因难以带领团队而感到痛苦，也有人可能会因难以开展工作而感到痛苦。但就 DevOps 而言，我可以说这些痛苦都是值得的。</p>\n<p>我也曾经关注过一个团队耗费大量时间优化技术流程的过程，在这个过程中，团队逐渐将流程进行自动化改造，并最终获得了成功。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/devops-delays.png\" alt=\"Improvements after DevOps transformation\" title=\"Improvements after DevOps transformation\"></p>\n<p>图片来源：Lee Eason. CC BY-SA 4.0</p>\n<p>这张图表充分表明了变革的价值。一家公司在我主导实行了 DevOps 转型之后，60 多个团队每月提交了超过 900 个发布请求。这些工作量的原耗时高达每个月 350 人/天，而这么多的工作量对于任何公司来说都是不可忽视的。除此以外，他们每月的部署次数从 100 次增加到了 9000 次，高危 bug 减少了 24%，工程师们更轻松了，<ruby>净推荐值<rt>Net Promoter Score</rt></ruby>（NPS）也提高了，而 NPS 提高反过来也让团队的 DevOps 转型更加顺利。正如 <a href=\"https://puppet.com/resources/whitepaper/state-of-devops-report\" target=\"_blank\" rel=\"noopener\">Puppet 发布的 DevOps 报告</a>所预测的，用在技术流程改进上的投入可以在业务成果上明显地体现出来。</p>\n<p>而 DevOps 主导者在推动变革时必须关注这三个方面：团队管理，团队文化和团队活力。</p>\n<h3 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h3><p>最重要的是，改进对技术流程的投入可以转化为更好的业务成果。</p>\n<p>组织架构越大，业务领导与一线员工之间的距离就会越大，当然发生误解的可能性也会越大。而且各种技术工具和实际应用都在以日新月异的速度变化，这就导致业务领导几乎不可能对 DevOps 或敏捷开发的转型方向有一个亲身的了解。</p>\n<p>DevOps 主导者必须和管理层密切合作，在进行决策的时候给出相关的意见，以帮助他们做出正确的决策。</p>\n<p>公司的管理层只是知道 DevOps 会对产品部署的方式进行改进，而并不了解其中的具体过程。假设你正在帮助一个软件开发团队实现自动化部署，当管理层得知某次部署失败时（这种情况是有的），就会想要了解这件事情的细节。如果管理层了解到进行部署的是软件团队而不是专门的发布管理团队，就可能会坚持使用传统的变更流程来保证业务的正常运作。你可能会失去团队的信任，团队也可能不愿意做出进一步的改变。</p>\n<p>如果没有和管理层做好心理上的预期，一旦发生意外的生产事件，重建管理层的信任并得到他们的支持比事先对他们进行教育需要更长的时间。所以，最好事先和管理层在各方面协调好，这会让你在后续的工作中避免很多麻烦。</p>\n<p>对于和管理层之间的协调，这里有两条建议：</p>\n<ul>\n<li>一是<strong>重视所有规章制度</strong>。如果管理层对合同、安全等各方面有任何疑问，你都可以向法务或安全负责人咨询，这样做可以避免犯下后果严重的错误。</li>\n<li>二是<strong>将管理层重点关注的方面输出为量化指标</strong>。举个例子，如果公司的目标是减少客户流失，而你调查得出计划外的服务宕机是造成客户流失的主要原因，那么就可以让团队对故障的<ruby>平均排查时间<rt>Mean Time To Detection</rt></ruby>（MTTD）和<ruby>平均解决时间<rt>Mean Time To Resolution</rt></ruby>（MTTR）实行重点优化。你可以使用这些关键指标来量化团队的工作成果，而管理层对此也可以有一个直观的了解。</li>\n</ul>\n<h3 id=\"团队文化\"><a href=\"#团队文化\" class=\"headerlink\" title=\"团队文化\"></a>团队文化</h3><p>DevOps 是一种专注于持续改进代码、构建、部署和操作流程的文化，而团队文化代表了团队的价值观和行为。从本质上说，团队文化是要塑造团队成员的行为方式，而这并不是一件容易的事。</p>\n<p>我推荐一本叫做《<a href=\"https://www.gartner.com/en/publications/wolf-cio\" target=\"_blank\" rel=\"noopener\">披着狼皮的 CIO</a>》的书。另外，研究心理学、阅读《<a href=\"https://en.wikipedia.org/wiki/Drive:_The_Surprising_Truth_About_What_Motivates_Us\" target=\"_blank\" rel=\"noopener\">Drive</a>》、观看 Daniel Pink 的 <a href=\"https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\" target=\"_blank\" rel=\"noopener\">TED 演讲</a>、阅读《<a href=\"https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\" target=\"_blank\" rel=\"noopener\">千面英雄</a>》、了解每个人的心路历程，以上这些都是你推动公司技术变革所应该尝试去做的事情。如果这些你都没兴趣，说明你不是那个推动公司变革的人。如果你想成为那个人，那就开始学习吧！</p>\n<p>从本质上说，改变一个人真不是件容易的事。</p>\n<p>理性的人大多都按照自己的价值观工作，然而团队通常没有让每个人都能达成共识的明确价值观。因此，你需要明确团队目前的价值观，包括价值观的形成过程和价值观的目标导向。但不能将这些价值观强加到团队成员身上，只需要让团队成员在现有条件下力所能及地做到最好就可以了。</p>\n<p>同时需要向团队成员阐明，公司正在发生组织和团队目标的变化，团队的价值观也随之改变，最好也厘清整个过程中将会作出什么变化。例如，公司以往或许是由于资金有限，一直将节约成本的原则放在首位，在研发新产品的时候，基础架构团队不得不共享数据库集群或服务器，从而导致了服务之间的紧密耦合。然而随着时间的推移，这种做法会产生难以维护的混乱，即使是一个小小的变化也可能造成无法预料的后果。这就导致交付团队难以执行变更控制流程，进而令变更停滞不前。</p>\n<p>如果这种状况持续几年，最终的结果将会是毫无创新、技术老旧、问题繁多以及产品品质低下，公司的发展到达了瓶颈，原本的价值观已经不再适用。所以，工作效率的优先级必须高于节约成本。如果一个选择能让团队运作更好，另一个选择只是短期来看成本便宜，那你应该选择前者。</p>\n<p>你必须反复强调团队的价值观。每当团队取得了一定的工作进展（即使探索创新时出现一些小的失误），都应该对团队作出激励。在团队部署出现失败时，鼓励他们承担风险、吸取教训，同时指导团队如何改进他们的工作并表示支持。长此下来，团队成员就会对你产生信任，不再顾虑为切合团队的价值观而做出改变。</p>\n<h3 id=\"团队活力\"><a href=\"#团队活力\" class=\"headerlink\" title=\"团队活力\"></a>团队活力</h3><p>你有没有在会议上听过类似这样的话？“在张三度假回来之前，我们无法对这件事情做出评估。他是唯一一个了解代码的人”，或者是“我们完成不了这项任务，它在网络上需要跨团队合作，而防火墙管理员刚好请病假了”，又或者是“张三最清楚这个系统，他说是怎么样，通常就是怎么样”。那么如果团队在处理工作时，谁才是主力？就是张三。而且也一直会是他。</p>\n<p>我们一直都认为这就是软件开发的自带属性。但是如果我们不作出改变，这种循环就会一直持续下去。</p>\n<p>熵的存在会让团队自发地变得混乱和缺乏活力，团队的成员和主导者的都有责任控制这个熵并保持团队的活力。DevOps、敏捷开发、上云、代码重构这些行为都会令熵加速增长，这是因为转型让团队需要学习更多新技能和专业知识以开展新工作。</p>\n<p>我们来看一个产品团队重构历史代码的例子。像往常一样，他们在 AWS 上构建新的服务。而传统的系统则在数据中心部署，并由 IT 部门进行监控和备份。IT 部门会确保在基础架构的层面上满足应用的安全需求、进行灾难恢复测试、系统补丁、安装配置了入侵检测和防病毒代理，而且 IT 部门还保留了年度审计流程所需的变更控制记录。</p>\n<p>产品团队经常会犯一个致命的错误，就是认为 IT 是消耗资源的部门，是需要突破的瓶颈。他们希望脱离已有的 IT 部门并使用公有云，但实际上是他们忽视了 IT 部门提供的关键服务。迁移到云上只是以不同的方式实现这些关键服务，因为 AWS 也是一个数据中心，团队即使使用 AWS 也需要完成 IT 运维任务。</p>\n<p>实际上，产品团队在向云迁移的时候也必须学习如何使用这些 IT 服务。因此，当产品团队开始重构历史代码并部署到云上时，也需要学习大量的技能才能正常运作。这些技能不会无师自通，必须自行学习或者聘用相关的人员，团队的主导者也必须积极进行管理。</p>\n<p>在带领团队时，我找不到任何适合我的工具，因此我建立了 <a href=\"https://tekata.io/\" target=\"_blank\" rel=\"noopener\">Tekita.io</a> 这个项目。Tekata 免费而且容易使用。但相比起来，把注意力集中在人员和流程上更为重要，你需要不断学习，持续关注团队的短板，因为它们会影响团队的交付能力，而弥补这些短板往往需要学习大量的新知识，这就需要团队成员之间有一个很好的协作。因此 76％ 的年轻人都认为个人发展机会是公司文化<a href=\"https://www.execu-search.com/~/media/Resources/pdf/2017_Hiring_Outlook_eBook\" target=\"_blank\" rel=\"noopener\">最重要的的一环</a>。</p>\n<h3 id=\"效果就是最好的证明\"><a href=\"#效果就是最好的证明\" class=\"headerlink\" title=\"效果就是最好的证明\"></a>效果就是最好的证明</h3><p>DevOps 转型会改变团队的工作方式和文化，这需要得到管理层的支持和理解。同时，工作方式的改变意味着新技术的引入，所以在管理上也必须谨慎。但转型的最终结果是团队变得更高效、成员变得更积极、产品变得更优质，客户也变得更满意。</p>\n<p>Lee Eason 将于 10 月 21-23 日在北卡罗来纳州 Raleigh 举行的 <a href=\"https://allthingsopen.org/\" target=\"_blank\" rel=\"noopener\">All Things Open</a> 上讲述 <a href=\"https://allthingsopen.org/talk/tales-from-a-devops-transformation/\" target=\"_blank\" rel=\"noopener\">DevOps 转型的故事</a>。</p>\n<p>免责声明：本文中的内容仅为 Lee Eason 的个人立场，不代表 Ipreo 或 IHS Markit。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/tales-devops-transformation\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/tales-devops-transformation</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>推动大规模的组织变革是一个痛苦的过程。对于 DevOps 来说，尽管也有阵痛，但变革带来的价值则相当可观。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/diversity-inclusion-transformation-change_20180927.png?itok=2E-g10hJ\" alt=\"\"></p>\n<p>避免痛苦是一种强大的动力。一些研究表明，<a href=\"https://link.springer.com/article/10.1007%2Fs00442-014-2995-6\" target=\"_blank\" rel=\"noopener\">植物也会通过遭受疼痛的过程</a>以采取措施来保护自己。我们人类有时也会刻意让自己受苦——在剧烈运动之后，身体可能会发生酸痛，但我们仍然坚持运动。那是因为当人认为整个过程利大于弊时，几乎可以忍受任何事情。</p>\n<p>推动大规模的组织变革的过程确实是痛苦的。有人可能会因难以改变价值观和行为而感到痛苦，有人可能会因难以带领团队而感到痛苦，也有人可能会因难以开展工作而感到痛苦。但就 DevOps 而言，我可以说这些痛苦都是值得的。</p>\n<p>我也曾经关注过一个团队耗费大量时间优化技术流程的过程，在这个过程中，团队逐渐将流程进行自动化改造，并最终获得了成功。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/devops-delays.png\" alt=\"Improvements after DevOps transformation\" title=\"Improvements after DevOps transformation\"></p>\n<p>图片来源：Lee Eason. CC BY-SA 4.0</p>\n<p>这张图表充分表明了变革的价值。一家公司在我主导实行了 DevOps 转型之后，60 多个团队每月提交了超过 900 个发布请求。这些工作量的原耗时高达每个月 350 人/天，而这么多的工作量对于任何公司来说都是不可忽视的。除此以外，他们每月的部署次数从 100 次增加到了 9000 次，高危 bug 减少了 24%，工程师们更轻松了，<ruby>净推荐值<rt>Net Promoter Score</rt></ruby>（NPS）也提高了，而 NPS 提高反过来也让团队的 DevOps 转型更加顺利。正如 <a href=\"https://puppet.com/resources/whitepaper/state-of-devops-report\" target=\"_blank\" rel=\"noopener\">Puppet 发布的 DevOps 报告</a>所预测的，用在技术流程改进上的投入可以在业务成果上明显地体现出来。</p>\n<p>而 DevOps 主导者在推动变革时必须关注这三个方面：团队管理，团队文化和团队活力。</p>\n<h3 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h3><p>最重要的是，改进对技术流程的投入可以转化为更好的业务成果。</p>\n<p>组织架构越大，业务领导与一线员工之间的距离就会越大，当然发生误解的可能性也会越大。而且各种技术工具和实际应用都在以日新月异的速度变化，这就导致业务领导几乎不可能对 DevOps 或敏捷开发的转型方向有一个亲身的了解。</p>\n<p>DevOps 主导者必须和管理层密切合作，在进行决策的时候给出相关的意见，以帮助他们做出正确的决策。</p>\n<p>公司的管理层只是知道 DevOps 会对产品部署的方式进行改进，而并不了解其中的具体过程。假设你正在帮助一个软件开发团队实现自动化部署，当管理层得知某次部署失败时（这种情况是有的），就会想要了解这件事情的细节。如果管理层了解到进行部署的是软件团队而不是专门的发布管理团队，就可能会坚持使用传统的变更流程来保证业务的正常运作。你可能会失去团队的信任，团队也可能不愿意做出进一步的改变。</p>\n<p>如果没有和管理层做好心理上的预期，一旦发生意外的生产事件，重建管理层的信任并得到他们的支持比事先对他们进行教育需要更长的时间。所以，最好事先和管理层在各方面协调好，这会让你在后续的工作中避免很多麻烦。</p>\n<p>对于和管理层之间的协调，这里有两条建议：</p>\n<ul>\n<li>一是<strong>重视所有规章制度</strong>。如果管理层对合同、安全等各方面有任何疑问，你都可以向法务或安全负责人咨询，这样做可以避免犯下后果严重的错误。</li>\n<li>二是<strong>将管理层重点关注的方面输出为量化指标</strong>。举个例子，如果公司的目标是减少客户流失，而你调查得出计划外的服务宕机是造成客户流失的主要原因，那么就可以让团队对故障的<ruby>平均排查时间<rt>Mean Time To Detection</rt></ruby>（MTTD）和<ruby>平均解决时间<rt>Mean Time To Resolution</rt></ruby>（MTTR）实行重点优化。你可以使用这些关键指标来量化团队的工作成果，而管理层对此也可以有一个直观的了解。</li>\n</ul>\n<h3 id=\"团队文化\"><a href=\"#团队文化\" class=\"headerlink\" title=\"团队文化\"></a>团队文化</h3><p>DevOps 是一种专注于持续改进代码、构建、部署和操作流程的文化，而团队文化代表了团队的价值观和行为。从本质上说，团队文化是要塑造团队成员的行为方式，而这并不是一件容易的事。</p>\n<p>我推荐一本叫做《<a href=\"https://www.gartner.com/en/publications/wolf-cio\" target=\"_blank\" rel=\"noopener\">披着狼皮的 CIO</a>》的书。另外，研究心理学、阅读《<a href=\"https://en.wikipedia.org/wiki/Drive:_The_Surprising_Truth_About_What_Motivates_Us\" target=\"_blank\" rel=\"noopener\">Drive</a>》、观看 Daniel Pink 的 <a href=\"https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\" target=\"_blank\" rel=\"noopener\">TED 演讲</a>、阅读《<a href=\"https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-2094\" target=\"_blank\" rel=\"noopener\">千面英雄</a>》、了解每个人的心路历程，以上这些都是你推动公司技术变革所应该尝试去做的事情。如果这些你都没兴趣，说明你不是那个推动公司变革的人。如果你想成为那个人，那就开始学习吧！</p>\n<p>从本质上说，改变一个人真不是件容易的事。</p>\n<p>理性的人大多都按照自己的价值观工作，然而团队通常没有让每个人都能达成共识的明确价值观。因此，你需要明确团队目前的价值观，包括价值观的形成过程和价值观的目标导向。但不能将这些价值观强加到团队成员身上，只需要让团队成员在现有条件下力所能及地做到最好就可以了。</p>\n<p>同时需要向团队成员阐明，公司正在发生组织和团队目标的变化，团队的价值观也随之改变，最好也厘清整个过程中将会作出什么变化。例如，公司以往或许是由于资金有限，一直将节约成本的原则放在首位，在研发新产品的时候，基础架构团队不得不共享数据库集群或服务器，从而导致了服务之间的紧密耦合。然而随着时间的推移，这种做法会产生难以维护的混乱，即使是一个小小的变化也可能造成无法预料的后果。这就导致交付团队难以执行变更控制流程，进而令变更停滞不前。</p>\n<p>如果这种状况持续几年，最终的结果将会是毫无创新、技术老旧、问题繁多以及产品品质低下，公司的发展到达了瓶颈，原本的价值观已经不再适用。所以，工作效率的优先级必须高于节约成本。如果一个选择能让团队运作更好，另一个选择只是短期来看成本便宜，那你应该选择前者。</p>\n<p>你必须反复强调团队的价值观。每当团队取得了一定的工作进展（即使探索创新时出现一些小的失误），都应该对团队作出激励。在团队部署出现失败时，鼓励他们承担风险、吸取教训，同时指导团队如何改进他们的工作并表示支持。长此下来，团队成员就会对你产生信任，不再顾虑为切合团队的价值观而做出改变。</p>\n<h3 id=\"团队活力\"><a href=\"#团队活力\" class=\"headerlink\" title=\"团队活力\"></a>团队活力</h3><p>你有没有在会议上听过类似这样的话？“在张三度假回来之前，我们无法对这件事情做出评估。他是唯一一个了解代码的人”，或者是“我们完成不了这项任务，它在网络上需要跨团队合作，而防火墙管理员刚好请病假了”，又或者是“张三最清楚这个系统，他说是怎么样，通常就是怎么样”。那么如果团队在处理工作时，谁才是主力？就是张三。而且也一直会是他。</p>\n<p>我们一直都认为这就是软件开发的自带属性。但是如果我们不作出改变，这种循环就会一直持续下去。</p>\n<p>熵的存在会让团队自发地变得混乱和缺乏活力，团队的成员和主导者的都有责任控制这个熵并保持团队的活力。DevOps、敏捷开发、上云、代码重构这些行为都会令熵加速增长，这是因为转型让团队需要学习更多新技能和专业知识以开展新工作。</p>\n<p>我们来看一个产品团队重构历史代码的例子。像往常一样，他们在 AWS 上构建新的服务。而传统的系统则在数据中心部署，并由 IT 部门进行监控和备份。IT 部门会确保在基础架构的层面上满足应用的安全需求、进行灾难恢复测试、系统补丁、安装配置了入侵检测和防病毒代理，而且 IT 部门还保留了年度审计流程所需的变更控制记录。</p>\n<p>产品团队经常会犯一个致命的错误，就是认为 IT 是消耗资源的部门，是需要突破的瓶颈。他们希望脱离已有的 IT 部门并使用公有云，但实际上是他们忽视了 IT 部门提供的关键服务。迁移到云上只是以不同的方式实现这些关键服务，因为 AWS 也是一个数据中心，团队即使使用 AWS 也需要完成 IT 运维任务。</p>\n<p>实际上，产品团队在向云迁移的时候也必须学习如何使用这些 IT 服务。因此，当产品团队开始重构历史代码并部署到云上时，也需要学习大量的技能才能正常运作。这些技能不会无师自通，必须自行学习或者聘用相关的人员，团队的主导者也必须积极进行管理。</p>\n<p>在带领团队时，我找不到任何适合我的工具，因此我建立了 <a href=\"https://tekata.io/\" target=\"_blank\" rel=\"noopener\">Tekita.io</a> 这个项目。Tekata 免费而且容易使用。但相比起来，把注意力集中在人员和流程上更为重要，你需要不断学习，持续关注团队的短板，因为它们会影响团队的交付能力，而弥补这些短板往往需要学习大量的新知识，这就需要团队成员之间有一个很好的协作。因此 76％ 的年轻人都认为个人发展机会是公司文化<a href=\"https://www.execu-search.com/~/media/Resources/pdf/2017_Hiring_Outlook_eBook\" target=\"_blank\" rel=\"noopener\">最重要的的一环</a>。</p>\n<h3 id=\"效果就是最好的证明\"><a href=\"#效果就是最好的证明\" class=\"headerlink\" title=\"效果就是最好的证明\"></a>效果就是最好的证明</h3><p>DevOps 转型会改变团队的工作方式和文化，这需要得到管理层的支持和理解。同时，工作方式的改变意味着新技术的引入，所以在管理上也必须谨慎。但转型的最终结果是团队变得更高效、成员变得更积极、产品变得更优质，客户也变得更满意。</p>\n<p>Lee Eason 将于 10 月 21-23 日在北卡罗来纳州 Raleigh 举行的 <a href=\"https://allthingsopen.org/\" target=\"_blank\" rel=\"noopener\">All Things Open</a> 上讲述 <a href=\"https://allthingsopen.org/talk/tales-from-a-devops-transformation/\" target=\"_blank\" rel=\"noopener\">DevOps 转型的故事</a>。</p>\n<p>免责声明：本文中的内容仅为 Lee Eason 的个人立场，不代表 Ipreo 或 IHS Markit。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/tales-devops-transformation\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/tales-devops-transformation</a></p>\n"},{"title":"无服务器架构的三个意义","date":"2018-12-11T15:11:08.000Z","_content":"\n> 以及，对于<ruby>无服务器<rt>Serverless</rt></ruby>架构，什么时候该用，什么时候不该用呢？\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/rh_003499_01_linux11x_cc.png?itok=XMDOouJR)\n\n如果将如今互联网体验中最方便实用的那一部分去掉，那么留下来的基本就是<ruby>客户端-服务端<rt>client-server</rt></ruby>模式了。这一个模式在互联网建立初期就已经在使用了，直到目前都没有太大的变化，也就是说，这个模式仍然在为我们服务。\n\n那么，当人们谈论<ruby>无服务器<rt>Serverless</rt></ruby>架构的时候，到底是指什么呢？其实，无服务器架构并不是说不使用服务器了。恰恰相反，客户端-服务端模式仍然在其中发挥着重要的作用。\n\n无服务器架构实际上指的是能够让开发者在不需要关心服务器上架、为操作系统打补丁、创建容器镜像这些工作的情况下，就能够完成编码、部署和创建应用这一整套流程的架构。\n\n### 无服务器架构的三个重要意义\n\n1. 一些缺乏开发经验的人员现在要参与到开发工作中来了。无服务器架构能够让他们尽量只学习必要的工作内容，把更多的时间放在更具创造性的开发工作中。\n2. 开发者不再需要重复造轮子。运行和维护服务器、为操作系统打补丁、创建容器等这一系列工作，都可以由更专业的无服务器架构提供商来完成。\n3. 最现实的一点是，如果不使用无服务器架构，那么在服务器管理方面，总需要有一个作最终决策的人。当服务器发生崩溃时，或是需要在服务器上执行某些操作时，总是需要这样一个统领全局的人来作出决策。因此最佳的方案是使用无服务器架构。\n\n### 什么时候该用或者不该用无服务器架构？\n\n听起来无服务器架构是个好东西。但事实上，无服务器架构并不是万能的，在使用之前还需要考虑以下这些因素：\n\n1. 成本\n2. 使用范围\n3. 时间\n4. 控制方式\n\n其中值得注意的是控制方式。现在已经有一些项目为开发者提供了操作和控制无服务器架构计算环境的工具了，[Apache OpenWhisk][1] 就是其中之一。\n\n### 为什么要将无服务器架构开源？\n\n关于这方面的更多内容，可以观看无服务器架构方面的专家 Saron Yitbarek 在 [Command Line Heroes][2] 节目中的访谈。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/12/serverless-podcast-command-line-heros\n\n[a]: https://opensource.com/users/remyd\n[b]: https://github.com/lujun9972\n[1]: https://opensource.com/article/18/11/developing-functions-service-apache-openwhisk\n[2]: https://www.redhat.com/en/command-line-heroes\n\n","source":"_posts/3-implications-of-serverless.md","raw":"---\ntitle: 无服务器架构的三个意义\ndate: 2018-12-11 23:11:08\ntags:\n  - 无服务器架构\n  - LCTT 翻译\n---\n\n> 以及，对于<ruby>无服务器<rt>Serverless</rt></ruby>架构，什么时候该用，什么时候不该用呢？\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/rh_003499_01_linux11x_cc.png?itok=XMDOouJR)\n\n如果将如今互联网体验中最方便实用的那一部分去掉，那么留下来的基本就是<ruby>客户端-服务端<rt>client-server</rt></ruby>模式了。这一个模式在互联网建立初期就已经在使用了，直到目前都没有太大的变化，也就是说，这个模式仍然在为我们服务。\n\n那么，当人们谈论<ruby>无服务器<rt>Serverless</rt></ruby>架构的时候，到底是指什么呢？其实，无服务器架构并不是说不使用服务器了。恰恰相反，客户端-服务端模式仍然在其中发挥着重要的作用。\n\n无服务器架构实际上指的是能够让开发者在不需要关心服务器上架、为操作系统打补丁、创建容器镜像这些工作的情况下，就能够完成编码、部署和创建应用这一整套流程的架构。\n\n### 无服务器架构的三个重要意义\n\n1. 一些缺乏开发经验的人员现在要参与到开发工作中来了。无服务器架构能够让他们尽量只学习必要的工作内容，把更多的时间放在更具创造性的开发工作中。\n2. 开发者不再需要重复造轮子。运行和维护服务器、为操作系统打补丁、创建容器等这一系列工作，都可以由更专业的无服务器架构提供商来完成。\n3. 最现实的一点是，如果不使用无服务器架构，那么在服务器管理方面，总需要有一个作最终决策的人。当服务器发生崩溃时，或是需要在服务器上执行某些操作时，总是需要这样一个统领全局的人来作出决策。因此最佳的方案是使用无服务器架构。\n\n### 什么时候该用或者不该用无服务器架构？\n\n听起来无服务器架构是个好东西。但事实上，无服务器架构并不是万能的，在使用之前还需要考虑以下这些因素：\n\n1. 成本\n2. 使用范围\n3. 时间\n4. 控制方式\n\n其中值得注意的是控制方式。现在已经有一些项目为开发者提供了操作和控制无服务器架构计算环境的工具了，[Apache OpenWhisk][1] 就是其中之一。\n\n### 为什么要将无服务器架构开源？\n\n关于这方面的更多内容，可以观看无服务器架构方面的专家 Saron Yitbarek 在 [Command Line Heroes][2] 节目中的访谈。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/12/serverless-podcast-command-line-heros\n\n[a]: https://opensource.com/users/remyd\n[b]: https://github.com/lujun9972\n[1]: https://opensource.com/article/18/11/developing-functions-service-apache-openwhisk\n[2]: https://www.redhat.com/en/command-line-heroes\n\n","slug":"3-implications-of-serverless","published":1,"updated":"2019-03-28T13:12:15.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0bi0002lixubrqjoyhx","content":"<blockquote>\n<p>以及，对于<ruby>无服务器<rt>Serverless</rt></ruby>架构，什么时候该用，什么时候不该用呢？</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/rh_003499_01_linux11x_cc.png?itok=XMDOouJR\" alt=\"\"></p>\n<p>如果将如今互联网体验中最方便实用的那一部分去掉，那么留下来的基本就是<ruby>客户端-服务端<rt>client-server</rt></ruby>模式了。这一个模式在互联网建立初期就已经在使用了，直到目前都没有太大的变化，也就是说，这个模式仍然在为我们服务。</p>\n<p>那么，当人们谈论<ruby>无服务器<rt>Serverless</rt></ruby>架构的时候，到底是指什么呢？其实，无服务器架构并不是说不使用服务器了。恰恰相反，客户端-服务端模式仍然在其中发挥着重要的作用。</p>\n<p>无服务器架构实际上指的是能够让开发者在不需要关心服务器上架、为操作系统打补丁、创建容器镜像这些工作的情况下，就能够完成编码、部署和创建应用这一整套流程的架构。</p>\n<h3 id=\"无服务器架构的三个重要意义\"><a href=\"#无服务器架构的三个重要意义\" class=\"headerlink\" title=\"无服务器架构的三个重要意义\"></a>无服务器架构的三个重要意义</h3><ol>\n<li>一些缺乏开发经验的人员现在要参与到开发工作中来了。无服务器架构能够让他们尽量只学习必要的工作内容，把更多的时间放在更具创造性的开发工作中。</li>\n<li>开发者不再需要重复造轮子。运行和维护服务器、为操作系统打补丁、创建容器等这一系列工作，都可以由更专业的无服务器架构提供商来完成。</li>\n<li>最现实的一点是，如果不使用无服务器架构，那么在服务器管理方面，总需要有一个作最终决策的人。当服务器发生崩溃时，或是需要在服务器上执行某些操作时，总是需要这样一个统领全局的人来作出决策。因此最佳的方案是使用无服务器架构。</li>\n</ol>\n<h3 id=\"什么时候该用或者不该用无服务器架构？\"><a href=\"#什么时候该用或者不该用无服务器架构？\" class=\"headerlink\" title=\"什么时候该用或者不该用无服务器架构？\"></a>什么时候该用或者不该用无服务器架构？</h3><p>听起来无服务器架构是个好东西。但事实上，无服务器架构并不是万能的，在使用之前还需要考虑以下这些因素：</p>\n<ol>\n<li>成本</li>\n<li>使用范围</li>\n<li>时间</li>\n<li>控制方式</li>\n</ol>\n<p>其中值得注意的是控制方式。现在已经有一些项目为开发者提供了操作和控制无服务器架构计算环境的工具了，<a href=\"https://opensource.com/article/18/11/developing-functions-service-apache-openwhisk\" target=\"_blank\" rel=\"noopener\">Apache OpenWhisk</a> 就是其中之一。</p>\n<h3 id=\"为什么要将无服务器架构开源？\"><a href=\"#为什么要将无服务器架构开源？\" class=\"headerlink\" title=\"为什么要将无服务器架构开源？\"></a>为什么要将无服务器架构开源？</h3><p>关于这方面的更多内容，可以观看无服务器架构方面的专家 Saron Yitbarek 在 <a href=\"https://www.redhat.com/en/command-line-heroes\" target=\"_blank\" rel=\"noopener\">Command Line Heroes</a> 节目中的访谈。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/12/serverless-podcast-command-line-heros\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/12/serverless-podcast-command-line-heros</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>以及，对于<ruby>无服务器<rt>Serverless</rt></ruby>架构，什么时候该用，什么时候不该用呢？</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/rh_003499_01_linux11x_cc.png?itok=XMDOouJR\" alt=\"\"></p>\n<p>如果将如今互联网体验中最方便实用的那一部分去掉，那么留下来的基本就是<ruby>客户端-服务端<rt>client-server</rt></ruby>模式了。这一个模式在互联网建立初期就已经在使用了，直到目前都没有太大的变化，也就是说，这个模式仍然在为我们服务。</p>\n<p>那么，当人们谈论<ruby>无服务器<rt>Serverless</rt></ruby>架构的时候，到底是指什么呢？其实，无服务器架构并不是说不使用服务器了。恰恰相反，客户端-服务端模式仍然在其中发挥着重要的作用。</p>\n<p>无服务器架构实际上指的是能够让开发者在不需要关心服务器上架、为操作系统打补丁、创建容器镜像这些工作的情况下，就能够完成编码、部署和创建应用这一整套流程的架构。</p>\n<h3 id=\"无服务器架构的三个重要意义\"><a href=\"#无服务器架构的三个重要意义\" class=\"headerlink\" title=\"无服务器架构的三个重要意义\"></a>无服务器架构的三个重要意义</h3><ol>\n<li>一些缺乏开发经验的人员现在要参与到开发工作中来了。无服务器架构能够让他们尽量只学习必要的工作内容，把更多的时间放在更具创造性的开发工作中。</li>\n<li>开发者不再需要重复造轮子。运行和维护服务器、为操作系统打补丁、创建容器等这一系列工作，都可以由更专业的无服务器架构提供商来完成。</li>\n<li>最现实的一点是，如果不使用无服务器架构，那么在服务器管理方面，总需要有一个作最终决策的人。当服务器发生崩溃时，或是需要在服务器上执行某些操作时，总是需要这样一个统领全局的人来作出决策。因此最佳的方案是使用无服务器架构。</li>\n</ol>\n<h3 id=\"什么时候该用或者不该用无服务器架构？\"><a href=\"#什么时候该用或者不该用无服务器架构？\" class=\"headerlink\" title=\"什么时候该用或者不该用无服务器架构？\"></a>什么时候该用或者不该用无服务器架构？</h3><p>听起来无服务器架构是个好东西。但事实上，无服务器架构并不是万能的，在使用之前还需要考虑以下这些因素：</p>\n<ol>\n<li>成本</li>\n<li>使用范围</li>\n<li>时间</li>\n<li>控制方式</li>\n</ol>\n<p>其中值得注意的是控制方式。现在已经有一些项目为开发者提供了操作和控制无服务器架构计算环境的工具了，<a href=\"https://opensource.com/article/18/11/developing-functions-service-apache-openwhisk\" target=\"_blank\" rel=\"noopener\">Apache OpenWhisk</a> 就是其中之一。</p>\n<h3 id=\"为什么要将无服务器架构开源？\"><a href=\"#为什么要将无服务器架构开源？\" class=\"headerlink\" title=\"为什么要将无服务器架构开源？\"></a>为什么要将无服务器架构开源？</h3><p>关于这方面的更多内容，可以观看无服务器架构方面的专家 Saron Yitbarek 在 <a href=\"https://www.redhat.com/en/command-line-heroes\" target=\"_blank\" rel=\"noopener\">Command Line Heroes</a> 节目中的访谈。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/12/serverless-podcast-command-line-heros\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/12/serverless-podcast-command-line-heros</a></p>\n"},{"title":"提高 Linux 的网络浏览器安全性的 5 个建议","date":"2018-12-03T02:16:11.000Z","_content":"\n> 这些简单的步骤可以大大提高您的在线安全性。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/cyber-security-20.jpg?itok=IkNDVnJr)\n\n如果你使用 Linux 桌面但从来不使用网络浏览器，那你算得上是百里挑一。网络浏览器是绝大多数人最常用的工具之一，无论是工作、娱乐、看新闻、社交、理财，对网络浏览器的依赖都比本地应用要多得多。因此，我们需要知道如何使用网络浏览器才是安全的。一直以来都有不法的犯罪分子以及他们建立的网页试图窃取私密的信息。正是由于我们需要通过网络浏览器收发大量的敏感信息，安全性就更是至关重要。\n\n对于用户来说，需要采取什么措施呢？在下文中，我会提出一些基本的建议，让你的重要数据不会被他人轻易窃取。尽管我用于演示的是 Firefox 网络浏览器，但其中大部分建议在任何一种网络浏览器当中都可以适用。\n\n### 正确选择浏览器\n\n尽管我提出的建议具有普适性，但是正确选择网络浏览器也是很必要的。网络浏览器的更新频率是它安全性的一个重要体现。网络浏览器会不断暴露出新的问题，因此版本越新的网络浏览器修复的问题就越多，也越安全。在主流的网络浏览器当中，2017 年版本更新的发布量排行榜如下：\n\n1. Chrome 发布了 8 个更新（Chromium 全年跟进发布了大量安全补丁）。\n2. Firefox 发布了 7 个更新。\n3. Edge 发布了 2 个更新。\n4. Safari 发布了 1 个更新（苹果也会每年发布 5 到 6 个安全补丁）。\n\n网络浏览器会经常发布更新，同时用户也要及时升级到最新的版本，否则毫无意义了。尽管大部分流行的 Linux 发行版都会自动更新网络浏览器到最新版本，但还是有一些 Linux 发行版不会自动进行更新，所以最好还是手动保持浏览器更新到最新版本。这就意味着你所使用的 Linux 发行版对应的标准软件库中存放的很可能就不是最新版本的网络浏览器，在这种情况下，你可以随时从网络浏览器开发者提供的最新版本下载页中进行下载安装。\n\n如果你是一个勇于探索的人，你还可以尝试使用测试版或者<ruby>每日构建<rt>daily build</rt></ruby>版的网络浏览器，不过，这些版本将伴随着不能稳定运行的可能性。在基于 Ubuntu 的发行版中，你可以使用到每日构建版的 Firefox，只需要执行以下命令添加所需的存储库：\n\n```\nsudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa\n```\n\n按照以下命令更新 `apt` 并安装每日构建版 Firefox：\n\n```\nsudo apt-get update\nsudo apt-get install firefox\n```\n\n最重要的事情就是永远不要让你的网络浏览器版本过时，必须使用最新版本的网络浏览器。就是这样。如果你没有跟上版本更新的脚步，你使用的将会是一个暴露着各种问题的浏览器。\n\n### 使用隐私窗口\n\n将网络浏览器更新到最新版本之后，又该如何使用呢？答案是使用隐私窗口，如果你确实很重视安全的话。隐私窗口不会保存你的数据：密码？cookie？缓存？历史？什么都不会保存。因此隐私窗口的一个显著缺点就是每次访问常用的网站或者服务时，都得重新输入密码才能登录使用。当然，如果你认为网络浏览器的安全性很重要，就永远都不要保存任何密码。\n\n说到这里，我觉得每一个人都需要让自己的密码变得更强。事实上，大家都应该使用强密码，然后通过管理器来存储。而我的选择是[<ruby>通用密码管理器<rt>Universal Password Manager</rt></ruby>][1]。\n\n### 保护好密码\n\n有的人可能会认为，每次都需要重复输入密码，这样的操作太麻烦了。在 Firefox 中，如果你既想保护好自己的密码，又不想经常输入密码，就可以通过<ruby>主密码<rt>Master Password</rt></ruby>这一款内置的工具来实现你的需求。起用了这个工具之后，需要输入正确的主密码，才能后续使用保存在浏览器中的其它密码。你可以按照以下步骤进行操作：\n\n1. 打开 Firefox。\n2. 点击菜单按钮。\n3. 点击“偏好设置”。\n4. 在偏好设置页面，点击“隐私与安全”。\n5. 在页面中勾选“使用主密码”选项（图 1）。\n6. 确认以后，输入新的主密码（图 2）。\n7. 重启 Firefox。\n\n![Master Password][3]\n\n*图 1： Firefox 偏好设置页中的主密码设置。*\n\n![Setting password][6]\n\n*图 2：在 Firefox 中设置主密码。*\n\n### 了解你使用的扩展和插件\n\n大多数网络浏览器在保护隐私方面都有很多扩展，你可以根据自己的需求选择不同的扩展。而我自己则选择了一下这些扩展：\n\n* [Firefox Multi-Account Containers][7] —— 允许将某些站点配置为在容器化选项卡中打开。\n* [Facebook Container][8] —— 始终在容器化选项卡中打开 Facebook（这个扩展需要 Firefox Multi-Account Containers）。\n* [Avast Online Security][9] —— 识别并拦截已知的钓鱼网站，并显示网站的安全评级（由超过 4 亿用户的 Avast 社区支持）。\n* [Mining Blocker][10] —— 拦截所有使用 CPU 的挖矿工具。\n* [PassFF][11] —— 通过集成 `pass` （一个 UNIX 密码管理器）以安全存储密码。\n* [Privacy Badger][12] —— 自动拦截网站跟踪。\n* [uBlock Origin][13] —— 拦截已知的网站跟踪。\n\n除此以外，以下这些浏览器还有很多安全方面的扩展：\n\n+ [Firefox][2]\n+ [Chrome、Chromium,、Vivaldi][5]\n+ [Opera][14]\n\n但并非每一个网络浏览器都会向用户提供扩展或插件。例如 Midoria 就只有少量可以开启或关闭的内置插件（图 3），同时这些轻量级浏览器的第三方插件也相当缺乏。\n\n![Midori Browser][15]\n\n*图 3：Midori 浏览器的插件窗口。*\n\n### 虚拟化\n\n如果担心数据在本地存储会被窃取，也可以在虚拟机上运行网络浏览器。只需要安装诸如 [VirtualBox][16] 的软件并安装 Linux 系统，然后就可以在虚拟机中运行任何一款浏览器了。再结合以上几条建议，基本可以保证一定的安全性。\n\n### 事情的真相\n\n实际上，如果你的机器连接到互联网，就永远不能保证 100% 的安全。当然，只要你正确地使用网络浏览器，你的安全系数会更高，数据也不会轻易被窃取。Linux 的一个好处是被安装恶意软件的几率比其它操作系统要低得多。另外，请记住要使用最新版本的网络浏览器、保持更新操作系统，并且谨慎访问一切网站。\n\n你还可以通过 Linux 基金会和 edX 开办的 “[Linux 介绍][17]” 公开课学习到更多这方面的内容。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security\n\n[a]: https://www.linux.com/users/jlwallen\n[b]: https://github.com/lujun9972\n[1]: http://upm.sourceforge.net/\n[2]: https://addons.mozilla.org/en-US/firefox/search/?q=security\n[3]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_1.jpg?itok=gHMPKEvr \"Master Password\"\n[4]: https://www.linux.com/licenses/category/used-permission\n[5]: https://chrome.google.com/webstore/search/security\n[6]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_2.jpg?itok=4L7DR2Ik \"Setting password\"\n[7]: https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/?src=search\n[8]: https://addons.mozilla.org/en-US/firefox/addon/facebook-container/?src=search\n[9]: https://addons.mozilla.org/en-US/firefox/addon/avast-online-security/?src=search\n[10]: https://addons.mozilla.org/en-US/firefox/addon/miningblocker/?src=search\n[11]: https://addons.mozilla.org/en-US/firefox/addon/passff/?src=search\n[12]: https://addons.mozilla.org/en-US/firefox/addon/privacy-badger17/\n[13]: https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/?src=search\n[14]: https://addons.opera.com/en/search/?query=security\n[15]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_3.jpg?itok=hdNor0gw \"Midori Browser\"\n[16]: https://www.virtualbox.org/\n[17]: https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\n\n","source":"_posts/5-Easy-Tips-for-Linux-Web-Browser-Security.md","raw":"---\ntitle: 提高 Linux 的网络浏览器安全性的 5 个建议\ndate: 2018-12-03 10:16:11\ntags:\n  - Linux\n  - 浏览器\n  - 安全\n  - LCTT 翻译\n---\n\n> 这些简单的步骤可以大大提高您的在线安全性。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/cyber-security-20.jpg?itok=IkNDVnJr)\n\n如果你使用 Linux 桌面但从来不使用网络浏览器，那你算得上是百里挑一。网络浏览器是绝大多数人最常用的工具之一，无论是工作、娱乐、看新闻、社交、理财，对网络浏览器的依赖都比本地应用要多得多。因此，我们需要知道如何使用网络浏览器才是安全的。一直以来都有不法的犯罪分子以及他们建立的网页试图窃取私密的信息。正是由于我们需要通过网络浏览器收发大量的敏感信息，安全性就更是至关重要。\n\n对于用户来说，需要采取什么措施呢？在下文中，我会提出一些基本的建议，让你的重要数据不会被他人轻易窃取。尽管我用于演示的是 Firefox 网络浏览器，但其中大部分建议在任何一种网络浏览器当中都可以适用。\n\n### 正确选择浏览器\n\n尽管我提出的建议具有普适性，但是正确选择网络浏览器也是很必要的。网络浏览器的更新频率是它安全性的一个重要体现。网络浏览器会不断暴露出新的问题，因此版本越新的网络浏览器修复的问题就越多，也越安全。在主流的网络浏览器当中，2017 年版本更新的发布量排行榜如下：\n\n1. Chrome 发布了 8 个更新（Chromium 全年跟进发布了大量安全补丁）。\n2. Firefox 发布了 7 个更新。\n3. Edge 发布了 2 个更新。\n4. Safari 发布了 1 个更新（苹果也会每年发布 5 到 6 个安全补丁）。\n\n网络浏览器会经常发布更新，同时用户也要及时升级到最新的版本，否则毫无意义了。尽管大部分流行的 Linux 发行版都会自动更新网络浏览器到最新版本，但还是有一些 Linux 发行版不会自动进行更新，所以最好还是手动保持浏览器更新到最新版本。这就意味着你所使用的 Linux 发行版对应的标准软件库中存放的很可能就不是最新版本的网络浏览器，在这种情况下，你可以随时从网络浏览器开发者提供的最新版本下载页中进行下载安装。\n\n如果你是一个勇于探索的人，你还可以尝试使用测试版或者<ruby>每日构建<rt>daily build</rt></ruby>版的网络浏览器，不过，这些版本将伴随着不能稳定运行的可能性。在基于 Ubuntu 的发行版中，你可以使用到每日构建版的 Firefox，只需要执行以下命令添加所需的存储库：\n\n```\nsudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa\n```\n\n按照以下命令更新 `apt` 并安装每日构建版 Firefox：\n\n```\nsudo apt-get update\nsudo apt-get install firefox\n```\n\n最重要的事情就是永远不要让你的网络浏览器版本过时，必须使用最新版本的网络浏览器。就是这样。如果你没有跟上版本更新的脚步，你使用的将会是一个暴露着各种问题的浏览器。\n\n### 使用隐私窗口\n\n将网络浏览器更新到最新版本之后，又该如何使用呢？答案是使用隐私窗口，如果你确实很重视安全的话。隐私窗口不会保存你的数据：密码？cookie？缓存？历史？什么都不会保存。因此隐私窗口的一个显著缺点就是每次访问常用的网站或者服务时，都得重新输入密码才能登录使用。当然，如果你认为网络浏览器的安全性很重要，就永远都不要保存任何密码。\n\n说到这里，我觉得每一个人都需要让自己的密码变得更强。事实上，大家都应该使用强密码，然后通过管理器来存储。而我的选择是[<ruby>通用密码管理器<rt>Universal Password Manager</rt></ruby>][1]。\n\n### 保护好密码\n\n有的人可能会认为，每次都需要重复输入密码，这样的操作太麻烦了。在 Firefox 中，如果你既想保护好自己的密码，又不想经常输入密码，就可以通过<ruby>主密码<rt>Master Password</rt></ruby>这一款内置的工具来实现你的需求。起用了这个工具之后，需要输入正确的主密码，才能后续使用保存在浏览器中的其它密码。你可以按照以下步骤进行操作：\n\n1. 打开 Firefox。\n2. 点击菜单按钮。\n3. 点击“偏好设置”。\n4. 在偏好设置页面，点击“隐私与安全”。\n5. 在页面中勾选“使用主密码”选项（图 1）。\n6. 确认以后，输入新的主密码（图 2）。\n7. 重启 Firefox。\n\n![Master Password][3]\n\n*图 1： Firefox 偏好设置页中的主密码设置。*\n\n![Setting password][6]\n\n*图 2：在 Firefox 中设置主密码。*\n\n### 了解你使用的扩展和插件\n\n大多数网络浏览器在保护隐私方面都有很多扩展，你可以根据自己的需求选择不同的扩展。而我自己则选择了一下这些扩展：\n\n* [Firefox Multi-Account Containers][7] —— 允许将某些站点配置为在容器化选项卡中打开。\n* [Facebook Container][8] —— 始终在容器化选项卡中打开 Facebook（这个扩展需要 Firefox Multi-Account Containers）。\n* [Avast Online Security][9] —— 识别并拦截已知的钓鱼网站，并显示网站的安全评级（由超过 4 亿用户的 Avast 社区支持）。\n* [Mining Blocker][10] —— 拦截所有使用 CPU 的挖矿工具。\n* [PassFF][11] —— 通过集成 `pass` （一个 UNIX 密码管理器）以安全存储密码。\n* [Privacy Badger][12] —— 自动拦截网站跟踪。\n* [uBlock Origin][13] —— 拦截已知的网站跟踪。\n\n除此以外，以下这些浏览器还有很多安全方面的扩展：\n\n+ [Firefox][2]\n+ [Chrome、Chromium,、Vivaldi][5]\n+ [Opera][14]\n\n但并非每一个网络浏览器都会向用户提供扩展或插件。例如 Midoria 就只有少量可以开启或关闭的内置插件（图 3），同时这些轻量级浏览器的第三方插件也相当缺乏。\n\n![Midori Browser][15]\n\n*图 3：Midori 浏览器的插件窗口。*\n\n### 虚拟化\n\n如果担心数据在本地存储会被窃取，也可以在虚拟机上运行网络浏览器。只需要安装诸如 [VirtualBox][16] 的软件并安装 Linux 系统，然后就可以在虚拟机中运行任何一款浏览器了。再结合以上几条建议，基本可以保证一定的安全性。\n\n### 事情的真相\n\n实际上，如果你的机器连接到互联网，就永远不能保证 100% 的安全。当然，只要你正确地使用网络浏览器，你的安全系数会更高，数据也不会轻易被窃取。Linux 的一个好处是被安装恶意软件的几率比其它操作系统要低得多。另外，请记住要使用最新版本的网络浏览器、保持更新操作系统，并且谨慎访问一切网站。\n\n你还可以通过 Linux 基金会和 edX 开办的 “[Linux 介绍][17]” 公开课学习到更多这方面的内容。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security\n\n[a]: https://www.linux.com/users/jlwallen\n[b]: https://github.com/lujun9972\n[1]: http://upm.sourceforge.net/\n[2]: https://addons.mozilla.org/en-US/firefox/search/?q=security\n[3]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_1.jpg?itok=gHMPKEvr \"Master Password\"\n[4]: https://www.linux.com/licenses/category/used-permission\n[5]: https://chrome.google.com/webstore/search/security\n[6]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_2.jpg?itok=4L7DR2Ik \"Setting password\"\n[7]: https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/?src=search\n[8]: https://addons.mozilla.org/en-US/firefox/addon/facebook-container/?src=search\n[9]: https://addons.mozilla.org/en-US/firefox/addon/avast-online-security/?src=search\n[10]: https://addons.mozilla.org/en-US/firefox/addon/miningblocker/?src=search\n[11]: https://addons.mozilla.org/en-US/firefox/addon/passff/?src=search\n[12]: https://addons.mozilla.org/en-US/firefox/addon/privacy-badger17/\n[13]: https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/?src=search\n[14]: https://addons.opera.com/en/search/?query=security\n[15]: https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_3.jpg?itok=hdNor0gw \"Midori Browser\"\n[16]: https://www.virtualbox.org/\n[17]: https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\n\n","slug":"5-Easy-Tips-for-Linux-Web-Browser-Security","published":1,"updated":"2019-03-28T13:07:31.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0bo0005lixuhqmt7u71","content":"<blockquote>\n<p>这些简单的步骤可以大大提高您的在线安全性。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/cyber-security-20.jpg?itok=IkNDVnJr\" alt=\"\"></p>\n<p>如果你使用 Linux 桌面但从来不使用网络浏览器，那你算得上是百里挑一。网络浏览器是绝大多数人最常用的工具之一，无论是工作、娱乐、看新闻、社交、理财，对网络浏览器的依赖都比本地应用要多得多。因此，我们需要知道如何使用网络浏览器才是安全的。一直以来都有不法的犯罪分子以及他们建立的网页试图窃取私密的信息。正是由于我们需要通过网络浏览器收发大量的敏感信息，安全性就更是至关重要。</p>\n<p>对于用户来说，需要采取什么措施呢？在下文中，我会提出一些基本的建议，让你的重要数据不会被他人轻易窃取。尽管我用于演示的是 Firefox 网络浏览器，但其中大部分建议在任何一种网络浏览器当中都可以适用。</p>\n<h3 id=\"正确选择浏览器\"><a href=\"#正确选择浏览器\" class=\"headerlink\" title=\"正确选择浏览器\"></a>正确选择浏览器</h3><p>尽管我提出的建议具有普适性，但是正确选择网络浏览器也是很必要的。网络浏览器的更新频率是它安全性的一个重要体现。网络浏览器会不断暴露出新的问题，因此版本越新的网络浏览器修复的问题就越多，也越安全。在主流的网络浏览器当中，2017 年版本更新的发布量排行榜如下：</p>\n<ol>\n<li>Chrome 发布了 8 个更新（Chromium 全年跟进发布了大量安全补丁）。</li>\n<li>Firefox 发布了 7 个更新。</li>\n<li>Edge 发布了 2 个更新。</li>\n<li>Safari 发布了 1 个更新（苹果也会每年发布 5 到 6 个安全补丁）。</li>\n</ol>\n<p>网络浏览器会经常发布更新，同时用户也要及时升级到最新的版本，否则毫无意义了。尽管大部分流行的 Linux 发行版都会自动更新网络浏览器到最新版本，但还是有一些 Linux 发行版不会自动进行更新，所以最好还是手动保持浏览器更新到最新版本。这就意味着你所使用的 Linux 发行版对应的标准软件库中存放的很可能就不是最新版本的网络浏览器，在这种情况下，你可以随时从网络浏览器开发者提供的最新版本下载页中进行下载安装。</p>\n<p>如果你是一个勇于探索的人，你还可以尝试使用测试版或者<ruby>每日构建<rt>daily build</rt></ruby>版的网络浏览器，不过，这些版本将伴随着不能稳定运行的可能性。在基于 Ubuntu 的发行版中，你可以使用到每日构建版的 Firefox，只需要执行以下命令添加所需的存储库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa</span><br></pre></td></tr></table></figure>\n<p>按照以下命令更新 <code>apt</code> 并安装每日构建版 Firefox：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install firefox</span><br></pre></td></tr></table></figure>\n<p>最重要的事情就是永远不要让你的网络浏览器版本过时，必须使用最新版本的网络浏览器。就是这样。如果你没有跟上版本更新的脚步，你使用的将会是一个暴露着各种问题的浏览器。</p>\n<h3 id=\"使用隐私窗口\"><a href=\"#使用隐私窗口\" class=\"headerlink\" title=\"使用隐私窗口\"></a>使用隐私窗口</h3><p>将网络浏览器更新到最新版本之后，又该如何使用呢？答案是使用隐私窗口，如果你确实很重视安全的话。隐私窗口不会保存你的数据：密码？cookie？缓存？历史？什么都不会保存。因此隐私窗口的一个显著缺点就是每次访问常用的网站或者服务时，都得重新输入密码才能登录使用。当然，如果你认为网络浏览器的安全性很重要，就永远都不要保存任何密码。</p>\n<p>说到这里，我觉得每一个人都需要让自己的密码变得更强。事实上，大家都应该使用强密码，然后通过管理器来存储。而我的选择是<a href=\"http://upm.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><ruby>通用密码管理器<rt>Universal Password Manager</rt></ruby></a>。</p>\n<h3 id=\"保护好密码\"><a href=\"#保护好密码\" class=\"headerlink\" title=\"保护好密码\"></a>保护好密码</h3><p>有的人可能会认为，每次都需要重复输入密码，这样的操作太麻烦了。在 Firefox 中，如果你既想保护好自己的密码，又不想经常输入密码，就可以通过<ruby>主密码<rt>Master Password</rt></ruby>这一款内置的工具来实现你的需求。起用了这个工具之后，需要输入正确的主密码，才能后续使用保存在浏览器中的其它密码。你可以按照以下步骤进行操作：</p>\n<ol>\n<li>打开 Firefox。</li>\n<li>点击菜单按钮。</li>\n<li>点击“偏好设置”。</li>\n<li>在偏好设置页面，点击“隐私与安全”。</li>\n<li>在页面中勾选“使用主密码”选项（图 1）。</li>\n<li>确认以后，输入新的主密码（图 2）。</li>\n<li>重启 Firefox。</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_1.jpg?itok=gHMPKEvr\" alt=\"Master Password\" title=\"Master Password\"></p>\n<p><em>图 1： Firefox 偏好设置页中的主密码设置。</em></p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_2.jpg?itok=4L7DR2Ik\" alt=\"Setting password\" title=\"Setting password\"></p>\n<p><em>图 2：在 Firefox 中设置主密码。</em></p>\n<h3 id=\"了解你使用的扩展和插件\"><a href=\"#了解你使用的扩展和插件\" class=\"headerlink\" title=\"了解你使用的扩展和插件\"></a>了解你使用的扩展和插件</h3><p>大多数网络浏览器在保护隐私方面都有很多扩展，你可以根据自己的需求选择不同的扩展。而我自己则选择了一下这些扩展：</p>\n<ul>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/?src=search\" target=\"_blank\" rel=\"noopener\">Firefox Multi-Account Containers</a> —— 允许将某些站点配置为在容器化选项卡中打开。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/facebook-container/?src=search\" target=\"_blank\" rel=\"noopener\">Facebook Container</a> —— 始终在容器化选项卡中打开 Facebook（这个扩展需要 Firefox Multi-Account Containers）。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/avast-online-security/?src=search\" target=\"_blank\" rel=\"noopener\">Avast Online Security</a> —— 识别并拦截已知的钓鱼网站，并显示网站的安全评级（由超过 4 亿用户的 Avast 社区支持）。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/miningblocker/?src=search\" target=\"_blank\" rel=\"noopener\">Mining Blocker</a> —— 拦截所有使用 CPU 的挖矿工具。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/passff/?src=search\" target=\"_blank\" rel=\"noopener\">PassFF</a> —— 通过集成 <code>pass</code> （一个 UNIX 密码管理器）以安全存储密码。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-badger17/\" target=\"_blank\" rel=\"noopener\">Privacy Badger</a> —— 自动拦截网站跟踪。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/?src=search\" target=\"_blank\" rel=\"noopener\">uBlock Origin</a> —— 拦截已知的网站跟踪。</li>\n</ul>\n<p>除此以外，以下这些浏览器还有很多安全方面的扩展：</p>\n<ul>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/search/?q=security\" target=\"_blank\" rel=\"noopener\">Firefox</a></li>\n<li><a href=\"https://chrome.google.com/webstore/search/security\" target=\"_blank\" rel=\"noopener\">Chrome、Chromium,、Vivaldi</a></li>\n<li><a href=\"https://addons.opera.com/en/search/?query=security\" target=\"_blank\" rel=\"noopener\">Opera</a></li>\n</ul>\n<p>但并非每一个网络浏览器都会向用户提供扩展或插件。例如 Midoria 就只有少量可以开启或关闭的内置插件（图 3），同时这些轻量级浏览器的第三方插件也相当缺乏。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_3.jpg?itok=hdNor0gw\" alt=\"Midori Browser\" title=\"Midori Browser\"></p>\n<p><em>图 3：Midori 浏览器的插件窗口。</em></p>\n<h3 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h3><p>如果担心数据在本地存储会被窃取，也可以在虚拟机上运行网络浏览器。只需要安装诸如 <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> 的软件并安装 Linux 系统，然后就可以在虚拟机中运行任何一款浏览器了。再结合以上几条建议，基本可以保证一定的安全性。</p>\n<h3 id=\"事情的真相\"><a href=\"#事情的真相\" class=\"headerlink\" title=\"事情的真相\"></a>事情的真相</h3><p>实际上，如果你的机器连接到互联网，就永远不能保证 100% 的安全。当然，只要你正确地使用网络浏览器，你的安全系数会更高，数据也不会轻易被窃取。Linux 的一个好处是被安装恶意软件的几率比其它操作系统要低得多。另外，请记住要使用最新版本的网络浏览器、保持更新操作系统，并且谨慎访问一切网站。</p>\n<p>你还可以通过 Linux 基金会和 edX 开办的 “<a href=\"https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\" target=\"_blank\" rel=\"noopener\">Linux 介绍</a>” 公开课学习到更多这方面的内容。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这些简单的步骤可以大大提高您的在线安全性。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/cyber-security-20.jpg?itok=IkNDVnJr\" alt=\"\"></p>\n<p>如果你使用 Linux 桌面但从来不使用网络浏览器，那你算得上是百里挑一。网络浏览器是绝大多数人最常用的工具之一，无论是工作、娱乐、看新闻、社交、理财，对网络浏览器的依赖都比本地应用要多得多。因此，我们需要知道如何使用网络浏览器才是安全的。一直以来都有不法的犯罪分子以及他们建立的网页试图窃取私密的信息。正是由于我们需要通过网络浏览器收发大量的敏感信息，安全性就更是至关重要。</p>\n<p>对于用户来说，需要采取什么措施呢？在下文中，我会提出一些基本的建议，让你的重要数据不会被他人轻易窃取。尽管我用于演示的是 Firefox 网络浏览器，但其中大部分建议在任何一种网络浏览器当中都可以适用。</p>\n<h3 id=\"正确选择浏览器\"><a href=\"#正确选择浏览器\" class=\"headerlink\" title=\"正确选择浏览器\"></a>正确选择浏览器</h3><p>尽管我提出的建议具有普适性，但是正确选择网络浏览器也是很必要的。网络浏览器的更新频率是它安全性的一个重要体现。网络浏览器会不断暴露出新的问题，因此版本越新的网络浏览器修复的问题就越多，也越安全。在主流的网络浏览器当中，2017 年版本更新的发布量排行榜如下：</p>\n<ol>\n<li>Chrome 发布了 8 个更新（Chromium 全年跟进发布了大量安全补丁）。</li>\n<li>Firefox 发布了 7 个更新。</li>\n<li>Edge 发布了 2 个更新。</li>\n<li>Safari 发布了 1 个更新（苹果也会每年发布 5 到 6 个安全补丁）。</li>\n</ol>\n<p>网络浏览器会经常发布更新，同时用户也要及时升级到最新的版本，否则毫无意义了。尽管大部分流行的 Linux 发行版都会自动更新网络浏览器到最新版本，但还是有一些 Linux 发行版不会自动进行更新，所以最好还是手动保持浏览器更新到最新版本。这就意味着你所使用的 Linux 发行版对应的标准软件库中存放的很可能就不是最新版本的网络浏览器，在这种情况下，你可以随时从网络浏览器开发者提供的最新版本下载页中进行下载安装。</p>\n<p>如果你是一个勇于探索的人，你还可以尝试使用测试版或者<ruby>每日构建<rt>daily build</rt></ruby>版的网络浏览器，不过，这些版本将伴随着不能稳定运行的可能性。在基于 Ubuntu 的发行版中，你可以使用到每日构建版的 Firefox，只需要执行以下命令添加所需的存储库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa</span><br></pre></td></tr></table></figure>\n<p>按照以下命令更新 <code>apt</code> 并安装每日构建版 Firefox：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install firefox</span><br></pre></td></tr></table></figure>\n<p>最重要的事情就是永远不要让你的网络浏览器版本过时，必须使用最新版本的网络浏览器。就是这样。如果你没有跟上版本更新的脚步，你使用的将会是一个暴露着各种问题的浏览器。</p>\n<h3 id=\"使用隐私窗口\"><a href=\"#使用隐私窗口\" class=\"headerlink\" title=\"使用隐私窗口\"></a>使用隐私窗口</h3><p>将网络浏览器更新到最新版本之后，又该如何使用呢？答案是使用隐私窗口，如果你确实很重视安全的话。隐私窗口不会保存你的数据：密码？cookie？缓存？历史？什么都不会保存。因此隐私窗口的一个显著缺点就是每次访问常用的网站或者服务时，都得重新输入密码才能登录使用。当然，如果你认为网络浏览器的安全性很重要，就永远都不要保存任何密码。</p>\n<p>说到这里，我觉得每一个人都需要让自己的密码变得更强。事实上，大家都应该使用强密码，然后通过管理器来存储。而我的选择是<a href=\"http://upm.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><ruby>通用密码管理器<rt>Universal Password Manager</rt></ruby></a>。</p>\n<h3 id=\"保护好密码\"><a href=\"#保护好密码\" class=\"headerlink\" title=\"保护好密码\"></a>保护好密码</h3><p>有的人可能会认为，每次都需要重复输入密码，这样的操作太麻烦了。在 Firefox 中，如果你既想保护好自己的密码，又不想经常输入密码，就可以通过<ruby>主密码<rt>Master Password</rt></ruby>这一款内置的工具来实现你的需求。起用了这个工具之后，需要输入正确的主密码，才能后续使用保存在浏览器中的其它密码。你可以按照以下步骤进行操作：</p>\n<ol>\n<li>打开 Firefox。</li>\n<li>点击菜单按钮。</li>\n<li>点击“偏好设置”。</li>\n<li>在偏好设置页面，点击“隐私与安全”。</li>\n<li>在页面中勾选“使用主密码”选项（图 1）。</li>\n<li>确认以后，输入新的主密码（图 2）。</li>\n<li>重启 Firefox。</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_1.jpg?itok=gHMPKEvr\" alt=\"Master Password\" title=\"Master Password\"></p>\n<p><em>图 1： Firefox 偏好设置页中的主密码设置。</em></p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_2.jpg?itok=4L7DR2Ik\" alt=\"Setting password\" title=\"Setting password\"></p>\n<p><em>图 2：在 Firefox 中设置主密码。</em></p>\n<h3 id=\"了解你使用的扩展和插件\"><a href=\"#了解你使用的扩展和插件\" class=\"headerlink\" title=\"了解你使用的扩展和插件\"></a>了解你使用的扩展和插件</h3><p>大多数网络浏览器在保护隐私方面都有很多扩展，你可以根据自己的需求选择不同的扩展。而我自己则选择了一下这些扩展：</p>\n<ul>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/?src=search\" target=\"_blank\" rel=\"noopener\">Firefox Multi-Account Containers</a> —— 允许将某些站点配置为在容器化选项卡中打开。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/facebook-container/?src=search\" target=\"_blank\" rel=\"noopener\">Facebook Container</a> —— 始终在容器化选项卡中打开 Facebook（这个扩展需要 Firefox Multi-Account Containers）。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/avast-online-security/?src=search\" target=\"_blank\" rel=\"noopener\">Avast Online Security</a> —— 识别并拦截已知的钓鱼网站，并显示网站的安全评级（由超过 4 亿用户的 Avast 社区支持）。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/miningblocker/?src=search\" target=\"_blank\" rel=\"noopener\">Mining Blocker</a> —— 拦截所有使用 CPU 的挖矿工具。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/passff/?src=search\" target=\"_blank\" rel=\"noopener\">PassFF</a> —— 通过集成 <code>pass</code> （一个 UNIX 密码管理器）以安全存储密码。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-badger17/\" target=\"_blank\" rel=\"noopener\">Privacy Badger</a> —— 自动拦截网站跟踪。</li>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/?src=search\" target=\"_blank\" rel=\"noopener\">uBlock Origin</a> —— 拦截已知的网站跟踪。</li>\n</ul>\n<p>除此以外，以下这些浏览器还有很多安全方面的扩展：</p>\n<ul>\n<li><a href=\"https://addons.mozilla.org/en-US/firefox/search/?q=security\" target=\"_blank\" rel=\"noopener\">Firefox</a></li>\n<li><a href=\"https://chrome.google.com/webstore/search/security\" target=\"_blank\" rel=\"noopener\">Chrome、Chromium,、Vivaldi</a></li>\n<li><a href=\"https://addons.opera.com/en/search/?query=security\" target=\"_blank\" rel=\"noopener\">Opera</a></li>\n</ul>\n<p>但并非每一个网络浏览器都会向用户提供扩展或插件。例如 Midoria 就只有少量可以开启或关闭的内置插件（图 3），同时这些轻量级浏览器的第三方插件也相当缺乏。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/browsersecurity_3.jpg?itok=hdNor0gw\" alt=\"Midori Browser\" title=\"Midori Browser\"></p>\n<p><em>图 3：Midori 浏览器的插件窗口。</em></p>\n<h3 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h3><p>如果担心数据在本地存储会被窃取，也可以在虚拟机上运行网络浏览器。只需要安装诸如 <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> 的软件并安装 Linux 系统，然后就可以在虚拟机中运行任何一款浏览器了。再结合以上几条建议，基本可以保证一定的安全性。</p>\n<h3 id=\"事情的真相\"><a href=\"#事情的真相\" class=\"headerlink\" title=\"事情的真相\"></a>事情的真相</h3><p>实际上，如果你的机器连接到互联网，就永远不能保证 100% 的安全。当然，只要你正确地使用网络浏览器，你的安全系数会更高，数据也不会轻易被窃取。Linux 的一个好处是被安装恶意软件的几率比其它操作系统要低得多。另外，请记住要使用最新版本的网络浏览器、保持更新操作系统，并且谨慎访问一切网站。</p>\n<p>你还可以通过 Linux 基金会和 edX 开办的 “<a href=\"https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\" target=\"_blank\" rel=\"noopener\">Linux 介绍</a>” 公开课学习到更多这方面的内容。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/intro-to-linux/2018/11/5-easy-tips-linux-web-browser-security</a></p>\n"},{"title":"Linux 开发的五大必备工具","date":"2018-10-08T14:47:21.000Z","_content":"\n> Linux 上的开发工具如此之多，以至于会担心找不到恰好适合你的。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/dev-tools.png?itok=kkDNylRg)\n\nLinux 已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在 Linux 的帮助下，技术的变革速度超出了人们的想象，Linux 开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习 Linux 开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着 Linux 的发展，大量适用于 Linux 的开发工具也不断成熟。甚至可以说，这样的工具已经多得有点惊人。\n\n为了选择更合适自己的开发工具，缩小选择范围是很必要的。但是这篇文章并不会要求你必须使用某个工具，而只是缩小到五个工具类别，然后对每个类别提供一个例子。然而，对于大多数类别，都会有不止一种选择。下面我们来看一下。\n\n### 容器\n\n放眼于现实，现在已经是容器的时代了。容器既及其容易部署，又可以方便地构建开发环境。如果你针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。\n\n一个使用容器的最佳范例是使用 [Docker][1]，使用容器（或 Docker）有这些好处：\n\n  * 开发环境保持一致\n  * 部署后即可运行\n  * 易于跨平台部署\n  * Docker 映像适用于多种开发环境和语言\n  * 部署单个容器或容器集群都并不繁琐\n\n通过 [Docker Hub][2]，几乎可以找到适用于任何平台、任何开发环境、任何服务器、任何服务的映像，几乎可以满足任何一种需求。使用 Docker Hub 中的映像，就相当于免除了搭建开发环境的步骤，可以直接开始开发应用程序、服务器、API 或服务。\n\nDocker 在所有 Linux 平台上都很容易安装，例如可以通过终端输入以下命令在 Ubuntu 上安装 Docker：\n\n```\nsudo apt-get install docker.io\n```\n\nDocker 安装完毕后，就可以从 Docker 仓库中拉取映像，然后开始开发和部署了（如下图）。\n\n![Docker images][4]\n\n*图 1： Docker 镜像准备部署*\n\n### 版本控制工具\n\n如果你正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。在 Linux 系统上，[Git][6] 和 [GitHub][7] 的易用性和流行程度是其它版本控制工具无法比拟的。如果你对 Git 和 GitHub 还不太熟悉，可以简单理解为 Git 是在本地计算机上安装的版本控制系统，而 GitHub 则是用于上传和管理项目的远程存储库。 Git 可以安装在大多数的 Linux 发行版上。例如在基于 Debian 的系统上，只需要通过以下这一条简单的命令就可以安装：\n\n```\nsudo apt-get install git\n```\n\n安装完毕后，就可以使用 Git 来实施版本控制了（如下图）。\n\n![Git installed][9]\n\n*图 2：Git 已经安装，可以用于很多重要任务*\n\nGithub 会要求用户创建一个帐户。用户可以免费使用 GitHub 来管理非商用项目，当然也可以使用 GitHub 的付费模式（更多相关信息，可以参阅[价格矩阵][10]）。\n\n### 文本编辑器\n\n如果没有文本编辑器，在 Linux 上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。对于文本编辑器，有人可能会使用 vim、emacs 或 nano，也有人会使用带有 GUI 的编辑器。但由于重点在于开发，我们需要的是一种能够满足开发人员需求的工具。不过我首先要说，vim 对于开发人员来说确实是一个利器，但前提是要对 vim 非常熟悉，在这种前提下，vim 能够满足你的所有需求，甚至还能给你更好的体验。然而，对于一些开发者（尤其是刚开始接触 Linux 的新手）来说，这不仅难以帮助他们快速达成需求，甚至还会是一个需要逾越的障碍。考虑到这篇文章的目标是帮助 Linux 的新手（而不仅仅是为各种编辑器的死忠粉宣传他们拥护的编辑器），我更倾向于使用 GUI 编辑器。\n\n就文本编辑器而论，选择 [Bluefish][11] 一般不会有错。 Bluefish 可以从大部分软件库中安装，它支持项目管理、远程文件多线程操作、搜索和替换、递归打开文件、侧边栏、集成 make/lint/weblint/xmllint、无限制撤销/重做、在线拼写检查、自动恢复、全屏编辑、语法高亮（如下图）、多种语言等等。\n\n![Bluefish][13]\n\n*图 3：运行在 Ubuntu 18.04 上的 Bluefish*\n\n### IDE\n\n<ruby>集成开发环境<rt>Integrated Development Environment</rt></ruby>（IDE）是包含一整套全面的工具、可以实现一站式功能的开发环境。 开发者除了可以使用 IDE 编写代码，还可以编写文档和构建软件。在 Linux 上也有很多适用的 IDE，其中 [Geany][14] 就包含在标准软件库中，它对用户非常友好，功能也相当强大。 Geany 具有语法高亮、代码折叠、自动完成，构建代码片段、自动关闭 XML 和 HTML 标签、调用提示、支持多种文件类型、符号列表、代码导航、构建编译，简单的项目管理和内置的插件系统等强大功能。\n\nGeany 也能在系统上轻松安装，例如执行以下命令在基于 Debian 的 Linux 发行版上安装 Geany：\n\n```\nsudo apt-get install geany\n```\n\n安装完毕后，就可以快速上手这个易用且强大的 IDE 了（如下图）。\n\n![Geany][16]\n\n*图 4：Geany 可以作为你的 IDE*\n\n### 文本比较工具\n\n有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本（有一个经过编译，而另一个没有）。这种情况下，你肯定不想要凭借肉眼来找出差异，而是想要使用像 [Meld][17] 这样的工具。 Meld 是针对开发者的文本比较和合并工具，可以使用 Meld 来发现两个文件之间的差异。虽然你可以使用命令行中的文本比较工具，但就效率而论，Meld 无疑更为优秀。\n\nMeld 可以打开两个文件进行比较，并突出显示文件之间的差异之处。 Meld 还允许用户从两个文件的其中一方合并差异（下图显示了 Meld 同时打开两个文件）。\n\n![Comparing two files][19]\n\n*图 5： 以简单差异的模式比较两个文件*\n\nMeld 也可以通过大多数标准的软件库安装，在基于 Debian 的系统上，执行以下命令就可以安装：\n\n```\nsudo apt-get install meld\n```\n\n### 高效地工作\n\n以上提到的五个工具除了帮助你完成工作，而且有助于提高效率。尽管适用于 Linux 开发者的工具有很多，但对于以上几个类别，你最好分别使用一个对应的工具。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development\n\n[a]:https://www.linux.com/users/jlwallen\n[1]:https://www.docker.com/\n[2]:https://hub.docker.com/\n[4]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_1.jpg?itok=V1Bsbkg9 \"Docker images\"\n[6]:https://git-scm.com/\n[7]:https://github.com/\n[9]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_2.jpg?itok=YJjhe4O6 \"Git installed\"\n[10]:https://github.com/pricing\n[11]:http://bluefish.openoffice.nl/index.html\n[13]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_3.jpg?itok=66A7Svme \"Bluefish\"\n[14]:https://www.geany.org/\n[16]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_4.jpg?itok=jRcA-0ue \"Geany\"\n[17]:http://meldmerge.org/\n[19]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_5.jpg?itok=eLkfM9oZ \"Comparing two files\"\n[20]:https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\n\n","source":"_posts/5-Essential-Tools-for-Linux-Development.md","raw":"---\ntitle: Linux 开发的五大必备工具\ndate: 2018-10-08 22:47:21\ntags:\n  - Linux\n  - LCTT 翻译\n---\n\n> Linux 上的开发工具如此之多，以至于会担心找不到恰好适合你的。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/dev-tools.png?itok=kkDNylRg)\n\nLinux 已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在 Linux 的帮助下，技术的变革速度超出了人们的想象，Linux 开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习 Linux 开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着 Linux 的发展，大量适用于 Linux 的开发工具也不断成熟。甚至可以说，这样的工具已经多得有点惊人。\n\n为了选择更合适自己的开发工具，缩小选择范围是很必要的。但是这篇文章并不会要求你必须使用某个工具，而只是缩小到五个工具类别，然后对每个类别提供一个例子。然而，对于大多数类别，都会有不止一种选择。下面我们来看一下。\n\n### 容器\n\n放眼于现实，现在已经是容器的时代了。容器既及其容易部署，又可以方便地构建开发环境。如果你针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。\n\n一个使用容器的最佳范例是使用 [Docker][1]，使用容器（或 Docker）有这些好处：\n\n  * 开发环境保持一致\n  * 部署后即可运行\n  * 易于跨平台部署\n  * Docker 映像适用于多种开发环境和语言\n  * 部署单个容器或容器集群都并不繁琐\n\n通过 [Docker Hub][2]，几乎可以找到适用于任何平台、任何开发环境、任何服务器、任何服务的映像，几乎可以满足任何一种需求。使用 Docker Hub 中的映像，就相当于免除了搭建开发环境的步骤，可以直接开始开发应用程序、服务器、API 或服务。\n\nDocker 在所有 Linux 平台上都很容易安装，例如可以通过终端输入以下命令在 Ubuntu 上安装 Docker：\n\n```\nsudo apt-get install docker.io\n```\n\nDocker 安装完毕后，就可以从 Docker 仓库中拉取映像，然后开始开发和部署了（如下图）。\n\n![Docker images][4]\n\n*图 1： Docker 镜像准备部署*\n\n### 版本控制工具\n\n如果你正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。在 Linux 系统上，[Git][6] 和 [GitHub][7] 的易用性和流行程度是其它版本控制工具无法比拟的。如果你对 Git 和 GitHub 还不太熟悉，可以简单理解为 Git 是在本地计算机上安装的版本控制系统，而 GitHub 则是用于上传和管理项目的远程存储库。 Git 可以安装在大多数的 Linux 发行版上。例如在基于 Debian 的系统上，只需要通过以下这一条简单的命令就可以安装：\n\n```\nsudo apt-get install git\n```\n\n安装完毕后，就可以使用 Git 来实施版本控制了（如下图）。\n\n![Git installed][9]\n\n*图 2：Git 已经安装，可以用于很多重要任务*\n\nGithub 会要求用户创建一个帐户。用户可以免费使用 GitHub 来管理非商用项目，当然也可以使用 GitHub 的付费模式（更多相关信息，可以参阅[价格矩阵][10]）。\n\n### 文本编辑器\n\n如果没有文本编辑器，在 Linux 上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。对于文本编辑器，有人可能会使用 vim、emacs 或 nano，也有人会使用带有 GUI 的编辑器。但由于重点在于开发，我们需要的是一种能够满足开发人员需求的工具。不过我首先要说，vim 对于开发人员来说确实是一个利器，但前提是要对 vim 非常熟悉，在这种前提下，vim 能够满足你的所有需求，甚至还能给你更好的体验。然而，对于一些开发者（尤其是刚开始接触 Linux 的新手）来说，这不仅难以帮助他们快速达成需求，甚至还会是一个需要逾越的障碍。考虑到这篇文章的目标是帮助 Linux 的新手（而不仅仅是为各种编辑器的死忠粉宣传他们拥护的编辑器），我更倾向于使用 GUI 编辑器。\n\n就文本编辑器而论，选择 [Bluefish][11] 一般不会有错。 Bluefish 可以从大部分软件库中安装，它支持项目管理、远程文件多线程操作、搜索和替换、递归打开文件、侧边栏、集成 make/lint/weblint/xmllint、无限制撤销/重做、在线拼写检查、自动恢复、全屏编辑、语法高亮（如下图）、多种语言等等。\n\n![Bluefish][13]\n\n*图 3：运行在 Ubuntu 18.04 上的 Bluefish*\n\n### IDE\n\n<ruby>集成开发环境<rt>Integrated Development Environment</rt></ruby>（IDE）是包含一整套全面的工具、可以实现一站式功能的开发环境。 开发者除了可以使用 IDE 编写代码，还可以编写文档和构建软件。在 Linux 上也有很多适用的 IDE，其中 [Geany][14] 就包含在标准软件库中，它对用户非常友好，功能也相当强大。 Geany 具有语法高亮、代码折叠、自动完成，构建代码片段、自动关闭 XML 和 HTML 标签、调用提示、支持多种文件类型、符号列表、代码导航、构建编译，简单的项目管理和内置的插件系统等强大功能。\n\nGeany 也能在系统上轻松安装，例如执行以下命令在基于 Debian 的 Linux 发行版上安装 Geany：\n\n```\nsudo apt-get install geany\n```\n\n安装完毕后，就可以快速上手这个易用且强大的 IDE 了（如下图）。\n\n![Geany][16]\n\n*图 4：Geany 可以作为你的 IDE*\n\n### 文本比较工具\n\n有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本（有一个经过编译，而另一个没有）。这种情况下，你肯定不想要凭借肉眼来找出差异，而是想要使用像 [Meld][17] 这样的工具。 Meld 是针对开发者的文本比较和合并工具，可以使用 Meld 来发现两个文件之间的差异。虽然你可以使用命令行中的文本比较工具，但就效率而论，Meld 无疑更为优秀。\n\nMeld 可以打开两个文件进行比较，并突出显示文件之间的差异之处。 Meld 还允许用户从两个文件的其中一方合并差异（下图显示了 Meld 同时打开两个文件）。\n\n![Comparing two files][19]\n\n*图 5： 以简单差异的模式比较两个文件*\n\nMeld 也可以通过大多数标准的软件库安装，在基于 Debian 的系统上，执行以下命令就可以安装：\n\n```\nsudo apt-get install meld\n```\n\n### 高效地工作\n\n以上提到的五个工具除了帮助你完成工作，而且有助于提高效率。尽管适用于 Linux 开发者的工具有很多，但对于以上几个类别，你最好分别使用一个对应的工具。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development\n\n[a]:https://www.linux.com/users/jlwallen\n[1]:https://www.docker.com/\n[2]:https://hub.docker.com/\n[4]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_1.jpg?itok=V1Bsbkg9 \"Docker images\"\n[6]:https://git-scm.com/\n[7]:https://github.com/\n[9]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_2.jpg?itok=YJjhe4O6 \"Git installed\"\n[10]:https://github.com/pricing\n[11]:http://bluefish.openoffice.nl/index.html\n[13]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_3.jpg?itok=66A7Svme \"Bluefish\"\n[14]:https://www.geany.org/\n[16]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_4.jpg?itok=jRcA-0ue \"Geany\"\n[17]:http://meldmerge.org/\n[19]:https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_5.jpg?itok=eLkfM9oZ \"Comparing two files\"\n[20]:https://training.linuxfoundation.org/linux-courses/system-administration-training/introduction-to-linux\n\n","slug":"5-Essential-Tools-for-Linux-Development","published":1,"updated":"2019-03-28T11:14:53.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0bq0006lixuab5ul2az","content":"<blockquote>\n<p>Linux 上的开发工具如此之多，以至于会担心找不到恰好适合你的。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/dev-tools.png?itok=kkDNylRg\" alt=\"\"></p>\n<p>Linux 已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在 Linux 的帮助下，技术的变革速度超出了人们的想象，Linux 开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习 Linux 开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着 Linux 的发展，大量适用于 Linux 的开发工具也不断成熟。甚至可以说，这样的工具已经多得有点惊人。</p>\n<p>为了选择更合适自己的开发工具，缩小选择范围是很必要的。但是这篇文章并不会要求你必须使用某个工具，而只是缩小到五个工具类别，然后对每个类别提供一个例子。然而，对于大多数类别，都会有不止一种选择。下面我们来看一下。</p>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>放眼于现实，现在已经是容器的时代了。容器既及其容易部署，又可以方便地构建开发环境。如果你针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。</p>\n<p>一个使用容器的最佳范例是使用 <a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker</a>，使用容器（或 Docker）有这些好处：</p>\n<ul>\n<li>开发环境保持一致</li>\n<li>部署后即可运行</li>\n<li>易于跨平台部署</li>\n<li>Docker 映像适用于多种开发环境和语言</li>\n<li>部署单个容器或容器集群都并不繁琐</li>\n</ul>\n<p>通过 <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>，几乎可以找到适用于任何平台、任何开发环境、任何服务器、任何服务的映像，几乎可以满足任何一种需求。使用 Docker Hub 中的映像，就相当于免除了搭建开发环境的步骤，可以直接开始开发应用程序、服务器、API 或服务。</p>\n<p>Docker 在所有 Linux 平台上都很容易安装，例如可以通过终端输入以下命令在 Ubuntu 上安装 Docker：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker.io</span><br></pre></td></tr></table></figure>\n<p>Docker 安装完毕后，就可以从 Docker 仓库中拉取映像，然后开始开发和部署了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_1.jpg?itok=V1Bsbkg9\" alt=\"Docker images\" title=\"Docker images\"></p>\n<p><em>图 1： Docker 镜像准备部署</em></p>\n<h3 id=\"版本控制工具\"><a href=\"#版本控制工具\" class=\"headerlink\" title=\"版本控制工具\"></a>版本控制工具</h3><p>如果你正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。在 Linux 系统上，<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a> 和 <a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a> 的易用性和流行程度是其它版本控制工具无法比拟的。如果你对 Git 和 GitHub 还不太熟悉，可以简单理解为 Git 是在本地计算机上安装的版本控制系统，而 GitHub 则是用于上传和管理项目的远程存储库。 Git 可以安装在大多数的 Linux 发行版上。例如在基于 Debian 的系统上，只需要通过以下这一条简单的命令就可以安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，就可以使用 Git 来实施版本控制了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_2.jpg?itok=YJjhe4O6\" alt=\"Git installed\" title=\"Git installed\"></p>\n<p><em>图 2：Git 已经安装，可以用于很多重要任务</em></p>\n<p>Github 会要求用户创建一个帐户。用户可以免费使用 GitHub 来管理非商用项目，当然也可以使用 GitHub 的付费模式（更多相关信息，可以参阅<a href=\"https://github.com/pricing\" target=\"_blank\" rel=\"noopener\">价格矩阵</a>）。</p>\n<h3 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h3><p>如果没有文本编辑器，在 Linux 上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。对于文本编辑器，有人可能会使用 vim、emacs 或 nano，也有人会使用带有 GUI 的编辑器。但由于重点在于开发，我们需要的是一种能够满足开发人员需求的工具。不过我首先要说，vim 对于开发人员来说确实是一个利器，但前提是要对 vim 非常熟悉，在这种前提下，vim 能够满足你的所有需求，甚至还能给你更好的体验。然而，对于一些开发者（尤其是刚开始接触 Linux 的新手）来说，这不仅难以帮助他们快速达成需求，甚至还会是一个需要逾越的障碍。考虑到这篇文章的目标是帮助 Linux 的新手（而不仅仅是为各种编辑器的死忠粉宣传他们拥护的编辑器），我更倾向于使用 GUI 编辑器。</p>\n<p>就文本编辑器而论，选择 <a href=\"http://bluefish.openoffice.nl/index.html\" target=\"_blank\" rel=\"noopener\">Bluefish</a> 一般不会有错。 Bluefish 可以从大部分软件库中安装，它支持项目管理、远程文件多线程操作、搜索和替换、递归打开文件、侧边栏、集成 make/lint/weblint/xmllint、无限制撤销/重做、在线拼写检查、自动恢复、全屏编辑、语法高亮（如下图）、多种语言等等。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_3.jpg?itok=66A7Svme\" alt=\"Bluefish\" title=\"Bluefish\"></p>\n<p><em>图 3：运行在 Ubuntu 18.04 上的 Bluefish</em></p>\n<h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p><ruby>集成开发环境<rt>Integrated Development Environment</rt></ruby>（IDE）是包含一整套全面的工具、可以实现一站式功能的开发环境。 开发者除了可以使用 IDE 编写代码，还可以编写文档和构建软件。在 Linux 上也有很多适用的 IDE，其中 <a href=\"https://www.geany.org/\" target=\"_blank\" rel=\"noopener\">Geany</a> 就包含在标准软件库中，它对用户非常友好，功能也相当强大。 Geany 具有语法高亮、代码折叠、自动完成，构建代码片段、自动关闭 XML 和 HTML 标签、调用提示、支持多种文件类型、符号列表、代码导航、构建编译，简单的项目管理和内置的插件系统等强大功能。</p>\n<p>Geany 也能在系统上轻松安装，例如执行以下命令在基于 Debian 的 Linux 发行版上安装 Geany：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install geany</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，就可以快速上手这个易用且强大的 IDE 了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_4.jpg?itok=jRcA-0ue\" alt=\"Geany\" title=\"Geany\"></p>\n<p><em>图 4：Geany 可以作为你的 IDE</em></p>\n<h3 id=\"文本比较工具\"><a href=\"#文本比较工具\" class=\"headerlink\" title=\"文本比较工具\"></a>文本比较工具</h3><p>有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本（有一个经过编译，而另一个没有）。这种情况下，你肯定不想要凭借肉眼来找出差异，而是想要使用像 <a href=\"http://meldmerge.org/\" target=\"_blank\" rel=\"noopener\">Meld</a> 这样的工具。 Meld 是针对开发者的文本比较和合并工具，可以使用 Meld 来发现两个文件之间的差异。虽然你可以使用命令行中的文本比较工具，但就效率而论，Meld 无疑更为优秀。</p>\n<p>Meld 可以打开两个文件进行比较，并突出显示文件之间的差异之处。 Meld 还允许用户从两个文件的其中一方合并差异（下图显示了 Meld 同时打开两个文件）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_5.jpg?itok=eLkfM9oZ\" alt=\"Comparing two files\" title=\"Comparing two files\"></p>\n<p><em>图 5： 以简单差异的模式比较两个文件</em></p>\n<p>Meld 也可以通过大多数标准的软件库安装，在基于 Debian 的系统上，执行以下命令就可以安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install meld</span><br></pre></td></tr></table></figure>\n<h3 id=\"高效地工作\"><a href=\"#高效地工作\" class=\"headerlink\" title=\"高效地工作\"></a>高效地工作</h3><p>以上提到的五个工具除了帮助你完成工作，而且有助于提高效率。尽管适用于 Linux 开发者的工具有很多，但对于以上几个类别，你最好分别使用一个对应的工具。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Linux 上的开发工具如此之多，以至于会担心找不到恰好适合你的。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/dev-tools.png?itok=kkDNylRg\" alt=\"\"></p>\n<p>Linux 已经成为工作、娱乐和个人生活等多个领域的支柱，人们已经越来越离不开它。在 Linux 的帮助下，技术的变革速度超出了人们的想象，Linux 开发的速度也以指数规模增长。因此，越来越多的开发者也不断地加入开源和学习 Linux 开发地潮流当中。在这个过程之中，合适的工具是必不可少的，可喜的是，随着 Linux 的发展，大量适用于 Linux 的开发工具也不断成熟。甚至可以说，这样的工具已经多得有点惊人。</p>\n<p>为了选择更合适自己的开发工具，缩小选择范围是很必要的。但是这篇文章并不会要求你必须使用某个工具，而只是缩小到五个工具类别，然后对每个类别提供一个例子。然而，对于大多数类别，都会有不止一种选择。下面我们来看一下。</p>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>放眼于现实，现在已经是容器的时代了。容器既及其容易部署，又可以方便地构建开发环境。如果你针对的是特定的平台的开发，将开发流程所需要的各种工具都创建到容器映像中是一种很好的方法，只要使用这一个容器映像，就能够快速启动大量运行所需服务的实例。</p>\n<p>一个使用容器的最佳范例是使用 <a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker</a>，使用容器（或 Docker）有这些好处：</p>\n<ul>\n<li>开发环境保持一致</li>\n<li>部署后即可运行</li>\n<li>易于跨平台部署</li>\n<li>Docker 映像适用于多种开发环境和语言</li>\n<li>部署单个容器或容器集群都并不繁琐</li>\n</ul>\n<p>通过 <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>，几乎可以找到适用于任何平台、任何开发环境、任何服务器、任何服务的映像，几乎可以满足任何一种需求。使用 Docker Hub 中的映像，就相当于免除了搭建开发环境的步骤，可以直接开始开发应用程序、服务器、API 或服务。</p>\n<p>Docker 在所有 Linux 平台上都很容易安装，例如可以通过终端输入以下命令在 Ubuntu 上安装 Docker：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker.io</span><br></pre></td></tr></table></figure>\n<p>Docker 安装完毕后，就可以从 Docker 仓库中拉取映像，然后开始开发和部署了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_1.jpg?itok=V1Bsbkg9\" alt=\"Docker images\" title=\"Docker images\"></p>\n<p><em>图 1： Docker 镜像准备部署</em></p>\n<h3 id=\"版本控制工具\"><a href=\"#版本控制工具\" class=\"headerlink\" title=\"版本控制工具\"></a>版本控制工具</h3><p>如果你正在开发一个大型项目，又或者参与团队开发，版本控制工具是必不可少的，它可以用于记录代码变更、提交代码以及合并代码。如果没有这样的工具，项目几乎无法妥善管理。在 Linux 系统上，<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a> 和 <a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a> 的易用性和流行程度是其它版本控制工具无法比拟的。如果你对 Git 和 GitHub 还不太熟悉，可以简单理解为 Git 是在本地计算机上安装的版本控制系统，而 GitHub 则是用于上传和管理项目的远程存储库。 Git 可以安装在大多数的 Linux 发行版上。例如在基于 Debian 的系统上，只需要通过以下这一条简单的命令就可以安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，就可以使用 Git 来实施版本控制了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_2.jpg?itok=YJjhe4O6\" alt=\"Git installed\" title=\"Git installed\"></p>\n<p><em>图 2：Git 已经安装，可以用于很多重要任务</em></p>\n<p>Github 会要求用户创建一个帐户。用户可以免费使用 GitHub 来管理非商用项目，当然也可以使用 GitHub 的付费模式（更多相关信息，可以参阅<a href=\"https://github.com/pricing\" target=\"_blank\" rel=\"noopener\">价格矩阵</a>）。</p>\n<h3 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h3><p>如果没有文本编辑器，在 Linux 上开发将会变得异常艰难。当然，文本编辑器之间孰优孰劣，具体还是要取决于开发者的需求。对于文本编辑器，有人可能会使用 vim、emacs 或 nano，也有人会使用带有 GUI 的编辑器。但由于重点在于开发，我们需要的是一种能够满足开发人员需求的工具。不过我首先要说，vim 对于开发人员来说确实是一个利器，但前提是要对 vim 非常熟悉，在这种前提下，vim 能够满足你的所有需求，甚至还能给你更好的体验。然而，对于一些开发者（尤其是刚开始接触 Linux 的新手）来说，这不仅难以帮助他们快速达成需求，甚至还会是一个需要逾越的障碍。考虑到这篇文章的目标是帮助 Linux 的新手（而不仅仅是为各种编辑器的死忠粉宣传他们拥护的编辑器），我更倾向于使用 GUI 编辑器。</p>\n<p>就文本编辑器而论，选择 <a href=\"http://bluefish.openoffice.nl/index.html\" target=\"_blank\" rel=\"noopener\">Bluefish</a> 一般不会有错。 Bluefish 可以从大部分软件库中安装，它支持项目管理、远程文件多线程操作、搜索和替换、递归打开文件、侧边栏、集成 make/lint/weblint/xmllint、无限制撤销/重做、在线拼写检查、自动恢复、全屏编辑、语法高亮（如下图）、多种语言等等。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_3.jpg?itok=66A7Svme\" alt=\"Bluefish\" title=\"Bluefish\"></p>\n<p><em>图 3：运行在 Ubuntu 18.04 上的 Bluefish</em></p>\n<h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p><ruby>集成开发环境<rt>Integrated Development Environment</rt></ruby>（IDE）是包含一整套全面的工具、可以实现一站式功能的开发环境。 开发者除了可以使用 IDE 编写代码，还可以编写文档和构建软件。在 Linux 上也有很多适用的 IDE，其中 <a href=\"https://www.geany.org/\" target=\"_blank\" rel=\"noopener\">Geany</a> 就包含在标准软件库中，它对用户非常友好，功能也相当强大。 Geany 具有语法高亮、代码折叠、自动完成，构建代码片段、自动关闭 XML 和 HTML 标签、调用提示、支持多种文件类型、符号列表、代码导航、构建编译，简单的项目管理和内置的插件系统等强大功能。</p>\n<p>Geany 也能在系统上轻松安装，例如执行以下命令在基于 Debian 的 Linux 发行版上安装 Geany：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install geany</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，就可以快速上手这个易用且强大的 IDE 了（如下图）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_4.jpg?itok=jRcA-0ue\" alt=\"Geany\" title=\"Geany\"></p>\n<p><em>图 4：Geany 可以作为你的 IDE</em></p>\n<h3 id=\"文本比较工具\"><a href=\"#文本比较工具\" class=\"headerlink\" title=\"文本比较工具\"></a>文本比较工具</h3><p>有时候会需要比较两个文件的内容来找到它们之间的不同之处，它们可能是同一文件的两个不同副本（有一个经过编译，而另一个没有）。这种情况下，你肯定不想要凭借肉眼来找出差异，而是想要使用像 <a href=\"http://meldmerge.org/\" target=\"_blank\" rel=\"noopener\">Meld</a> 这样的工具。 Meld 是针对开发者的文本比较和合并工具，可以使用 Meld 来发现两个文件之间的差异。虽然你可以使用命令行中的文本比较工具，但就效率而论，Meld 无疑更为优秀。</p>\n<p>Meld 可以打开两个文件进行比较，并突出显示文件之间的差异之处。 Meld 还允许用户从两个文件的其中一方合并差异（下图显示了 Meld 同时打开两个文件）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/5devtools_5.jpg?itok=eLkfM9oZ\" alt=\"Comparing two files\" title=\"Comparing two files\"></p>\n<p><em>图 5： 以简单差异的模式比较两个文件</em></p>\n<p>Meld 也可以通过大多数标准的软件库安装，在基于 Debian 的系统上，执行以下命令就可以安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install meld</span><br></pre></td></tr></table></figure>\n<h3 id=\"高效地工作\"><a href=\"#高效地工作\" class=\"headerlink\" title=\"高效地工作\"></a>高效地工作</h3><p>以上提到的五个工具除了帮助你完成工作，而且有助于提高效率。尽管适用于 Linux 开发者的工具有很多，但对于以上几个类别，你最好分别使用一个对应的工具。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/intro-to-linux/2018/8/5-essential-tools-linux-development</a></p>\n"},{"title":"在 Linux 下截屏并编辑的最佳工具","date":"2018-10-01T13:15:54.000Z","_content":"\n> 有几种获取屏幕截图并对其进行添加文字、箭头等编辑的方法，这里提及的的屏幕截图工具在 Ubuntu 和其它主流 Linux 发行版中都能够使用。\n\n![在 Ubuntu Linux 中如何获取屏幕截图][1]\n\n当我的主力操作系统从 Windows 转换到 Ubuntu 的时候，首要考虑的就是屏幕截图工具的可用性。尽管使用默认的键盘快捷键也可以获取屏幕截图，但如果使用屏幕截图工具，可以更方便地对屏幕截图进行编辑。\n\n本文将会介绍在不适用第三方工具的情况下，如何通过系统自带的方法和工具获取屏幕截图，另外还会介绍一些可用于 Linux 的最佳截图工具。\n\n### 方法 1：在 Linux 中截图的默认方式\n\n你想要截取整个屏幕？屏幕中的某个区域？某个特定的窗口？\n\n如果只需要获取一张屏幕截图，不对其进行编辑的话，那么键盘的默认快捷键就可以满足要求了。而且不仅仅是 Ubuntu ，绝大部分的 Linux 发行版和桌面环境都支持以下这些快捷键：\n\n- `PrtSc` – 获取整个屏幕的截图并保存到 Pictures 目录。\n- `Shift + PrtSc` – 获取屏幕的某个区域截图并保存到 Pictures 目录。\n- `Alt + PrtSc` –获取当前窗口的截图并保存到 Pictures 目录。\n- `Ctrl + PrtSc` – 获取整个屏幕的截图并存放到剪贴板。\n- `Shift + Ctrl + PrtSc` – 获取屏幕的某个区域截图并存放到剪贴板。\n- `Ctrl + Alt + PrtSc` – 获取当前窗口的 截图并存放到剪贴板。\n\n如上所述，在 Linux 中使用默认的快捷键获取屏幕截图是相当简单的。但如果要在不把屏幕截图导入到其它应用程序的情况下对屏幕截图进行编辑，还是使用屏幕截图工具比较方便。\n\n### 方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑\n\n![flameshot][2]\n\n功能概述：\n\n  * 注释 (高亮、标示、添加文本、框选)\n  * 图片模糊\n  * 图片裁剪\n  * 上传到 Imgur\n  * 用另一个应用打开截图\n\nFlameshot 在去年发布到 [GitHub][3]，并成为一个引人注目的工具。\n\n如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。\n\n下面将会介绍如何安装 Flameshot 并根据你的偏好进行配置。\n\n如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了。要是你想使用终端来安装，可以执行以下命令：\n\n```\nsudo apt install flameshot\n```\n\n如果你在安装过程中遇到问题，可以按照[官方的安装说明][4]进行操作。安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 `PrtSc` 键触发启动，则需要指定对应的键盘快捷键。以下是相关配置步骤：\n\n  * 进入系统设置中的“键盘设置”\n  * 页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮\n  * 点击 “+” 按钮添加自定义快捷键并输入以下两个字段：\n    * “名称”： 任意名称均可。\n    * “命令”： `/usr/bin/flameshot gui`\n  * 最后将这个快捷操作绑定到  `PrtSc` 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。\n\n配置之后，你的自定义快捷键页面大概会是以下这样：\n\n![][5]\n\n*将键盘快捷键映射到 Flameshot*\n\n### 方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑\n\n![][6]\n\n功能概述：\n\n  * 注释 (高亮、标示、添加文本、框选)\n  * 图片模糊\n  * 图片裁剪\n  * 上传到图片网站\n\n[Shutter][7] 是一个对所有主流 Linux 发行版都适用的屏幕截图工具。尽管最近已经不太更新了，但仍然是操作屏幕截图的一个优秀工具。\n\n在使用过程中可能会遇到这个工具的一些缺陷。Shutter 在任何一款最新的 Linux 发行版上最常见的问题就是由于缺少了任务栏上的程序图标，导致默认禁用了编辑屏幕截图的功能。 对于这个缺陷，还是有解决方案的。你只需要跟随我们的教程[在 Shutter 中修复这个禁止编辑选项并将程序图标在任务栏上显示出来][8]。问题修复后，就可以使用 Shutter 来快速编辑屏幕截图了。\n\n同样地，在软件中心搜索也可以找到进而安装 Shutter，也可以在基于 Ubuntu 的发行版中执行以下命令使用命令行安装：\n\n```\nsudo apt install shutter\n```\n\n类似 Flameshot，你可以通过搜索 Shutter 手动启动它，也可以按照相似的方式设置自定义快捷方式以 `PrtSc` 键唤起 Shutter。\n\n如果要指定自定义键盘快捷键，只需要执行以下命令：\n\n```\nshutter -f\n```\n\n### 方法 4：在 Linux 中使用 GIMP 获取屏幕截图\n\n![][9]\n\n功能概述：\n\n  * 高级图像编辑功能（缩放、添加滤镜、颜色校正、添加图层、裁剪等）\n  * 截取某一区域的屏幕截图\n\n如果需要对屏幕截图进行一些预先编辑，GIMP 是一个不错的选择。\n\n通过软件中心可以安装 GIMP。如果在安装时遇到问题，可以参考其[官方网站的安装说明][10]。\n\n要使用 GIMP 获取屏幕截图，需要先启动程序，然后通过 “File-> Create-> Screenshot” 导航。\n\n打开 Screenshot 选项后，会看到几个控制点来控制屏幕截图范围。点击 “Snap” 截取屏幕截图，图像将自动显示在 GIMP 中可供编辑。\n\n### 方法 5：在 Linux 中使用命令行工具获取屏幕截图\n\n这一节内容仅适用于终端爱好者。如果你也喜欢使用终端，可以使用 “GNOME 截图工具”或 “ImageMagick” 或 “Deepin Scrot”，大部分流行的 Linux 发行版中都自带这些工具。\n\n要立即获取屏幕截图，可以执行以下命令：\n\n#### GNOME 截图工具（可用于 GNOME 桌面）\n\n```\ngnome-screenshot\n```\n\nGNOME 截图工具是使用 GNOME 桌面的 Linux 发行版中都自带的一个默认工具。如果需要延时获取屏幕截图，可以执行以下命令（这里的 `5` 是需要延迟的秒数）：\n\n```\ngnome-screenshot -d -5\n```\n\n#### ImageMagick\n\n如果你的操作系统是 Ubuntu、Mint 或其它流行的 Linux 发行版，一般会自带 [ImageMagick][11] 这个工具。如果没有这个工具，也可以按照[官方安装说明][12]使用安装源来安装。你也可以在终端中执行这个命令：\n\n```\nsudo apt-get install imagemagick\n```\n\n安装完成后，执行下面的命令就可以获取到屏幕截图（截取整个屏幕）：\n\n```\nimport -window root image.png\n```\n\n这里的 “image.png” 就是屏幕截图文件保存的名称。\n\n要获取屏幕一个区域的截图，可以执行以下命令:\n\n```\nimport image.png\n```\n\n#### Deepin Scrot\n\nDeepin Scrot 是基于终端的一个较新的截图工具。和前面两个工具类似，一般自带于 Linux 发行版中。如果需要自行安装，可以执行以下命令：\n\n```\nsudo apt-get install scrot\n```\n\n安装完成后，使用下面这些命令可以获取屏幕截图。\n\n获取整个屏幕的截图：\n\n```\nscrot myimage.png\n```\n\n获取屏幕某一区域的截图：\n\n```\nscrot -s myimage.png\n```\n\n### 总结\n\n以上是一些在 Linux 上的优秀截图工具。当然还有很多截图工具没有提及（例如用于 KDE 发行版的 [Spectacle][13]），但相比起来还是上面几个工具更为好用。\n\n如果你有比文章中提到的更好的截图工具，欢迎讨论！\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/take-screenshot-linux/\n\n[a]: https://itsfoss.com/author/ankush/\n[1]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Taking-Screenshots-in-Linux.png\n[2]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-pic.png\n[3]: https://github.com/lupoDharkael/flameshot\n[4]: https://github.com/lupoDharkael/flameshot#installation\n[5]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-config-default.png\n[6]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/shutter-screenshot.jpg\n[7]: http://shutter-project.org/\n[8]: https://itsfoss.com/shutter-edit-button-disabled/\n[9]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/gimp-screenshot.jpg\n[10]: https://www.gimp.org/downloads/\n[11]: https://www.imagemagick.org/script/index.php\n[12]: https://www.imagemagick.org/script/install-source.php\n[13]: https://www.kde.org/applications/graphics/spectacle/\n\n","source":"_posts/5-Ways-to-Take-Screenshot-in-Linux-GUI-and-Terminal.md","raw":"---\ntitle: 在 Linux 下截屏并编辑的最佳工具\ndate: 2018-10-01 21:15:54\ntags:\n  - Linux\n  - 截屏\n  - LCTT 翻译\n---\n\n> 有几种获取屏幕截图并对其进行添加文字、箭头等编辑的方法，这里提及的的屏幕截图工具在 Ubuntu 和其它主流 Linux 发行版中都能够使用。\n\n![在 Ubuntu Linux 中如何获取屏幕截图][1]\n\n当我的主力操作系统从 Windows 转换到 Ubuntu 的时候，首要考虑的就是屏幕截图工具的可用性。尽管使用默认的键盘快捷键也可以获取屏幕截图，但如果使用屏幕截图工具，可以更方便地对屏幕截图进行编辑。\n\n本文将会介绍在不适用第三方工具的情况下，如何通过系统自带的方法和工具获取屏幕截图，另外还会介绍一些可用于 Linux 的最佳截图工具。\n\n### 方法 1：在 Linux 中截图的默认方式\n\n你想要截取整个屏幕？屏幕中的某个区域？某个特定的窗口？\n\n如果只需要获取一张屏幕截图，不对其进行编辑的话，那么键盘的默认快捷键就可以满足要求了。而且不仅仅是 Ubuntu ，绝大部分的 Linux 发行版和桌面环境都支持以下这些快捷键：\n\n- `PrtSc` – 获取整个屏幕的截图并保存到 Pictures 目录。\n- `Shift + PrtSc` – 获取屏幕的某个区域截图并保存到 Pictures 目录。\n- `Alt + PrtSc` –获取当前窗口的截图并保存到 Pictures 目录。\n- `Ctrl + PrtSc` – 获取整个屏幕的截图并存放到剪贴板。\n- `Shift + Ctrl + PrtSc` – 获取屏幕的某个区域截图并存放到剪贴板。\n- `Ctrl + Alt + PrtSc` – 获取当前窗口的 截图并存放到剪贴板。\n\n如上所述，在 Linux 中使用默认的快捷键获取屏幕截图是相当简单的。但如果要在不把屏幕截图导入到其它应用程序的情况下对屏幕截图进行编辑，还是使用屏幕截图工具比较方便。\n\n### 方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑\n\n![flameshot][2]\n\n功能概述：\n\n  * 注释 (高亮、标示、添加文本、框选)\n  * 图片模糊\n  * 图片裁剪\n  * 上传到 Imgur\n  * 用另一个应用打开截图\n\nFlameshot 在去年发布到 [GitHub][3]，并成为一个引人注目的工具。\n\n如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。\n\n下面将会介绍如何安装 Flameshot 并根据你的偏好进行配置。\n\n如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了。要是你想使用终端来安装，可以执行以下命令：\n\n```\nsudo apt install flameshot\n```\n\n如果你在安装过程中遇到问题，可以按照[官方的安装说明][4]进行操作。安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 `PrtSc` 键触发启动，则需要指定对应的键盘快捷键。以下是相关配置步骤：\n\n  * 进入系统设置中的“键盘设置”\n  * 页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮\n  * 点击 “+” 按钮添加自定义快捷键并输入以下两个字段：\n    * “名称”： 任意名称均可。\n    * “命令”： `/usr/bin/flameshot gui`\n  * 最后将这个快捷操作绑定到  `PrtSc` 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。\n\n配置之后，你的自定义快捷键页面大概会是以下这样：\n\n![][5]\n\n*将键盘快捷键映射到 Flameshot*\n\n### 方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑\n\n![][6]\n\n功能概述：\n\n  * 注释 (高亮、标示、添加文本、框选)\n  * 图片模糊\n  * 图片裁剪\n  * 上传到图片网站\n\n[Shutter][7] 是一个对所有主流 Linux 发行版都适用的屏幕截图工具。尽管最近已经不太更新了，但仍然是操作屏幕截图的一个优秀工具。\n\n在使用过程中可能会遇到这个工具的一些缺陷。Shutter 在任何一款最新的 Linux 发行版上最常见的问题就是由于缺少了任务栏上的程序图标，导致默认禁用了编辑屏幕截图的功能。 对于这个缺陷，还是有解决方案的。你只需要跟随我们的教程[在 Shutter 中修复这个禁止编辑选项并将程序图标在任务栏上显示出来][8]。问题修复后，就可以使用 Shutter 来快速编辑屏幕截图了。\n\n同样地，在软件中心搜索也可以找到进而安装 Shutter，也可以在基于 Ubuntu 的发行版中执行以下命令使用命令行安装：\n\n```\nsudo apt install shutter\n```\n\n类似 Flameshot，你可以通过搜索 Shutter 手动启动它，也可以按照相似的方式设置自定义快捷方式以 `PrtSc` 键唤起 Shutter。\n\n如果要指定自定义键盘快捷键，只需要执行以下命令：\n\n```\nshutter -f\n```\n\n### 方法 4：在 Linux 中使用 GIMP 获取屏幕截图\n\n![][9]\n\n功能概述：\n\n  * 高级图像编辑功能（缩放、添加滤镜、颜色校正、添加图层、裁剪等）\n  * 截取某一区域的屏幕截图\n\n如果需要对屏幕截图进行一些预先编辑，GIMP 是一个不错的选择。\n\n通过软件中心可以安装 GIMP。如果在安装时遇到问题，可以参考其[官方网站的安装说明][10]。\n\n要使用 GIMP 获取屏幕截图，需要先启动程序，然后通过 “File-> Create-> Screenshot” 导航。\n\n打开 Screenshot 选项后，会看到几个控制点来控制屏幕截图范围。点击 “Snap” 截取屏幕截图，图像将自动显示在 GIMP 中可供编辑。\n\n### 方法 5：在 Linux 中使用命令行工具获取屏幕截图\n\n这一节内容仅适用于终端爱好者。如果你也喜欢使用终端，可以使用 “GNOME 截图工具”或 “ImageMagick” 或 “Deepin Scrot”，大部分流行的 Linux 发行版中都自带这些工具。\n\n要立即获取屏幕截图，可以执行以下命令：\n\n#### GNOME 截图工具（可用于 GNOME 桌面）\n\n```\ngnome-screenshot\n```\n\nGNOME 截图工具是使用 GNOME 桌面的 Linux 发行版中都自带的一个默认工具。如果需要延时获取屏幕截图，可以执行以下命令（这里的 `5` 是需要延迟的秒数）：\n\n```\ngnome-screenshot -d -5\n```\n\n#### ImageMagick\n\n如果你的操作系统是 Ubuntu、Mint 或其它流行的 Linux 发行版，一般会自带 [ImageMagick][11] 这个工具。如果没有这个工具，也可以按照[官方安装说明][12]使用安装源来安装。你也可以在终端中执行这个命令：\n\n```\nsudo apt-get install imagemagick\n```\n\n安装完成后，执行下面的命令就可以获取到屏幕截图（截取整个屏幕）：\n\n```\nimport -window root image.png\n```\n\n这里的 “image.png” 就是屏幕截图文件保存的名称。\n\n要获取屏幕一个区域的截图，可以执行以下命令:\n\n```\nimport image.png\n```\n\n#### Deepin Scrot\n\nDeepin Scrot 是基于终端的一个较新的截图工具。和前面两个工具类似，一般自带于 Linux 发行版中。如果需要自行安装，可以执行以下命令：\n\n```\nsudo apt-get install scrot\n```\n\n安装完成后，使用下面这些命令可以获取屏幕截图。\n\n获取整个屏幕的截图：\n\n```\nscrot myimage.png\n```\n\n获取屏幕某一区域的截图：\n\n```\nscrot -s myimage.png\n```\n\n### 总结\n\n以上是一些在 Linux 上的优秀截图工具。当然还有很多截图工具没有提及（例如用于 KDE 发行版的 [Spectacle][13]），但相比起来还是上面几个工具更为好用。\n\n如果你有比文章中提到的更好的截图工具，欢迎讨论！\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/take-screenshot-linux/\n\n[a]: https://itsfoss.com/author/ankush/\n[1]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Taking-Screenshots-in-Linux.png\n[2]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-pic.png\n[3]: https://github.com/lupoDharkael/flameshot\n[4]: https://github.com/lupoDharkael/flameshot#installation\n[5]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-config-default.png\n[6]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/shutter-screenshot.jpg\n[7]: http://shutter-project.org/\n[8]: https://itsfoss.com/shutter-edit-button-disabled/\n[9]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/gimp-screenshot.jpg\n[10]: https://www.gimp.org/downloads/\n[11]: https://www.imagemagick.org/script/index.php\n[12]: https://www.imagemagick.org/script/install-source.php\n[13]: https://www.kde.org/applications/graphics/spectacle/\n\n","slug":"5-Ways-to-Take-Screenshot-in-Linux-GUI-and-Terminal","published":1,"updated":"2019-03-28T11:02:44.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0bs0007lixud2nne756","content":"<blockquote>\n<p>有几种获取屏幕截图并对其进行添加文字、箭头等编辑的方法，这里提及的的屏幕截图工具在 Ubuntu 和其它主流 Linux 发行版中都能够使用。</p>\n</blockquote>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Taking-Screenshots-in-Linux.png\" alt=\"在 Ubuntu Linux 中如何获取屏幕截图\"></p>\n<p>当我的主力操作系统从 Windows 转换到 Ubuntu 的时候，首要考虑的就是屏幕截图工具的可用性。尽管使用默认的键盘快捷键也可以获取屏幕截图，但如果使用屏幕截图工具，可以更方便地对屏幕截图进行编辑。</p>\n<p>本文将会介绍在不适用第三方工具的情况下，如何通过系统自带的方法和工具获取屏幕截图，另外还会介绍一些可用于 Linux 的最佳截图工具。</p>\n<h3 id=\"方法-1：在-Linux-中截图的默认方式\"><a href=\"#方法-1：在-Linux-中截图的默认方式\" class=\"headerlink\" title=\"方法 1：在 Linux 中截图的默认方式\"></a>方法 1：在 Linux 中截图的默认方式</h3><p>你想要截取整个屏幕？屏幕中的某个区域？某个特定的窗口？</p>\n<p>如果只需要获取一张屏幕截图，不对其进行编辑的话，那么键盘的默认快捷键就可以满足要求了。而且不仅仅是 Ubuntu ，绝大部分的 Linux 发行版和桌面环境都支持以下这些快捷键：</p>\n<ul>\n<li><code>PrtSc</code> – 获取整个屏幕的截图并保存到 Pictures 目录。</li>\n<li><code>Shift + PrtSc</code> – 获取屏幕的某个区域截图并保存到 Pictures 目录。</li>\n<li><code>Alt + PrtSc</code> –获取当前窗口的截图并保存到 Pictures 目录。</li>\n<li><code>Ctrl + PrtSc</code> – 获取整个屏幕的截图并存放到剪贴板。</li>\n<li><code>Shift + Ctrl + PrtSc</code> – 获取屏幕的某个区域截图并存放到剪贴板。</li>\n<li><code>Ctrl + Alt + PrtSc</code> – 获取当前窗口的 截图并存放到剪贴板。</li>\n</ul>\n<p>如上所述，在 Linux 中使用默认的快捷键获取屏幕截图是相当简单的。但如果要在不把屏幕截图导入到其它应用程序的情况下对屏幕截图进行编辑，还是使用屏幕截图工具比较方便。</p>\n<h3 id=\"方法-2：在-Linux-中使用-Flameshot-获取屏幕截图并编辑\"><a href=\"#方法-2：在-Linux-中使用-Flameshot-获取屏幕截图并编辑\" class=\"headerlink\" title=\"方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑\"></a>方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-pic.png\" alt=\"flameshot\"></p>\n<p>功能概述：</p>\n<ul>\n<li>注释 (高亮、标示、添加文本、框选)</li>\n<li>图片模糊</li>\n<li>图片裁剪</li>\n<li>上传到 Imgur</li>\n<li>用另一个应用打开截图</li>\n</ul>\n<p>Flameshot 在去年发布到 <a href=\"https://github.com/lupoDharkael/flameshot\" target=\"_blank\" rel=\"noopener\">GitHub</a>，并成为一个引人注目的工具。</p>\n<p>如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。</p>\n<p>下面将会介绍如何安装 Flameshot 并根据你的偏好进行配置。</p>\n<p>如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了。要是你想使用终端来安装，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install flameshot</span><br></pre></td></tr></table></figure>\n<p>如果你在安装过程中遇到问题，可以按照<a href=\"https://github.com/lupoDharkael/flameshot#installation\" target=\"_blank\" rel=\"noopener\">官方的安装说明</a>进行操作。安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 <code>PrtSc</code> 键触发启动，则需要指定对应的键盘快捷键。以下是相关配置步骤：</p>\n<ul>\n<li>进入系统设置中的“键盘设置”</li>\n<li>页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮</li>\n<li>点击 “+” 按钮添加自定义快捷键并输入以下两个字段：<ul>\n<li>“名称”： 任意名称均可。</li>\n<li>“命令”： <code>/usr/bin/flameshot gui</code></li>\n</ul>\n</li>\n<li>最后将这个快捷操作绑定到  <code>PrtSc</code> 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。</li>\n</ul>\n<p>配置之后，你的自定义快捷键页面大概会是以下这样：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-config-default.png\" alt=\"\"></p>\n<p><em>将键盘快捷键映射到 Flameshot</em></p>\n<h3 id=\"方法-3：在-Linux-中使用-Shutter-获取屏幕截图并编辑\"><a href=\"#方法-3：在-Linux-中使用-Shutter-获取屏幕截图并编辑\" class=\"headerlink\" title=\"方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑\"></a>方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/shutter-screenshot.jpg\" alt=\"\"></p>\n<p>功能概述：</p>\n<ul>\n<li>注释 (高亮、标示、添加文本、框选)</li>\n<li>图片模糊</li>\n<li>图片裁剪</li>\n<li>上传到图片网站</li>\n</ul>\n<p><a href=\"http://shutter-project.org/\" target=\"_blank\" rel=\"noopener\">Shutter</a> 是一个对所有主流 Linux 发行版都适用的屏幕截图工具。尽管最近已经不太更新了，但仍然是操作屏幕截图的一个优秀工具。</p>\n<p>在使用过程中可能会遇到这个工具的一些缺陷。Shutter 在任何一款最新的 Linux 发行版上最常见的问题就是由于缺少了任务栏上的程序图标，导致默认禁用了编辑屏幕截图的功能。 对于这个缺陷，还是有解决方案的。你只需要跟随我们的教程<a href=\"https://itsfoss.com/shutter-edit-button-disabled/\" target=\"_blank\" rel=\"noopener\">在 Shutter 中修复这个禁止编辑选项并将程序图标在任务栏上显示出来</a>。问题修复后，就可以使用 Shutter 来快速编辑屏幕截图了。</p>\n<p>同样地，在软件中心搜索也可以找到进而安装 Shutter，也可以在基于 Ubuntu 的发行版中执行以下命令使用命令行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install shutter</span><br></pre></td></tr></table></figure>\n<p>类似 Flameshot，你可以通过搜索 Shutter 手动启动它，也可以按照相似的方式设置自定义快捷方式以 <code>PrtSc</code> 键唤起 Shutter。</p>\n<p>如果要指定自定义键盘快捷键，只需要执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutter -f</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-4：在-Linux-中使用-GIMP-获取屏幕截图\"><a href=\"#方法-4：在-Linux-中使用-GIMP-获取屏幕截图\" class=\"headerlink\" title=\"方法 4：在 Linux 中使用 GIMP 获取屏幕截图\"></a>方法 4：在 Linux 中使用 GIMP 获取屏幕截图</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/gimp-screenshot.jpg\" alt=\"\"></p>\n<p>功能概述：</p>\n<ul>\n<li>高级图像编辑功能（缩放、添加滤镜、颜色校正、添加图层、裁剪等）</li>\n<li>截取某一区域的屏幕截图</li>\n</ul>\n<p>如果需要对屏幕截图进行一些预先编辑，GIMP 是一个不错的选择。</p>\n<p>通过软件中心可以安装 GIMP。如果在安装时遇到问题，可以参考其<a href=\"https://www.gimp.org/downloads/\" target=\"_blank\" rel=\"noopener\">官方网站的安装说明</a>。</p>\n<p>要使用 GIMP 获取屏幕截图，需要先启动程序，然后通过 “File-&gt; Create-&gt; Screenshot” 导航。</p>\n<p>打开 Screenshot 选项后，会看到几个控制点来控制屏幕截图范围。点击 “Snap” 截取屏幕截图，图像将自动显示在 GIMP 中可供编辑。</p>\n<h3 id=\"方法-5：在-Linux-中使用命令行工具获取屏幕截图\"><a href=\"#方法-5：在-Linux-中使用命令行工具获取屏幕截图\" class=\"headerlink\" title=\"方法 5：在 Linux 中使用命令行工具获取屏幕截图\"></a>方法 5：在 Linux 中使用命令行工具获取屏幕截图</h3><p>这一节内容仅适用于终端爱好者。如果你也喜欢使用终端，可以使用 “GNOME 截图工具”或 “ImageMagick” 或 “Deepin Scrot”，大部分流行的 Linux 发行版中都自带这些工具。</p>\n<p>要立即获取屏幕截图，可以执行以下命令：</p>\n<h4 id=\"GNOME-截图工具（可用于-GNOME-桌面）\"><a href=\"#GNOME-截图工具（可用于-GNOME-桌面）\" class=\"headerlink\" title=\"GNOME 截图工具（可用于 GNOME 桌面）\"></a>GNOME 截图工具（可用于 GNOME 桌面）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gnome-screenshot</span><br></pre></td></tr></table></figure>\n<p>GNOME 截图工具是使用 GNOME 桌面的 Linux 发行版中都自带的一个默认工具。如果需要延时获取屏幕截图，可以执行以下命令（这里的 <code>5</code> 是需要延迟的秒数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gnome-screenshot -d -5</span><br></pre></td></tr></table></figure>\n<h4 id=\"ImageMagick\"><a href=\"#ImageMagick\" class=\"headerlink\" title=\"ImageMagick\"></a>ImageMagick</h4><p>如果你的操作系统是 Ubuntu、Mint 或其它流行的 Linux 发行版，一般会自带 <a href=\"https://www.imagemagick.org/script/index.php\" target=\"_blank\" rel=\"noopener\">ImageMagick</a> 这个工具。如果没有这个工具，也可以按照<a href=\"https://www.imagemagick.org/script/install-source.php\" target=\"_blank\" rel=\"noopener\">官方安装说明</a>使用安装源来安装。你也可以在终端中执行这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install imagemagick</span><br></pre></td></tr></table></figure>\n<p>安装完成后，执行下面的命令就可以获取到屏幕截图（截取整个屏幕）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import -window root image.png</span><br></pre></td></tr></table></figure>\n<p>这里的 “image.png” 就是屏幕截图文件保存的名称。</p>\n<p>要获取屏幕一个区域的截图，可以执行以下命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import image.png</span><br></pre></td></tr></table></figure>\n<h4 id=\"Deepin-Scrot\"><a href=\"#Deepin-Scrot\" class=\"headerlink\" title=\"Deepin Scrot\"></a>Deepin Scrot</h4><p>Deepin Scrot 是基于终端的一个较新的截图工具。和前面两个工具类似，一般自带于 Linux 发行版中。如果需要自行安装，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install scrot</span><br></pre></td></tr></table></figure>\n<p>安装完成后，使用下面这些命令可以获取屏幕截图。</p>\n<p>获取整个屏幕的截图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrot myimage.png</span><br></pre></td></tr></table></figure>\n<p>获取屏幕某一区域的截图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrot -s myimage.png</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上是一些在 Linux 上的优秀截图工具。当然还有很多截图工具没有提及（例如用于 KDE 发行版的 <a href=\"https://www.kde.org/applications/graphics/spectacle/\" target=\"_blank\" rel=\"noopener\">Spectacle</a>），但相比起来还是上面几个工具更为好用。</p>\n<p>如果你有比文章中提到的更好的截图工具，欢迎讨论！</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/take-screenshot-linux/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/take-screenshot-linux/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>有几种获取屏幕截图并对其进行添加文字、箭头等编辑的方法，这里提及的的屏幕截图工具在 Ubuntu 和其它主流 Linux 发行版中都能够使用。</p>\n</blockquote>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Taking-Screenshots-in-Linux.png\" alt=\"在 Ubuntu Linux 中如何获取屏幕截图\"></p>\n<p>当我的主力操作系统从 Windows 转换到 Ubuntu 的时候，首要考虑的就是屏幕截图工具的可用性。尽管使用默认的键盘快捷键也可以获取屏幕截图，但如果使用屏幕截图工具，可以更方便地对屏幕截图进行编辑。</p>\n<p>本文将会介绍在不适用第三方工具的情况下，如何通过系统自带的方法和工具获取屏幕截图，另外还会介绍一些可用于 Linux 的最佳截图工具。</p>\n<h3 id=\"方法-1：在-Linux-中截图的默认方式\"><a href=\"#方法-1：在-Linux-中截图的默认方式\" class=\"headerlink\" title=\"方法 1：在 Linux 中截图的默认方式\"></a>方法 1：在 Linux 中截图的默认方式</h3><p>你想要截取整个屏幕？屏幕中的某个区域？某个特定的窗口？</p>\n<p>如果只需要获取一张屏幕截图，不对其进行编辑的话，那么键盘的默认快捷键就可以满足要求了。而且不仅仅是 Ubuntu ，绝大部分的 Linux 发行版和桌面环境都支持以下这些快捷键：</p>\n<ul>\n<li><code>PrtSc</code> – 获取整个屏幕的截图并保存到 Pictures 目录。</li>\n<li><code>Shift + PrtSc</code> – 获取屏幕的某个区域截图并保存到 Pictures 目录。</li>\n<li><code>Alt + PrtSc</code> –获取当前窗口的截图并保存到 Pictures 目录。</li>\n<li><code>Ctrl + PrtSc</code> – 获取整个屏幕的截图并存放到剪贴板。</li>\n<li><code>Shift + Ctrl + PrtSc</code> – 获取屏幕的某个区域截图并存放到剪贴板。</li>\n<li><code>Ctrl + Alt + PrtSc</code> – 获取当前窗口的 截图并存放到剪贴板。</li>\n</ul>\n<p>如上所述，在 Linux 中使用默认的快捷键获取屏幕截图是相当简单的。但如果要在不把屏幕截图导入到其它应用程序的情况下对屏幕截图进行编辑，还是使用屏幕截图工具比较方便。</p>\n<h3 id=\"方法-2：在-Linux-中使用-Flameshot-获取屏幕截图并编辑\"><a href=\"#方法-2：在-Linux-中使用-Flameshot-获取屏幕截图并编辑\" class=\"headerlink\" title=\"方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑\"></a>方法 2：在 Linux 中使用 Flameshot 获取屏幕截图并编辑</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-pic.png\" alt=\"flameshot\"></p>\n<p>功能概述：</p>\n<ul>\n<li>注释 (高亮、标示、添加文本、框选)</li>\n<li>图片模糊</li>\n<li>图片裁剪</li>\n<li>上传到 Imgur</li>\n<li>用另一个应用打开截图</li>\n</ul>\n<p>Flameshot 在去年发布到 <a href=\"https://github.com/lupoDharkael/flameshot\" target=\"_blank\" rel=\"noopener\">GitHub</a>，并成为一个引人注目的工具。</p>\n<p>如果你需要的是一个能够用于标注、模糊、上传到 imgur 的新式截图工具，那么 Flameshot 是一个好的选择。</p>\n<p>下面将会介绍如何安装 Flameshot 并根据你的偏好进行配置。</p>\n<p>如果你用的是 Ubuntu，那么只需要在 Ubuntu 软件中心上搜索，就可以找到 Flameshot 进而完成安装了。要是你想使用终端来安装，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install flameshot</span><br></pre></td></tr></table></figure>\n<p>如果你在安装过程中遇到问题，可以按照<a href=\"https://github.com/lupoDharkael/flameshot#installation\" target=\"_blank\" rel=\"noopener\">官方的安装说明</a>进行操作。安装完成后，你还需要进行配置。尽管可以通过搜索来随时启动 Flameshot，但如果想使用 <code>PrtSc</code> 键触发启动，则需要指定对应的键盘快捷键。以下是相关配置步骤：</p>\n<ul>\n<li>进入系统设置中的“键盘设置”</li>\n<li>页面中会列出所有现有的键盘快捷键，拉到底部就会看见一个 “+” 按钮</li>\n<li>点击 “+” 按钮添加自定义快捷键并输入以下两个字段：<ul>\n<li>“名称”： 任意名称均可。</li>\n<li>“命令”： <code>/usr/bin/flameshot gui</code></li>\n</ul>\n</li>\n<li>最后将这个快捷操作绑定到  <code>PrtSc</code> 键上，可能会提示与系统的截图功能相冲突，但可以忽略掉这个警告。</li>\n</ul>\n<p>配置之后，你的自定义快捷键页面大概会是以下这样：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/flameshot-config-default.png\" alt=\"\"></p>\n<p><em>将键盘快捷键映射到 Flameshot</em></p>\n<h3 id=\"方法-3：在-Linux-中使用-Shutter-获取屏幕截图并编辑\"><a href=\"#方法-3：在-Linux-中使用-Shutter-获取屏幕截图并编辑\" class=\"headerlink\" title=\"方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑\"></a>方法 3：在 Linux 中使用 Shutter 获取屏幕截图并编辑</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/shutter-screenshot.jpg\" alt=\"\"></p>\n<p>功能概述：</p>\n<ul>\n<li>注释 (高亮、标示、添加文本、框选)</li>\n<li>图片模糊</li>\n<li>图片裁剪</li>\n<li>上传到图片网站</li>\n</ul>\n<p><a href=\"http://shutter-project.org/\" target=\"_blank\" rel=\"noopener\">Shutter</a> 是一个对所有主流 Linux 发行版都适用的屏幕截图工具。尽管最近已经不太更新了，但仍然是操作屏幕截图的一个优秀工具。</p>\n<p>在使用过程中可能会遇到这个工具的一些缺陷。Shutter 在任何一款最新的 Linux 发行版上最常见的问题就是由于缺少了任务栏上的程序图标，导致默认禁用了编辑屏幕截图的功能。 对于这个缺陷，还是有解决方案的。你只需要跟随我们的教程<a href=\"https://itsfoss.com/shutter-edit-button-disabled/\" target=\"_blank\" rel=\"noopener\">在 Shutter 中修复这个禁止编辑选项并将程序图标在任务栏上显示出来</a>。问题修复后，就可以使用 Shutter 来快速编辑屏幕截图了。</p>\n<p>同样地，在软件中心搜索也可以找到进而安装 Shutter，也可以在基于 Ubuntu 的发行版中执行以下命令使用命令行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install shutter</span><br></pre></td></tr></table></figure>\n<p>类似 Flameshot，你可以通过搜索 Shutter 手动启动它，也可以按照相似的方式设置自定义快捷方式以 <code>PrtSc</code> 键唤起 Shutter。</p>\n<p>如果要指定自定义键盘快捷键，只需要执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutter -f</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-4：在-Linux-中使用-GIMP-获取屏幕截图\"><a href=\"#方法-4：在-Linux-中使用-GIMP-获取屏幕截图\" class=\"headerlink\" title=\"方法 4：在 Linux 中使用 GIMP 获取屏幕截图\"></a>方法 4：在 Linux 中使用 GIMP 获取屏幕截图</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/gimp-screenshot.jpg\" alt=\"\"></p>\n<p>功能概述：</p>\n<ul>\n<li>高级图像编辑功能（缩放、添加滤镜、颜色校正、添加图层、裁剪等）</li>\n<li>截取某一区域的屏幕截图</li>\n</ul>\n<p>如果需要对屏幕截图进行一些预先编辑，GIMP 是一个不错的选择。</p>\n<p>通过软件中心可以安装 GIMP。如果在安装时遇到问题，可以参考其<a href=\"https://www.gimp.org/downloads/\" target=\"_blank\" rel=\"noopener\">官方网站的安装说明</a>。</p>\n<p>要使用 GIMP 获取屏幕截图，需要先启动程序，然后通过 “File-&gt; Create-&gt; Screenshot” 导航。</p>\n<p>打开 Screenshot 选项后，会看到几个控制点来控制屏幕截图范围。点击 “Snap” 截取屏幕截图，图像将自动显示在 GIMP 中可供编辑。</p>\n<h3 id=\"方法-5：在-Linux-中使用命令行工具获取屏幕截图\"><a href=\"#方法-5：在-Linux-中使用命令行工具获取屏幕截图\" class=\"headerlink\" title=\"方法 5：在 Linux 中使用命令行工具获取屏幕截图\"></a>方法 5：在 Linux 中使用命令行工具获取屏幕截图</h3><p>这一节内容仅适用于终端爱好者。如果你也喜欢使用终端，可以使用 “GNOME 截图工具”或 “ImageMagick” 或 “Deepin Scrot”，大部分流行的 Linux 发行版中都自带这些工具。</p>\n<p>要立即获取屏幕截图，可以执行以下命令：</p>\n<h4 id=\"GNOME-截图工具（可用于-GNOME-桌面）\"><a href=\"#GNOME-截图工具（可用于-GNOME-桌面）\" class=\"headerlink\" title=\"GNOME 截图工具（可用于 GNOME 桌面）\"></a>GNOME 截图工具（可用于 GNOME 桌面）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gnome-screenshot</span><br></pre></td></tr></table></figure>\n<p>GNOME 截图工具是使用 GNOME 桌面的 Linux 发行版中都自带的一个默认工具。如果需要延时获取屏幕截图，可以执行以下命令（这里的 <code>5</code> 是需要延迟的秒数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gnome-screenshot -d -5</span><br></pre></td></tr></table></figure>\n<h4 id=\"ImageMagick\"><a href=\"#ImageMagick\" class=\"headerlink\" title=\"ImageMagick\"></a>ImageMagick</h4><p>如果你的操作系统是 Ubuntu、Mint 或其它流行的 Linux 发行版，一般会自带 <a href=\"https://www.imagemagick.org/script/index.php\" target=\"_blank\" rel=\"noopener\">ImageMagick</a> 这个工具。如果没有这个工具，也可以按照<a href=\"https://www.imagemagick.org/script/install-source.php\" target=\"_blank\" rel=\"noopener\">官方安装说明</a>使用安装源来安装。你也可以在终端中执行这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install imagemagick</span><br></pre></td></tr></table></figure>\n<p>安装完成后，执行下面的命令就可以获取到屏幕截图（截取整个屏幕）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import -window root image.png</span><br></pre></td></tr></table></figure>\n<p>这里的 “image.png” 就是屏幕截图文件保存的名称。</p>\n<p>要获取屏幕一个区域的截图，可以执行以下命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import image.png</span><br></pre></td></tr></table></figure>\n<h4 id=\"Deepin-Scrot\"><a href=\"#Deepin-Scrot\" class=\"headerlink\" title=\"Deepin Scrot\"></a>Deepin Scrot</h4><p>Deepin Scrot 是基于终端的一个较新的截图工具。和前面两个工具类似，一般自带于 Linux 发行版中。如果需要自行安装，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install scrot</span><br></pre></td></tr></table></figure>\n<p>安装完成后，使用下面这些命令可以获取屏幕截图。</p>\n<p>获取整个屏幕的截图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrot myimage.png</span><br></pre></td></tr></table></figure>\n<p>获取屏幕某一区域的截图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrot -s myimage.png</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上是一些在 Linux 上的优秀截图工具。当然还有很多截图工具没有提及（例如用于 KDE 发行版的 <a href=\"https://www.kde.org/applications/graphics/spectacle/\" target=\"_blank\" rel=\"noopener\">Spectacle</a>），但相比起来还是上面几个工具更为好用。</p>\n<p>如果你有比文章中提到的更好的截图工具，欢迎讨论！</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/take-screenshot-linux/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/take-screenshot-linux/</a></p>\n"},{"title":"5 个适合系统管理员使用的告警可视化工具","date":"2018-11-11T09:41:56.000Z","_content":"\n> 这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/metrics_data_dashboard_system_computer_analytics.png?itok=oxAeIEI-)\n\n你大概已经知道（或猜到）<ruby>告警可视化<rt>alerting and visualization</rt></ruby>工具是用来做什么的了。下面我们就要来说一下，为什么要讨论这样的工具，甚至某些系统专门将可视化作为特有的功能。\n\n<ruby>可观察性<rt>Observability</rt></ruby>的概念来自<ruby>控制理论<rt>control theory</ruby>，这个概念描述了我们通过对系统的输入和输出来了解其的能力。本文将重点介绍具有可观察性的输出组件。\n\n告警可视化工具可以对其它系统的输出进行分析，进而对输出的信息进行结构化表示。告警实际上是对系统异常状态的描述，而可视化则是让用户能够直观理解的结构化表示。\n\n### 常见的可视化告警\n\n#### 告警\n\n首先要明确一下<ruby>告警<rt>alert</rt></ruby>的含义。在人员无法响应告警内容情况下，不应该发送告警 —— 包括那些发给多个人但只有其中少数人可以响应的告警，以及系统中的每个异常都触发的告警。因为这样会产生告警疲劳，告警接收者也往往会对这些过多的告警采取忽视的态度 —— 直到系统恶化到以少见的方式告警。\n\n例如，如果管理员每天都会收到告警系统发来的数百封告警邮件，他就很容易会忽略告警系统的所有邮件。除非他真的看到问题发生，或者受到了客户或上级的询问时，管理员才会重新重视告警信息。在这种情况下，告警已经失去了原有的意义和用途。\n\n告警不是一个持续的信息流或者状态更新。告警的目的在于暴露系统无法自动恢复的问题，而且告警应该只发送给最有可能解决问题的人员。超出这个定义的内容都不应该作为告警，否则将会对实际工作造成不良的影响。\n\n不同的告警体系都会有各自的告警类型，因此不能用优先级（P1-P5）或者诸如“信息”、“警告”、“严重”之类的字眼来一概而论，下面我会介绍一些新兴的复杂系统的事件响应中出现的通用分类方式。\n\n刚才我提到了一个“信息”这个告警类型，但实际上告警不应该是一个信息，尽管有些人可能会不这样认为。但我觉得如果一个告警没有发送给任何一个人，它就不应该是警报，而只是一些在许多系统中被视为警报的数据点，代表了一些应该知晓但不需要响应的事件。它更应该作为告警可视化工具的一部分，而不是会导致触发告警的事件。《[实用监控][1]》是这个领域的必读书籍，其作者 Mike Julian 在书中就介绍了他自己关于告警的看法。\n\n而非信息警报则代表告警需要被响应以及需要相关的操作。我将这些告警大致分为内部故障和外部故障两种类型，而对于大多数公司来说，通常会有两个以上的级别来确定响应告警的优先级。系统性能下降就是一种故障，因为其对用户的影响通常都是未知的。\n\n内部故障比外部故障的优先级低，但也需要快速响应。内部故障通常包括公司员工使用的内部系统或仅对公司员工可见的应用故障。\n\n外部故障则包括任何马上会产生业务影响的系统故障，但不包括影响系统更新的故障。外部故障一般包括客户所面临的应用故障、数据库故障和导致系统可用性或一致性失效的网络故障，这些都会影响用户的正常使用。对于不直接影响用户的依赖组件故障也属于外部故障，随着应用程序的不断运行，一旦依赖组件发生故障，系统的性能也会受到波及。这种情况对于使用某些外部服务或数据源的系统来说很常见，尽管这些外部服务或数据源对于可能不涉及到系统的主要功能，但是当系统在处理相关依赖组件的错误时可能会出现较明显的延迟。\n\n### 可视化\n\n可视化的种类有很多，我就不一一赘述了。这是一个有趣的研究领域，在我这些年的数据分析经历当中，学习和应用可视化方面的知识可以说是相当有挑战性。我们需要将复杂的系统输出通过直观的方式来向他人展示，才能有效地把信息传播出去。[Google Charts][2] 和 [Tableau][3] 都提供了很多可视化方面的工具。下面将会介绍一些最常见的可视化创新解决方案。\n\n#### 折线图\n\n折线图可能是最常见的可视化方式了，它可以让用户很直观地按照时间维度了解系统的情况。系统中每个单一或聚合的指标都会以一条折线在图表中体现。但当同一个图表中同时存在多条折线时，就可能会对阅读有所影响（如下图所示），所以大多数情况下都可以选择仅查看其中的少数几条折线，而不是让所有折线同时显示。如果某个指标的数值产生了大于正常范围的波动，就会很容易发现。例如下图中异常的紫线、黄线、浅蓝线。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart.png)\n\n折线图的另一个用法是可以将多条折线堆叠起来以显示它们之间的关系。例如对于通过折线图反映服务器的请求数量，可以单独看到每台服务器上的请求，也可以聚合在一起看。这就可以在同一个图表中灵活查看整个系统以及每个实例的情况了。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart_aggregate.png)\n\n#### 热力图\n\n另一种常见的可视化方式是热力图。热力图与条形图比较类似，还可以在条形图的基础上显示某部分在整体中占比的变化情况。例如在查看网络请求延时的时候，就可以使用热力图快速查看到所有网络请求的总体趋势和分布情况，另外，它可以使用不同颜色来表示不同部分的数值。\n\n在以下这个热力图中，通过竖直方向上每个时间段的色块数量分布，可以清楚地看到大部分数据集中在整个范围的中心位置。我们还可以发现，大多数时间段的色块分布都是比较宽松的，而 14:00 到 15:00 这一段则分布得很密集，这样的分布有可能意味着一种不健康的状态。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_histogram.png)\n\n#### 仪表图\n\n还有一种常见的可视化方式是仪表图，用户可以通过仪表图快速了解单个指标。仪表一般用于单个指标的显示，例如车速表代表汽车的行驶速度、油量表代表油箱中的汽油量等等。大多数的仪表图都有一个共通点，就是会划分出所示指标的对应状态。如下图所示，绿色表示正常的状态，橙色表示不良的状态，而红色则表示极差的状态。下图中间一行模拟了真实仪表的显示情况。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_gauges.png)\n\n上面图表中，除了常规仪表样式的显示方式之外，还有较为直接的数据显示方式，配合相同的配色方案，一眼就可以看出各个指标所处的状态，这一点与和仪表的特点类似。所以，最下面一行可能是仪表图的最佳显示方式，用户不需要仔细阅读，就可以大致了解各个指标的不同状态。这种类型的可视化是我最常用的类型，在数秒钟之间，我就可以全面地总览系统各方面地运行情况。\n\n#### 火焰图\n\n由 [Netflix 的 Brendan Gregg][4] 在 2011 年开始使用的火焰图是一种较为少见地可视化方式。它不像仪表图那样可以从图表中快速得到关键信息，通常只会在需要解决某个应用的问题的时候才会用到这种图表。火焰图主要用于 CPU、内存和相关帧方面的表示，X 轴按字母顺序将帧一一列出，而 Y 轴则表示堆栈的深度。图中每个矩形都是一个标明了调用的函数的堆栈帧。矩形越宽，就表示它在堆栈中出现越频繁。在分析系统性能问题的时候，火焰图能够起到很大的作用，大家不妨尝试一下。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_flame_graph_0.png)\n\n### 工具的选择\n\n在告警工具方面，有几个商用的工具相当不错。但由于这是一篇介绍开源技术的文章，我只会介绍那些已经被广泛使用的免费工具。希望你也能够为这些工具贡献你自己的代码，让它们更加完善。\n\n### 告警工具\n\n#### Bosun\n\n如果你的电脑出现问题，得多亏 Stack Exchange 你才能在网上查到解决办法。Stack Exchange 以众包问答的模式运营着很多不同类型的网站。其中就有广受开发者欢迎的 [Stack Overflow][5]，以及运维方面有名的 [Super User][6]。除此以外，从育儿经验到科幻小说、从哲学讨论到单车论坛，Stack Exchange 都有涉猎。\n\nStack Exchange 开源了它的告警管理系统 [Bosun][7]，同时也发布了 Prometheus 及其 [AlertManager][8] 系统。这两个系统有共通点。Bosun 和 Prometheus 一样使用 Golang 开发，但 Bosun 比 Prometheus 更为强大，因为它可以使用<ruby>指标聚合<rt>metrics aggregation</rt></ruby>以外的方式与系统交互。Bosun 还可以从日志和事件收集系统中提取数据，并且支持 Graphite、InfluxDB、OpenTSDB 和 Elasticsearch。\n\nBosun 的架构包括一个单一的服务器的二进制文件，一个诸如 OpenTSDB 的后端、Redis 以及 [scollector 代理][9]。 scollector 代理会自动检测主机上正在运行的服务，并反馈这些进程和其它的系统资源的情况。这些数据将发送到后端。随后 Bosun 的二进制服务文件会向后端发起查询，确定是否需要触发告警。也可以通过 [Grafana][10] 这些工具通过一个通用接口查询 Bosun 的底层后端。而 Redis 则用于存储 Bosun 的状态信息和元数据。\n\nBosun 有一个非常巧妙的功能，就是可以根据历史数据来测试告警。这是我几年前在使用 Prometheus 的时候就非常需要的功能，当时我有一个异常的数据需要产生告警，但没有一个可以用于测试的简便方法。为了确保告警能够正常触发，我不得不造出对应的数据来进行测试。而 Bosun 让这个步骤的耗时大大缩短。\n\nBosun 更是涵盖了所有常用过的功能，包括简单的图形化表示和告警的创建。它还带有强大的用于编写告警规则的表达式语言。但 Bosun 默认只带有电子邮件通知配置和 HTTP 通知配置，因此如果需要连接到 Slack 或其它工具，就需要对配置作出更大程度的定制化（[其文档中有][11]）。类似于 Prometheus，Bosun 还可以使用模板通知，你可以使用 HTML 和 CSS 来创建你所需要的电子邮件通知。\n\n#### Cabot\n\n[Cabot][12] 由 [Arachnys][13] 公司开发。你或许对 Arachnys 公司并不了解，但它很有影响力：Arachnys 公司构建了一个基于云的先进解决方案，用于防范金融犯罪。在之前的公司时，我也曾经参与过类似“[了解你的客户][14]（KYC）”的工作。大多数公司都认为与恐怖组织产生联系会造成相当不好的影响，因为恐怖组织可能会利用自己的系统来筹集资金。而这些解决方案将有助于防范欺诈类犯罪，尽管这类犯罪情节相对较轻，但仍然也会对机构产生风险。\n\nArachnys 公司为什么要开发 Cabot 呢？其实只是因为 Arachnys 的开发人员对 [Nagios][15] 不太熟悉。Cabot 的出现对很多人来说都是一个好消息，它基于 Django 和 Bootstrap 开发，因此如果想对这个项目做出自己的贡献，门槛并不高。（另外值得一提的是，Cabot 这个名字来源于开发者的狗。）\n\n与 Bosun 类似，Cabot 也不对数据进行收集，而是使用监控对象的 API 提供的数据。因此，Cabot 告警的模式是拉取而不是推送。它通过访问每个监控对象的 API，根据特定的指标检索所需的数据，然后将告警数据使用 Redis 缓存，进而持久化存储到 Postgres 数据库。\n\nCabot 的一个较为少见的特点是，它原生支持 [Graphite][16]，同时也支持 [Jenkins][17]。Jenkins 在这里被视为一个集中式的定时任务，它会以对待故障的方式去对待构建失败的状况。构建失败当然没有系统故障那么紧急，但一旦出现构建失败，还是需要团队采取措施去处理，毕竟并不是每个人在收到构建失败的电子邮件时都会亲自去检查 Jenkins。\n\nCabot 另一个有趣的功能是它可以接入 Google 日历安排值班人员，这个称为 Rota 的功能用处很大，希望其它告警系统也能加入类似的功能。Cabot 目前仅支持安排主备联系人，但还有继续改进的空间。它自己的文档也提到，如果需要全面的功能，更应该考虑付费的解决方案。\n\n#### StatsAgg\n\n[Pearson][19] 作为一家开发了 [StatsAgg][18] 告警平台的出版公司，这是极为罕见的，当然也很值得敬佩。除此以外，Pearson 还运营着另外几个网站以及和 [O'Reilly Media][20] 合资的企业。但我仍然会将它视为出版教学书籍的公司。\n\nStatsAgg 除了是一个告警平台，还是一个指标聚合平台，甚至也有点类似其它系统的代理。StatsAgg 支持通过 Graphite、StatsD、InfluxDB 和 OpenTSDB 输入数据，也支持将其转发到各种平台。但随着中心服务的负载不断增加，风险也不断增大。尽管如此，如果 StatsAgg 的基础架构足够强壮，即使后端存储平台出现故障，也不会对它产生告警的过程造成影响。\n\nStatsAgg 是用 Java 开发的，为了尽可能降低复杂性，它仅包括主服务和一个 UI。StatsAgg 支持基于正则表达式匹配来发送告警，而且它更注重于服务方面的告警，而不是服务器基础告警。我认为它填补了开源监控工具方面的空白，而这正式它自己的目标。\n\n### 可视化工具\n\n#### Grafana\n\n[Grafana][10] 的知名度很高，它也被广泛采用。每当我需要用到数据面板的时候，我总是会想到它，因为它比我使用过的任何一款类似的产品都要好。Grafana 由 Torkel Ödegaard 开发的，像 Cabot 一样，也是在圣诞节期间开发的，并在 2014 年 1 月发布。在短短几年之间，它已经有了长足的发展。Grafana 基于 Kibana 开发，Torkel 开启了新的分支并将其命名为 Grafana。\n\nGrafana 着重体现了实用性以及数据呈现的美观性。它天生就可以从 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 收集数据。此外有一个 Grafana 商用版插件可以从更多数据源获取数据，但是其他数据源插件也并非没有开源版本，Grafana 的插件生态系统已经提供了各种数据源。\n\nGrafana 能做什么呢？Grafana 提供了一个中心化的了解系统的方式。它通过 web 来展示数据，任何人都有机会访问到相关信息，当然也可以使用身份验证来对访问进行限制。Grafana 使用各种可视化方式来提供对系统一目了然的了解。Grafana 还支持不同类型的可视化方式，包括集成告警可视化的功能。\n\n现在你可以更直观地设置告警了。通过 Grafana，可以查看图表，还可以查看由于系统性能下降而触发告警的位置，单击要触发报警的位置，并告诉 Grafana 将告警发送何处。这是一个对告警平台非常强大的补充。告警平台不一定会因此而被取代，但告警系统一定会由此得到更多启发和发展。\n\nGrafana 还引入了很多团队协作的功能。不同用户之间能够共享数据面板，你不再需要为 [Kubernetes][21] 集群创建独立的数据面板，因为由 Kubernetes 开发者和 Grafana 开发者共同维护的一些数据面板已经可用了。\n\n团队协作过程中一个重要的功能是注释。注释功能允许用户将上下文添加到图表当中，其他用户就可以通过上下文更直观地理解图表。当团队成员在处理某个事件，并且需要沟通和理解时，这个功能就十分重要了。将所有相关信息都放在需要的位置，可以让整个团队中快速达成共识。在团队需要调查故障原因和定位事件责任时，这个功能就可以发挥作用了。\n\n#### Vizceral\n\n[Vizceral][22] 由 Netflix 开发，用于在故障发生时更有效地了解流量的情况。Grafana 是一种通用性更强的工具，而 Vizceral 则专用于某些领域。 尽管 Netflix 表示已经不再在内部使用 Vizceral，也不再主动对其展开维护，但 Vizceral 仍然会定期更新。我在这里介绍这个工具，主要是为了介绍它的的可视化机制，以及如何利用它来协助解决问题。你可以在样例环境中用它来更好地掌握这一类系统的特性。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins\n\n[a]: https://opensource.com/users/barkerd427\n[b]: https://github.com/lujun9972\n[1]: https://www.practicalmonitoring.com/\n[2]: https://developers.google.com/chart/interactive/docs/gallery\n[3]: https://libguides.libraries.claremont.edu/c.php?g=474417&p=3286401\n[4]: http://www.brendangregg.com/flamegraphs.html\n[5]: https://stackoverflow.com/\n[6]: https://superuser.com/\n[7]: http://bosun.org/\n[8]: https://prometheus.io/docs/alerting/alertmanager/\n[9]: https://bosun.org/scollector/\n[10]: https://grafana.com/\n[11]: https://bosun.org/notifications\n[12]: https://cabotapp.com/\n[13]: https://www.arachnys.com/\n[14]: https://en.wikipedia.org/wiki/Know_your_customer\n[15]: https://www.nagios.org/\n[16]: https://graphiteapp.org/\n[17]: https://jenkins.io/\n[18]: https://github.com/PearsonEducation/StatsAgg\n[19]: https://www.pearson.com/us/\n[20]: https://www.oreilly.com/\n[21]: https://opensource.com/resources/what-is-kubernetes\n[22]: https://github.com/Netflix/vizceral\n\n","source":"_posts/5-alerting-and-visualization-tools-for-sysadmins.md","raw":"---\ntitle: 5 个适合系统管理员使用的告警可视化工具\ndate: 2018-11-11 17:41:56\ntags:\n  - 可视化\n  - 告警\n  - LCTT 翻译\n---\n\n> 这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/metrics_data_dashboard_system_computer_analytics.png?itok=oxAeIEI-)\n\n你大概已经知道（或猜到）<ruby>告警可视化<rt>alerting and visualization</rt></ruby>工具是用来做什么的了。下面我们就要来说一下，为什么要讨论这样的工具，甚至某些系统专门将可视化作为特有的功能。\n\n<ruby>可观察性<rt>Observability</rt></ruby>的概念来自<ruby>控制理论<rt>control theory</ruby>，这个概念描述了我们通过对系统的输入和输出来了解其的能力。本文将重点介绍具有可观察性的输出组件。\n\n告警可视化工具可以对其它系统的输出进行分析，进而对输出的信息进行结构化表示。告警实际上是对系统异常状态的描述，而可视化则是让用户能够直观理解的结构化表示。\n\n### 常见的可视化告警\n\n#### 告警\n\n首先要明确一下<ruby>告警<rt>alert</rt></ruby>的含义。在人员无法响应告警内容情况下，不应该发送告警 —— 包括那些发给多个人但只有其中少数人可以响应的告警，以及系统中的每个异常都触发的告警。因为这样会产生告警疲劳，告警接收者也往往会对这些过多的告警采取忽视的态度 —— 直到系统恶化到以少见的方式告警。\n\n例如，如果管理员每天都会收到告警系统发来的数百封告警邮件，他就很容易会忽略告警系统的所有邮件。除非他真的看到问题发生，或者受到了客户或上级的询问时，管理员才会重新重视告警信息。在这种情况下，告警已经失去了原有的意义和用途。\n\n告警不是一个持续的信息流或者状态更新。告警的目的在于暴露系统无法自动恢复的问题，而且告警应该只发送给最有可能解决问题的人员。超出这个定义的内容都不应该作为告警，否则将会对实际工作造成不良的影响。\n\n不同的告警体系都会有各自的告警类型，因此不能用优先级（P1-P5）或者诸如“信息”、“警告”、“严重”之类的字眼来一概而论，下面我会介绍一些新兴的复杂系统的事件响应中出现的通用分类方式。\n\n刚才我提到了一个“信息”这个告警类型，但实际上告警不应该是一个信息，尽管有些人可能会不这样认为。但我觉得如果一个告警没有发送给任何一个人，它就不应该是警报，而只是一些在许多系统中被视为警报的数据点，代表了一些应该知晓但不需要响应的事件。它更应该作为告警可视化工具的一部分，而不是会导致触发告警的事件。《[实用监控][1]》是这个领域的必读书籍，其作者 Mike Julian 在书中就介绍了他自己关于告警的看法。\n\n而非信息警报则代表告警需要被响应以及需要相关的操作。我将这些告警大致分为内部故障和外部故障两种类型，而对于大多数公司来说，通常会有两个以上的级别来确定响应告警的优先级。系统性能下降就是一种故障，因为其对用户的影响通常都是未知的。\n\n内部故障比外部故障的优先级低，但也需要快速响应。内部故障通常包括公司员工使用的内部系统或仅对公司员工可见的应用故障。\n\n外部故障则包括任何马上会产生业务影响的系统故障，但不包括影响系统更新的故障。外部故障一般包括客户所面临的应用故障、数据库故障和导致系统可用性或一致性失效的网络故障，这些都会影响用户的正常使用。对于不直接影响用户的依赖组件故障也属于外部故障，随着应用程序的不断运行，一旦依赖组件发生故障，系统的性能也会受到波及。这种情况对于使用某些外部服务或数据源的系统来说很常见，尽管这些外部服务或数据源对于可能不涉及到系统的主要功能，但是当系统在处理相关依赖组件的错误时可能会出现较明显的延迟。\n\n### 可视化\n\n可视化的种类有很多，我就不一一赘述了。这是一个有趣的研究领域，在我这些年的数据分析经历当中，学习和应用可视化方面的知识可以说是相当有挑战性。我们需要将复杂的系统输出通过直观的方式来向他人展示，才能有效地把信息传播出去。[Google Charts][2] 和 [Tableau][3] 都提供了很多可视化方面的工具。下面将会介绍一些最常见的可视化创新解决方案。\n\n#### 折线图\n\n折线图可能是最常见的可视化方式了，它可以让用户很直观地按照时间维度了解系统的情况。系统中每个单一或聚合的指标都会以一条折线在图表中体现。但当同一个图表中同时存在多条折线时，就可能会对阅读有所影响（如下图所示），所以大多数情况下都可以选择仅查看其中的少数几条折线，而不是让所有折线同时显示。如果某个指标的数值产生了大于正常范围的波动，就会很容易发现。例如下图中异常的紫线、黄线、浅蓝线。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart.png)\n\n折线图的另一个用法是可以将多条折线堆叠起来以显示它们之间的关系。例如对于通过折线图反映服务器的请求数量，可以单独看到每台服务器上的请求，也可以聚合在一起看。这就可以在同一个图表中灵活查看整个系统以及每个实例的情况了。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart_aggregate.png)\n\n#### 热力图\n\n另一种常见的可视化方式是热力图。热力图与条形图比较类似，还可以在条形图的基础上显示某部分在整体中占比的变化情况。例如在查看网络请求延时的时候，就可以使用热力图快速查看到所有网络请求的总体趋势和分布情况，另外，它可以使用不同颜色来表示不同部分的数值。\n\n在以下这个热力图中，通过竖直方向上每个时间段的色块数量分布，可以清楚地看到大部分数据集中在整个范围的中心位置。我们还可以发现，大多数时间段的色块分布都是比较宽松的，而 14:00 到 15:00 这一段则分布得很密集，这样的分布有可能意味着一种不健康的状态。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_histogram.png)\n\n#### 仪表图\n\n还有一种常见的可视化方式是仪表图，用户可以通过仪表图快速了解单个指标。仪表一般用于单个指标的显示，例如车速表代表汽车的行驶速度、油量表代表油箱中的汽油量等等。大多数的仪表图都有一个共通点，就是会划分出所示指标的对应状态。如下图所示，绿色表示正常的状态，橙色表示不良的状态，而红色则表示极差的状态。下图中间一行模拟了真实仪表的显示情况。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_gauges.png)\n\n上面图表中，除了常规仪表样式的显示方式之外，还有较为直接的数据显示方式，配合相同的配色方案，一眼就可以看出各个指标所处的状态，这一点与和仪表的特点类似。所以，最下面一行可能是仪表图的最佳显示方式，用户不需要仔细阅读，就可以大致了解各个指标的不同状态。这种类型的可视化是我最常用的类型，在数秒钟之间，我就可以全面地总览系统各方面地运行情况。\n\n#### 火焰图\n\n由 [Netflix 的 Brendan Gregg][4] 在 2011 年开始使用的火焰图是一种较为少见地可视化方式。它不像仪表图那样可以从图表中快速得到关键信息，通常只会在需要解决某个应用的问题的时候才会用到这种图表。火焰图主要用于 CPU、内存和相关帧方面的表示，X 轴按字母顺序将帧一一列出，而 Y 轴则表示堆栈的深度。图中每个矩形都是一个标明了调用的函数的堆栈帧。矩形越宽，就表示它在堆栈中出现越频繁。在分析系统性能问题的时候，火焰图能够起到很大的作用，大家不妨尝试一下。\n\n![](https://opensource.com/sites/default/files/uploads/monitoring_guide_flame_graph_0.png)\n\n### 工具的选择\n\n在告警工具方面，有几个商用的工具相当不错。但由于这是一篇介绍开源技术的文章，我只会介绍那些已经被广泛使用的免费工具。希望你也能够为这些工具贡献你自己的代码，让它们更加完善。\n\n### 告警工具\n\n#### Bosun\n\n如果你的电脑出现问题，得多亏 Stack Exchange 你才能在网上查到解决办法。Stack Exchange 以众包问答的模式运营着很多不同类型的网站。其中就有广受开发者欢迎的 [Stack Overflow][5]，以及运维方面有名的 [Super User][6]。除此以外，从育儿经验到科幻小说、从哲学讨论到单车论坛，Stack Exchange 都有涉猎。\n\nStack Exchange 开源了它的告警管理系统 [Bosun][7]，同时也发布了 Prometheus 及其 [AlertManager][8] 系统。这两个系统有共通点。Bosun 和 Prometheus 一样使用 Golang 开发，但 Bosun 比 Prometheus 更为强大，因为它可以使用<ruby>指标聚合<rt>metrics aggregation</rt></ruby>以外的方式与系统交互。Bosun 还可以从日志和事件收集系统中提取数据，并且支持 Graphite、InfluxDB、OpenTSDB 和 Elasticsearch。\n\nBosun 的架构包括一个单一的服务器的二进制文件，一个诸如 OpenTSDB 的后端、Redis 以及 [scollector 代理][9]。 scollector 代理会自动检测主机上正在运行的服务，并反馈这些进程和其它的系统资源的情况。这些数据将发送到后端。随后 Bosun 的二进制服务文件会向后端发起查询，确定是否需要触发告警。也可以通过 [Grafana][10] 这些工具通过一个通用接口查询 Bosun 的底层后端。而 Redis 则用于存储 Bosun 的状态信息和元数据。\n\nBosun 有一个非常巧妙的功能，就是可以根据历史数据来测试告警。这是我几年前在使用 Prometheus 的时候就非常需要的功能，当时我有一个异常的数据需要产生告警，但没有一个可以用于测试的简便方法。为了确保告警能够正常触发，我不得不造出对应的数据来进行测试。而 Bosun 让这个步骤的耗时大大缩短。\n\nBosun 更是涵盖了所有常用过的功能，包括简单的图形化表示和告警的创建。它还带有强大的用于编写告警规则的表达式语言。但 Bosun 默认只带有电子邮件通知配置和 HTTP 通知配置，因此如果需要连接到 Slack 或其它工具，就需要对配置作出更大程度的定制化（[其文档中有][11]）。类似于 Prometheus，Bosun 还可以使用模板通知，你可以使用 HTML 和 CSS 来创建你所需要的电子邮件通知。\n\n#### Cabot\n\n[Cabot][12] 由 [Arachnys][13] 公司开发。你或许对 Arachnys 公司并不了解，但它很有影响力：Arachnys 公司构建了一个基于云的先进解决方案，用于防范金融犯罪。在之前的公司时，我也曾经参与过类似“[了解你的客户][14]（KYC）”的工作。大多数公司都认为与恐怖组织产生联系会造成相当不好的影响，因为恐怖组织可能会利用自己的系统来筹集资金。而这些解决方案将有助于防范欺诈类犯罪，尽管这类犯罪情节相对较轻，但仍然也会对机构产生风险。\n\nArachnys 公司为什么要开发 Cabot 呢？其实只是因为 Arachnys 的开发人员对 [Nagios][15] 不太熟悉。Cabot 的出现对很多人来说都是一个好消息，它基于 Django 和 Bootstrap 开发，因此如果想对这个项目做出自己的贡献，门槛并不高。（另外值得一提的是，Cabot 这个名字来源于开发者的狗。）\n\n与 Bosun 类似，Cabot 也不对数据进行收集，而是使用监控对象的 API 提供的数据。因此，Cabot 告警的模式是拉取而不是推送。它通过访问每个监控对象的 API，根据特定的指标检索所需的数据，然后将告警数据使用 Redis 缓存，进而持久化存储到 Postgres 数据库。\n\nCabot 的一个较为少见的特点是，它原生支持 [Graphite][16]，同时也支持 [Jenkins][17]。Jenkins 在这里被视为一个集中式的定时任务，它会以对待故障的方式去对待构建失败的状况。构建失败当然没有系统故障那么紧急，但一旦出现构建失败，还是需要团队采取措施去处理，毕竟并不是每个人在收到构建失败的电子邮件时都会亲自去检查 Jenkins。\n\nCabot 另一个有趣的功能是它可以接入 Google 日历安排值班人员，这个称为 Rota 的功能用处很大，希望其它告警系统也能加入类似的功能。Cabot 目前仅支持安排主备联系人，但还有继续改进的空间。它自己的文档也提到，如果需要全面的功能，更应该考虑付费的解决方案。\n\n#### StatsAgg\n\n[Pearson][19] 作为一家开发了 [StatsAgg][18] 告警平台的出版公司，这是极为罕见的，当然也很值得敬佩。除此以外，Pearson 还运营着另外几个网站以及和 [O'Reilly Media][20] 合资的企业。但我仍然会将它视为出版教学书籍的公司。\n\nStatsAgg 除了是一个告警平台，还是一个指标聚合平台，甚至也有点类似其它系统的代理。StatsAgg 支持通过 Graphite、StatsD、InfluxDB 和 OpenTSDB 输入数据，也支持将其转发到各种平台。但随着中心服务的负载不断增加，风险也不断增大。尽管如此，如果 StatsAgg 的基础架构足够强壮，即使后端存储平台出现故障，也不会对它产生告警的过程造成影响。\n\nStatsAgg 是用 Java 开发的，为了尽可能降低复杂性，它仅包括主服务和一个 UI。StatsAgg 支持基于正则表达式匹配来发送告警，而且它更注重于服务方面的告警，而不是服务器基础告警。我认为它填补了开源监控工具方面的空白，而这正式它自己的目标。\n\n### 可视化工具\n\n#### Grafana\n\n[Grafana][10] 的知名度很高，它也被广泛采用。每当我需要用到数据面板的时候，我总是会想到它，因为它比我使用过的任何一款类似的产品都要好。Grafana 由 Torkel Ödegaard 开发的，像 Cabot 一样，也是在圣诞节期间开发的，并在 2014 年 1 月发布。在短短几年之间，它已经有了长足的发展。Grafana 基于 Kibana 开发，Torkel 开启了新的分支并将其命名为 Grafana。\n\nGrafana 着重体现了实用性以及数据呈现的美观性。它天生就可以从 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 收集数据。此外有一个 Grafana 商用版插件可以从更多数据源获取数据，但是其他数据源插件也并非没有开源版本，Grafana 的插件生态系统已经提供了各种数据源。\n\nGrafana 能做什么呢？Grafana 提供了一个中心化的了解系统的方式。它通过 web 来展示数据，任何人都有机会访问到相关信息，当然也可以使用身份验证来对访问进行限制。Grafana 使用各种可视化方式来提供对系统一目了然的了解。Grafana 还支持不同类型的可视化方式，包括集成告警可视化的功能。\n\n现在你可以更直观地设置告警了。通过 Grafana，可以查看图表，还可以查看由于系统性能下降而触发告警的位置，单击要触发报警的位置，并告诉 Grafana 将告警发送何处。这是一个对告警平台非常强大的补充。告警平台不一定会因此而被取代，但告警系统一定会由此得到更多启发和发展。\n\nGrafana 还引入了很多团队协作的功能。不同用户之间能够共享数据面板，你不再需要为 [Kubernetes][21] 集群创建独立的数据面板，因为由 Kubernetes 开发者和 Grafana 开发者共同维护的一些数据面板已经可用了。\n\n团队协作过程中一个重要的功能是注释。注释功能允许用户将上下文添加到图表当中，其他用户就可以通过上下文更直观地理解图表。当团队成员在处理某个事件，并且需要沟通和理解时，这个功能就十分重要了。将所有相关信息都放在需要的位置，可以让整个团队中快速达成共识。在团队需要调查故障原因和定位事件责任时，这个功能就可以发挥作用了。\n\n#### Vizceral\n\n[Vizceral][22] 由 Netflix 开发，用于在故障发生时更有效地了解流量的情况。Grafana 是一种通用性更强的工具，而 Vizceral 则专用于某些领域。 尽管 Netflix 表示已经不再在内部使用 Vizceral，也不再主动对其展开维护，但 Vizceral 仍然会定期更新。我在这里介绍这个工具，主要是为了介绍它的的可视化机制，以及如何利用它来协助解决问题。你可以在样例环境中用它来更好地掌握这一类系统的特性。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins\n\n[a]: https://opensource.com/users/barkerd427\n[b]: https://github.com/lujun9972\n[1]: https://www.practicalmonitoring.com/\n[2]: https://developers.google.com/chart/interactive/docs/gallery\n[3]: https://libguides.libraries.claremont.edu/c.php?g=474417&p=3286401\n[4]: http://www.brendangregg.com/flamegraphs.html\n[5]: https://stackoverflow.com/\n[6]: https://superuser.com/\n[7]: http://bosun.org/\n[8]: https://prometheus.io/docs/alerting/alertmanager/\n[9]: https://bosun.org/scollector/\n[10]: https://grafana.com/\n[11]: https://bosun.org/notifications\n[12]: https://cabotapp.com/\n[13]: https://www.arachnys.com/\n[14]: https://en.wikipedia.org/wiki/Know_your_customer\n[15]: https://www.nagios.org/\n[16]: https://graphiteapp.org/\n[17]: https://jenkins.io/\n[18]: https://github.com/PearsonEducation/StatsAgg\n[19]: https://www.pearson.com/us/\n[20]: https://www.oreilly.com/\n[21]: https://opensource.com/resources/what-is-kubernetes\n[22]: https://github.com/Netflix/vizceral\n\n","slug":"5-alerting-and-visualization-tools-for-sysadmins","published":1,"updated":"2019-03-28T12:35:23.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0bu0009lixuautnamci","content":"<blockquote>\n<p>这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/metrics_data_dashboard_system_computer_analytics.png?itok=oxAeIEI-\" alt=\"\"></p>\n<p>你大概已经知道（或猜到）<ruby>告警可视化<rt>alerting and visualization</rt></ruby>工具是用来做什么的了。下面我们就要来说一下，为什么要讨论这样的工具，甚至某些系统专门将可视化作为特有的功能。</p>\n<p><ruby>可观察性<rt>Observability</rt></ruby>的概念来自<ruby>控制理论<rt>control theory</rt></ruby>，这个概念描述了我们通过对系统的输入和输出来了解其的能力。本文将重点介绍具有可观察性的输出组件。</p>\n<p>告警可视化工具可以对其它系统的输出进行分析，进而对输出的信息进行结构化表示。告警实际上是对系统异常状态的描述，而可视化则是让用户能够直观理解的结构化表示。</p>\n<h3 id=\"常见的可视化告警\"><a href=\"#常见的可视化告警\" class=\"headerlink\" title=\"常见的可视化告警\"></a>常见的可视化告警</h3><h4 id=\"告警\"><a href=\"#告警\" class=\"headerlink\" title=\"告警\"></a>告警</h4><p>首先要明确一下<ruby>告警<rt>alert</rt></ruby>的含义。在人员无法响应告警内容情况下，不应该发送告警 —— 包括那些发给多个人但只有其中少数人可以响应的告警，以及系统中的每个异常都触发的告警。因为这样会产生告警疲劳，告警接收者也往往会对这些过多的告警采取忽视的态度 —— 直到系统恶化到以少见的方式告警。</p>\n<p>例如，如果管理员每天都会收到告警系统发来的数百封告警邮件，他就很容易会忽略告警系统的所有邮件。除非他真的看到问题发生，或者受到了客户或上级的询问时，管理员才会重新重视告警信息。在这种情况下，告警已经失去了原有的意义和用途。</p>\n<p>告警不是一个持续的信息流或者状态更新。告警的目的在于暴露系统无法自动恢复的问题，而且告警应该只发送给最有可能解决问题的人员。超出这个定义的内容都不应该作为告警，否则将会对实际工作造成不良的影响。</p>\n<p>不同的告警体系都会有各自的告警类型，因此不能用优先级（P1-P5）或者诸如“信息”、“警告”、“严重”之类的字眼来一概而论，下面我会介绍一些新兴的复杂系统的事件响应中出现的通用分类方式。</p>\n<p>刚才我提到了一个“信息”这个告警类型，但实际上告警不应该是一个信息，尽管有些人可能会不这样认为。但我觉得如果一个告警没有发送给任何一个人，它就不应该是警报，而只是一些在许多系统中被视为警报的数据点，代表了一些应该知晓但不需要响应的事件。它更应该作为告警可视化工具的一部分，而不是会导致触发告警的事件。《<a href=\"https://www.practicalmonitoring.com/\" target=\"_blank\" rel=\"noopener\">实用监控</a>》是这个领域的必读书籍，其作者 Mike Julian 在书中就介绍了他自己关于告警的看法。</p>\n<p>而非信息警报则代表告警需要被响应以及需要相关的操作。我将这些告警大致分为内部故障和外部故障两种类型，而对于大多数公司来说，通常会有两个以上的级别来确定响应告警的优先级。系统性能下降就是一种故障，因为其对用户的影响通常都是未知的。</p>\n<p>内部故障比外部故障的优先级低，但也需要快速响应。内部故障通常包括公司员工使用的内部系统或仅对公司员工可见的应用故障。</p>\n<p>外部故障则包括任何马上会产生业务影响的系统故障，但不包括影响系统更新的故障。外部故障一般包括客户所面临的应用故障、数据库故障和导致系统可用性或一致性失效的网络故障，这些都会影响用户的正常使用。对于不直接影响用户的依赖组件故障也属于外部故障，随着应用程序的不断运行，一旦依赖组件发生故障，系统的性能也会受到波及。这种情况对于使用某些外部服务或数据源的系统来说很常见，尽管这些外部服务或数据源对于可能不涉及到系统的主要功能，但是当系统在处理相关依赖组件的错误时可能会出现较明显的延迟。</p>\n<h3 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h3><p>可视化的种类有很多，我就不一一赘述了。这是一个有趣的研究领域，在我这些年的数据分析经历当中，学习和应用可视化方面的知识可以说是相当有挑战性。我们需要将复杂的系统输出通过直观的方式来向他人展示，才能有效地把信息传播出去。<a href=\"https://developers.google.com/chart/interactive/docs/gallery\" target=\"_blank\" rel=\"noopener\">Google Charts</a> 和 <a href=\"https://libguides.libraries.claremont.edu/c.php?g=474417&amp;p=3286401\" target=\"_blank\" rel=\"noopener\">Tableau</a> 都提供了很多可视化方面的工具。下面将会介绍一些最常见的可视化创新解决方案。</p>\n<h4 id=\"折线图\"><a href=\"#折线图\" class=\"headerlink\" title=\"折线图\"></a>折线图</h4><p>折线图可能是最常见的可视化方式了，它可以让用户很直观地按照时间维度了解系统的情况。系统中每个单一或聚合的指标都会以一条折线在图表中体现。但当同一个图表中同时存在多条折线时，就可能会对阅读有所影响（如下图所示），所以大多数情况下都可以选择仅查看其中的少数几条折线，而不是让所有折线同时显示。如果某个指标的数值产生了大于正常范围的波动，就会很容易发现。例如下图中异常的紫线、黄线、浅蓝线。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart.png\" alt=\"\"></p>\n<p>折线图的另一个用法是可以将多条折线堆叠起来以显示它们之间的关系。例如对于通过折线图反映服务器的请求数量，可以单独看到每台服务器上的请求，也可以聚合在一起看。这就可以在同一个图表中灵活查看整个系统以及每个实例的情况了。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart_aggregate.png\" alt=\"\"></p>\n<h4 id=\"热力图\"><a href=\"#热力图\" class=\"headerlink\" title=\"热力图\"></a>热力图</h4><p>另一种常见的可视化方式是热力图。热力图与条形图比较类似，还可以在条形图的基础上显示某部分在整体中占比的变化情况。例如在查看网络请求延时的时候，就可以使用热力图快速查看到所有网络请求的总体趋势和分布情况，另外，它可以使用不同颜色来表示不同部分的数值。</p>\n<p>在以下这个热力图中，通过竖直方向上每个时间段的色块数量分布，可以清楚地看到大部分数据集中在整个范围的中心位置。我们还可以发现，大多数时间段的色块分布都是比较宽松的，而 14:00 到 15:00 这一段则分布得很密集，这样的分布有可能意味着一种不健康的状态。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_histogram.png\" alt=\"\"></p>\n<h4 id=\"仪表图\"><a href=\"#仪表图\" class=\"headerlink\" title=\"仪表图\"></a>仪表图</h4><p>还有一种常见的可视化方式是仪表图，用户可以通过仪表图快速了解单个指标。仪表一般用于单个指标的显示，例如车速表代表汽车的行驶速度、油量表代表油箱中的汽油量等等。大多数的仪表图都有一个共通点，就是会划分出所示指标的对应状态。如下图所示，绿色表示正常的状态，橙色表示不良的状态，而红色则表示极差的状态。下图中间一行模拟了真实仪表的显示情况。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_gauges.png\" alt=\"\"></p>\n<p>上面图表中，除了常规仪表样式的显示方式之外，还有较为直接的数据显示方式，配合相同的配色方案，一眼就可以看出各个指标所处的状态，这一点与和仪表的特点类似。所以，最下面一行可能是仪表图的最佳显示方式，用户不需要仔细阅读，就可以大致了解各个指标的不同状态。这种类型的可视化是我最常用的类型，在数秒钟之间，我就可以全面地总览系统各方面地运行情况。</p>\n<h4 id=\"火焰图\"><a href=\"#火焰图\" class=\"headerlink\" title=\"火焰图\"></a>火焰图</h4><p>由 <a href=\"http://www.brendangregg.com/flamegraphs.html\" target=\"_blank\" rel=\"noopener\">Netflix 的 Brendan Gregg</a> 在 2011 年开始使用的火焰图是一种较为少见地可视化方式。它不像仪表图那样可以从图表中快速得到关键信息，通常只会在需要解决某个应用的问题的时候才会用到这种图表。火焰图主要用于 CPU、内存和相关帧方面的表示，X 轴按字母顺序将帧一一列出，而 Y 轴则表示堆栈的深度。图中每个矩形都是一个标明了调用的函数的堆栈帧。矩形越宽，就表示它在堆栈中出现越频繁。在分析系统性能问题的时候，火焰图能够起到很大的作用，大家不妨尝试一下。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_flame_graph_0.png\" alt=\"\"></p>\n<h3 id=\"工具的选择\"><a href=\"#工具的选择\" class=\"headerlink\" title=\"工具的选择\"></a>工具的选择</h3><p>在告警工具方面，有几个商用的工具相当不错。但由于这是一篇介绍开源技术的文章，我只会介绍那些已经被广泛使用的免费工具。希望你也能够为这些工具贡献你自己的代码，让它们更加完善。</p>\n<h3 id=\"告警工具\"><a href=\"#告警工具\" class=\"headerlink\" title=\"告警工具\"></a>告警工具</h3><h4 id=\"Bosun\"><a href=\"#Bosun\" class=\"headerlink\" title=\"Bosun\"></a>Bosun</h4><p>如果你的电脑出现问题，得多亏 Stack Exchange 你才能在网上查到解决办法。Stack Exchange 以众包问答的模式运营着很多不同类型的网站。其中就有广受开发者欢迎的 <a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a>，以及运维方面有名的 <a href=\"https://superuser.com/\" target=\"_blank\" rel=\"noopener\">Super User</a>。除此以外，从育儿经验到科幻小说、从哲学讨论到单车论坛，Stack Exchange 都有涉猎。</p>\n<p>Stack Exchange 开源了它的告警管理系统 <a href=\"http://bosun.org/\" target=\"_blank\" rel=\"noopener\">Bosun</a>，同时也发布了 Prometheus 及其 <a href=\"https://prometheus.io/docs/alerting/alertmanager/\" target=\"_blank\" rel=\"noopener\">AlertManager</a> 系统。这两个系统有共通点。Bosun 和 Prometheus 一样使用 Golang 开发，但 Bosun 比 Prometheus 更为强大，因为它可以使用<ruby>指标聚合<rt>metrics aggregation</rt></ruby>以外的方式与系统交互。Bosun 还可以从日志和事件收集系统中提取数据，并且支持 Graphite、InfluxDB、OpenTSDB 和 Elasticsearch。</p>\n<p>Bosun 的架构包括一个单一的服务器的二进制文件，一个诸如 OpenTSDB 的后端、Redis 以及 <a href=\"https://bosun.org/scollector/\" target=\"_blank\" rel=\"noopener\">scollector 代理</a>。 scollector 代理会自动检测主机上正在运行的服务，并反馈这些进程和其它的系统资源的情况。这些数据将发送到后端。随后 Bosun 的二进制服务文件会向后端发起查询，确定是否需要触发告警。也可以通过 <a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">Grafana</a> 这些工具通过一个通用接口查询 Bosun 的底层后端。而 Redis 则用于存储 Bosun 的状态信息和元数据。</p>\n<p>Bosun 有一个非常巧妙的功能，就是可以根据历史数据来测试告警。这是我几年前在使用 Prometheus 的时候就非常需要的功能，当时我有一个异常的数据需要产生告警，但没有一个可以用于测试的简便方法。为了确保告警能够正常触发，我不得不造出对应的数据来进行测试。而 Bosun 让这个步骤的耗时大大缩短。</p>\n<p>Bosun 更是涵盖了所有常用过的功能，包括简单的图形化表示和告警的创建。它还带有强大的用于编写告警规则的表达式语言。但 Bosun 默认只带有电子邮件通知配置和 HTTP 通知配置，因此如果需要连接到 Slack 或其它工具，就需要对配置作出更大程度的定制化（<a href=\"https://bosun.org/notifications\" target=\"_blank\" rel=\"noopener\">其文档中有</a>）。类似于 Prometheus，Bosun 还可以使用模板通知，你可以使用 HTML 和 CSS 来创建你所需要的电子邮件通知。</p>\n<h4 id=\"Cabot\"><a href=\"#Cabot\" class=\"headerlink\" title=\"Cabot\"></a>Cabot</h4><p><a href=\"https://cabotapp.com/\" target=\"_blank\" rel=\"noopener\">Cabot</a> 由 <a href=\"https://www.arachnys.com/\" target=\"_blank\" rel=\"noopener\">Arachnys</a> 公司开发。你或许对 Arachnys 公司并不了解，但它很有影响力：Arachnys 公司构建了一个基于云的先进解决方案，用于防范金融犯罪。在之前的公司时，我也曾经参与过类似“<a href=\"https://en.wikipedia.org/wiki/Know_your_customer\" target=\"_blank\" rel=\"noopener\">了解你的客户</a>（KYC）”的工作。大多数公司都认为与恐怖组织产生联系会造成相当不好的影响，因为恐怖组织可能会利用自己的系统来筹集资金。而这些解决方案将有助于防范欺诈类犯罪，尽管这类犯罪情节相对较轻，但仍然也会对机构产生风险。</p>\n<p>Arachnys 公司为什么要开发 Cabot 呢？其实只是因为 Arachnys 的开发人员对 <a href=\"https://www.nagios.org/\" target=\"_blank\" rel=\"noopener\">Nagios</a> 不太熟悉。Cabot 的出现对很多人来说都是一个好消息，它基于 Django 和 Bootstrap 开发，因此如果想对这个项目做出自己的贡献，门槛并不高。（另外值得一提的是，Cabot 这个名字来源于开发者的狗。）</p>\n<p>与 Bosun 类似，Cabot 也不对数据进行收集，而是使用监控对象的 API 提供的数据。因此，Cabot 告警的模式是拉取而不是推送。它通过访问每个监控对象的 API，根据特定的指标检索所需的数据，然后将告警数据使用 Redis 缓存，进而持久化存储到 Postgres 数据库。</p>\n<p>Cabot 的一个较为少见的特点是，它原生支持 <a href=\"https://graphiteapp.org/\" target=\"_blank\" rel=\"noopener\">Graphite</a>，同时也支持 <a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>。Jenkins 在这里被视为一个集中式的定时任务，它会以对待故障的方式去对待构建失败的状况。构建失败当然没有系统故障那么紧急，但一旦出现构建失败，还是需要团队采取措施去处理，毕竟并不是每个人在收到构建失败的电子邮件时都会亲自去检查 Jenkins。</p>\n<p>Cabot 另一个有趣的功能是它可以接入 Google 日历安排值班人员，这个称为 Rota 的功能用处很大，希望其它告警系统也能加入类似的功能。Cabot 目前仅支持安排主备联系人，但还有继续改进的空间。它自己的文档也提到，如果需要全面的功能，更应该考虑付费的解决方案。</p>\n<h4 id=\"StatsAgg\"><a href=\"#StatsAgg\" class=\"headerlink\" title=\"StatsAgg\"></a>StatsAgg</h4><p><a href=\"https://www.pearson.com/us/\" target=\"_blank\" rel=\"noopener\">Pearson</a> 作为一家开发了 <a href=\"https://github.com/PearsonEducation/StatsAgg\" target=\"_blank\" rel=\"noopener\">StatsAgg</a> 告警平台的出版公司，这是极为罕见的，当然也很值得敬佩。除此以外，Pearson 还运营着另外几个网站以及和 <a href=\"https://www.oreilly.com/\" target=\"_blank\" rel=\"noopener\">O’Reilly Media</a> 合资的企业。但我仍然会将它视为出版教学书籍的公司。</p>\n<p>StatsAgg 除了是一个告警平台，还是一个指标聚合平台，甚至也有点类似其它系统的代理。StatsAgg 支持通过 Graphite、StatsD、InfluxDB 和 OpenTSDB 输入数据，也支持将其转发到各种平台。但随着中心服务的负载不断增加，风险也不断增大。尽管如此，如果 StatsAgg 的基础架构足够强壮，即使后端存储平台出现故障，也不会对它产生告警的过程造成影响。</p>\n<p>StatsAgg 是用 Java 开发的，为了尽可能降低复杂性，它仅包括主服务和一个 UI。StatsAgg 支持基于正则表达式匹配来发送告警，而且它更注重于服务方面的告警，而不是服务器基础告警。我认为它填补了开源监控工具方面的空白，而这正式它自己的目标。</p>\n<h3 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h3><h4 id=\"Grafana\"><a href=\"#Grafana\" class=\"headerlink\" title=\"Grafana\"></a>Grafana</h4><p><a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">Grafana</a> 的知名度很高，它也被广泛采用。每当我需要用到数据面板的时候，我总是会想到它，因为它比我使用过的任何一款类似的产品都要好。Grafana 由 Torkel Ödegaard 开发的，像 Cabot 一样，也是在圣诞节期间开发的，并在 2014 年 1 月发布。在短短几年之间，它已经有了长足的发展。Grafana 基于 Kibana 开发，Torkel 开启了新的分支并将其命名为 Grafana。</p>\n<p>Grafana 着重体现了实用性以及数据呈现的美观性。它天生就可以从 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 收集数据。此外有一个 Grafana 商用版插件可以从更多数据源获取数据，但是其他数据源插件也并非没有开源版本，Grafana 的插件生态系统已经提供了各种数据源。</p>\n<p>Grafana 能做什么呢？Grafana 提供了一个中心化的了解系统的方式。它通过 web 来展示数据，任何人都有机会访问到相关信息，当然也可以使用身份验证来对访问进行限制。Grafana 使用各种可视化方式来提供对系统一目了然的了解。Grafana 还支持不同类型的可视化方式，包括集成告警可视化的功能。</p>\n<p>现在你可以更直观地设置告警了。通过 Grafana，可以查看图表，还可以查看由于系统性能下降而触发告警的位置，单击要触发报警的位置，并告诉 Grafana 将告警发送何处。这是一个对告警平台非常强大的补充。告警平台不一定会因此而被取代，但告警系统一定会由此得到更多启发和发展。</p>\n<p>Grafana 还引入了很多团队协作的功能。不同用户之间能够共享数据面板，你不再需要为 <a href=\"https://opensource.com/resources/what-is-kubernetes\" target=\"_blank\" rel=\"noopener\">Kubernetes</a> 集群创建独立的数据面板，因为由 Kubernetes 开发者和 Grafana 开发者共同维护的一些数据面板已经可用了。</p>\n<p>团队协作过程中一个重要的功能是注释。注释功能允许用户将上下文添加到图表当中，其他用户就可以通过上下文更直观地理解图表。当团队成员在处理某个事件，并且需要沟通和理解时，这个功能就十分重要了。将所有相关信息都放在需要的位置，可以让整个团队中快速达成共识。在团队需要调查故障原因和定位事件责任时，这个功能就可以发挥作用了。</p>\n<h4 id=\"Vizceral\"><a href=\"#Vizceral\" class=\"headerlink\" title=\"Vizceral\"></a>Vizceral</h4><p><a href=\"https://github.com/Netflix/vizceral\" target=\"_blank\" rel=\"noopener\">Vizceral</a> 由 Netflix 开发，用于在故障发生时更有效地了解流量的情况。Grafana 是一种通用性更强的工具，而 Vizceral 则专用于某些领域。 尽管 Netflix 表示已经不再在内部使用 Vizceral，也不再主动对其展开维护，但 Vizceral 仍然会定期更新。我在这里介绍这个工具，主要是为了介绍它的的可视化机制，以及如何利用它来协助解决问题。你可以在样例环境中用它来更好地掌握这一类系统的特性。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/metrics_data_dashboard_system_computer_analytics.png?itok=oxAeIEI-\" alt=\"\"></p>\n<p>你大概已经知道（或猜到）<ruby>告警可视化<rt>alerting and visualization</rt></ruby>工具是用来做什么的了。下面我们就要来说一下，为什么要讨论这样的工具，甚至某些系统专门将可视化作为特有的功能。</p>\n<p><ruby>可观察性<rt>Observability</rt></ruby>的概念来自<ruby>控制理论<rt>control theory</rt></ruby>，这个概念描述了我们通过对系统的输入和输出来了解其的能力。本文将重点介绍具有可观察性的输出组件。</p>\n<p>告警可视化工具可以对其它系统的输出进行分析，进而对输出的信息进行结构化表示。告警实际上是对系统异常状态的描述，而可视化则是让用户能够直观理解的结构化表示。</p>\n<h3 id=\"常见的可视化告警\"><a href=\"#常见的可视化告警\" class=\"headerlink\" title=\"常见的可视化告警\"></a>常见的可视化告警</h3><h4 id=\"告警\"><a href=\"#告警\" class=\"headerlink\" title=\"告警\"></a>告警</h4><p>首先要明确一下<ruby>告警<rt>alert</rt></ruby>的含义。在人员无法响应告警内容情况下，不应该发送告警 —— 包括那些发给多个人但只有其中少数人可以响应的告警，以及系统中的每个异常都触发的告警。因为这样会产生告警疲劳，告警接收者也往往会对这些过多的告警采取忽视的态度 —— 直到系统恶化到以少见的方式告警。</p>\n<p>例如，如果管理员每天都会收到告警系统发来的数百封告警邮件，他就很容易会忽略告警系统的所有邮件。除非他真的看到问题发生，或者受到了客户或上级的询问时，管理员才会重新重视告警信息。在这种情况下，告警已经失去了原有的意义和用途。</p>\n<p>告警不是一个持续的信息流或者状态更新。告警的目的在于暴露系统无法自动恢复的问题，而且告警应该只发送给最有可能解决问题的人员。超出这个定义的内容都不应该作为告警，否则将会对实际工作造成不良的影响。</p>\n<p>不同的告警体系都会有各自的告警类型，因此不能用优先级（P1-P5）或者诸如“信息”、“警告”、“严重”之类的字眼来一概而论，下面我会介绍一些新兴的复杂系统的事件响应中出现的通用分类方式。</p>\n<p>刚才我提到了一个“信息”这个告警类型，但实际上告警不应该是一个信息，尽管有些人可能会不这样认为。但我觉得如果一个告警没有发送给任何一个人，它就不应该是警报，而只是一些在许多系统中被视为警报的数据点，代表了一些应该知晓但不需要响应的事件。它更应该作为告警可视化工具的一部分，而不是会导致触发告警的事件。《<a href=\"https://www.practicalmonitoring.com/\" target=\"_blank\" rel=\"noopener\">实用监控</a>》是这个领域的必读书籍，其作者 Mike Julian 在书中就介绍了他自己关于告警的看法。</p>\n<p>而非信息警报则代表告警需要被响应以及需要相关的操作。我将这些告警大致分为内部故障和外部故障两种类型，而对于大多数公司来说，通常会有两个以上的级别来确定响应告警的优先级。系统性能下降就是一种故障，因为其对用户的影响通常都是未知的。</p>\n<p>内部故障比外部故障的优先级低，但也需要快速响应。内部故障通常包括公司员工使用的内部系统或仅对公司员工可见的应用故障。</p>\n<p>外部故障则包括任何马上会产生业务影响的系统故障，但不包括影响系统更新的故障。外部故障一般包括客户所面临的应用故障、数据库故障和导致系统可用性或一致性失效的网络故障，这些都会影响用户的正常使用。对于不直接影响用户的依赖组件故障也属于外部故障，随着应用程序的不断运行，一旦依赖组件发生故障，系统的性能也会受到波及。这种情况对于使用某些外部服务或数据源的系统来说很常见，尽管这些外部服务或数据源对于可能不涉及到系统的主要功能，但是当系统在处理相关依赖组件的错误时可能会出现较明显的延迟。</p>\n<h3 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h3><p>可视化的种类有很多，我就不一一赘述了。这是一个有趣的研究领域，在我这些年的数据分析经历当中，学习和应用可视化方面的知识可以说是相当有挑战性。我们需要将复杂的系统输出通过直观的方式来向他人展示，才能有效地把信息传播出去。<a href=\"https://developers.google.com/chart/interactive/docs/gallery\" target=\"_blank\" rel=\"noopener\">Google Charts</a> 和 <a href=\"https://libguides.libraries.claremont.edu/c.php?g=474417&amp;p=3286401\" target=\"_blank\" rel=\"noopener\">Tableau</a> 都提供了很多可视化方面的工具。下面将会介绍一些最常见的可视化创新解决方案。</p>\n<h4 id=\"折线图\"><a href=\"#折线图\" class=\"headerlink\" title=\"折线图\"></a>折线图</h4><p>折线图可能是最常见的可视化方式了，它可以让用户很直观地按照时间维度了解系统的情况。系统中每个单一或聚合的指标都会以一条折线在图表中体现。但当同一个图表中同时存在多条折线时，就可能会对阅读有所影响（如下图所示），所以大多数情况下都可以选择仅查看其中的少数几条折线，而不是让所有折线同时显示。如果某个指标的数值产生了大于正常范围的波动，就会很容易发现。例如下图中异常的紫线、黄线、浅蓝线。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart.png\" alt=\"\"></p>\n<p>折线图的另一个用法是可以将多条折线堆叠起来以显示它们之间的关系。例如对于通过折线图反映服务器的请求数量，可以单独看到每台服务器上的请求，也可以聚合在一起看。这就可以在同一个图表中灵活查看整个系统以及每个实例的情况了。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_line_chart_aggregate.png\" alt=\"\"></p>\n<h4 id=\"热力图\"><a href=\"#热力图\" class=\"headerlink\" title=\"热力图\"></a>热力图</h4><p>另一种常见的可视化方式是热力图。热力图与条形图比较类似，还可以在条形图的基础上显示某部分在整体中占比的变化情况。例如在查看网络请求延时的时候，就可以使用热力图快速查看到所有网络请求的总体趋势和分布情况，另外，它可以使用不同颜色来表示不同部分的数值。</p>\n<p>在以下这个热力图中，通过竖直方向上每个时间段的色块数量分布，可以清楚地看到大部分数据集中在整个范围的中心位置。我们还可以发现，大多数时间段的色块分布都是比较宽松的，而 14:00 到 15:00 这一段则分布得很密集，这样的分布有可能意味着一种不健康的状态。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_histogram.png\" alt=\"\"></p>\n<h4 id=\"仪表图\"><a href=\"#仪表图\" class=\"headerlink\" title=\"仪表图\"></a>仪表图</h4><p>还有一种常见的可视化方式是仪表图，用户可以通过仪表图快速了解单个指标。仪表一般用于单个指标的显示，例如车速表代表汽车的行驶速度、油量表代表油箱中的汽油量等等。大多数的仪表图都有一个共通点，就是会划分出所示指标的对应状态。如下图所示，绿色表示正常的状态，橙色表示不良的状态，而红色则表示极差的状态。下图中间一行模拟了真实仪表的显示情况。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_gauges.png\" alt=\"\"></p>\n<p>上面图表中，除了常规仪表样式的显示方式之外，还有较为直接的数据显示方式，配合相同的配色方案，一眼就可以看出各个指标所处的状态，这一点与和仪表的特点类似。所以，最下面一行可能是仪表图的最佳显示方式，用户不需要仔细阅读，就可以大致了解各个指标的不同状态。这种类型的可视化是我最常用的类型，在数秒钟之间，我就可以全面地总览系统各方面地运行情况。</p>\n<h4 id=\"火焰图\"><a href=\"#火焰图\" class=\"headerlink\" title=\"火焰图\"></a>火焰图</h4><p>由 <a href=\"http://www.brendangregg.com/flamegraphs.html\" target=\"_blank\" rel=\"noopener\">Netflix 的 Brendan Gregg</a> 在 2011 年开始使用的火焰图是一种较为少见地可视化方式。它不像仪表图那样可以从图表中快速得到关键信息，通常只会在需要解决某个应用的问题的时候才会用到这种图表。火焰图主要用于 CPU、内存和相关帧方面的表示，X 轴按字母顺序将帧一一列出，而 Y 轴则表示堆栈的深度。图中每个矩形都是一个标明了调用的函数的堆栈帧。矩形越宽，就表示它在堆栈中出现越频繁。在分析系统性能问题的时候，火焰图能够起到很大的作用，大家不妨尝试一下。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/monitoring_guide_flame_graph_0.png\" alt=\"\"></p>\n<h3 id=\"工具的选择\"><a href=\"#工具的选择\" class=\"headerlink\" title=\"工具的选择\"></a>工具的选择</h3><p>在告警工具方面，有几个商用的工具相当不错。但由于这是一篇介绍开源技术的文章，我只会介绍那些已经被广泛使用的免费工具。希望你也能够为这些工具贡献你自己的代码，让它们更加完善。</p>\n<h3 id=\"告警工具\"><a href=\"#告警工具\" class=\"headerlink\" title=\"告警工具\"></a>告警工具</h3><h4 id=\"Bosun\"><a href=\"#Bosun\" class=\"headerlink\" title=\"Bosun\"></a>Bosun</h4><p>如果你的电脑出现问题，得多亏 Stack Exchange 你才能在网上查到解决办法。Stack Exchange 以众包问答的模式运营着很多不同类型的网站。其中就有广受开发者欢迎的 <a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a>，以及运维方面有名的 <a href=\"https://superuser.com/\" target=\"_blank\" rel=\"noopener\">Super User</a>。除此以外，从育儿经验到科幻小说、从哲学讨论到单车论坛，Stack Exchange 都有涉猎。</p>\n<p>Stack Exchange 开源了它的告警管理系统 <a href=\"http://bosun.org/\" target=\"_blank\" rel=\"noopener\">Bosun</a>，同时也发布了 Prometheus 及其 <a href=\"https://prometheus.io/docs/alerting/alertmanager/\" target=\"_blank\" rel=\"noopener\">AlertManager</a> 系统。这两个系统有共通点。Bosun 和 Prometheus 一样使用 Golang 开发，但 Bosun 比 Prometheus 更为强大，因为它可以使用<ruby>指标聚合<rt>metrics aggregation</rt></ruby>以外的方式与系统交互。Bosun 还可以从日志和事件收集系统中提取数据，并且支持 Graphite、InfluxDB、OpenTSDB 和 Elasticsearch。</p>\n<p>Bosun 的架构包括一个单一的服务器的二进制文件，一个诸如 OpenTSDB 的后端、Redis 以及 <a href=\"https://bosun.org/scollector/\" target=\"_blank\" rel=\"noopener\">scollector 代理</a>。 scollector 代理会自动检测主机上正在运行的服务，并反馈这些进程和其它的系统资源的情况。这些数据将发送到后端。随后 Bosun 的二进制服务文件会向后端发起查询，确定是否需要触发告警。也可以通过 <a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">Grafana</a> 这些工具通过一个通用接口查询 Bosun 的底层后端。而 Redis 则用于存储 Bosun 的状态信息和元数据。</p>\n<p>Bosun 有一个非常巧妙的功能，就是可以根据历史数据来测试告警。这是我几年前在使用 Prometheus 的时候就非常需要的功能，当时我有一个异常的数据需要产生告警，但没有一个可以用于测试的简便方法。为了确保告警能够正常触发，我不得不造出对应的数据来进行测试。而 Bosun 让这个步骤的耗时大大缩短。</p>\n<p>Bosun 更是涵盖了所有常用过的功能，包括简单的图形化表示和告警的创建。它还带有强大的用于编写告警规则的表达式语言。但 Bosun 默认只带有电子邮件通知配置和 HTTP 通知配置，因此如果需要连接到 Slack 或其它工具，就需要对配置作出更大程度的定制化（<a href=\"https://bosun.org/notifications\" target=\"_blank\" rel=\"noopener\">其文档中有</a>）。类似于 Prometheus，Bosun 还可以使用模板通知，你可以使用 HTML 和 CSS 来创建你所需要的电子邮件通知。</p>\n<h4 id=\"Cabot\"><a href=\"#Cabot\" class=\"headerlink\" title=\"Cabot\"></a>Cabot</h4><p><a href=\"https://cabotapp.com/\" target=\"_blank\" rel=\"noopener\">Cabot</a> 由 <a href=\"https://www.arachnys.com/\" target=\"_blank\" rel=\"noopener\">Arachnys</a> 公司开发。你或许对 Arachnys 公司并不了解，但它很有影响力：Arachnys 公司构建了一个基于云的先进解决方案，用于防范金融犯罪。在之前的公司时，我也曾经参与过类似“<a href=\"https://en.wikipedia.org/wiki/Know_your_customer\" target=\"_blank\" rel=\"noopener\">了解你的客户</a>（KYC）”的工作。大多数公司都认为与恐怖组织产生联系会造成相当不好的影响，因为恐怖组织可能会利用自己的系统来筹集资金。而这些解决方案将有助于防范欺诈类犯罪，尽管这类犯罪情节相对较轻，但仍然也会对机构产生风险。</p>\n<p>Arachnys 公司为什么要开发 Cabot 呢？其实只是因为 Arachnys 的开发人员对 <a href=\"https://www.nagios.org/\" target=\"_blank\" rel=\"noopener\">Nagios</a> 不太熟悉。Cabot 的出现对很多人来说都是一个好消息，它基于 Django 和 Bootstrap 开发，因此如果想对这个项目做出自己的贡献，门槛并不高。（另外值得一提的是，Cabot 这个名字来源于开发者的狗。）</p>\n<p>与 Bosun 类似，Cabot 也不对数据进行收集，而是使用监控对象的 API 提供的数据。因此，Cabot 告警的模式是拉取而不是推送。它通过访问每个监控对象的 API，根据特定的指标检索所需的数据，然后将告警数据使用 Redis 缓存，进而持久化存储到 Postgres 数据库。</p>\n<p>Cabot 的一个较为少见的特点是，它原生支持 <a href=\"https://graphiteapp.org/\" target=\"_blank\" rel=\"noopener\">Graphite</a>，同时也支持 <a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>。Jenkins 在这里被视为一个集中式的定时任务，它会以对待故障的方式去对待构建失败的状况。构建失败当然没有系统故障那么紧急，但一旦出现构建失败，还是需要团队采取措施去处理，毕竟并不是每个人在收到构建失败的电子邮件时都会亲自去检查 Jenkins。</p>\n<p>Cabot 另一个有趣的功能是它可以接入 Google 日历安排值班人员，这个称为 Rota 的功能用处很大，希望其它告警系统也能加入类似的功能。Cabot 目前仅支持安排主备联系人，但还有继续改进的空间。它自己的文档也提到，如果需要全面的功能，更应该考虑付费的解决方案。</p>\n<h4 id=\"StatsAgg\"><a href=\"#StatsAgg\" class=\"headerlink\" title=\"StatsAgg\"></a>StatsAgg</h4><p><a href=\"https://www.pearson.com/us/\" target=\"_blank\" rel=\"noopener\">Pearson</a> 作为一家开发了 <a href=\"https://github.com/PearsonEducation/StatsAgg\" target=\"_blank\" rel=\"noopener\">StatsAgg</a> 告警平台的出版公司，这是极为罕见的，当然也很值得敬佩。除此以外，Pearson 还运营着另外几个网站以及和 <a href=\"https://www.oreilly.com/\" target=\"_blank\" rel=\"noopener\">O’Reilly Media</a> 合资的企业。但我仍然会将它视为出版教学书籍的公司。</p>\n<p>StatsAgg 除了是一个告警平台，还是一个指标聚合平台，甚至也有点类似其它系统的代理。StatsAgg 支持通过 Graphite、StatsD、InfluxDB 和 OpenTSDB 输入数据，也支持将其转发到各种平台。但随着中心服务的负载不断增加，风险也不断增大。尽管如此，如果 StatsAgg 的基础架构足够强壮，即使后端存储平台出现故障，也不会对它产生告警的过程造成影响。</p>\n<p>StatsAgg 是用 Java 开发的，为了尽可能降低复杂性，它仅包括主服务和一个 UI。StatsAgg 支持基于正则表达式匹配来发送告警，而且它更注重于服务方面的告警，而不是服务器基础告警。我认为它填补了开源监控工具方面的空白，而这正式它自己的目标。</p>\n<h3 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h3><h4 id=\"Grafana\"><a href=\"#Grafana\" class=\"headerlink\" title=\"Grafana\"></a>Grafana</h4><p><a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">Grafana</a> 的知名度很高，它也被广泛采用。每当我需要用到数据面板的时候，我总是会想到它，因为它比我使用过的任何一款类似的产品都要好。Grafana 由 Torkel Ödegaard 开发的，像 Cabot 一样，也是在圣诞节期间开发的，并在 2014 年 1 月发布。在短短几年之间，它已经有了长足的发展。Grafana 基于 Kibana 开发，Torkel 开启了新的分支并将其命名为 Grafana。</p>\n<p>Grafana 着重体现了实用性以及数据呈现的美观性。它天生就可以从 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 收集数据。此外有一个 Grafana 商用版插件可以从更多数据源获取数据，但是其他数据源插件也并非没有开源版本，Grafana 的插件生态系统已经提供了各种数据源。</p>\n<p>Grafana 能做什么呢？Grafana 提供了一个中心化的了解系统的方式。它通过 web 来展示数据，任何人都有机会访问到相关信息，当然也可以使用身份验证来对访问进行限制。Grafana 使用各种可视化方式来提供对系统一目了然的了解。Grafana 还支持不同类型的可视化方式，包括集成告警可视化的功能。</p>\n<p>现在你可以更直观地设置告警了。通过 Grafana，可以查看图表，还可以查看由于系统性能下降而触发告警的位置，单击要触发报警的位置，并告诉 Grafana 将告警发送何处。这是一个对告警平台非常强大的补充。告警平台不一定会因此而被取代，但告警系统一定会由此得到更多启发和发展。</p>\n<p>Grafana 还引入了很多团队协作的功能。不同用户之间能够共享数据面板，你不再需要为 <a href=\"https://opensource.com/resources/what-is-kubernetes\" target=\"_blank\" rel=\"noopener\">Kubernetes</a> 集群创建独立的数据面板，因为由 Kubernetes 开发者和 Grafana 开发者共同维护的一些数据面板已经可用了。</p>\n<p>团队协作过程中一个重要的功能是注释。注释功能允许用户将上下文添加到图表当中，其他用户就可以通过上下文更直观地理解图表。当团队成员在处理某个事件，并且需要沟通和理解时，这个功能就十分重要了。将所有相关信息都放在需要的位置，可以让整个团队中快速达成共识。在团队需要调查故障原因和定位事件责任时，这个功能就可以发挥作用了。</p>\n<h4 id=\"Vizceral\"><a href=\"#Vizceral\" class=\"headerlink\" title=\"Vizceral\"></a>Vizceral</h4><p><a href=\"https://github.com/Netflix/vizceral\" target=\"_blank\" rel=\"noopener\">Vizceral</a> 由 Netflix 开发，用于在故障发生时更有效地了解流量的情况。Grafana 是一种通用性更强的工具，而 Vizceral 则专用于某些领域。 尽管 Netflix 表示已经不再在内部使用 Vizceral，也不再主动对其展开维护，但 Vizceral 仍然会定期更新。我在这里介绍这个工具，主要是为了介绍它的的可视化机制，以及如何利用它来协助解决问题。你可以在样例环境中用它来更好地掌握这一类系统的特性。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/alerting-and-visualization-tools-sysadmins</a></p>\n"},{"title":"正确选择开源数据库的 5 个技巧","date":"2018-11-01T15:21:16.000Z","_content":"\n> 对关键应用的选择不容许丝毫错误。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/server_data_system_admin.png?itok=q6HCfNQ8)\n\n你或许会遇到需要选择合适的开源数据库的情况。但这无论对于开源方面的老手或是新手，都是一项艰巨的任务。\n\n在过去的几年中，采用开源技术的企业越来越多。面对这样的趋势，众多开源应用公司都纷纷承诺自己提供的解决方案能够各种问题、适应各种负载。但这些承诺不能轻信，在开源应用上的选择是重要而艰难的，尤其是数据库这种关键的应用。\n\n凭借我在 [Percona][1] 和其它公司担任 IT 专家的经验，我很幸运能够指导其他人在开源技术的选择上做出正确的决策，因为需要考虑的重要因素太多了。希望通过这篇文章能够向大家分享这方面的一些技巧。\n\n### 有一个明确的目标\n\n这一点看似简单，但在和很多人聊过 MySQL、MongoDB、PostgreSQL 之后，我觉得这一点才是最重要的。\n\n面对繁杂的开源数据库，更需要明确自己的目标。无论这个数据库是作为开发用的标准化数据库后端，抑或是用于替换遗留代码中的原有数据库，这都是一个明确的目标。\n\n目标一旦确定，就可以集中精力与开源软件的提供方商讨更多细节了。\n\n### 了解你的工作负载\n\n尽管开源数据库技术的功能越来越丰富，但这些新加入的功能都不太具有普适性。譬如 MongoDB 新增了事务的支持、MySQL 新增了 JSON 存储的功能等等。目前开源数据库的普遍趋势是不断加入新的功能，但很多人的误区却在于没有选择最适合的工具来完成自己的工作 —— 这样的人或许是一个自大的开发者，又或许是一个视野狭窄的主管 —— 最终导致公司业务上的损失。最致命的是，在业务初期，使用了不适合的工具往往也可以顺利地完成任务，但随着业务的增长，很快就会到达瓶颈，尽管这个时候还可以替换更合适的工具，但成本就比较高了。\n\n例如，如果你需要的是数据分析仓库，关系数据库可能不是一个适合的选择；如果你处理事务的应用要求严格的数据完整性和一致性，就不要考虑 NoSQL 了。\n\n### 不要重新发明轮子\n\n在过去的数十年，开源数据库技术迅速发展壮大。开源数据库从新生，到受到质疑，再到受到认可，现在已经成为很多企业生产环境的数据库。企业不再需要担心选择开源数据库技术会产生风险，因为开源数据库通常都有活跃的社区，可以为越来越多的初创公司、中型企业甚至 500 强公司提供开源数据库领域的支持和第三方工具。\n\nBattery Ventures 是一家专注于技术的投资公司，最近推出了一个用于跟踪最受欢迎开源项目的 [BOSS 指数][2] 。它提供了对一些被广泛采用的开源项目和活跃的开源项目的详细情况。其中，数据库技术毫无悬念地占据了榜单的主导地位，在前十位之中占了一半。这个 BOSS 指数对于刚接触开源数据库领域的人来说，这是一个很好的切入点。当然，开源技术的提供者也会针对很多常见的典型问题给出对应的解决方案。\n\n我认为，你想要做的事情很可能已经有人解决过了。即使这些先行者的解决方案不一定完全契合你的需求，但也可以从他们成功或失败的案例中根据你自己的需求修改得出合适的解决方案。\n\n如果你采用了一个最前沿的技术，这就是你探索的好机会了。如果你的工作负载刚好适合新的开源数据库技术，放胆去尝试吧。第一个吃螃蟹的人总是会得到意外的挑战和收获。\n\n### 先从简单开始\n\n你的数据库实际上需要达到多少个 [9][4] 的可用性？对许多公司来说，“实现高可用性”仅仅只是一个模糊的目标。当然，最常见的答案都会是“它是关键应用，我们无论多短的停机时间都是无法忍受的”。\n\n数据库环境越复杂，管理的难度就越大，成本也会越高。理论上你总可以将数据库的可用性提得更高，但代价将会是大大增加的管理难度和性能下降。所以，先从简单开始，直到有需要时再逐步扩展。\n\n例如，Booking.com 是一个有名的旅游预订网站。但少有人知的是，它使用 MySQL 作为数据库后端。 Booking.com 高级系统架构师 Nicolai Plum 曾经发表过一次[演讲][5]，讲述了他们公司使用 MySQL 数据库的历程。其中一个重点就是，在初始阶段数据库可以被配置得很简单，然后逐渐变得复杂。对于早期的数据库需求，一个简单的主从架构就足够了，但随着工作负载和数据量的增加，数据库引入了负载均衡、多个读取副本，还使用 Hadoop 进行分析。尽管如此，早期的架构仍然是非常简单的。\n\n![](https://opensource.com/sites/default/files/uploads/internet_app_barrett_chambers.png)\n\n### 有疑问，找专家\n\n如果你仍然不确定数据库选择的是否合适，可以在论坛、网站或者与软件的提供者处商讨。研究各种开源数据库是否满足自己的需求是一件很有意义的事，因为总会发现你从不知道的技术。而开源社区就是分享这些信息的地方。\n\n当你接触到开源软件和软件提供者时，有一件重要的事情需要注意。很多公司都有开放的核心业务模式，鼓励采用他们的数据库软件。你可以只接受他们的部分建议和指导，然后用你自己的能力去研究和探索替代方案。\n\n### 总结\n\n选择正确的开源数据库是一个重要的过程。很多时候，人们都会在真正理解需求之前就做出决定，这是本末倒置的。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/tips-choosing-right-open-source-database\n\n[a]: https://opensource.com/users/barrettc\n[b]: https://github.com/lujun9972\n[1]: https://www.percona.com/\n[2]: https://techcrunch.com/2017/04/07/tracking-the-explosive-growth-of-open-source-software/\n[3]: https://docs.aws.amazon.com/quickstart/latest/mongodb/welcome.html\n[4]: https://en.wikipedia.org/wiki/Five_nines\n[5]: https://www.percona.com/live/mysql-conference-2015/sessions/bookingcom-evolution-mysql-system-design\n[6]: https://allthingsopen.org/talk/choosing-the-right-open-source-database/\n[7]: https://allthingsopen.org/\n\n","source":"_posts/5-tips-for-choosing-the-right-open-source-database.md","raw":"---\ntitle: 正确选择开源数据库的 5 个技巧\ndate: 2018-11-01 23:21:16\ntags:\n  - 数据库\n  - LCTT 翻译\n---\n\n> 对关键应用的选择不容许丝毫错误。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/server_data_system_admin.png?itok=q6HCfNQ8)\n\n你或许会遇到需要选择合适的开源数据库的情况。但这无论对于开源方面的老手或是新手，都是一项艰巨的任务。\n\n在过去的几年中，采用开源技术的企业越来越多。面对这样的趋势，众多开源应用公司都纷纷承诺自己提供的解决方案能够各种问题、适应各种负载。但这些承诺不能轻信，在开源应用上的选择是重要而艰难的，尤其是数据库这种关键的应用。\n\n凭借我在 [Percona][1] 和其它公司担任 IT 专家的经验，我很幸运能够指导其他人在开源技术的选择上做出正确的决策，因为需要考虑的重要因素太多了。希望通过这篇文章能够向大家分享这方面的一些技巧。\n\n### 有一个明确的目标\n\n这一点看似简单，但在和很多人聊过 MySQL、MongoDB、PostgreSQL 之后，我觉得这一点才是最重要的。\n\n面对繁杂的开源数据库，更需要明确自己的目标。无论这个数据库是作为开发用的标准化数据库后端，抑或是用于替换遗留代码中的原有数据库，这都是一个明确的目标。\n\n目标一旦确定，就可以集中精力与开源软件的提供方商讨更多细节了。\n\n### 了解你的工作负载\n\n尽管开源数据库技术的功能越来越丰富，但这些新加入的功能都不太具有普适性。譬如 MongoDB 新增了事务的支持、MySQL 新增了 JSON 存储的功能等等。目前开源数据库的普遍趋势是不断加入新的功能，但很多人的误区却在于没有选择最适合的工具来完成自己的工作 —— 这样的人或许是一个自大的开发者，又或许是一个视野狭窄的主管 —— 最终导致公司业务上的损失。最致命的是，在业务初期，使用了不适合的工具往往也可以顺利地完成任务，但随着业务的增长，很快就会到达瓶颈，尽管这个时候还可以替换更合适的工具，但成本就比较高了。\n\n例如，如果你需要的是数据分析仓库，关系数据库可能不是一个适合的选择；如果你处理事务的应用要求严格的数据完整性和一致性，就不要考虑 NoSQL 了。\n\n### 不要重新发明轮子\n\n在过去的数十年，开源数据库技术迅速发展壮大。开源数据库从新生，到受到质疑，再到受到认可，现在已经成为很多企业生产环境的数据库。企业不再需要担心选择开源数据库技术会产生风险，因为开源数据库通常都有活跃的社区，可以为越来越多的初创公司、中型企业甚至 500 强公司提供开源数据库领域的支持和第三方工具。\n\nBattery Ventures 是一家专注于技术的投资公司，最近推出了一个用于跟踪最受欢迎开源项目的 [BOSS 指数][2] 。它提供了对一些被广泛采用的开源项目和活跃的开源项目的详细情况。其中，数据库技术毫无悬念地占据了榜单的主导地位，在前十位之中占了一半。这个 BOSS 指数对于刚接触开源数据库领域的人来说，这是一个很好的切入点。当然，开源技术的提供者也会针对很多常见的典型问题给出对应的解决方案。\n\n我认为，你想要做的事情很可能已经有人解决过了。即使这些先行者的解决方案不一定完全契合你的需求，但也可以从他们成功或失败的案例中根据你自己的需求修改得出合适的解决方案。\n\n如果你采用了一个最前沿的技术，这就是你探索的好机会了。如果你的工作负载刚好适合新的开源数据库技术，放胆去尝试吧。第一个吃螃蟹的人总是会得到意外的挑战和收获。\n\n### 先从简单开始\n\n你的数据库实际上需要达到多少个 [9][4] 的可用性？对许多公司来说，“实现高可用性”仅仅只是一个模糊的目标。当然，最常见的答案都会是“它是关键应用，我们无论多短的停机时间都是无法忍受的”。\n\n数据库环境越复杂，管理的难度就越大，成本也会越高。理论上你总可以将数据库的可用性提得更高，但代价将会是大大增加的管理难度和性能下降。所以，先从简单开始，直到有需要时再逐步扩展。\n\n例如，Booking.com 是一个有名的旅游预订网站。但少有人知的是，它使用 MySQL 作为数据库后端。 Booking.com 高级系统架构师 Nicolai Plum 曾经发表过一次[演讲][5]，讲述了他们公司使用 MySQL 数据库的历程。其中一个重点就是，在初始阶段数据库可以被配置得很简单，然后逐渐变得复杂。对于早期的数据库需求，一个简单的主从架构就足够了，但随着工作负载和数据量的增加，数据库引入了负载均衡、多个读取副本，还使用 Hadoop 进行分析。尽管如此，早期的架构仍然是非常简单的。\n\n![](https://opensource.com/sites/default/files/uploads/internet_app_barrett_chambers.png)\n\n### 有疑问，找专家\n\n如果你仍然不确定数据库选择的是否合适，可以在论坛、网站或者与软件的提供者处商讨。研究各种开源数据库是否满足自己的需求是一件很有意义的事，因为总会发现你从不知道的技术。而开源社区就是分享这些信息的地方。\n\n当你接触到开源软件和软件提供者时，有一件重要的事情需要注意。很多公司都有开放的核心业务模式，鼓励采用他们的数据库软件。你可以只接受他们的部分建议和指导，然后用你自己的能力去研究和探索替代方案。\n\n### 总结\n\n选择正确的开源数据库是一个重要的过程。很多时候，人们都会在真正理解需求之前就做出决定，这是本末倒置的。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/tips-choosing-right-open-source-database\n\n[a]: https://opensource.com/users/barrettc\n[b]: https://github.com/lujun9972\n[1]: https://www.percona.com/\n[2]: https://techcrunch.com/2017/04/07/tracking-the-explosive-growth-of-open-source-software/\n[3]: https://docs.aws.amazon.com/quickstart/latest/mongodb/welcome.html\n[4]: https://en.wikipedia.org/wiki/Five_nines\n[5]: https://www.percona.com/live/mysql-conference-2015/sessions/bookingcom-evolution-mysql-system-design\n[6]: https://allthingsopen.org/talk/choosing-the-right-open-source-database/\n[7]: https://allthingsopen.org/\n\n","slug":"5-tips-for-choosing-the-right-open-source-database","published":1,"updated":"2019-03-28T12:24:51.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0c1000alixuh7xywqzm","content":"<blockquote>\n<p>对关键应用的选择不容许丝毫错误。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/server_data_system_admin.png?itok=q6HCfNQ8\" alt=\"\"></p>\n<p>你或许会遇到需要选择合适的开源数据库的情况。但这无论对于开源方面的老手或是新手，都是一项艰巨的任务。</p>\n<p>在过去的几年中，采用开源技术的企业越来越多。面对这样的趋势，众多开源应用公司都纷纷承诺自己提供的解决方案能够各种问题、适应各种负载。但这些承诺不能轻信，在开源应用上的选择是重要而艰难的，尤其是数据库这种关键的应用。</p>\n<p>凭借我在 <a href=\"https://www.percona.com/\" target=\"_blank\" rel=\"noopener\">Percona</a> 和其它公司担任 IT 专家的经验，我很幸运能够指导其他人在开源技术的选择上做出正确的决策，因为需要考虑的重要因素太多了。希望通过这篇文章能够向大家分享这方面的一些技巧。</p>\n<h3 id=\"有一个明确的目标\"><a href=\"#有一个明确的目标\" class=\"headerlink\" title=\"有一个明确的目标\"></a>有一个明确的目标</h3><p>这一点看似简单，但在和很多人聊过 MySQL、MongoDB、PostgreSQL 之后，我觉得这一点才是最重要的。</p>\n<p>面对繁杂的开源数据库，更需要明确自己的目标。无论这个数据库是作为开发用的标准化数据库后端，抑或是用于替换遗留代码中的原有数据库，这都是一个明确的目标。</p>\n<p>目标一旦确定，就可以集中精力与开源软件的提供方商讨更多细节了。</p>\n<h3 id=\"了解你的工作负载\"><a href=\"#了解你的工作负载\" class=\"headerlink\" title=\"了解你的工作负载\"></a>了解你的工作负载</h3><p>尽管开源数据库技术的功能越来越丰富，但这些新加入的功能都不太具有普适性。譬如 MongoDB 新增了事务的支持、MySQL 新增了 JSON 存储的功能等等。目前开源数据库的普遍趋势是不断加入新的功能，但很多人的误区却在于没有选择最适合的工具来完成自己的工作 —— 这样的人或许是一个自大的开发者，又或许是一个视野狭窄的主管 —— 最终导致公司业务上的损失。最致命的是，在业务初期，使用了不适合的工具往往也可以顺利地完成任务，但随着业务的增长，很快就会到达瓶颈，尽管这个时候还可以替换更合适的工具，但成本就比较高了。</p>\n<p>例如，如果你需要的是数据分析仓库，关系数据库可能不是一个适合的选择；如果你处理事务的应用要求严格的数据完整性和一致性，就不要考虑 NoSQL 了。</p>\n<h3 id=\"不要重新发明轮子\"><a href=\"#不要重新发明轮子\" class=\"headerlink\" title=\"不要重新发明轮子\"></a>不要重新发明轮子</h3><p>在过去的数十年，开源数据库技术迅速发展壮大。开源数据库从新生，到受到质疑，再到受到认可，现在已经成为很多企业生产环境的数据库。企业不再需要担心选择开源数据库技术会产生风险，因为开源数据库通常都有活跃的社区，可以为越来越多的初创公司、中型企业甚至 500 强公司提供开源数据库领域的支持和第三方工具。</p>\n<p>Battery Ventures 是一家专注于技术的投资公司，最近推出了一个用于跟踪最受欢迎开源项目的 <a href=\"https://techcrunch.com/2017/04/07/tracking-the-explosive-growth-of-open-source-software/\" target=\"_blank\" rel=\"noopener\">BOSS 指数</a> 。它提供了对一些被广泛采用的开源项目和活跃的开源项目的详细情况。其中，数据库技术毫无悬念地占据了榜单的主导地位，在前十位之中占了一半。这个 BOSS 指数对于刚接触开源数据库领域的人来说，这是一个很好的切入点。当然，开源技术的提供者也会针对很多常见的典型问题给出对应的解决方案。</p>\n<p>我认为，你想要做的事情很可能已经有人解决过了。即使这些先行者的解决方案不一定完全契合你的需求，但也可以从他们成功或失败的案例中根据你自己的需求修改得出合适的解决方案。</p>\n<p>如果你采用了一个最前沿的技术，这就是你探索的好机会了。如果你的工作负载刚好适合新的开源数据库技术，放胆去尝试吧。第一个吃螃蟹的人总是会得到意外的挑战和收获。</p>\n<h3 id=\"先从简单开始\"><a href=\"#先从简单开始\" class=\"headerlink\" title=\"先从简单开始\"></a>先从简单开始</h3><p>你的数据库实际上需要达到多少个 <a href=\"https://en.wikipedia.org/wiki/Five_nines\" target=\"_blank\" rel=\"noopener\">9</a> 的可用性？对许多公司来说，“实现高可用性”仅仅只是一个模糊的目标。当然，最常见的答案都会是“它是关键应用，我们无论多短的停机时间都是无法忍受的”。</p>\n<p>数据库环境越复杂，管理的难度就越大，成本也会越高。理论上你总可以将数据库的可用性提得更高，但代价将会是大大增加的管理难度和性能下降。所以，先从简单开始，直到有需要时再逐步扩展。</p>\n<p>例如，Booking.com 是一个有名的旅游预订网站。但少有人知的是，它使用 MySQL 作为数据库后端。 Booking.com 高级系统架构师 Nicolai Plum 曾经发表过一次<a href=\"https://www.percona.com/live/mysql-conference-2015/sessions/bookingcom-evolution-mysql-system-design\" target=\"_blank\" rel=\"noopener\">演讲</a>，讲述了他们公司使用 MySQL 数据库的历程。其中一个重点就是，在初始阶段数据库可以被配置得很简单，然后逐渐变得复杂。对于早期的数据库需求，一个简单的主从架构就足够了，但随着工作负载和数据量的增加，数据库引入了负载均衡、多个读取副本，还使用 Hadoop 进行分析。尽管如此，早期的架构仍然是非常简单的。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/internet_app_barrett_chambers.png\" alt=\"\"></p>\n<h3 id=\"有疑问，找专家\"><a href=\"#有疑问，找专家\" class=\"headerlink\" title=\"有疑问，找专家\"></a>有疑问，找专家</h3><p>如果你仍然不确定数据库选择的是否合适，可以在论坛、网站或者与软件的提供者处商讨。研究各种开源数据库是否满足自己的需求是一件很有意义的事，因为总会发现你从不知道的技术。而开源社区就是分享这些信息的地方。</p>\n<p>当你接触到开源软件和软件提供者时，有一件重要的事情需要注意。很多公司都有开放的核心业务模式，鼓励采用他们的数据库软件。你可以只接受他们的部分建议和指导，然后用你自己的能力去研究和探索替代方案。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>选择正确的开源数据库是一个重要的过程。很多时候，人们都会在真正理解需求之前就做出决定，这是本末倒置的。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/tips-choosing-right-open-source-database\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/tips-choosing-right-open-source-database</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>对关键应用的选择不容许丝毫错误。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/server_data_system_admin.png?itok=q6HCfNQ8\" alt=\"\"></p>\n<p>你或许会遇到需要选择合适的开源数据库的情况。但这无论对于开源方面的老手或是新手，都是一项艰巨的任务。</p>\n<p>在过去的几年中，采用开源技术的企业越来越多。面对这样的趋势，众多开源应用公司都纷纷承诺自己提供的解决方案能够各种问题、适应各种负载。但这些承诺不能轻信，在开源应用上的选择是重要而艰难的，尤其是数据库这种关键的应用。</p>\n<p>凭借我在 <a href=\"https://www.percona.com/\" target=\"_blank\" rel=\"noopener\">Percona</a> 和其它公司担任 IT 专家的经验，我很幸运能够指导其他人在开源技术的选择上做出正确的决策，因为需要考虑的重要因素太多了。希望通过这篇文章能够向大家分享这方面的一些技巧。</p>\n<h3 id=\"有一个明确的目标\"><a href=\"#有一个明确的目标\" class=\"headerlink\" title=\"有一个明确的目标\"></a>有一个明确的目标</h3><p>这一点看似简单，但在和很多人聊过 MySQL、MongoDB、PostgreSQL 之后，我觉得这一点才是最重要的。</p>\n<p>面对繁杂的开源数据库，更需要明确自己的目标。无论这个数据库是作为开发用的标准化数据库后端，抑或是用于替换遗留代码中的原有数据库，这都是一个明确的目标。</p>\n<p>目标一旦确定，就可以集中精力与开源软件的提供方商讨更多细节了。</p>\n<h3 id=\"了解你的工作负载\"><a href=\"#了解你的工作负载\" class=\"headerlink\" title=\"了解你的工作负载\"></a>了解你的工作负载</h3><p>尽管开源数据库技术的功能越来越丰富，但这些新加入的功能都不太具有普适性。譬如 MongoDB 新增了事务的支持、MySQL 新增了 JSON 存储的功能等等。目前开源数据库的普遍趋势是不断加入新的功能，但很多人的误区却在于没有选择最适合的工具来完成自己的工作 —— 这样的人或许是一个自大的开发者，又或许是一个视野狭窄的主管 —— 最终导致公司业务上的损失。最致命的是，在业务初期，使用了不适合的工具往往也可以顺利地完成任务，但随着业务的增长，很快就会到达瓶颈，尽管这个时候还可以替换更合适的工具，但成本就比较高了。</p>\n<p>例如，如果你需要的是数据分析仓库，关系数据库可能不是一个适合的选择；如果你处理事务的应用要求严格的数据完整性和一致性，就不要考虑 NoSQL 了。</p>\n<h3 id=\"不要重新发明轮子\"><a href=\"#不要重新发明轮子\" class=\"headerlink\" title=\"不要重新发明轮子\"></a>不要重新发明轮子</h3><p>在过去的数十年，开源数据库技术迅速发展壮大。开源数据库从新生，到受到质疑，再到受到认可，现在已经成为很多企业生产环境的数据库。企业不再需要担心选择开源数据库技术会产生风险，因为开源数据库通常都有活跃的社区，可以为越来越多的初创公司、中型企业甚至 500 强公司提供开源数据库领域的支持和第三方工具。</p>\n<p>Battery Ventures 是一家专注于技术的投资公司，最近推出了一个用于跟踪最受欢迎开源项目的 <a href=\"https://techcrunch.com/2017/04/07/tracking-the-explosive-growth-of-open-source-software/\" target=\"_blank\" rel=\"noopener\">BOSS 指数</a> 。它提供了对一些被广泛采用的开源项目和活跃的开源项目的详细情况。其中，数据库技术毫无悬念地占据了榜单的主导地位，在前十位之中占了一半。这个 BOSS 指数对于刚接触开源数据库领域的人来说，这是一个很好的切入点。当然，开源技术的提供者也会针对很多常见的典型问题给出对应的解决方案。</p>\n<p>我认为，你想要做的事情很可能已经有人解决过了。即使这些先行者的解决方案不一定完全契合你的需求，但也可以从他们成功或失败的案例中根据你自己的需求修改得出合适的解决方案。</p>\n<p>如果你采用了一个最前沿的技术，这就是你探索的好机会了。如果你的工作负载刚好适合新的开源数据库技术，放胆去尝试吧。第一个吃螃蟹的人总是会得到意外的挑战和收获。</p>\n<h3 id=\"先从简单开始\"><a href=\"#先从简单开始\" class=\"headerlink\" title=\"先从简单开始\"></a>先从简单开始</h3><p>你的数据库实际上需要达到多少个 <a href=\"https://en.wikipedia.org/wiki/Five_nines\" target=\"_blank\" rel=\"noopener\">9</a> 的可用性？对许多公司来说，“实现高可用性”仅仅只是一个模糊的目标。当然，最常见的答案都会是“它是关键应用，我们无论多短的停机时间都是无法忍受的”。</p>\n<p>数据库环境越复杂，管理的难度就越大，成本也会越高。理论上你总可以将数据库的可用性提得更高，但代价将会是大大增加的管理难度和性能下降。所以，先从简单开始，直到有需要时再逐步扩展。</p>\n<p>例如，Booking.com 是一个有名的旅游预订网站。但少有人知的是，它使用 MySQL 作为数据库后端。 Booking.com 高级系统架构师 Nicolai Plum 曾经发表过一次<a href=\"https://www.percona.com/live/mysql-conference-2015/sessions/bookingcom-evolution-mysql-system-design\" target=\"_blank\" rel=\"noopener\">演讲</a>，讲述了他们公司使用 MySQL 数据库的历程。其中一个重点就是，在初始阶段数据库可以被配置得很简单，然后逐渐变得复杂。对于早期的数据库需求，一个简单的主从架构就足够了，但随着工作负载和数据量的增加，数据库引入了负载均衡、多个读取副本，还使用 Hadoop 进行分析。尽管如此，早期的架构仍然是非常简单的。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/internet_app_barrett_chambers.png\" alt=\"\"></p>\n<h3 id=\"有疑问，找专家\"><a href=\"#有疑问，找专家\" class=\"headerlink\" title=\"有疑问，找专家\"></a>有疑问，找专家</h3><p>如果你仍然不确定数据库选择的是否合适，可以在论坛、网站或者与软件的提供者处商讨。研究各种开源数据库是否满足自己的需求是一件很有意义的事，因为总会发现你从不知道的技术。而开源社区就是分享这些信息的地方。</p>\n<p>当你接触到开源软件和软件提供者时，有一件重要的事情需要注意。很多公司都有开放的核心业务模式，鼓励采用他们的数据库软件。你可以只接受他们的部分建议和指导，然后用你自己的能力去研究和探索替代方案。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>选择正确的开源数据库是一个重要的过程。很多时候，人们都会在真正理解需求之前就做出决定，这是本末倒置的。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/tips-choosing-right-open-source-database\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/tips-choosing-right-open-source-database</a></p>\n"},{"title":"让 Python 代码更易维护的七种武器","date":"2018-09-29T02:48:27.000Z","_content":"\n> 检查你的代码的质量，通过这些外部库使其更易维护。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming_keyboard_coding.png?itok=E0Vvam7A)\n\n> 可读性很重要。\n>  — <ruby>[Python 之禅][1]<rt>The Zen of Python</rt></ruby>，Tim Peters\n\n随着软件项目进入“维护模式”，对可读性和编码标准的要求很容易落空（甚至从一开始就没有建立过那些标准）。然而，在代码库中保持一致的代码风格和测试标准能够显著减轻维护的压力，也能确保新的开发者能够快速了解项目的情况，同时能更好地全程保持应用程序的质量。\n\n使用外部库来检查代码的质量不失为保护项目未来可维护性的一个好方法。以下会推荐一些我们最喜爱的[检查代码][2]（包括检查 PEP 8 和其它代码风格错误）的库，用它们来强制保持代码风格一致，并确保在项目成熟时有一个可接受的测试覆盖率。\n\n### 检查你的代码风格\n\n[PEP 8][3] 是 Python 代码风格规范，它规定了类似行长度、缩进、多行表达式、变量命名约定等内容。尽管你的团队自身可能也会有稍微不同于 PEP 8 的代码风格规范，但任何代码风格规范的目标都是在代码库中强制实施一致的标准，使代码的可读性更强、更易于维护。下面三个库就可以用来帮助你美化代码。\n\n#### 1、 Pylint\n\n[Pylint][4] 是一个检查违反 PEP 8 规范和常见错误的库。它在一些流行的[编辑器和 IDE][5] 中都有集成，也可以单独从命令行运行。\n\n执行 `pip install pylint` 安装 Pylint 。然后运行 `pylint [options] path/to/dir` 或者 `pylint [options] path/to/module.py` 就可以在命令行中使用 Pylint，它会向控制台输出代码中违反规范和出现错误的地方。\n\n你还可以使用 `pylintrc` [配置文件][6]来自定义 Pylint 对哪些代码错误进行检查。\n\n#### 2、 Flake8\n\n[Flake8][7] 是“将 PEP 8、Pyflakes（类似 Pylint）、McCabe（代码复杂性检查器）和第三方插件整合到一起，以检查 Python 代码风格和质量的一个 Python 工具”。\n\n执行 `pip install flake8` 安装 flake8 ，然后执行 `flake8 [options] path/to/dir` 或者 `flake8 [options] path/to/module.py` 可以查看报出的错误和警告。\n\n和 Pylint 类似，Flake8 允许通过[配置文件][8]来自定义检查的内容。它有非常清晰的文档，包括一些有用的[提交钩子][9]，可以将自动检查代码纳入到开发工作流程之中。\n\nFlake8 也可以集成到一些流行的编辑器和 IDE 当中，但在文档中并没有详细说明。要将 Flake8 集成到喜欢的编辑器或 IDE 中，可以搜索插件（例如 [Sublime Text 的 Flake8 插件][10]）。\n\n#### 3、 Isort\n\n[Isort][11] 这个库能将你在项目中导入的库按字母顺序排序，并将其[正确划分为不同部分][12]（例如标准库、第三方库、自建的库等）。这样提高了代码的可读性，并且可以在导入的库较多的时候轻松找到各个库。\n\n执行 `pip install isort` 安装 isort，然后执行 `isort path/to/module.py` 就可以运行了。[文档][13]中还提供了更多的配置项，例如通过[配置][14] `.isort.cfg` 文件来决定 isort 如何处理一个库的多行导入。\n\n和 Flake8、Pylint 一样，isort 也提供了将其与流行的[编辑器和 IDE][15] 集成的插件。\n\n### 分享你的代码风格\n\n每次文件发生变动之后都用命令行手动检查代码是一件痛苦的事，你可能也不太喜欢通过运行 IDE 中某个插件来实现这个功能。同样地，你的同事可能会用不同的代码检查方式，也许他们的编辑器中也没有那种插件，甚至你自己可能也不会严格检查代码和按照警告来更正代码。总之，你分享出来的代码库将会逐渐地变得混乱且难以阅读。\n\n一个很好的解决方案是使用一个库，自动将代码按照 PEP 8 规范进行格式化。我们推荐的三个库都有不同的自定义级别来控制如何格式化代码。其中有一些设置较为特殊，例如 Pylint 和 Flake8 ，你需要先行测试，看看是否有你无法忍受但又不能修改的默认配置。\n\n#### 4、 Autopep8\n\n[Autopep8][16] 可以自动格式化指定的模块中的代码，包括重新缩进行、修复缩进、删除多余的空格，并重构常见的比较错误（例如布尔值和 `None` 值）。你可以查看文档中完整的[更正列表][17]。\n\n运行 `pip install --upgrade autopep8` 安装 Autopep8。然后执行 `autopep8 --in-place --aggressive --aggressive <filename>` 就可以重新格式化你的代码。`aggressive` 选项的数量表示 Auotopep8 在代码风格控制上有多少控制权。在这里可以详细了解 [aggressive][18] 选项。\n\n#### 5、 Yapf\n\n[Yapf][19] 是另一种有自己的[配置项][20]列表的重新格式化代码的工具。它与 Autopep8 的不同之处在于它不仅会指出代码中违反 PEP 8 规范的地方，还会对没有违反 PEP 8 但代码风格不一致的地方重新格式化，旨在令代码的可读性更强。\n\n执行 `pip install yapf` 安装 Yapf，然后执行 `yapf [options] path/to/dir` 或 `yapf [options] path/to/module.py` 可以对代码重新格式化。[定制选项][20]的完整列表在这里。\n\n#### 6、 Black\n\n[Black][21] 在代码检查工具当中算是比较新的一个。它与 Autopep8 和 Yapf 类似，但限制较多，没有太多的自定义选项。这样的好处是你不需要去决定使用怎么样的代码风格，让 Black 来给你做决定就好。你可以在这里查阅 Black [有限的自定义选项][22]以及[如何在配置文件中对其进行设置][23]。\n\nBlack 依赖于 Python 3.6+，但它可以格式化用 Python 2 编写的代码。执行 `pip install black` 安装 Black，然后执行 `black path/to/dir` 或 `black path/to/module.py` 就可以使用 Black 优化你的代码。\n\n### 检查你的测试覆盖率\n\n如果你正在进行编写测试，你需要确保提交到代码库的新代码都已经测试通过，并且不会降低测试覆盖率。虽然测试覆盖率不是衡量测试有效性和充分性的唯一指标，但它是确保项目遵循基本测试标准的一种方法。对于计算测试覆盖率，我们推荐使用 Coverage 这个库。\n\n#### 7、 Coverage\n\n[Coverage][24] 有数种显示测试覆盖率的方式，包括将结果输出到控制台或 HTML 页面，并指出哪些具体哪些地方没有被覆盖到。你可以通过[配置文件][25]自定义 Coverage 检查的内容，让你更方便使用。\n\n执行 `pip install coverage` 安装 Converage 。然后执行 `coverage [path/to/module.py] [args]` 可以运行程序并查看输出结果。如果要查看哪些代码行没有被覆盖，执行 `coverage report -m` 即可。\n\n### 持续集成工具\n\n<ruby>持续集成<rt>Continuous integration</rt></ruby>（CI）是在合并和部署代码之前自动检查代码风格错误和测试覆盖率最小值的过程。很多免费或付费的工具都可以用于执行这项工作，具体的过程不在本文中赘述，但 CI 过程是令代码更易读和更易维护的重要步骤，关于这一部分可以参考 [Travis CI][26] 和  [Jenkins][27]。\n\n以上这些只是用于检查 Python 代码的各种工具中的其中几个。如果你有其它喜爱的工具，欢迎在评论中分享。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code\n\n[a]:https://opensource.com/users/laceynwilliams\n[1]:https://www.python.org/dev/peps/pep-0020/\n[2]:https://en.wikipedia.org/wiki/Lint_(software)\n[3]:https://www.python.org/dev/peps/pep-0008/\n[4]:https://www.pylint.org/\n[5]:https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html\n[6]:https://pylint.readthedocs.io/en/latest/user_guide/run.html#command-line-options\n[7]:http://flake8.pycqa.org/en/latest/\n[8]:http://flake8.pycqa.org/en/latest/user/configuration.html#configuration-locations\n[9]:http://flake8.pycqa.org/en/latest/user/using-hooks.html\n[10]:https://github.com/SublimeLinter/SublimeLinter-flake8\n[11]:https://github.com/timothycrosley/isort\n[12]:https://github.com/timothycrosley/isort#how-does-isort-work\n[13]:https://github.com/timothycrosley/isort#using-isort\n[14]:https://github.com/timothycrosley/isort#configuring-isort\n[15]:https://github.com/timothycrosley/isort/wiki/isort-Plugins\n[16]:https://github.com/hhatto/autopep8\n[17]:https://github.com/hhatto/autopep8#id4\n[18]:https://github.com/hhatto/autopep8#id5\n[19]:https://github.com/google/yapf\n[20]:https://github.com/google/yapf#usage\n[21]:https://github.com/ambv/black\n[22]:https://github.com/ambv/black#command-line-options\n[23]:https://github.com/ambv/black#pyprojecttoml\n[24]:https://coverage.readthedocs.io/en/latest/\n[25]:https://coverage.readthedocs.io/en/latest/config.html\n[26]:https://travis-ci.org/\n[27]:https://jenkins.io/\n\n","source":"_posts/7-Python-libraries-for-more-maintainable-code.md","raw":"---\ntitle: 让 Python 代码更易维护的七种武器\ndate: 2018-09-29 10:48:27\ntags:\n  - Python\n  - LCTT 翻译\n---\n\n> 检查你的代码的质量，通过这些外部库使其更易维护。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming_keyboard_coding.png?itok=E0Vvam7A)\n\n> 可读性很重要。\n>  — <ruby>[Python 之禅][1]<rt>The Zen of Python</rt></ruby>，Tim Peters\n\n随着软件项目进入“维护模式”，对可读性和编码标准的要求很容易落空（甚至从一开始就没有建立过那些标准）。然而，在代码库中保持一致的代码风格和测试标准能够显著减轻维护的压力，也能确保新的开发者能够快速了解项目的情况，同时能更好地全程保持应用程序的质量。\n\n使用外部库来检查代码的质量不失为保护项目未来可维护性的一个好方法。以下会推荐一些我们最喜爱的[检查代码][2]（包括检查 PEP 8 和其它代码风格错误）的库，用它们来强制保持代码风格一致，并确保在项目成熟时有一个可接受的测试覆盖率。\n\n### 检查你的代码风格\n\n[PEP 8][3] 是 Python 代码风格规范，它规定了类似行长度、缩进、多行表达式、变量命名约定等内容。尽管你的团队自身可能也会有稍微不同于 PEP 8 的代码风格规范，但任何代码风格规范的目标都是在代码库中强制实施一致的标准，使代码的可读性更强、更易于维护。下面三个库就可以用来帮助你美化代码。\n\n#### 1、 Pylint\n\n[Pylint][4] 是一个检查违反 PEP 8 规范和常见错误的库。它在一些流行的[编辑器和 IDE][5] 中都有集成，也可以单独从命令行运行。\n\n执行 `pip install pylint` 安装 Pylint 。然后运行 `pylint [options] path/to/dir` 或者 `pylint [options] path/to/module.py` 就可以在命令行中使用 Pylint，它会向控制台输出代码中违反规范和出现错误的地方。\n\n你还可以使用 `pylintrc` [配置文件][6]来自定义 Pylint 对哪些代码错误进行检查。\n\n#### 2、 Flake8\n\n[Flake8][7] 是“将 PEP 8、Pyflakes（类似 Pylint）、McCabe（代码复杂性检查器）和第三方插件整合到一起，以检查 Python 代码风格和质量的一个 Python 工具”。\n\n执行 `pip install flake8` 安装 flake8 ，然后执行 `flake8 [options] path/to/dir` 或者 `flake8 [options] path/to/module.py` 可以查看报出的错误和警告。\n\n和 Pylint 类似，Flake8 允许通过[配置文件][8]来自定义检查的内容。它有非常清晰的文档，包括一些有用的[提交钩子][9]，可以将自动检查代码纳入到开发工作流程之中。\n\nFlake8 也可以集成到一些流行的编辑器和 IDE 当中，但在文档中并没有详细说明。要将 Flake8 集成到喜欢的编辑器或 IDE 中，可以搜索插件（例如 [Sublime Text 的 Flake8 插件][10]）。\n\n#### 3、 Isort\n\n[Isort][11] 这个库能将你在项目中导入的库按字母顺序排序，并将其[正确划分为不同部分][12]（例如标准库、第三方库、自建的库等）。这样提高了代码的可读性，并且可以在导入的库较多的时候轻松找到各个库。\n\n执行 `pip install isort` 安装 isort，然后执行 `isort path/to/module.py` 就可以运行了。[文档][13]中还提供了更多的配置项，例如通过[配置][14] `.isort.cfg` 文件来决定 isort 如何处理一个库的多行导入。\n\n和 Flake8、Pylint 一样，isort 也提供了将其与流行的[编辑器和 IDE][15] 集成的插件。\n\n### 分享你的代码风格\n\n每次文件发生变动之后都用命令行手动检查代码是一件痛苦的事，你可能也不太喜欢通过运行 IDE 中某个插件来实现这个功能。同样地，你的同事可能会用不同的代码检查方式，也许他们的编辑器中也没有那种插件，甚至你自己可能也不会严格检查代码和按照警告来更正代码。总之，你分享出来的代码库将会逐渐地变得混乱且难以阅读。\n\n一个很好的解决方案是使用一个库，自动将代码按照 PEP 8 规范进行格式化。我们推荐的三个库都有不同的自定义级别来控制如何格式化代码。其中有一些设置较为特殊，例如 Pylint 和 Flake8 ，你需要先行测试，看看是否有你无法忍受但又不能修改的默认配置。\n\n#### 4、 Autopep8\n\n[Autopep8][16] 可以自动格式化指定的模块中的代码，包括重新缩进行、修复缩进、删除多余的空格，并重构常见的比较错误（例如布尔值和 `None` 值）。你可以查看文档中完整的[更正列表][17]。\n\n运行 `pip install --upgrade autopep8` 安装 Autopep8。然后执行 `autopep8 --in-place --aggressive --aggressive <filename>` 就可以重新格式化你的代码。`aggressive` 选项的数量表示 Auotopep8 在代码风格控制上有多少控制权。在这里可以详细了解 [aggressive][18] 选项。\n\n#### 5、 Yapf\n\n[Yapf][19] 是另一种有自己的[配置项][20]列表的重新格式化代码的工具。它与 Autopep8 的不同之处在于它不仅会指出代码中违反 PEP 8 规范的地方，还会对没有违反 PEP 8 但代码风格不一致的地方重新格式化，旨在令代码的可读性更强。\n\n执行 `pip install yapf` 安装 Yapf，然后执行 `yapf [options] path/to/dir` 或 `yapf [options] path/to/module.py` 可以对代码重新格式化。[定制选项][20]的完整列表在这里。\n\n#### 6、 Black\n\n[Black][21] 在代码检查工具当中算是比较新的一个。它与 Autopep8 和 Yapf 类似，但限制较多，没有太多的自定义选项。这样的好处是你不需要去决定使用怎么样的代码风格，让 Black 来给你做决定就好。你可以在这里查阅 Black [有限的自定义选项][22]以及[如何在配置文件中对其进行设置][23]。\n\nBlack 依赖于 Python 3.6+，但它可以格式化用 Python 2 编写的代码。执行 `pip install black` 安装 Black，然后执行 `black path/to/dir` 或 `black path/to/module.py` 就可以使用 Black 优化你的代码。\n\n### 检查你的测试覆盖率\n\n如果你正在进行编写测试，你需要确保提交到代码库的新代码都已经测试通过，并且不会降低测试覆盖率。虽然测试覆盖率不是衡量测试有效性和充分性的唯一指标，但它是确保项目遵循基本测试标准的一种方法。对于计算测试覆盖率，我们推荐使用 Coverage 这个库。\n\n#### 7、 Coverage\n\n[Coverage][24] 有数种显示测试覆盖率的方式，包括将结果输出到控制台或 HTML 页面，并指出哪些具体哪些地方没有被覆盖到。你可以通过[配置文件][25]自定义 Coverage 检查的内容，让你更方便使用。\n\n执行 `pip install coverage` 安装 Converage 。然后执行 `coverage [path/to/module.py] [args]` 可以运行程序并查看输出结果。如果要查看哪些代码行没有被覆盖，执行 `coverage report -m` 即可。\n\n### 持续集成工具\n\n<ruby>持续集成<rt>Continuous integration</rt></ruby>（CI）是在合并和部署代码之前自动检查代码风格错误和测试覆盖率最小值的过程。很多免费或付费的工具都可以用于执行这项工作，具体的过程不在本文中赘述，但 CI 过程是令代码更易读和更易维护的重要步骤，关于这一部分可以参考 [Travis CI][26] 和  [Jenkins][27]。\n\n以上这些只是用于检查 Python 代码的各种工具中的其中几个。如果你有其它喜爱的工具，欢迎在评论中分享。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code\n\n[a]:https://opensource.com/users/laceynwilliams\n[1]:https://www.python.org/dev/peps/pep-0020/\n[2]:https://en.wikipedia.org/wiki/Lint_(software)\n[3]:https://www.python.org/dev/peps/pep-0008/\n[4]:https://www.pylint.org/\n[5]:https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html\n[6]:https://pylint.readthedocs.io/en/latest/user_guide/run.html#command-line-options\n[7]:http://flake8.pycqa.org/en/latest/\n[8]:http://flake8.pycqa.org/en/latest/user/configuration.html#configuration-locations\n[9]:http://flake8.pycqa.org/en/latest/user/using-hooks.html\n[10]:https://github.com/SublimeLinter/SublimeLinter-flake8\n[11]:https://github.com/timothycrosley/isort\n[12]:https://github.com/timothycrosley/isort#how-does-isort-work\n[13]:https://github.com/timothycrosley/isort#using-isort\n[14]:https://github.com/timothycrosley/isort#configuring-isort\n[15]:https://github.com/timothycrosley/isort/wiki/isort-Plugins\n[16]:https://github.com/hhatto/autopep8\n[17]:https://github.com/hhatto/autopep8#id4\n[18]:https://github.com/hhatto/autopep8#id5\n[19]:https://github.com/google/yapf\n[20]:https://github.com/google/yapf#usage\n[21]:https://github.com/ambv/black\n[22]:https://github.com/ambv/black#command-line-options\n[23]:https://github.com/ambv/black#pyprojecttoml\n[24]:https://coverage.readthedocs.io/en/latest/\n[25]:https://coverage.readthedocs.io/en/latest/config.html\n[26]:https://travis-ci.org/\n[27]:https://jenkins.io/\n\n","slug":"7-Python-libraries-for-more-maintainable-code","published":1,"updated":"2019-03-28T05:57:53.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0c4000clixuel5wgwlw","content":"<blockquote>\n<p>检查你的代码的质量，通过这些外部库使其更易维护。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming_keyboard_coding.png?itok=E0Vvam7A\" alt=\"\"></p>\n<blockquote>\n<p>可读性很重要。<br> — <ruby><a href=\"https://www.python.org/dev/peps/pep-0020/\" target=\"_blank\" rel=\"noopener\">Python 之禅</a><rt>The Zen of Python</rt></ruby>，Tim Peters</p>\n</blockquote>\n<p>随着软件项目进入“维护模式”，对可读性和编码标准的要求很容易落空（甚至从一开始就没有建立过那些标准）。然而，在代码库中保持一致的代码风格和测试标准能够显著减轻维护的压力，也能确保新的开发者能够快速了解项目的情况，同时能更好地全程保持应用程序的质量。</p>\n<p>使用外部库来检查代码的质量不失为保护项目未来可维护性的一个好方法。以下会推荐一些我们最喜爱的<a href=\"https://en.wikipedia.org/wiki/Lint_(software)\" target=\"_blank\" rel=\"noopener\">检查代码</a>（包括检查 PEP 8 和其它代码风格错误）的库，用它们来强制保持代码风格一致，并确保在项目成熟时有一个可接受的测试覆盖率。</p>\n<h3 id=\"检查你的代码风格\"><a href=\"#检查你的代码风格\" class=\"headerlink\" title=\"检查你的代码风格\"></a>检查你的代码风格</h3><p><a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">PEP 8</a> 是 Python 代码风格规范，它规定了类似行长度、缩进、多行表达式、变量命名约定等内容。尽管你的团队自身可能也会有稍微不同于 PEP 8 的代码风格规范，但任何代码风格规范的目标都是在代码库中强制实施一致的标准，使代码的可读性更强、更易于维护。下面三个库就可以用来帮助你美化代码。</p>\n<h4 id=\"1、-Pylint\"><a href=\"#1、-Pylint\" class=\"headerlink\" title=\"1、 Pylint\"></a>1、 Pylint</h4><p><a href=\"https://www.pylint.org/\" target=\"_blank\" rel=\"noopener\">Pylint</a> 是一个检查违反 PEP 8 规范和常见错误的库。它在一些流行的<a href=\"https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html\" target=\"_blank\" rel=\"noopener\">编辑器和 IDE</a> 中都有集成，也可以单独从命令行运行。</p>\n<p>执行 <code>pip install pylint</code> 安装 Pylint 。然后运行 <code>pylint [options] path/to/dir</code> 或者 <code>pylint [options] path/to/module.py</code> 就可以在命令行中使用 Pylint，它会向控制台输出代码中违反规范和出现错误的地方。</p>\n<p>你还可以使用 <code>pylintrc</code> <a href=\"https://pylint.readthedocs.io/en/latest/user_guide/run.html#command-line-options\" target=\"_blank\" rel=\"noopener\">配置文件</a>来自定义 Pylint 对哪些代码错误进行检查。</p>\n<h4 id=\"2、-Flake8\"><a href=\"#2、-Flake8\" class=\"headerlink\" title=\"2、 Flake8\"></a>2、 Flake8</h4><p><a href=\"http://flake8.pycqa.org/en/latest/\" target=\"_blank\" rel=\"noopener\">Flake8</a> 是“将 PEP 8、Pyflakes（类似 Pylint）、McCabe（代码复杂性检查器）和第三方插件整合到一起，以检查 Python 代码风格和质量的一个 Python 工具”。</p>\n<p>执行 <code>pip install flake8</code> 安装 flake8 ，然后执行 <code>flake8 [options] path/to/dir</code> 或者 <code>flake8 [options] path/to/module.py</code> 可以查看报出的错误和警告。</p>\n<p>和 Pylint 类似，Flake8 允许通过<a href=\"http://flake8.pycqa.org/en/latest/user/configuration.html#configuration-locations\" target=\"_blank\" rel=\"noopener\">配置文件</a>来自定义检查的内容。它有非常清晰的文档，包括一些有用的<a href=\"http://flake8.pycqa.org/en/latest/user/using-hooks.html\" target=\"_blank\" rel=\"noopener\">提交钩子</a>，可以将自动检查代码纳入到开发工作流程之中。</p>\n<p>Flake8 也可以集成到一些流行的编辑器和 IDE 当中，但在文档中并没有详细说明。要将 Flake8 集成到喜欢的编辑器或 IDE 中，可以搜索插件（例如 <a href=\"https://github.com/SublimeLinter/SublimeLinter-flake8\" target=\"_blank\" rel=\"noopener\">Sublime Text 的 Flake8 插件</a>）。</p>\n<h4 id=\"3、-Isort\"><a href=\"#3、-Isort\" class=\"headerlink\" title=\"3、 Isort\"></a>3、 Isort</h4><p><a href=\"https://github.com/timothycrosley/isort\" target=\"_blank\" rel=\"noopener\">Isort</a> 这个库能将你在项目中导入的库按字母顺序排序，并将其<a href=\"https://github.com/timothycrosley/isort#how-does-isort-work\" target=\"_blank\" rel=\"noopener\">正确划分为不同部分</a>（例如标准库、第三方库、自建的库等）。这样提高了代码的可读性，并且可以在导入的库较多的时候轻松找到各个库。</p>\n<p>执行 <code>pip install isort</code> 安装 isort，然后执行 <code>isort path/to/module.py</code> 就可以运行了。<a href=\"https://github.com/timothycrosley/isort#using-isort\" target=\"_blank\" rel=\"noopener\">文档</a>中还提供了更多的配置项，例如通过<a href=\"https://github.com/timothycrosley/isort#configuring-isort\" target=\"_blank\" rel=\"noopener\">配置</a> <code>.isort.cfg</code> 文件来决定 isort 如何处理一个库的多行导入。</p>\n<p>和 Flake8、Pylint 一样，isort 也提供了将其与流行的<a href=\"https://github.com/timothycrosley/isort/wiki/isort-Plugins\" target=\"_blank\" rel=\"noopener\">编辑器和 IDE</a> 集成的插件。</p>\n<h3 id=\"分享你的代码风格\"><a href=\"#分享你的代码风格\" class=\"headerlink\" title=\"分享你的代码风格\"></a>分享你的代码风格</h3><p>每次文件发生变动之后都用命令行手动检查代码是一件痛苦的事，你可能也不太喜欢通过运行 IDE 中某个插件来实现这个功能。同样地，你的同事可能会用不同的代码检查方式，也许他们的编辑器中也没有那种插件，甚至你自己可能也不会严格检查代码和按照警告来更正代码。总之，你分享出来的代码库将会逐渐地变得混乱且难以阅读。</p>\n<p>一个很好的解决方案是使用一个库，自动将代码按照 PEP 8 规范进行格式化。我们推荐的三个库都有不同的自定义级别来控制如何格式化代码。其中有一些设置较为特殊，例如 Pylint 和 Flake8 ，你需要先行测试，看看是否有你无法忍受但又不能修改的默认配置。</p>\n<h4 id=\"4、-Autopep8\"><a href=\"#4、-Autopep8\" class=\"headerlink\" title=\"4、 Autopep8\"></a>4、 Autopep8</h4><p><a href=\"https://github.com/hhatto/autopep8\" target=\"_blank\" rel=\"noopener\">Autopep8</a> 可以自动格式化指定的模块中的代码，包括重新缩进行、修复缩进、删除多余的空格，并重构常见的比较错误（例如布尔值和 <code>None</code> 值）。你可以查看文档中完整的<a href=\"https://github.com/hhatto/autopep8#id4\" target=\"_blank\" rel=\"noopener\">更正列表</a>。</p>\n<p>运行 <code>pip install --upgrade autopep8</code> 安装 Autopep8。然后执行 <code>autopep8 --in-place --aggressive --aggressive &lt;filename&gt;</code> 就可以重新格式化你的代码。<code>aggressive</code> 选项的数量表示 Auotopep8 在代码风格控制上有多少控制权。在这里可以详细了解 <a href=\"https://github.com/hhatto/autopep8#id5\" target=\"_blank\" rel=\"noopener\">aggressive</a> 选项。</p>\n<h4 id=\"5、-Yapf\"><a href=\"#5、-Yapf\" class=\"headerlink\" title=\"5、 Yapf\"></a>5、 Yapf</h4><p><a href=\"https://github.com/google/yapf\" target=\"_blank\" rel=\"noopener\">Yapf</a> 是另一种有自己的<a href=\"https://github.com/google/yapf#usage\" target=\"_blank\" rel=\"noopener\">配置项</a>列表的重新格式化代码的工具。它与 Autopep8 的不同之处在于它不仅会指出代码中违反 PEP 8 规范的地方，还会对没有违反 PEP 8 但代码风格不一致的地方重新格式化，旨在令代码的可读性更强。</p>\n<p>执行 <code>pip install yapf</code> 安装 Yapf，然后执行 <code>yapf [options] path/to/dir</code> 或 <code>yapf [options] path/to/module.py</code> 可以对代码重新格式化。<a href=\"https://github.com/google/yapf#usage\" target=\"_blank\" rel=\"noopener\">定制选项</a>的完整列表在这里。</p>\n<h4 id=\"6、-Black\"><a href=\"#6、-Black\" class=\"headerlink\" title=\"6、 Black\"></a>6、 Black</h4><p><a href=\"https://github.com/ambv/black\" target=\"_blank\" rel=\"noopener\">Black</a> 在代码检查工具当中算是比较新的一个。它与 Autopep8 和 Yapf 类似，但限制较多，没有太多的自定义选项。这样的好处是你不需要去决定使用怎么样的代码风格，让 Black 来给你做决定就好。你可以在这里查阅 Black <a href=\"https://github.com/ambv/black#command-line-options\" target=\"_blank\" rel=\"noopener\">有限的自定义选项</a>以及<a href=\"https://github.com/ambv/black#pyprojecttoml\" target=\"_blank\" rel=\"noopener\">如何在配置文件中对其进行设置</a>。</p>\n<p>Black 依赖于 Python 3.6+，但它可以格式化用 Python 2 编写的代码。执行 <code>pip install black</code> 安装 Black，然后执行 <code>black path/to/dir</code> 或 <code>black path/to/module.py</code> 就可以使用 Black 优化你的代码。</p>\n<h3 id=\"检查你的测试覆盖率\"><a href=\"#检查你的测试覆盖率\" class=\"headerlink\" title=\"检查你的测试覆盖率\"></a>检查你的测试覆盖率</h3><p>如果你正在进行编写测试，你需要确保提交到代码库的新代码都已经测试通过，并且不会降低测试覆盖率。虽然测试覆盖率不是衡量测试有效性和充分性的唯一指标，但它是确保项目遵循基本测试标准的一种方法。对于计算测试覆盖率，我们推荐使用 Coverage 这个库。</p>\n<h4 id=\"7、-Coverage\"><a href=\"#7、-Coverage\" class=\"headerlink\" title=\"7、 Coverage\"></a>7、 Coverage</h4><p><a href=\"https://coverage.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Coverage</a> 有数种显示测试覆盖率的方式，包括将结果输出到控制台或 HTML 页面，并指出哪些具体哪些地方没有被覆盖到。你可以通过<a href=\"https://coverage.readthedocs.io/en/latest/config.html\" target=\"_blank\" rel=\"noopener\">配置文件</a>自定义 Coverage 检查的内容，让你更方便使用。</p>\n<p>执行 <code>pip install coverage</code> 安装 Converage 。然后执行 <code>coverage [path/to/module.py] [args]</code> 可以运行程序并查看输出结果。如果要查看哪些代码行没有被覆盖，执行 <code>coverage report -m</code> 即可。</p>\n<h3 id=\"持续集成工具\"><a href=\"#持续集成工具\" class=\"headerlink\" title=\"持续集成工具\"></a>持续集成工具</h3><p><ruby>持续集成<rt>Continuous integration</rt></ruby>（CI）是在合并和部署代码之前自动检查代码风格错误和测试覆盖率最小值的过程。很多免费或付费的工具都可以用于执行这项工作，具体的过程不在本文中赘述，但 CI 过程是令代码更易读和更易维护的重要步骤，关于这一部分可以参考 <a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 和  <a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>。</p>\n<p>以上这些只是用于检查 Python 代码的各种工具中的其中几个。如果你有其它喜爱的工具，欢迎在评论中分享。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>检查你的代码的质量，通过这些外部库使其更易维护。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming_keyboard_coding.png?itok=E0Vvam7A\" alt=\"\"></p>\n<blockquote>\n<p>可读性很重要。<br> — <ruby><a href=\"https://www.python.org/dev/peps/pep-0020/\" target=\"_blank\" rel=\"noopener\">Python 之禅</a><rt>The Zen of Python</rt></ruby>，Tim Peters</p>\n</blockquote>\n<p>随着软件项目进入“维护模式”，对可读性和编码标准的要求很容易落空（甚至从一开始就没有建立过那些标准）。然而，在代码库中保持一致的代码风格和测试标准能够显著减轻维护的压力，也能确保新的开发者能够快速了解项目的情况，同时能更好地全程保持应用程序的质量。</p>\n<p>使用外部库来检查代码的质量不失为保护项目未来可维护性的一个好方法。以下会推荐一些我们最喜爱的<a href=\"https://en.wikipedia.org/wiki/Lint_(software)\" target=\"_blank\" rel=\"noopener\">检查代码</a>（包括检查 PEP 8 和其它代码风格错误）的库，用它们来强制保持代码风格一致，并确保在项目成熟时有一个可接受的测试覆盖率。</p>\n<h3 id=\"检查你的代码风格\"><a href=\"#检查你的代码风格\" class=\"headerlink\" title=\"检查你的代码风格\"></a>检查你的代码风格</h3><p><a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">PEP 8</a> 是 Python 代码风格规范，它规定了类似行长度、缩进、多行表达式、变量命名约定等内容。尽管你的团队自身可能也会有稍微不同于 PEP 8 的代码风格规范，但任何代码风格规范的目标都是在代码库中强制实施一致的标准，使代码的可读性更强、更易于维护。下面三个库就可以用来帮助你美化代码。</p>\n<h4 id=\"1、-Pylint\"><a href=\"#1、-Pylint\" class=\"headerlink\" title=\"1、 Pylint\"></a>1、 Pylint</h4><p><a href=\"https://www.pylint.org/\" target=\"_blank\" rel=\"noopener\">Pylint</a> 是一个检查违反 PEP 8 规范和常见错误的库。它在一些流行的<a href=\"https://pylint.readthedocs.io/en/latest/user_guide/ide-integration.html\" target=\"_blank\" rel=\"noopener\">编辑器和 IDE</a> 中都有集成，也可以单独从命令行运行。</p>\n<p>执行 <code>pip install pylint</code> 安装 Pylint 。然后运行 <code>pylint [options] path/to/dir</code> 或者 <code>pylint [options] path/to/module.py</code> 就可以在命令行中使用 Pylint，它会向控制台输出代码中违反规范和出现错误的地方。</p>\n<p>你还可以使用 <code>pylintrc</code> <a href=\"https://pylint.readthedocs.io/en/latest/user_guide/run.html#command-line-options\" target=\"_blank\" rel=\"noopener\">配置文件</a>来自定义 Pylint 对哪些代码错误进行检查。</p>\n<h4 id=\"2、-Flake8\"><a href=\"#2、-Flake8\" class=\"headerlink\" title=\"2、 Flake8\"></a>2、 Flake8</h4><p><a href=\"http://flake8.pycqa.org/en/latest/\" target=\"_blank\" rel=\"noopener\">Flake8</a> 是“将 PEP 8、Pyflakes（类似 Pylint）、McCabe（代码复杂性检查器）和第三方插件整合到一起，以检查 Python 代码风格和质量的一个 Python 工具”。</p>\n<p>执行 <code>pip install flake8</code> 安装 flake8 ，然后执行 <code>flake8 [options] path/to/dir</code> 或者 <code>flake8 [options] path/to/module.py</code> 可以查看报出的错误和警告。</p>\n<p>和 Pylint 类似，Flake8 允许通过<a href=\"http://flake8.pycqa.org/en/latest/user/configuration.html#configuration-locations\" target=\"_blank\" rel=\"noopener\">配置文件</a>来自定义检查的内容。它有非常清晰的文档，包括一些有用的<a href=\"http://flake8.pycqa.org/en/latest/user/using-hooks.html\" target=\"_blank\" rel=\"noopener\">提交钩子</a>，可以将自动检查代码纳入到开发工作流程之中。</p>\n<p>Flake8 也可以集成到一些流行的编辑器和 IDE 当中，但在文档中并没有详细说明。要将 Flake8 集成到喜欢的编辑器或 IDE 中，可以搜索插件（例如 <a href=\"https://github.com/SublimeLinter/SublimeLinter-flake8\" target=\"_blank\" rel=\"noopener\">Sublime Text 的 Flake8 插件</a>）。</p>\n<h4 id=\"3、-Isort\"><a href=\"#3、-Isort\" class=\"headerlink\" title=\"3、 Isort\"></a>3、 Isort</h4><p><a href=\"https://github.com/timothycrosley/isort\" target=\"_blank\" rel=\"noopener\">Isort</a> 这个库能将你在项目中导入的库按字母顺序排序，并将其<a href=\"https://github.com/timothycrosley/isort#how-does-isort-work\" target=\"_blank\" rel=\"noopener\">正确划分为不同部分</a>（例如标准库、第三方库、自建的库等）。这样提高了代码的可读性，并且可以在导入的库较多的时候轻松找到各个库。</p>\n<p>执行 <code>pip install isort</code> 安装 isort，然后执行 <code>isort path/to/module.py</code> 就可以运行了。<a href=\"https://github.com/timothycrosley/isort#using-isort\" target=\"_blank\" rel=\"noopener\">文档</a>中还提供了更多的配置项，例如通过<a href=\"https://github.com/timothycrosley/isort#configuring-isort\" target=\"_blank\" rel=\"noopener\">配置</a> <code>.isort.cfg</code> 文件来决定 isort 如何处理一个库的多行导入。</p>\n<p>和 Flake8、Pylint 一样，isort 也提供了将其与流行的<a href=\"https://github.com/timothycrosley/isort/wiki/isort-Plugins\" target=\"_blank\" rel=\"noopener\">编辑器和 IDE</a> 集成的插件。</p>\n<h3 id=\"分享你的代码风格\"><a href=\"#分享你的代码风格\" class=\"headerlink\" title=\"分享你的代码风格\"></a>分享你的代码风格</h3><p>每次文件发生变动之后都用命令行手动检查代码是一件痛苦的事，你可能也不太喜欢通过运行 IDE 中某个插件来实现这个功能。同样地，你的同事可能会用不同的代码检查方式，也许他们的编辑器中也没有那种插件，甚至你自己可能也不会严格检查代码和按照警告来更正代码。总之，你分享出来的代码库将会逐渐地变得混乱且难以阅读。</p>\n<p>一个很好的解决方案是使用一个库，自动将代码按照 PEP 8 规范进行格式化。我们推荐的三个库都有不同的自定义级别来控制如何格式化代码。其中有一些设置较为特殊，例如 Pylint 和 Flake8 ，你需要先行测试，看看是否有你无法忍受但又不能修改的默认配置。</p>\n<h4 id=\"4、-Autopep8\"><a href=\"#4、-Autopep8\" class=\"headerlink\" title=\"4、 Autopep8\"></a>4、 Autopep8</h4><p><a href=\"https://github.com/hhatto/autopep8\" target=\"_blank\" rel=\"noopener\">Autopep8</a> 可以自动格式化指定的模块中的代码，包括重新缩进行、修复缩进、删除多余的空格，并重构常见的比较错误（例如布尔值和 <code>None</code> 值）。你可以查看文档中完整的<a href=\"https://github.com/hhatto/autopep8#id4\" target=\"_blank\" rel=\"noopener\">更正列表</a>。</p>\n<p>运行 <code>pip install --upgrade autopep8</code> 安装 Autopep8。然后执行 <code>autopep8 --in-place --aggressive --aggressive &lt;filename&gt;</code> 就可以重新格式化你的代码。<code>aggressive</code> 选项的数量表示 Auotopep8 在代码风格控制上有多少控制权。在这里可以详细了解 <a href=\"https://github.com/hhatto/autopep8#id5\" target=\"_blank\" rel=\"noopener\">aggressive</a> 选项。</p>\n<h4 id=\"5、-Yapf\"><a href=\"#5、-Yapf\" class=\"headerlink\" title=\"5、 Yapf\"></a>5、 Yapf</h4><p><a href=\"https://github.com/google/yapf\" target=\"_blank\" rel=\"noopener\">Yapf</a> 是另一种有自己的<a href=\"https://github.com/google/yapf#usage\" target=\"_blank\" rel=\"noopener\">配置项</a>列表的重新格式化代码的工具。它与 Autopep8 的不同之处在于它不仅会指出代码中违反 PEP 8 规范的地方，还会对没有违反 PEP 8 但代码风格不一致的地方重新格式化，旨在令代码的可读性更强。</p>\n<p>执行 <code>pip install yapf</code> 安装 Yapf，然后执行 <code>yapf [options] path/to/dir</code> 或 <code>yapf [options] path/to/module.py</code> 可以对代码重新格式化。<a href=\"https://github.com/google/yapf#usage\" target=\"_blank\" rel=\"noopener\">定制选项</a>的完整列表在这里。</p>\n<h4 id=\"6、-Black\"><a href=\"#6、-Black\" class=\"headerlink\" title=\"6、 Black\"></a>6、 Black</h4><p><a href=\"https://github.com/ambv/black\" target=\"_blank\" rel=\"noopener\">Black</a> 在代码检查工具当中算是比较新的一个。它与 Autopep8 和 Yapf 类似，但限制较多，没有太多的自定义选项。这样的好处是你不需要去决定使用怎么样的代码风格，让 Black 来给你做决定就好。你可以在这里查阅 Black <a href=\"https://github.com/ambv/black#command-line-options\" target=\"_blank\" rel=\"noopener\">有限的自定义选项</a>以及<a href=\"https://github.com/ambv/black#pyprojecttoml\" target=\"_blank\" rel=\"noopener\">如何在配置文件中对其进行设置</a>。</p>\n<p>Black 依赖于 Python 3.6+，但它可以格式化用 Python 2 编写的代码。执行 <code>pip install black</code> 安装 Black，然后执行 <code>black path/to/dir</code> 或 <code>black path/to/module.py</code> 就可以使用 Black 优化你的代码。</p>\n<h3 id=\"检查你的测试覆盖率\"><a href=\"#检查你的测试覆盖率\" class=\"headerlink\" title=\"检查你的测试覆盖率\"></a>检查你的测试覆盖率</h3><p>如果你正在进行编写测试，你需要确保提交到代码库的新代码都已经测试通过，并且不会降低测试覆盖率。虽然测试覆盖率不是衡量测试有效性和充分性的唯一指标，但它是确保项目遵循基本测试标准的一种方法。对于计算测试覆盖率，我们推荐使用 Coverage 这个库。</p>\n<h4 id=\"7、-Coverage\"><a href=\"#7、-Coverage\" class=\"headerlink\" title=\"7、 Coverage\"></a>7、 Coverage</h4><p><a href=\"https://coverage.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Coverage</a> 有数种显示测试覆盖率的方式，包括将结果输出到控制台或 HTML 页面，并指出哪些具体哪些地方没有被覆盖到。你可以通过<a href=\"https://coverage.readthedocs.io/en/latest/config.html\" target=\"_blank\" rel=\"noopener\">配置文件</a>自定义 Coverage 检查的内容，让你更方便使用。</p>\n<p>执行 <code>pip install coverage</code> 安装 Converage 。然后执行 <code>coverage [path/to/module.py] [args]</code> 可以运行程序并查看输出结果。如果要查看哪些代码行没有被覆盖，执行 <code>coverage report -m</code> 即可。</p>\n<h3 id=\"持续集成工具\"><a href=\"#持续集成工具\" class=\"headerlink\" title=\"持续集成工具\"></a>持续集成工具</h3><p><ruby>持续集成<rt>Continuous integration</rt></ruby>（CI）是在合并和部署代码之前自动检查代码风格错误和测试覆盖率最小值的过程。很多免费或付费的工具都可以用于执行这项工作，具体的过程不在本文中赘述，但 CI 过程是令代码更易读和更易维护的重要步骤，关于这一部分可以参考 <a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 和  <a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">Jenkins</a>。</p>\n<p>以上这些只是用于检查 Python 代码的各种工具中的其中几个。如果你有其它喜爱的工具，欢迎在评论中分享。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/7/7-python-libraries-more-maintainable-code</a></p>\n"},{"title":"75 个最常用的 Linux 应用程序（2018 年）","date":"2018-10-10T05:40:26.000Z","_content":"\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Most-Used-Ubuntu-Applications.png)\n\n对于许多应用程序来说，2018 年是非常好的一年，尤其是自由开源的应用程序。尽管各种 Linux 发行版都自带了很多默认的应用程序，但用户也可以自由地选择使用它们或者其它任何免费或付费替代方案。\n\n下面汇总了[一系列的 Linux 应用程序][3]，这些应用程序都能够在 Linux 系统上安装，尽管还有很多其它选择。以下汇总中的任何应用程序都属于其类别中最常用的应用程序，如果你还没有用过，欢迎试用一下！\n\n### 备份工具\n\n#### Rsync\n\n[Rsync][4] 是一个开源的、节约带宽的工具，它用于执行快速的增量文件传输，而且它也是一个免费工具。\n\n```\n$ rsync [OPTION...] SRC... [DEST]\n```\n\n想要了解更多示例和用法，可以参考《[10 个使用 Rsync 命令的实际例子][5]》。\n\n#### Timeshift\n\n[Timeshift][6] 能够通过增量快照来保护用户的系统数据，而且可以按照日期恢复指定的快照，类似于 Mac OS 中的 Time Machine 功能和 Windows 中的系统还原功能。\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Timeshift-Create-Linux-Mint-Snapshot.png)\n\n### BT（BitTorrent） 客户端\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Torrent-Clients.png)\n\n#### Deluge\n\n[Deluge][7] 是一个漂亮的跨平台 BT 客户端，旨在优化 μTorrent 体验，并向用户免费提供服务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Deluge。\n\n```\n$ sudo add-apt-repository ppa:deluge-team/ppa\n$ sudo apt-get update\n$ sudo apt-get install deluge\n```\n\n#### qBittorent\n\n[qBittorent][8] 是一个开源的 BT 客户端，旨在提供类似 μTorrent 的免费替代方案。\n\n使用以下命令在 Ubuntu 和 Debian 安装 qBittorent。\n\n```\n$ sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable\n$ sudo apt-get update\n$ sudo apt-get install qbittorrent\n```\n\n#### Transmission\n\n[Transmission][9] 是一个强大的 BT 客户端，它主要关注速度和易用性，一般在很多 Linux 发行版上都有预装。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Transmission。\n\n```\n$ sudo add-apt-repository ppa:transmissionbt/ppa\n$ sudo apt-get update\n$ sudo apt-get install transmission-gtk transmission-cli transmission-common transmission-daemon\n```\n\n### 云存储\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Cloud-Storage.png)\n\n#### Dropbox\n\n[Dropbox][10] 团队在今年早些时候给他们的云服务换了一个名字，也为客户提供了更好的性能和集成了更多应用程序。Dropbox 会向用户免费提供 2 GB 存储空间。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Dropbox。\n\n```\n$ cd ~ && wget -O - \"https://www.dropbox.com/download?plat=lnx.x86\" | tar xzf - [On 32-Bit]\n$ cd ~ && wget -O - \"https://www.dropbox.com/download?plat=lnx.x86_64\" | tar xzf - [On 64-Bit]\n$ ~/.dropbox-dist/dropboxd\n```\n\n#### Google Drive\n\n[Google Drive][11] 是 Google 提供的云服务解决方案，这已经是一个广为人知的服务了。与 Dropbox 一样，可以通过它在所有联网的设备上同步文件。它免费提供了 15 GB 存储空间，包括Gmail、Google 图片、Google 地图等服务。\n\n参考阅读：[5 个适用于 Linux 的 Google Drive 客户端][12]\n\n#### Mega\n\n[Mega][13] 也是一个出色的云存储解决方案，它的亮点除了高度的安全性之外，还有为用户免费提供高达 50 GB 的免费存储空间。它使用端到端加密，以确保用户的数据安全，所以如果忘记了恢复密钥，用户自己也无法访问到存储的数据。\n\n参考阅读：[在 Ubuntu 下载 Mega 云存储客户端][14]\n\n### 命令行编辑器\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Commandline-Editors.png)\n\n#### Vim\n\n[Vim][15] 是 vi 文本编辑器的开源克隆版本，它的主要目的是可以高度定制化并能够处理任何类型的文本。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Vim。\n\n```\n$ sudo add-apt-repository ppa:jonathonf/vim\n$ sudo apt update\n$ sudo apt install vim\n```\n\n#### Emacs\n\n[Emacs][16] 是一个高度可配置的文本编辑器，最流行的一个分支 GNU Emacs 是用 Lisp 和 C 编写的，它的最大特点是可以自文档化、可扩展和可自定义。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Emacs。\n\n```\n$ sudo add-apt-repository ppa:kelleyk/emacs\n$ sudo apt update\n$ sudo apt install emacs25\n```\n\n#### Nano\n\n[Nano][17] 是一款功能丰富的命令行文本编辑器，比较适合高级用户。它可以通过多个终端进行不同功能的操作。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Nano。\n\n```\n$ sudo add-apt-repository ppa:n-muench/programs-ppa\n$ sudo apt-get update\n$ sudo apt-get install nano\n```\n\n### 下载器\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Download-Managers.png)\n\n#### Aria2\n\n[Aria2][18] 是一个开源的、轻量级的、多软件源和多协议的命令行下载器，它支持 Metalink、torrent、HTTP/HTTPS、SFTP 等多种协议。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Aria2。\n\n```\n$ sudo apt-get install aria2\n```\n\n#### uGet\n\n[uGet][19] 已经成为 Linux 各种发行版中排名第一的开源下载器，它可以处理任何下载任务，包括多连接、队列、类目等。\n\n使用以下命令在 Ubuntu 和 Debian 安装 uGet。\n\n```\n$ sudo add-apt-repository ppa:plushuang-tw/uget-stable\n$ sudo apt update\n$ sudo apt install uget\n```\n\n#### XDM\n\n[XDM][20]（Xtreme Download Manager）是一个使用 Java 编写的开源下载软件。和其它下载器一样，它可以结合队列、种子、浏览器使用，而且还带有视频采集器和智能调度器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 XDM。\n\n```\n$ sudo add-apt-repository ppa:noobslab/apps\n$ sudo apt-get update\n$ sudo apt-get install xdman\n```\n\n### 电子邮件客户端\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Email-Clients.png)\n\n#### Thunderbird\n\n[Thunderbird][21] 是最受欢迎的电子邮件客户端之一。它的优点包括免费、开源、可定制、功能丰富，而且最重要的是安装过程也很简便。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Thunderbird。\n\n```\n$ sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa\n$ sudo apt-get update\n$ sudo apt-get install thunderbird\n```\n\n#### Geary\n\n[Geary][22] 是一个基于 WebKitGTK+ 的开源电子邮件客户端。它是一个免费开源的功能丰富的软件，并被 GNOME 项目收录。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Geary。\n\n```\n$ sudo add-apt-repository ppa:geary-team/releases\n$ sudo apt-get update\n$ sudo apt-get install geary\n```\n\n#### Evolution\n\n[Evolution][23] 是一个免费开源的电子邮件客户端，可以用于电子邮件、会议日程、备忘录和联系人的管理。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Evolution。\n\n```\n$ sudo add-apt-repository ppa:gnome3-team/gnome3-staging\n$ sudo apt-get update\n$ sudo apt-get install evolution\n```\n\n### 财务软件\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Accounting-Software.png)\n\n#### GnuCash\n\n[GnuCash][24] 是一款免费的跨平台开源软件，它适用于个人和中小型企业的财务任务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 GnuCash。\n\n```\n$ sudo sh -c 'echo \"deb http://archive.getdeb.net/ubuntu $(lsb_release -sc)-getdeb apps\" >> /etc/apt/sources.list.d/getdeb.list'\n$ sudo apt-get update\n$ sudo apt-get install gnucash\n```\n\n#### KMyMoney\n\n[KMyMoney][25] 是一个财务管理软件，它可以提供商用或个人理财所需的大部分主要功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 KmyMoney。\n\n```\n$ sudo add-apt-repository ppa:claydoh/kmymoney2-kde4\n$ sudo apt-get update\n$ sudo apt-get install kmymoney\n```\n\n### IDE\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IDE-Editors.png)\n\n#### Eclipse IDE\n\n[Eclipse][26] 是最广为使用的 Java IDE，它包括一个基本工作空间和一个用于自定义编程环境的强大的的插件配置系统。\n\n关于 Eclipse IDE 的安装，可以参考 [如何在 Debian 和 Ubuntu 上安装 Eclipse IDE][27] 这一篇文章。\n\n#### Netbeans IDE\n\n[Netbeans][28] 是一个相当受用户欢迎的 IDE，它支持使用 Java、PHP、HTML 5、JavaScript、C/C++ 或其他语言编写移动应用，桌面软件和 web 应用。\n\n关于 Netbeans IDE 的安装，可以参考 [如何在 Debian 和 Ubuntu 上安装 Netbeans IDE][29] 这一篇文章。\n\n#### Brackets\n\n[Brackets][30] 是由 Adobe 开发的高级文本编辑器，它带有可视化工具，支持预处理程序，以及用于 web 开发的以设计为中心的用户流程。对于熟悉它的用户，它可以发挥 IDE 的作用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Brackets。\n\n```\n$ sudo add-apt-repository ppa:webupd8team/brackets\n$ sudo apt-get update\n$ sudo apt-get install brackets\n```\n\n#### Atom IDE\n\n[Atom IDE][31] 是一个加强版的 Atom 编辑器，它添加了大量扩展和库以提高性能和增加功能。总之，它是各方面都变得更强大了的 Atom 。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Atom。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install atom --classic\n```\n\n#### Light Table\n\n[Light Table][32] 号称下一代的 IDE，它提供了数据流量统计和协作编程等的强大功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Light Table。\n\n```\n$ sudo add-apt-repository ppa:dr-akulavich/lighttable\n$ sudo apt-get update\n$ sudo apt-get install lighttable-installer\n```\n\n#### Visual Studio Code\n\n[Visual Studio Code][33] 是由微软开发的代码编辑器，它包含了文本编辑器所需要的最先进的功能，包括语法高亮、自动完成、代码调试、性能统计和图表显示等功能。\n\n参考阅读：[在Ubuntu 下载 Visual Studio Code][34]\n\n### 即时通信工具\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IM-Clients.png)\n\n#### Pidgin\n\n[Pidgin][35] 是一个开源的即时通信工具，它几乎支持所有聊天平台，还支持额外扩展功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Pidgin。\n\n```\n$ sudo add-apt-repository ppa:jonathonf/backports\n$ sudo apt-get update\n$ sudo apt-get install pidgin\n```\n\n#### Skype\n\n[Skype][36] 也是一个广为人知的软件了，任何感兴趣的用户都可以在 Linux 上使用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Skype。\n\n```\n$ sudo apt install snapd\n$ sudo snap install skype --classic\n```\n\n#### Empathy\n\n[Empathy][37] 是一个支持多协议语音、视频聊天、文本和文件传输的即时通信工具。它还允许用户添加多个服务的帐户，并用其与所有服务的帐户进行交互。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Empathy。\n\n```\n$ sudo apt-get install empathy\n```\n\n### Linux 防病毒工具\n\n#### ClamAV/ClamTk\n\n[ClamAV][38] 是一个开源的跨平台命令行防病毒工具，用于检测木马、病毒和其他恶意代码。而 [ClamTk][39] 则是它的前端 GUI。\n\n使用以下命令在 Ubuntu 和 Debian 安装 ClamAV 和 ClamTk。\n\n```\n$ sudo apt-get install clamav\n$ sudo apt-get install clamtk\n```\n\n### Linux 桌面环境\n\n#### Cinnamon\n\n[Cinnamon][40] 是 GNOME 3 的自由开源衍生产品，它遵循传统的 <ruby>桌面比拟<rt>desktop metaphor</rt></ruby> 约定。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Cinnamon。\n\n```\n$ sudo add-apt-repository ppa:embrosyn/cinnamon\n$ sudo apt update\n$ sudo apt install cinnamon-desktop-environment lightdm\n```\n\n#### Mate\n\n[Mate][41] 桌面环境是 GNOME 2 的衍生和延续，目的是在 Linux 上通过使用传统的桌面比拟提供有一个吸引力的 UI。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Mate。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install ubuntu-mate-desktop\n```\n\n#### GNOME\n\n[GNOME][42] 是由一些免费和开源应用程序组成的桌面环境，它可以运行在任何 Linux 发行版和大多数 BSD 衍生版本上。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install ubuntu-desktop\n```\n\n#### KDE\n\n[KDE][43] 由 KDE 社区开发，它为用户提供图形解决方案以控制操作系统并执行不同的计算任务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 KDE。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install kubuntu-desktop\n```\n\n### Linux 维护工具\n\n#### GNOME Tweak Tool\n\n[GNOME Tweak Tool][44] 是用于自定义和调整 GNOME 3 和 GNOME Shell 设置的流行工具。\n\n使用以下命令在 Ubuntu 和 Debian 安装 GNOME Tweak Tool。\n\n```\n$ sudo apt install gnome-tweak-tool\n```\n\n#### Stacer\n\n[Stacer][45] 是一款用于监控和优化 Linux 系统的免费开源应用程序。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Stacer。\n\n```\n$ sudo add-apt-repository ppa:oguzhaninan/stacer\n$ sudo apt-get update\n$ sudo apt-get install stacer\n```\n\n#### BleachBit\n\n[BleachBit][46] 是一个免费的磁盘空间清理器，它也可用作隐私管理器和系统优化器。\n\n参考阅读：[在 Ubuntu 下载 BleachBit][47]\n\n### Linux 终端工具\n\n#### GNOME 终端\n\n[GNOME 终端][48] 是 GNOME 的默认终端模拟器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome 终端。\n\n```\n$ sudo apt-get install gnome-terminal\n```\n\n#### Konsole\n\n[Konsole][49] 是 KDE 的一个终端模拟器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Konsole。\n\n```\n$ sudo apt-get install konsole\n```\n\n#### Terminator\n\n[Terminator][50] 是一个功能丰富的终端程序，它基于 GNOME 终端，并且专注于整理终端功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Terminator。\n\n```\n$ sudo apt-get install terminator\n```\n\n#### Guake\n\n[Guake][51] 是 GNOME 桌面环境下一个轻量级的可下拉式终端。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Guake。\n\n```\n$ sudo apt-get install guake\n```\n\n### 多媒体编辑工具\n\n#### Ardour\n\n[Ardour][52] 是一款漂亮的的<ruby>数字音频工作站<rt>Digital Audio Workstation</rt></ruby>，可以完成专业的录制、编辑和混音工作。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Ardour。\n\n```\n$ sudo add-apt-repository ppa:dobey/audiotools\n$ sudo apt-get update\n$ sudo apt-get install ardour\n```\n\n#### Audacity\n\n[Audacity][53] 是最著名的音频编辑软件之一，它是一款跨平台的开源多轨音频编辑器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Audacity。\n\n```\n$ sudo add-apt-repository ppa:ubuntuhandbook1/audacity\n$ sudo apt-get update\n$ sudo apt-get install audacity\n```\n\n#### GIMP\n\n[GIMP][54] 是 Photoshop 的开源替代品中最受欢迎的。这是因为它有多种可自定义的选项、第三方插件以及活跃的用户社区。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gimp。\n\n```\n$ sudo add-apt-repository ppa:otto-kesselgulasch/gimp\n$ sudo apt update\n$ sudo apt install gimp\n```\n\n#### Krita\n\n[Krita][55] 是一款开源的绘画程序，它具有美观的 UI 和可靠的性能，也可以用作图像处理工具。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Krita。\n\n```\n$ sudo add-apt-repository ppa:kritalime/ppa\n$ sudo apt update\n$ sudo apt install krita\n```\n\n#### Lightworks\n\n[Lightworks][56] 是一款功能强大、灵活美观的专业视频编辑工具。它拥有上百种配套的视觉效果功能，可以处理任何编辑任务，毕竟这个软件已经有长达 25 年的视频处理经验。\n\n参考阅读：[在 Ubuntu 下载 Lightworks][57]\n\n#### OpenShot\n\n[OpenShot][58] 是一款屡获殊荣的免费开源视频编辑器，这主要得益于其出色的性能和强大的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 `Openshot。\n\n```\n$ sudo add-apt-repository ppa:openshot.developers/ppa\n$ sudo apt update\n$ sudo apt install openshot-qt\n```\n\n#### PiTiV\n\n[Pitivi][59] 也是一个美观的视频编辑器，它有优美的代码库、优质的社区，还支持优秀的协作编辑功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 PiTiV。\n\n```\n$ flatpak install --user https://flathub.org/repo/appstream/org.pitivi.Pitivi.flatpakref\n$ flatpak install --user http://flatpak.pitivi.org/pitivi.flatpakref\n$ flatpak run org.pitivi.Pitivi//stable\n```\n\n### 音乐播放器\n\n#### Rhythmbox\n\n[Rhythmbox][60] 支持海量种类的音乐，目前被认为是最可靠的音乐播放器，并由 Ubuntu 自带。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Rhythmbox。\n\n```\n$ sudo add-apt-repository ppa:fossfreedom/rhythmbox\n$ sudo apt-get update\n$ sudo apt-get install rhythmbox\n```\n\n#### Lollypop\n\n[Lollypop][61] 是一款较为年轻的开源音乐播放器，它有很多高级选项，包括网络电台，滑动播放和派对模式。尽管功能繁多，它仍然尽量做到简单易管理。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Lollypop。\n\n```\n$ sudo add-apt-repository ppa:gnumdk/lollypop\n$ sudo apt-get update\n$ sudo apt-get install lollypop\n```\n\n#### Amarok\n\n[Amarok][62] 是一款功能强大的音乐播放器，它有一个直观的 UI 和大量的高级功能，而且允许用户根据自己的偏好去发现新音乐。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Amarok。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install amarok\n\n```\n\n#### Clementine\n\n[Clementine][63] 是一款 Amarok 风格的音乐播放器，因此和 Amarok 相似，也有直观的用户界面、先进的控制模块，以及让用户搜索和发现新音乐的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Clementine。\n\n```\n$ sudo add-apt-repository ppa:me-davidsansome/clementine\n$ sudo apt-get update\n$ sudo apt-get install clementine\n```\n\n#### Cmus\n\n[Cmus][64] 可以说是最高效的的命令行界面音乐播放器了，它具有快速可靠的特点，也支持使用扩展。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Cmus。\n\n```\n$ sudo add-apt-repository ppa:jmuc/cmus\n$ sudo apt-get update\n$ sudo apt-get install cmus\n```\n\n### 办公软件\n\n#### Calligra 套件\n\n[Calligra 套件][65]为用户提供了一套总共 8 个应用程序，涵盖办公、管理、图表等各个范畴。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Calligra 套件。\n\n```\n$ sudo apt-get install calligra\n```\n\n#### LibreOffice\n\n[LibreOffice][66] 是开源社区中开发过程最活跃的办公套件，它以可靠性著称，也可以通过扩展来添加功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 LibreOffice。\n\n```\n$ sudo add-apt-repository ppa:libreoffice/ppa\n$ sudo apt update\n$ sudo apt install libreoffice\n```\n\n#### WPS Office\n\n[WPS Office][67] 是一款漂亮的办公套件，它有一个很具现代感的 UI。\n\n参考阅读：[在 Ubuntu 安装 WPS Office][68]\n\n### 屏幕截图工具\n\n#### Shutter\n\n[Shutter][69] 允许用户截取桌面的屏幕截图，然后使用一些效果进行编辑，还支持上传和在线共享。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Shutter。\n\n```\n$ sudo add-apt-repository -y ppa:shutter/ppa\n$ sudo apt update\n$ sudo apt install shutter\n```\n\n#### Kazam\n\n[Kazam][70] 可以用于捕获屏幕截图，它的输出对于任何支持 VP8/WebM 和 PulseAudio 视频播放器都可用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Kazam。\n\n```\n$ sudo add-apt-repository ppa:kazam-team/unstable-series\n$ sudo apt update\n$ sudo apt install kazam python3-cairo python3-xlib\n```\n\n#### Gnome Screenshot\n\n[Gnome Screenshot][71] 过去曾经和 Gnome 一起捆绑，但现在已经独立出来。它以易于共享的格式进行截屏。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome Screenshot。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gnome-screenshot\n```\n\n### 录屏工具\n\n#### SimpleScreenRecorder\n\n[SimpleScreenRecorder][72] 面世时已经是录屏工具中的佼佼者，现在已成为 Linux 各个发行版中最有效、最易用的录屏工具之一。\n\n使用以下命令在 Ubuntu 和 Debian 安装 SimpleScreenRecorder。\n\n```\n$ sudo add-apt-repository ppa:maarten-baert/simplescreenrecorder\n$ sudo apt-get update\n$ sudo apt-get install simplescreenrecorder\n```\n\n#### recordMyDesktop\n\n[recordMyDesktop][73] 是一个开源的会话记录器，它也能记录桌面会话的音频。\n\n使用以下命令在 Ubuntu 和 Debian 安装 recordMyDesktop。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gtk-recordmydesktop\n```\n\n### 文本编辑器\n\n#### Atom\n\n[Atom][74] 是由 GitHub 开发和维护的可定制文本编辑器。它是开箱即用的，但也可以使用扩展和主题自定义 UI 来增强其功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Atom。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install atom --classic\n```\n\n#### Sublime Text\n\n[Sublime Text][75] 已经成为目前最棒的文本编辑器。它可定制、轻量灵活（即使打开了大量数据文件和加入了大量扩展），最重要的是可以永久免费使用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Sublime Text。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install sublime-text\n```\n\n#### Geany\n\n[Geany][76] 是一个内存友好的文本编辑器，它具有基本的IDE功能，可以显示加载时间、扩展库函数等。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Geany。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install geany\n```\n\n#### Gedit\n\n[Gedit][77] 以其简单著称，在很多 Linux 发行版都有预装，它具有文本编辑器都具有的优秀的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gedit。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gedit\n```\n\n### 备忘录软件\n\n#### Evernote\n\n[Evernote][78] 是一款云上的笔记程序，它带有待办列表和提醒功能，能够与不同类型的笔记完美配合。\n\nEvernote 在 Linux 上没有官方提供的软件，但可以参考 [Linux 上的 6 个 Evernote 替代客户端][79] 这篇文章使用其它第三方工具。\n\n#### Everdo\n\n[Everdo][78] 是一款美观，安全，易兼容的备忘软件，可以用于处理待办事项和其它笔记。如果你认为 Evernote 有所不足，相信 Everdo 会是一个好的替代。\n\n参考阅读：[在 Ubuntu 下载 Everdo][80]\n\n#### Taskwarrior\n\n[Taskwarrior][81] 是一个用于管理个人任务的开源跨平台命令行应用，它的速度和无干扰的环境是它的两大特点。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Taskwarrior。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install taskwarrior\n```\n\n### 视频播放器\n\n#### Banshee\n\n[Banshee][82] 是一个开源的支持多格式的媒体播放器，于 2005 年开始开发并逐渐成长。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Banshee。\n\n```\n$ sudo add-apt-repository ppa:banshee-team/ppa\n$ sudo apt-get update\n$ sudo apt-get install banshee\n```\n\n#### VLC\n\n[VLC][83] 是我最喜欢的视频播放器，它几乎可以播放任何格式的音频和视频，它还可以播放网络电台、录制桌面会话以及在线播放电影。\n\n使用以下命令在 Ubuntu 和 Debian 安装 VLC。\n\n```\n$ sudo add-apt-repository ppa:videolan/stable-daily\n$ sudo apt-get update\n$ sudo apt-get install vlc\n```\n\n#### Kodi\n\n[Kodi][84] 是世界上最着名的媒体播放器之一，它有一个成熟的媒体中心，可以播放本地和远程的多媒体文件。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Kodi。\n\n```\n$ sudo apt-get install software-properties-common\n$ sudo add-apt-repository ppa:team-xbmc/ppa\n$ sudo apt-get update\n$ sudo apt-get install kodi\n```\n\n#### SMPlayer\n\n[SMPlayer][85] 是 MPlayer 的 GUI 版本，所有流行的媒体格式它都能够处理，并且它还有从 YouTube 和 Chromcast 和下载字幕的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 SMPlayer。\n\n```\n$ sudo add-apt-repository ppa:rvm/smplayer\n$ sudo apt-get update\n$ sudo apt-get install smplayer\n```\n\n### 虚拟化工具\n\n#### VirtualBox\n\n[VirtualBox][86] 是一个用于操作系统虚拟化的开源应用程序，在服务器、台式机和嵌入式系统上都可以运行。\n\n使用以下命令在 Ubuntu 和 Debian 安装 VirtualBox。\n\n```\n$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -\n$ wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -\n$ sudo apt-get update\n$ sudo apt-get install virtualbox-5.2\n$ virtualbox\n```\n\n#### VMWare\n\n[VMware][87] 是一个为客户提供平台虚拟化和云计算服务的数字工作区，是第一个成功将 x86 架构系统虚拟化的工作站。 VMware 工作站的其中一个产品就允许用户在虚拟内存中运行多个操作系统。\n\n参阅 [在 Ubuntu 上安装 VMWare Workstation Pro][88] 可以了解 VMWare 的安装。\n\n### 浏览器\n\n#### Chrome\n\n[Google Chrome][89] 无疑是最受欢迎的浏览器。Chrome 以其速度、简洁、安全、美观而受人喜爱，它遵循了 Google 的界面设计风格，是 web 开发人员不可缺少的浏览器，同时它也是免费开源的。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Google Chrome。\n\n```\n$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -\n$ sudo sh -c 'echo \"deb http://dl.google.com/linux/chrome/deb/ stable main\" >> /etc/apt/sources.list.d/google.list'\n$ sudo apt-get update\n$ sudo apt-get install google-chrome-stable\n```\n\n#### Firefox\n\n[Firefox Quantum][90] 是一款漂亮、快速、完善并且可自定义的浏览器。它也是自由开源的，包含有开发人员所需要的工具，对于初学者也没有任何使用门槛。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Firefox Quantum。\n\n```\n$ sudo add-apt-repository ppa:mozillateam/firefox-next\n$ sudo apt update && sudo apt upgrade\n$ sudo apt install firefox\n```\n\n#### Vivaldi\n\n[Vivaldi][91] 是一个基于 Chrome 的自由开源项目，旨在通过添加扩展来使 Chrome 的功能更加完善。色彩丰富的界面，性能良好、灵活性强是它的几大特点。\n\n参考阅读：[在 Ubuntu 下载 Vivaldi][91]\n\n以上就是我的推荐，你还有更好的软件向大家分享吗？欢迎评论。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.fossmint.com/most-used-linux-applications/\n\n[a]:https://www.fossmint.com/author/dillivine/\n[1]:https://plus.google.com/share?url=https://www.fossmint.com/most-used-linux-applications/ \"Share on Google+\"\n[2]:https://www.linkedin.com/shareArticle?mini=true&url=https://www.fossmint.com/most-used-linux-applications/ \"Share on LinkedIn\"\n[3]:https://www.fossmint.com/awesome-linux-software/\n[4]:https://rsync.samba.org/\n[5]:https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/\n[6]:https://github.com/teejee2008/timeshift\n[7]:https://deluge-torrent.org/\n[8]:https://www.qbittorrent.org/\n[9]:https://transmissionbt.com/\n[10]:https://www.dropbox.com/\n[11]:https://www.google.com/drive/\n[12]:https://www.fossmint.com/best-google-drive-clients-for-linux/\n[13]:https://mega.nz/\n[14]:https://mega.nz/sync!linux\n[15]:https://www.vim.org/\n[16]:https://www.gnu.org/s/emacs/\n[17]:https://www.nano-editor.org/\n[18]:https://aria2.github.io/\n[19]:http://ugetdm.com/\n[20]:http://xdman.sourceforge.net/\n[21]:https://www.thunderbird.net/\n[22]:https://github.com/GNOME/geary\n[23]:https://github.com/GNOME/evolution\n[24]:https://www.gnucash.org/\n[25]:https://kmymoney.org/\n[26]:https://www.eclipse.org/ide/\n[27]:https://www.tecmint.com/install-eclipse-oxygen-ide-in-ubuntu-debian/\n[28]:https://netbeans.org/\n[29]:https://www.tecmint.com/install-netbeans-ide-in-ubuntu-debian-linux-mint/\n[30]:http://brackets.io/\n[31]:https://ide.atom.io/\n[32]:http://lighttable.com/\n[33]:https://code.visualstudio.com/\n[34]:https://code.visualstudio.com/download\n[35]:https://www.pidgin.im/\n[36]:https://www.skype.com/\n[37]:https://wiki.gnome.org/Apps/Empathy\n[38]:https://www.clamav.net/\n[39]:https://dave-theunsub.github.io/clamtk/\n[40]:https://github.com/linuxmint/cinnamon-desktop\n[41]:https://mate-desktop.org/\n[42]:https://www.gnome.org/\n[43]:https://www.kde.org/plasma-desktop\n[44]:https://github.com/nzjrs/gnome-tweak-tool\n[45]:https://github.com/oguzhaninan/Stacer\n[46]:https://www.bleachbit.org/\n[47]:https://www.bleachbit.org/download\n[48]:https://github.com/GNOME/gnome-terminal\n[49]:https://konsole.kde.org/\n[50]:https://gnometerminator.blogspot.com/p/introduction.html\n[51]:http://guake-project.org/\n[52]:https://ardour.org/\n[53]:https://www.audacityteam.org/\n[54]:https://www.gimp.org/\n[55]:https://krita.org/en/\n[56]:https://www.lwks.com/\n[57]:https://www.lwks.com/index.php?option=com_lwks&view=download&Itemid=206\n[58]:https://www.openshot.org/\n[59]:http://www.pitivi.org/\n[60]:https://wiki.gnome.org/Apps/Rhythmbox\n[61]:https://gnumdk.github.io/lollypop-web/\n[62]:https://amarok.kde.org/en\n[63]:https://www.clementine-player.org/\n[64]:https://cmus.github.io/\n[65]:https://www.calligra.org/tour/calligra-suite/\n[66]:https://www.libreoffice.org/\n[67]:https://www.wps.com/\n[68]:http://wps-community.org/downloads\n[69]:http://shutter-project.org/\n[70]:https://launchpad.net/kazam\n[71]:https://gitlab.gnome.org/GNOME/gnome-screenshot\n[72]:http://www.maartenbaert.be/simplescreenrecorder/\n[73]:http://recordmydesktop.sourceforge.net/about.php\n[74]:https://atom.io/\n[75]:https://www.sublimetext.com/\n[76]:https://www.geany.org/\n[77]:https://wiki.gnome.org/Apps/Gedit\n[78]:https://everdo.net/\n[79]:https://www.fossmint.com/evernote-alternatives-for-linux/\n[80]:https://everdo.net/linux/\n[81]:https://taskwarrior.org/\n[82]:http://banshee.fm/\n[83]:https://www.videolan.org/\n[84]:https://kodi.tv/\n[85]:https://www.smplayer.info/\n[86]:https://www.virtualbox.org/wiki/VirtualBox\n[87]:https://www.vmware.com/\n[88]:https://www.tecmint.com/install-vmware-workstation-in-linux/\n[89]:https://www.google.com/chrome/\n[90]:https://www.mozilla.org/en-US/firefox/\n[91]:https://vivaldi.com/\n\n","source":"_posts/75-Most-Used-Essential-Linux-Applications-of-2018.md","raw":"---\ntitle: 75 个最常用的 Linux 应用程序（2018 年）\ndate: 2018-10-10 13:40:26\ntags:\n  - Linux\n  - 应用\n  - LCTT 翻译\n---\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Most-Used-Ubuntu-Applications.png)\n\n对于许多应用程序来说，2018 年是非常好的一年，尤其是自由开源的应用程序。尽管各种 Linux 发行版都自带了很多默认的应用程序，但用户也可以自由地选择使用它们或者其它任何免费或付费替代方案。\n\n下面汇总了[一系列的 Linux 应用程序][3]，这些应用程序都能够在 Linux 系统上安装，尽管还有很多其它选择。以下汇总中的任何应用程序都属于其类别中最常用的应用程序，如果你还没有用过，欢迎试用一下！\n\n### 备份工具\n\n#### Rsync\n\n[Rsync][4] 是一个开源的、节约带宽的工具，它用于执行快速的增量文件传输，而且它也是一个免费工具。\n\n```\n$ rsync [OPTION...] SRC... [DEST]\n```\n\n想要了解更多示例和用法，可以参考《[10 个使用 Rsync 命令的实际例子][5]》。\n\n#### Timeshift\n\n[Timeshift][6] 能够通过增量快照来保护用户的系统数据，而且可以按照日期恢复指定的快照，类似于 Mac OS 中的 Time Machine 功能和 Windows 中的系统还原功能。\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Timeshift-Create-Linux-Mint-Snapshot.png)\n\n### BT（BitTorrent） 客户端\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Torrent-Clients.png)\n\n#### Deluge\n\n[Deluge][7] 是一个漂亮的跨平台 BT 客户端，旨在优化 μTorrent 体验，并向用户免费提供服务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Deluge。\n\n```\n$ sudo add-apt-repository ppa:deluge-team/ppa\n$ sudo apt-get update\n$ sudo apt-get install deluge\n```\n\n#### qBittorent\n\n[qBittorent][8] 是一个开源的 BT 客户端，旨在提供类似 μTorrent 的免费替代方案。\n\n使用以下命令在 Ubuntu 和 Debian 安装 qBittorent。\n\n```\n$ sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable\n$ sudo apt-get update\n$ sudo apt-get install qbittorrent\n```\n\n#### Transmission\n\n[Transmission][9] 是一个强大的 BT 客户端，它主要关注速度和易用性，一般在很多 Linux 发行版上都有预装。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Transmission。\n\n```\n$ sudo add-apt-repository ppa:transmissionbt/ppa\n$ sudo apt-get update\n$ sudo apt-get install transmission-gtk transmission-cli transmission-common transmission-daemon\n```\n\n### 云存储\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Cloud-Storage.png)\n\n#### Dropbox\n\n[Dropbox][10] 团队在今年早些时候给他们的云服务换了一个名字，也为客户提供了更好的性能和集成了更多应用程序。Dropbox 会向用户免费提供 2 GB 存储空间。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Dropbox。\n\n```\n$ cd ~ && wget -O - \"https://www.dropbox.com/download?plat=lnx.x86\" | tar xzf - [On 32-Bit]\n$ cd ~ && wget -O - \"https://www.dropbox.com/download?plat=lnx.x86_64\" | tar xzf - [On 64-Bit]\n$ ~/.dropbox-dist/dropboxd\n```\n\n#### Google Drive\n\n[Google Drive][11] 是 Google 提供的云服务解决方案，这已经是一个广为人知的服务了。与 Dropbox 一样，可以通过它在所有联网的设备上同步文件。它免费提供了 15 GB 存储空间，包括Gmail、Google 图片、Google 地图等服务。\n\n参考阅读：[5 个适用于 Linux 的 Google Drive 客户端][12]\n\n#### Mega\n\n[Mega][13] 也是一个出色的云存储解决方案，它的亮点除了高度的安全性之外，还有为用户免费提供高达 50 GB 的免费存储空间。它使用端到端加密，以确保用户的数据安全，所以如果忘记了恢复密钥，用户自己也无法访问到存储的数据。\n\n参考阅读：[在 Ubuntu 下载 Mega 云存储客户端][14]\n\n### 命令行编辑器\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Commandline-Editors.png)\n\n#### Vim\n\n[Vim][15] 是 vi 文本编辑器的开源克隆版本，它的主要目的是可以高度定制化并能够处理任何类型的文本。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Vim。\n\n```\n$ sudo add-apt-repository ppa:jonathonf/vim\n$ sudo apt update\n$ sudo apt install vim\n```\n\n#### Emacs\n\n[Emacs][16] 是一个高度可配置的文本编辑器，最流行的一个分支 GNU Emacs 是用 Lisp 和 C 编写的，它的最大特点是可以自文档化、可扩展和可自定义。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Emacs。\n\n```\n$ sudo add-apt-repository ppa:kelleyk/emacs\n$ sudo apt update\n$ sudo apt install emacs25\n```\n\n#### Nano\n\n[Nano][17] 是一款功能丰富的命令行文本编辑器，比较适合高级用户。它可以通过多个终端进行不同功能的操作。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Nano。\n\n```\n$ sudo add-apt-repository ppa:n-muench/programs-ppa\n$ sudo apt-get update\n$ sudo apt-get install nano\n```\n\n### 下载器\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Download-Managers.png)\n\n#### Aria2\n\n[Aria2][18] 是一个开源的、轻量级的、多软件源和多协议的命令行下载器，它支持 Metalink、torrent、HTTP/HTTPS、SFTP 等多种协议。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Aria2。\n\n```\n$ sudo apt-get install aria2\n```\n\n#### uGet\n\n[uGet][19] 已经成为 Linux 各种发行版中排名第一的开源下载器，它可以处理任何下载任务，包括多连接、队列、类目等。\n\n使用以下命令在 Ubuntu 和 Debian 安装 uGet。\n\n```\n$ sudo add-apt-repository ppa:plushuang-tw/uget-stable\n$ sudo apt update\n$ sudo apt install uget\n```\n\n#### XDM\n\n[XDM][20]（Xtreme Download Manager）是一个使用 Java 编写的开源下载软件。和其它下载器一样，它可以结合队列、种子、浏览器使用，而且还带有视频采集器和智能调度器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 XDM。\n\n```\n$ sudo add-apt-repository ppa:noobslab/apps\n$ sudo apt-get update\n$ sudo apt-get install xdman\n```\n\n### 电子邮件客户端\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Email-Clients.png)\n\n#### Thunderbird\n\n[Thunderbird][21] 是最受欢迎的电子邮件客户端之一。它的优点包括免费、开源、可定制、功能丰富，而且最重要的是安装过程也很简便。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Thunderbird。\n\n```\n$ sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa\n$ sudo apt-get update\n$ sudo apt-get install thunderbird\n```\n\n#### Geary\n\n[Geary][22] 是一个基于 WebKitGTK+ 的开源电子邮件客户端。它是一个免费开源的功能丰富的软件，并被 GNOME 项目收录。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Geary。\n\n```\n$ sudo add-apt-repository ppa:geary-team/releases\n$ sudo apt-get update\n$ sudo apt-get install geary\n```\n\n#### Evolution\n\n[Evolution][23] 是一个免费开源的电子邮件客户端，可以用于电子邮件、会议日程、备忘录和联系人的管理。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Evolution。\n\n```\n$ sudo add-apt-repository ppa:gnome3-team/gnome3-staging\n$ sudo apt-get update\n$ sudo apt-get install evolution\n```\n\n### 财务软件\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Accounting-Software.png)\n\n#### GnuCash\n\n[GnuCash][24] 是一款免费的跨平台开源软件，它适用于个人和中小型企业的财务任务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 GnuCash。\n\n```\n$ sudo sh -c 'echo \"deb http://archive.getdeb.net/ubuntu $(lsb_release -sc)-getdeb apps\" >> /etc/apt/sources.list.d/getdeb.list'\n$ sudo apt-get update\n$ sudo apt-get install gnucash\n```\n\n#### KMyMoney\n\n[KMyMoney][25] 是一个财务管理软件，它可以提供商用或个人理财所需的大部分主要功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 KmyMoney。\n\n```\n$ sudo add-apt-repository ppa:claydoh/kmymoney2-kde4\n$ sudo apt-get update\n$ sudo apt-get install kmymoney\n```\n\n### IDE\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IDE-Editors.png)\n\n#### Eclipse IDE\n\n[Eclipse][26] 是最广为使用的 Java IDE，它包括一个基本工作空间和一个用于自定义编程环境的强大的的插件配置系统。\n\n关于 Eclipse IDE 的安装，可以参考 [如何在 Debian 和 Ubuntu 上安装 Eclipse IDE][27] 这一篇文章。\n\n#### Netbeans IDE\n\n[Netbeans][28] 是一个相当受用户欢迎的 IDE，它支持使用 Java、PHP、HTML 5、JavaScript、C/C++ 或其他语言编写移动应用，桌面软件和 web 应用。\n\n关于 Netbeans IDE 的安装，可以参考 [如何在 Debian 和 Ubuntu 上安装 Netbeans IDE][29] 这一篇文章。\n\n#### Brackets\n\n[Brackets][30] 是由 Adobe 开发的高级文本编辑器，它带有可视化工具，支持预处理程序，以及用于 web 开发的以设计为中心的用户流程。对于熟悉它的用户，它可以发挥 IDE 的作用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Brackets。\n\n```\n$ sudo add-apt-repository ppa:webupd8team/brackets\n$ sudo apt-get update\n$ sudo apt-get install brackets\n```\n\n#### Atom IDE\n\n[Atom IDE][31] 是一个加强版的 Atom 编辑器，它添加了大量扩展和库以提高性能和增加功能。总之，它是各方面都变得更强大了的 Atom 。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Atom。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install atom --classic\n```\n\n#### Light Table\n\n[Light Table][32] 号称下一代的 IDE，它提供了数据流量统计和协作编程等的强大功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Light Table。\n\n```\n$ sudo add-apt-repository ppa:dr-akulavich/lighttable\n$ sudo apt-get update\n$ sudo apt-get install lighttable-installer\n```\n\n#### Visual Studio Code\n\n[Visual Studio Code][33] 是由微软开发的代码编辑器，它包含了文本编辑器所需要的最先进的功能，包括语法高亮、自动完成、代码调试、性能统计和图表显示等功能。\n\n参考阅读：[在Ubuntu 下载 Visual Studio Code][34]\n\n### 即时通信工具\n\n![](https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IM-Clients.png)\n\n#### Pidgin\n\n[Pidgin][35] 是一个开源的即时通信工具，它几乎支持所有聊天平台，还支持额外扩展功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Pidgin。\n\n```\n$ sudo add-apt-repository ppa:jonathonf/backports\n$ sudo apt-get update\n$ sudo apt-get install pidgin\n```\n\n#### Skype\n\n[Skype][36] 也是一个广为人知的软件了，任何感兴趣的用户都可以在 Linux 上使用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Skype。\n\n```\n$ sudo apt install snapd\n$ sudo snap install skype --classic\n```\n\n#### Empathy\n\n[Empathy][37] 是一个支持多协议语音、视频聊天、文本和文件传输的即时通信工具。它还允许用户添加多个服务的帐户，并用其与所有服务的帐户进行交互。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Empathy。\n\n```\n$ sudo apt-get install empathy\n```\n\n### Linux 防病毒工具\n\n#### ClamAV/ClamTk\n\n[ClamAV][38] 是一个开源的跨平台命令行防病毒工具，用于检测木马、病毒和其他恶意代码。而 [ClamTk][39] 则是它的前端 GUI。\n\n使用以下命令在 Ubuntu 和 Debian 安装 ClamAV 和 ClamTk。\n\n```\n$ sudo apt-get install clamav\n$ sudo apt-get install clamtk\n```\n\n### Linux 桌面环境\n\n#### Cinnamon\n\n[Cinnamon][40] 是 GNOME 3 的自由开源衍生产品，它遵循传统的 <ruby>桌面比拟<rt>desktop metaphor</rt></ruby> 约定。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Cinnamon。\n\n```\n$ sudo add-apt-repository ppa:embrosyn/cinnamon\n$ sudo apt update\n$ sudo apt install cinnamon-desktop-environment lightdm\n```\n\n#### Mate\n\n[Mate][41] 桌面环境是 GNOME 2 的衍生和延续，目的是在 Linux 上通过使用传统的桌面比拟提供有一个吸引力的 UI。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Mate。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install ubuntu-mate-desktop\n```\n\n#### GNOME\n\n[GNOME][42] 是由一些免费和开源应用程序组成的桌面环境，它可以运行在任何 Linux 发行版和大多数 BSD 衍生版本上。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install ubuntu-desktop\n```\n\n#### KDE\n\n[KDE][43] 由 KDE 社区开发，它为用户提供图形解决方案以控制操作系统并执行不同的计算任务。\n\n使用以下命令在 Ubuntu 和 Debian 安装 KDE。\n\n```\n$ sudo apt install tasksel\n$ sudo apt update\n$ sudo tasksel install kubuntu-desktop\n```\n\n### Linux 维护工具\n\n#### GNOME Tweak Tool\n\n[GNOME Tweak Tool][44] 是用于自定义和调整 GNOME 3 和 GNOME Shell 设置的流行工具。\n\n使用以下命令在 Ubuntu 和 Debian 安装 GNOME Tweak Tool。\n\n```\n$ sudo apt install gnome-tweak-tool\n```\n\n#### Stacer\n\n[Stacer][45] 是一款用于监控和优化 Linux 系统的免费开源应用程序。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Stacer。\n\n```\n$ sudo add-apt-repository ppa:oguzhaninan/stacer\n$ sudo apt-get update\n$ sudo apt-get install stacer\n```\n\n#### BleachBit\n\n[BleachBit][46] 是一个免费的磁盘空间清理器，它也可用作隐私管理器和系统优化器。\n\n参考阅读：[在 Ubuntu 下载 BleachBit][47]\n\n### Linux 终端工具\n\n#### GNOME 终端\n\n[GNOME 终端][48] 是 GNOME 的默认终端模拟器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome 终端。\n\n```\n$ sudo apt-get install gnome-terminal\n```\n\n#### Konsole\n\n[Konsole][49] 是 KDE 的一个终端模拟器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Konsole。\n\n```\n$ sudo apt-get install konsole\n```\n\n#### Terminator\n\n[Terminator][50] 是一个功能丰富的终端程序，它基于 GNOME 终端，并且专注于整理终端功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Terminator。\n\n```\n$ sudo apt-get install terminator\n```\n\n#### Guake\n\n[Guake][51] 是 GNOME 桌面环境下一个轻量级的可下拉式终端。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Guake。\n\n```\n$ sudo apt-get install guake\n```\n\n### 多媒体编辑工具\n\n#### Ardour\n\n[Ardour][52] 是一款漂亮的的<ruby>数字音频工作站<rt>Digital Audio Workstation</rt></ruby>，可以完成专业的录制、编辑和混音工作。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Ardour。\n\n```\n$ sudo add-apt-repository ppa:dobey/audiotools\n$ sudo apt-get update\n$ sudo apt-get install ardour\n```\n\n#### Audacity\n\n[Audacity][53] 是最著名的音频编辑软件之一，它是一款跨平台的开源多轨音频编辑器。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Audacity。\n\n```\n$ sudo add-apt-repository ppa:ubuntuhandbook1/audacity\n$ sudo apt-get update\n$ sudo apt-get install audacity\n```\n\n#### GIMP\n\n[GIMP][54] 是 Photoshop 的开源替代品中最受欢迎的。这是因为它有多种可自定义的选项、第三方插件以及活跃的用户社区。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gimp。\n\n```\n$ sudo add-apt-repository ppa:otto-kesselgulasch/gimp\n$ sudo apt update\n$ sudo apt install gimp\n```\n\n#### Krita\n\n[Krita][55] 是一款开源的绘画程序，它具有美观的 UI 和可靠的性能，也可以用作图像处理工具。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Krita。\n\n```\n$ sudo add-apt-repository ppa:kritalime/ppa\n$ sudo apt update\n$ sudo apt install krita\n```\n\n#### Lightworks\n\n[Lightworks][56] 是一款功能强大、灵活美观的专业视频编辑工具。它拥有上百种配套的视觉效果功能，可以处理任何编辑任务，毕竟这个软件已经有长达 25 年的视频处理经验。\n\n参考阅读：[在 Ubuntu 下载 Lightworks][57]\n\n#### OpenShot\n\n[OpenShot][58] 是一款屡获殊荣的免费开源视频编辑器，这主要得益于其出色的性能和强大的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 `Openshot。\n\n```\n$ sudo add-apt-repository ppa:openshot.developers/ppa\n$ sudo apt update\n$ sudo apt install openshot-qt\n```\n\n#### PiTiV\n\n[Pitivi][59] 也是一个美观的视频编辑器，它有优美的代码库、优质的社区，还支持优秀的协作编辑功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 PiTiV。\n\n```\n$ flatpak install --user https://flathub.org/repo/appstream/org.pitivi.Pitivi.flatpakref\n$ flatpak install --user http://flatpak.pitivi.org/pitivi.flatpakref\n$ flatpak run org.pitivi.Pitivi//stable\n```\n\n### 音乐播放器\n\n#### Rhythmbox\n\n[Rhythmbox][60] 支持海量种类的音乐，目前被认为是最可靠的音乐播放器，并由 Ubuntu 自带。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Rhythmbox。\n\n```\n$ sudo add-apt-repository ppa:fossfreedom/rhythmbox\n$ sudo apt-get update\n$ sudo apt-get install rhythmbox\n```\n\n#### Lollypop\n\n[Lollypop][61] 是一款较为年轻的开源音乐播放器，它有很多高级选项，包括网络电台，滑动播放和派对模式。尽管功能繁多，它仍然尽量做到简单易管理。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Lollypop。\n\n```\n$ sudo add-apt-repository ppa:gnumdk/lollypop\n$ sudo apt-get update\n$ sudo apt-get install lollypop\n```\n\n#### Amarok\n\n[Amarok][62] 是一款功能强大的音乐播放器，它有一个直观的 UI 和大量的高级功能，而且允许用户根据自己的偏好去发现新音乐。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Amarok。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install amarok\n\n```\n\n#### Clementine\n\n[Clementine][63] 是一款 Amarok 风格的音乐播放器，因此和 Amarok 相似，也有直观的用户界面、先进的控制模块，以及让用户搜索和发现新音乐的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Clementine。\n\n```\n$ sudo add-apt-repository ppa:me-davidsansome/clementine\n$ sudo apt-get update\n$ sudo apt-get install clementine\n```\n\n#### Cmus\n\n[Cmus][64] 可以说是最高效的的命令行界面音乐播放器了，它具有快速可靠的特点，也支持使用扩展。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Cmus。\n\n```\n$ sudo add-apt-repository ppa:jmuc/cmus\n$ sudo apt-get update\n$ sudo apt-get install cmus\n```\n\n### 办公软件\n\n#### Calligra 套件\n\n[Calligra 套件][65]为用户提供了一套总共 8 个应用程序，涵盖办公、管理、图表等各个范畴。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Calligra 套件。\n\n```\n$ sudo apt-get install calligra\n```\n\n#### LibreOffice\n\n[LibreOffice][66] 是开源社区中开发过程最活跃的办公套件，它以可靠性著称，也可以通过扩展来添加功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 LibreOffice。\n\n```\n$ sudo add-apt-repository ppa:libreoffice/ppa\n$ sudo apt update\n$ sudo apt install libreoffice\n```\n\n#### WPS Office\n\n[WPS Office][67] 是一款漂亮的办公套件，它有一个很具现代感的 UI。\n\n参考阅读：[在 Ubuntu 安装 WPS Office][68]\n\n### 屏幕截图工具\n\n#### Shutter\n\n[Shutter][69] 允许用户截取桌面的屏幕截图，然后使用一些效果进行编辑，还支持上传和在线共享。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Shutter。\n\n```\n$ sudo add-apt-repository -y ppa:shutter/ppa\n$ sudo apt update\n$ sudo apt install shutter\n```\n\n#### Kazam\n\n[Kazam][70] 可以用于捕获屏幕截图，它的输出对于任何支持 VP8/WebM 和 PulseAudio 视频播放器都可用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Kazam。\n\n```\n$ sudo add-apt-repository ppa:kazam-team/unstable-series\n$ sudo apt update\n$ sudo apt install kazam python3-cairo python3-xlib\n```\n\n#### Gnome Screenshot\n\n[Gnome Screenshot][71] 过去曾经和 Gnome 一起捆绑，但现在已经独立出来。它以易于共享的格式进行截屏。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gnome Screenshot。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gnome-screenshot\n```\n\n### 录屏工具\n\n#### SimpleScreenRecorder\n\n[SimpleScreenRecorder][72] 面世时已经是录屏工具中的佼佼者，现在已成为 Linux 各个发行版中最有效、最易用的录屏工具之一。\n\n使用以下命令在 Ubuntu 和 Debian 安装 SimpleScreenRecorder。\n\n```\n$ sudo add-apt-repository ppa:maarten-baert/simplescreenrecorder\n$ sudo apt-get update\n$ sudo apt-get install simplescreenrecorder\n```\n\n#### recordMyDesktop\n\n[recordMyDesktop][73] 是一个开源的会话记录器，它也能记录桌面会话的音频。\n\n使用以下命令在 Ubuntu 和 Debian 安装 recordMyDesktop。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gtk-recordmydesktop\n```\n\n### 文本编辑器\n\n#### Atom\n\n[Atom][74] 是由 GitHub 开发和维护的可定制文本编辑器。它是开箱即用的，但也可以使用扩展和主题自定义 UI 来增强其功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Atom。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install atom --classic\n```\n\n#### Sublime Text\n\n[Sublime Text][75] 已经成为目前最棒的文本编辑器。它可定制、轻量灵活（即使打开了大量数据文件和加入了大量扩展），最重要的是可以永久免费使用。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Sublime Text。\n\n```\n$ sudo apt-get install snapd\n$ sudo snap install sublime-text\n```\n\n#### Geany\n\n[Geany][76] 是一个内存友好的文本编辑器，它具有基本的IDE功能，可以显示加载时间、扩展库函数等。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Geany。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install geany\n```\n\n#### Gedit\n\n[Gedit][77] 以其简单著称，在很多 Linux 发行版都有预装，它具有文本编辑器都具有的优秀的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Gedit。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install gedit\n```\n\n### 备忘录软件\n\n#### Evernote\n\n[Evernote][78] 是一款云上的笔记程序，它带有待办列表和提醒功能，能够与不同类型的笔记完美配合。\n\nEvernote 在 Linux 上没有官方提供的软件，但可以参考 [Linux 上的 6 个 Evernote 替代客户端][79] 这篇文章使用其它第三方工具。\n\n#### Everdo\n\n[Everdo][78] 是一款美观，安全，易兼容的备忘软件，可以用于处理待办事项和其它笔记。如果你认为 Evernote 有所不足，相信 Everdo 会是一个好的替代。\n\n参考阅读：[在 Ubuntu 下载 Everdo][80]\n\n#### Taskwarrior\n\n[Taskwarrior][81] 是一个用于管理个人任务的开源跨平台命令行应用，它的速度和无干扰的环境是它的两大特点。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Taskwarrior。\n\n```\n$ sudo apt-get update\n$ sudo apt-get install taskwarrior\n```\n\n### 视频播放器\n\n#### Banshee\n\n[Banshee][82] 是一个开源的支持多格式的媒体播放器，于 2005 年开始开发并逐渐成长。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Banshee。\n\n```\n$ sudo add-apt-repository ppa:banshee-team/ppa\n$ sudo apt-get update\n$ sudo apt-get install banshee\n```\n\n#### VLC\n\n[VLC][83] 是我最喜欢的视频播放器，它几乎可以播放任何格式的音频和视频，它还可以播放网络电台、录制桌面会话以及在线播放电影。\n\n使用以下命令在 Ubuntu 和 Debian 安装 VLC。\n\n```\n$ sudo add-apt-repository ppa:videolan/stable-daily\n$ sudo apt-get update\n$ sudo apt-get install vlc\n```\n\n#### Kodi\n\n[Kodi][84] 是世界上最着名的媒体播放器之一，它有一个成熟的媒体中心，可以播放本地和远程的多媒体文件。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Kodi。\n\n```\n$ sudo apt-get install software-properties-common\n$ sudo add-apt-repository ppa:team-xbmc/ppa\n$ sudo apt-get update\n$ sudo apt-get install kodi\n```\n\n#### SMPlayer\n\n[SMPlayer][85] 是 MPlayer 的 GUI 版本，所有流行的媒体格式它都能够处理，并且它还有从 YouTube 和 Chromcast 和下载字幕的功能。\n\n使用以下命令在 Ubuntu 和 Debian 安装 SMPlayer。\n\n```\n$ sudo add-apt-repository ppa:rvm/smplayer\n$ sudo apt-get update\n$ sudo apt-get install smplayer\n```\n\n### 虚拟化工具\n\n#### VirtualBox\n\n[VirtualBox][86] 是一个用于操作系统虚拟化的开源应用程序，在服务器、台式机和嵌入式系统上都可以运行。\n\n使用以下命令在 Ubuntu 和 Debian 安装 VirtualBox。\n\n```\n$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -\n$ wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -\n$ sudo apt-get update\n$ sudo apt-get install virtualbox-5.2\n$ virtualbox\n```\n\n#### VMWare\n\n[VMware][87] 是一个为客户提供平台虚拟化和云计算服务的数字工作区，是第一个成功将 x86 架构系统虚拟化的工作站。 VMware 工作站的其中一个产品就允许用户在虚拟内存中运行多个操作系统。\n\n参阅 [在 Ubuntu 上安装 VMWare Workstation Pro][88] 可以了解 VMWare 的安装。\n\n### 浏览器\n\n#### Chrome\n\n[Google Chrome][89] 无疑是最受欢迎的浏览器。Chrome 以其速度、简洁、安全、美观而受人喜爱，它遵循了 Google 的界面设计风格，是 web 开发人员不可缺少的浏览器，同时它也是免费开源的。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Google Chrome。\n\n```\n$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -\n$ sudo sh -c 'echo \"deb http://dl.google.com/linux/chrome/deb/ stable main\" >> /etc/apt/sources.list.d/google.list'\n$ sudo apt-get update\n$ sudo apt-get install google-chrome-stable\n```\n\n#### Firefox\n\n[Firefox Quantum][90] 是一款漂亮、快速、完善并且可自定义的浏览器。它也是自由开源的，包含有开发人员所需要的工具，对于初学者也没有任何使用门槛。\n\n使用以下命令在 Ubuntu 和 Debian 安装 Firefox Quantum。\n\n```\n$ sudo add-apt-repository ppa:mozillateam/firefox-next\n$ sudo apt update && sudo apt upgrade\n$ sudo apt install firefox\n```\n\n#### Vivaldi\n\n[Vivaldi][91] 是一个基于 Chrome 的自由开源项目，旨在通过添加扩展来使 Chrome 的功能更加完善。色彩丰富的界面，性能良好、灵活性强是它的几大特点。\n\n参考阅读：[在 Ubuntu 下载 Vivaldi][91]\n\n以上就是我的推荐，你还有更好的软件向大家分享吗？欢迎评论。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.fossmint.com/most-used-linux-applications/\n\n[a]:https://www.fossmint.com/author/dillivine/\n[1]:https://plus.google.com/share?url=https://www.fossmint.com/most-used-linux-applications/ \"Share on Google+\"\n[2]:https://www.linkedin.com/shareArticle?mini=true&url=https://www.fossmint.com/most-used-linux-applications/ \"Share on LinkedIn\"\n[3]:https://www.fossmint.com/awesome-linux-software/\n[4]:https://rsync.samba.org/\n[5]:https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/\n[6]:https://github.com/teejee2008/timeshift\n[7]:https://deluge-torrent.org/\n[8]:https://www.qbittorrent.org/\n[9]:https://transmissionbt.com/\n[10]:https://www.dropbox.com/\n[11]:https://www.google.com/drive/\n[12]:https://www.fossmint.com/best-google-drive-clients-for-linux/\n[13]:https://mega.nz/\n[14]:https://mega.nz/sync!linux\n[15]:https://www.vim.org/\n[16]:https://www.gnu.org/s/emacs/\n[17]:https://www.nano-editor.org/\n[18]:https://aria2.github.io/\n[19]:http://ugetdm.com/\n[20]:http://xdman.sourceforge.net/\n[21]:https://www.thunderbird.net/\n[22]:https://github.com/GNOME/geary\n[23]:https://github.com/GNOME/evolution\n[24]:https://www.gnucash.org/\n[25]:https://kmymoney.org/\n[26]:https://www.eclipse.org/ide/\n[27]:https://www.tecmint.com/install-eclipse-oxygen-ide-in-ubuntu-debian/\n[28]:https://netbeans.org/\n[29]:https://www.tecmint.com/install-netbeans-ide-in-ubuntu-debian-linux-mint/\n[30]:http://brackets.io/\n[31]:https://ide.atom.io/\n[32]:http://lighttable.com/\n[33]:https://code.visualstudio.com/\n[34]:https://code.visualstudio.com/download\n[35]:https://www.pidgin.im/\n[36]:https://www.skype.com/\n[37]:https://wiki.gnome.org/Apps/Empathy\n[38]:https://www.clamav.net/\n[39]:https://dave-theunsub.github.io/clamtk/\n[40]:https://github.com/linuxmint/cinnamon-desktop\n[41]:https://mate-desktop.org/\n[42]:https://www.gnome.org/\n[43]:https://www.kde.org/plasma-desktop\n[44]:https://github.com/nzjrs/gnome-tweak-tool\n[45]:https://github.com/oguzhaninan/Stacer\n[46]:https://www.bleachbit.org/\n[47]:https://www.bleachbit.org/download\n[48]:https://github.com/GNOME/gnome-terminal\n[49]:https://konsole.kde.org/\n[50]:https://gnometerminator.blogspot.com/p/introduction.html\n[51]:http://guake-project.org/\n[52]:https://ardour.org/\n[53]:https://www.audacityteam.org/\n[54]:https://www.gimp.org/\n[55]:https://krita.org/en/\n[56]:https://www.lwks.com/\n[57]:https://www.lwks.com/index.php?option=com_lwks&view=download&Itemid=206\n[58]:https://www.openshot.org/\n[59]:http://www.pitivi.org/\n[60]:https://wiki.gnome.org/Apps/Rhythmbox\n[61]:https://gnumdk.github.io/lollypop-web/\n[62]:https://amarok.kde.org/en\n[63]:https://www.clementine-player.org/\n[64]:https://cmus.github.io/\n[65]:https://www.calligra.org/tour/calligra-suite/\n[66]:https://www.libreoffice.org/\n[67]:https://www.wps.com/\n[68]:http://wps-community.org/downloads\n[69]:http://shutter-project.org/\n[70]:https://launchpad.net/kazam\n[71]:https://gitlab.gnome.org/GNOME/gnome-screenshot\n[72]:http://www.maartenbaert.be/simplescreenrecorder/\n[73]:http://recordmydesktop.sourceforge.net/about.php\n[74]:https://atom.io/\n[75]:https://www.sublimetext.com/\n[76]:https://www.geany.org/\n[77]:https://wiki.gnome.org/Apps/Gedit\n[78]:https://everdo.net/\n[79]:https://www.fossmint.com/evernote-alternatives-for-linux/\n[80]:https://everdo.net/linux/\n[81]:https://taskwarrior.org/\n[82]:http://banshee.fm/\n[83]:https://www.videolan.org/\n[84]:https://kodi.tv/\n[85]:https://www.smplayer.info/\n[86]:https://www.virtualbox.org/wiki/VirtualBox\n[87]:https://www.vmware.com/\n[88]:https://www.tecmint.com/install-vmware-workstation-in-linux/\n[89]:https://www.google.com/chrome/\n[90]:https://www.mozilla.org/en-US/firefox/\n[91]:https://vivaldi.com/\n\n","slug":"75-Most-Used-Essential-Linux-Applications-of-2018","published":1,"updated":"2019-03-28T11:18:29.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0c5000elixuojv49b1j","content":"<p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Most-Used-Ubuntu-Applications.png\" alt=\"\"></p>\n<p>对于许多应用程序来说，2018 年是非常好的一年，尤其是自由开源的应用程序。尽管各种 Linux 发行版都自带了很多默认的应用程序，但用户也可以自由地选择使用它们或者其它任何免费或付费替代方案。</p>\n<p>下面汇总了<a href=\"https://www.fossmint.com/awesome-linux-software/\" target=\"_blank\" rel=\"noopener\">一系列的 Linux 应用程序</a>，这些应用程序都能够在 Linux 系统上安装，尽管还有很多其它选择。以下汇总中的任何应用程序都属于其类别中最常用的应用程序，如果你还没有用过，欢迎试用一下！</p>\n<h3 id=\"备份工具\"><a href=\"#备份工具\" class=\"headerlink\" title=\"备份工具\"></a>备份工具</h3><h4 id=\"Rsync\"><a href=\"#Rsync\" class=\"headerlink\" title=\"Rsync\"></a>Rsync</h4><p><a href=\"https://rsync.samba.org/\" target=\"_blank\" rel=\"noopener\">Rsync</a> 是一个开源的、节约带宽的工具，它用于执行快速的增量文件传输，而且它也是一个免费工具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rsync [OPTION...] SRC... [DEST]</span><br></pre></td></tr></table></figure>\n<p>想要了解更多示例和用法，可以参考《<a href=\"https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/\" target=\"_blank\" rel=\"noopener\">10 个使用 Rsync 命令的实际例子</a>》。</p>\n<h4 id=\"Timeshift\"><a href=\"#Timeshift\" class=\"headerlink\" title=\"Timeshift\"></a>Timeshift</h4><p><a href=\"https://github.com/teejee2008/timeshift\" target=\"_blank\" rel=\"noopener\">Timeshift</a> 能够通过增量快照来保护用户的系统数据，而且可以按照日期恢复指定的快照，类似于 Mac OS 中的 Time Machine 功能和 Windows 中的系统还原功能。</p>\n<p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Timeshift-Create-Linux-Mint-Snapshot.png\" alt=\"\"></p>\n<h3 id=\"BT（BitTorrent）-客户端\"><a href=\"#BT（BitTorrent）-客户端\" class=\"headerlink\" title=\"BT（BitTorrent） 客户端\"></a>BT（BitTorrent） 客户端</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Torrent-Clients.png\" alt=\"\"></p>\n<h4 id=\"Deluge\"><a href=\"#Deluge\" class=\"headerlink\" title=\"Deluge\"></a>Deluge</h4><p><a href=\"https://deluge-torrent.org/\" target=\"_blank\" rel=\"noopener\">Deluge</a> 是一个漂亮的跨平台 BT 客户端，旨在优化 μTorrent 体验，并向用户免费提供服务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Deluge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:deluge-team/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install deluge</span><br></pre></td></tr></table></figure>\n<h4 id=\"qBittorent\"><a href=\"#qBittorent\" class=\"headerlink\" title=\"qBittorent\"></a>qBittorent</h4><p><a href=\"https://www.qbittorrent.org/\" target=\"_blank\" rel=\"noopener\">qBittorent</a> 是一个开源的 BT 客户端，旨在提供类似 μTorrent 的免费替代方案。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 qBittorent。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install qbittorrent</span><br></pre></td></tr></table></figure>\n<h4 id=\"Transmission\"><a href=\"#Transmission\" class=\"headerlink\" title=\"Transmission\"></a>Transmission</h4><p><a href=\"https://transmissionbt.com/\" target=\"_blank\" rel=\"noopener\">Transmission</a> 是一个强大的 BT 客户端，它主要关注速度和易用性，一般在很多 Linux 发行版上都有预装。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Transmission。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:transmissionbt/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install transmission-gtk transmission-cli transmission-common transmission-daemon</span><br></pre></td></tr></table></figure>\n<h3 id=\"云存储\"><a href=\"#云存储\" class=\"headerlink\" title=\"云存储\"></a>云存储</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Cloud-Storage.png\" alt=\"\"></p>\n<h4 id=\"Dropbox\"><a href=\"#Dropbox\" class=\"headerlink\" title=\"Dropbox\"></a>Dropbox</h4><p><a href=\"https://www.dropbox.com/\" target=\"_blank\" rel=\"noopener\">Dropbox</a> 团队在今年早些时候给他们的云服务换了一个名字，也为客户提供了更好的性能和集成了更多应用程序。Dropbox 会向用户免费提供 2 GB 存储空间。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Dropbox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86&quot; | tar xzf - [On 32-Bit]</span><br><span class=\"line\">$ cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86_64&quot; | tar xzf - [On 64-Bit]</span><br><span class=\"line\">$ ~/.dropbox-dist/dropboxd</span><br></pre></td></tr></table></figure>\n<h4 id=\"Google-Drive\"><a href=\"#Google-Drive\" class=\"headerlink\" title=\"Google Drive\"></a>Google Drive</h4><p><a href=\"https://www.google.com/drive/\" target=\"_blank\" rel=\"noopener\">Google Drive</a> 是 Google 提供的云服务解决方案，这已经是一个广为人知的服务了。与 Dropbox 一样，可以通过它在所有联网的设备上同步文件。它免费提供了 15 GB 存储空间，包括Gmail、Google 图片、Google 地图等服务。</p>\n<p>参考阅读：<a href=\"https://www.fossmint.com/best-google-drive-clients-for-linux/\" target=\"_blank\" rel=\"noopener\">5 个适用于 Linux 的 Google Drive 客户端</a></p>\n<h4 id=\"Mega\"><a href=\"#Mega\" class=\"headerlink\" title=\"Mega\"></a>Mega</h4><p><a href=\"https://mega.nz/\" target=\"_blank\" rel=\"noopener\">Mega</a> 也是一个出色的云存储解决方案，它的亮点除了高度的安全性之外，还有为用户免费提供高达 50 GB 的免费存储空间。它使用端到端加密，以确保用户的数据安全，所以如果忘记了恢复密钥，用户自己也无法访问到存储的数据。</p>\n<p>参考阅读：<a href=\"https://mega.nz/sync!linux\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Mega 云存储客户端</a></p>\n<h3 id=\"命令行编辑器\"><a href=\"#命令行编辑器\" class=\"headerlink\" title=\"命令行编辑器\"></a>命令行编辑器</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Commandline-Editors.png\" alt=\"\"></p>\n<h4 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h4><p><a href=\"https://www.vim.org/\" target=\"_blank\" rel=\"noopener\">Vim</a> 是 vi 文本编辑器的开源克隆版本，它的主要目的是可以高度定制化并能够处理任何类型的文本。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Vim。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jonathonf/vim</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install vim</span><br></pre></td></tr></table></figure>\n<h4 id=\"Emacs\"><a href=\"#Emacs\" class=\"headerlink\" title=\"Emacs\"></a>Emacs</h4><p><a href=\"https://www.gnu.org/s/emacs/\" target=\"_blank\" rel=\"noopener\">Emacs</a> 是一个高度可配置的文本编辑器，最流行的一个分支 GNU Emacs 是用 Lisp 和 C 编写的，它的最大特点是可以自文档化、可扩展和可自定义。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Emacs。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kelleyk/emacs</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install emacs25</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nano\"><a href=\"#Nano\" class=\"headerlink\" title=\"Nano\"></a>Nano</h4><p><a href=\"https://www.nano-editor.org/\" target=\"_blank\" rel=\"noopener\">Nano</a> 是一款功能丰富的命令行文本编辑器，比较适合高级用户。它可以通过多个终端进行不同功能的操作。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Nano。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:n-muench/programs-ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install nano</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载器\"><a href=\"#下载器\" class=\"headerlink\" title=\"下载器\"></a>下载器</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Download-Managers.png\" alt=\"\"></p>\n<h4 id=\"Aria2\"><a href=\"#Aria2\" class=\"headerlink\" title=\"Aria2\"></a>Aria2</h4><p><a href=\"https://aria2.github.io/\" target=\"_blank\" rel=\"noopener\">Aria2</a> 是一个开源的、轻量级的、多软件源和多协议的命令行下载器，它支持 Metalink、torrent、HTTP/HTTPS、SFTP 等多种协议。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Aria2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install aria2</span><br></pre></td></tr></table></figure>\n<h4 id=\"uGet\"><a href=\"#uGet\" class=\"headerlink\" title=\"uGet\"></a>uGet</h4><p><a href=\"http://ugetdm.com/\" target=\"_blank\" rel=\"noopener\">uGet</a> 已经成为 Linux 各种发行版中排名第一的开源下载器，它可以处理任何下载任务，包括多连接、队列、类目等。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 uGet。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:plushuang-tw/uget-stable</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install uget</span><br></pre></td></tr></table></figure>\n<h4 id=\"XDM\"><a href=\"#XDM\" class=\"headerlink\" title=\"XDM\"></a>XDM</h4><p><a href=\"http://xdman.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">XDM</a>（Xtreme Download Manager）是一个使用 Java 编写的开源下载软件。和其它下载器一样，它可以结合队列、种子、浏览器使用，而且还带有视频采集器和智能调度器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 XDM。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:noobslab/apps</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install xdman</span><br></pre></td></tr></table></figure>\n<h3 id=\"电子邮件客户端\"><a href=\"#电子邮件客户端\" class=\"headerlink\" title=\"电子邮件客户端\"></a>电子邮件客户端</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Email-Clients.png\" alt=\"\"></p>\n<h4 id=\"Thunderbird\"><a href=\"#Thunderbird\" class=\"headerlink\" title=\"Thunderbird\"></a>Thunderbird</h4><p><a href=\"https://www.thunderbird.net/\" target=\"_blank\" rel=\"noopener\">Thunderbird</a> 是最受欢迎的电子邮件客户端之一。它的优点包括免费、开源、可定制、功能丰富，而且最重要的是安装过程也很简便。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Thunderbird。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install thunderbird</span><br></pre></td></tr></table></figure>\n<h4 id=\"Geary\"><a href=\"#Geary\" class=\"headerlink\" title=\"Geary\"></a>Geary</h4><p><a href=\"https://github.com/GNOME/geary\" target=\"_blank\" rel=\"noopener\">Geary</a> 是一个基于 WebKitGTK+ 的开源电子邮件客户端。它是一个免费开源的功能丰富的软件，并被 GNOME 项目收录。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Geary。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:geary-team/releases</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install geary</span><br></pre></td></tr></table></figure>\n<h4 id=\"Evolution\"><a href=\"#Evolution\" class=\"headerlink\" title=\"Evolution\"></a>Evolution</h4><p><a href=\"https://github.com/GNOME/evolution\" target=\"_blank\" rel=\"noopener\">Evolution</a> 是一个免费开源的电子邮件客户端，可以用于电子邮件、会议日程、备忘录和联系人的管理。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Evolution。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:gnome3-team/gnome3-staging</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install evolution</span><br></pre></td></tr></table></figure>\n<h3 id=\"财务软件\"><a href=\"#财务软件\" class=\"headerlink\" title=\"财务软件\"></a>财务软件</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Accounting-Software.png\" alt=\"\"></p>\n<h4 id=\"GnuCash\"><a href=\"#GnuCash\" class=\"headerlink\" title=\"GnuCash\"></a>GnuCash</h4><p><a href=\"https://www.gnucash.org/\" target=\"_blank\" rel=\"noopener\">GnuCash</a> 是一款免费的跨平台开源软件，它适用于个人和中小型企业的财务任务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 GnuCash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo sh -c &apos;echo &quot;deb http://archive.getdeb.net/ubuntu $(lsb_release -sc)-getdeb apps&quot; &gt;&gt; /etc/apt/sources.list.d/getdeb.list&apos;</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gnucash</span><br></pre></td></tr></table></figure>\n<h4 id=\"KMyMoney\"><a href=\"#KMyMoney\" class=\"headerlink\" title=\"KMyMoney\"></a>KMyMoney</h4><p><a href=\"https://kmymoney.org/\" target=\"_blank\" rel=\"noopener\">KMyMoney</a> 是一个财务管理软件，它可以提供商用或个人理财所需的大部分主要功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 KmyMoney。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:claydoh/kmymoney2-kde4</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install kmymoney</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IDE-Editors.png\" alt=\"\"></p>\n<h4 id=\"Eclipse-IDE\"><a href=\"#Eclipse-IDE\" class=\"headerlink\" title=\"Eclipse IDE\"></a>Eclipse IDE</h4><p><a href=\"https://www.eclipse.org/ide/\" target=\"_blank\" rel=\"noopener\">Eclipse</a> 是最广为使用的 Java IDE，它包括一个基本工作空间和一个用于自定义编程环境的强大的的插件配置系统。</p>\n<p>关于 Eclipse IDE 的安装，可以参考 <a href=\"https://www.tecmint.com/install-eclipse-oxygen-ide-in-ubuntu-debian/\" target=\"_blank\" rel=\"noopener\">如何在 Debian 和 Ubuntu 上安装 Eclipse IDE</a> 这一篇文章。</p>\n<h4 id=\"Netbeans-IDE\"><a href=\"#Netbeans-IDE\" class=\"headerlink\" title=\"Netbeans IDE\"></a>Netbeans IDE</h4><p><a href=\"https://netbeans.org/\" target=\"_blank\" rel=\"noopener\">Netbeans</a> 是一个相当受用户欢迎的 IDE，它支持使用 Java、PHP、HTML 5、JavaScript、C/C++ 或其他语言编写移动应用，桌面软件和 web 应用。</p>\n<p>关于 Netbeans IDE 的安装，可以参考 <a href=\"https://www.tecmint.com/install-netbeans-ide-in-ubuntu-debian-linux-mint/\" target=\"_blank\" rel=\"noopener\">如何在 Debian 和 Ubuntu 上安装 Netbeans IDE</a> 这一篇文章。</p>\n<h4 id=\"Brackets\"><a href=\"#Brackets\" class=\"headerlink\" title=\"Brackets\"></a>Brackets</h4><p><a href=\"http://brackets.io/\" target=\"_blank\" rel=\"noopener\">Brackets</a> 是由 Adobe 开发的高级文本编辑器，它带有可视化工具，支持预处理程序，以及用于 web 开发的以设计为中心的用户流程。对于熟悉它的用户，它可以发挥 IDE 的作用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Brackets。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:webupd8team/brackets</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install brackets</span><br></pre></td></tr></table></figure>\n<h4 id=\"Atom-IDE\"><a href=\"#Atom-IDE\" class=\"headerlink\" title=\"Atom IDE\"></a>Atom IDE</h4><p><a href=\"https://ide.atom.io/\" target=\"_blank\" rel=\"noopener\">Atom IDE</a> 是一个加强版的 Atom 编辑器，它添加了大量扩展和库以提高性能和增加功能。总之，它是各方面都变得更强大了的 Atom 。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Atom。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install atom --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Light-Table\"><a href=\"#Light-Table\" class=\"headerlink\" title=\"Light Table\"></a>Light Table</h4><p><a href=\"http://lighttable.com/\" target=\"_blank\" rel=\"noopener\">Light Table</a> 号称下一代的 IDE，它提供了数据流量统计和协作编程等的强大功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Light Table。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:dr-akulavich/lighttable</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install lighttable-installer</span><br></pre></td></tr></table></figure>\n<h4 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h4><p><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a> 是由微软开发的代码编辑器，它包含了文本编辑器所需要的最先进的功能，包括语法高亮、自动完成、代码调试、性能统计和图表显示等功能。</p>\n<p>参考阅读：<a href=\"https://code.visualstudio.com/download\" target=\"_blank\" rel=\"noopener\">在Ubuntu 下载 Visual Studio Code</a></p>\n<h3 id=\"即时通信工具\"><a href=\"#即时通信工具\" class=\"headerlink\" title=\"即时通信工具\"></a>即时通信工具</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IM-Clients.png\" alt=\"\"></p>\n<h4 id=\"Pidgin\"><a href=\"#Pidgin\" class=\"headerlink\" title=\"Pidgin\"></a>Pidgin</h4><p><a href=\"https://www.pidgin.im/\" target=\"_blank\" rel=\"noopener\">Pidgin</a> 是一个开源的即时通信工具，它几乎支持所有聊天平台，还支持额外扩展功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Pidgin。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jonathonf/backports</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install pidgin</span><br></pre></td></tr></table></figure>\n<h4 id=\"Skype\"><a href=\"#Skype\" class=\"headerlink\" title=\"Skype\"></a>Skype</h4><p><a href=\"https://www.skype.com/\" target=\"_blank\" rel=\"noopener\">Skype</a> 也是一个广为人知的软件了，任何感兴趣的用户都可以在 Linux 上使用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Skype。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install snapd</span><br><span class=\"line\">$ sudo snap install skype --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Empathy\"><a href=\"#Empathy\" class=\"headerlink\" title=\"Empathy\"></a>Empathy</h4><p><a href=\"https://wiki.gnome.org/Apps/Empathy\" target=\"_blank\" rel=\"noopener\">Empathy</a> 是一个支持多协议语音、视频聊天、文本和文件传输的即时通信工具。它还允许用户添加多个服务的帐户，并用其与所有服务的帐户进行交互。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Empathy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install empathy</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-防病毒工具\"><a href=\"#Linux-防病毒工具\" class=\"headerlink\" title=\"Linux 防病毒工具\"></a>Linux 防病毒工具</h3><h4 id=\"ClamAV-ClamTk\"><a href=\"#ClamAV-ClamTk\" class=\"headerlink\" title=\"ClamAV/ClamTk\"></a>ClamAV/ClamTk</h4><p><a href=\"https://www.clamav.net/\" target=\"_blank\" rel=\"noopener\">ClamAV</a> 是一个开源的跨平台命令行防病毒工具，用于检测木马、病毒和其他恶意代码。而 <a href=\"https://dave-theunsub.github.io/clamtk/\" target=\"_blank\" rel=\"noopener\">ClamTk</a> 则是它的前端 GUI。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 ClamAV 和 ClamTk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install clamav</span><br><span class=\"line\">$ sudo apt-get install clamtk</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-桌面环境\"><a href=\"#Linux-桌面环境\" class=\"headerlink\" title=\"Linux 桌面环境\"></a>Linux 桌面环境</h3><h4 id=\"Cinnamon\"><a href=\"#Cinnamon\" class=\"headerlink\" title=\"Cinnamon\"></a>Cinnamon</h4><p><a href=\"https://github.com/linuxmint/cinnamon-desktop\" target=\"_blank\" rel=\"noopener\">Cinnamon</a> 是 GNOME 3 的自由开源衍生产品，它遵循传统的 <ruby>桌面比拟<rt>desktop metaphor</rt></ruby> 约定。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Cinnamon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:embrosyn/cinnamon</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install cinnamon-desktop-environment lightdm</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mate\"><a href=\"#Mate\" class=\"headerlink\" title=\"Mate\"></a>Mate</h4><p><a href=\"https://mate-desktop.org/\" target=\"_blank\" rel=\"noopener\">Mate</a> 桌面环境是 GNOME 2 的衍生和延续，目的是在 Linux 上通过使用传统的桌面比拟提供有一个吸引力的 UI。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Mate。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install ubuntu-mate-desktop</span><br></pre></td></tr></table></figure>\n<h4 id=\"GNOME\"><a href=\"#GNOME\" class=\"headerlink\" title=\"GNOME\"></a>GNOME</h4><p><a href=\"https://www.gnome.org/\" target=\"_blank\" rel=\"noopener\">GNOME</a> 是由一些免费和开源应用程序组成的桌面环境，它可以运行在任何 Linux 发行版和大多数 BSD 衍生版本上。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install ubuntu-desktop</span><br></pre></td></tr></table></figure>\n<h4 id=\"KDE\"><a href=\"#KDE\" class=\"headerlink\" title=\"KDE\"></a>KDE</h4><p><a href=\"https://www.kde.org/plasma-desktop\" target=\"_blank\" rel=\"noopener\">KDE</a> 由 KDE 社区开发，它为用户提供图形解决方案以控制操作系统并执行不同的计算任务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 KDE。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install kubuntu-desktop</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-维护工具\"><a href=\"#Linux-维护工具\" class=\"headerlink\" title=\"Linux 维护工具\"></a>Linux 维护工具</h3><h4 id=\"GNOME-Tweak-Tool\"><a href=\"#GNOME-Tweak-Tool\" class=\"headerlink\" title=\"GNOME Tweak Tool\"></a>GNOME Tweak Tool</h4><p><a href=\"https://github.com/nzjrs/gnome-tweak-tool\" target=\"_blank\" rel=\"noopener\">GNOME Tweak Tool</a> 是用于自定义和调整 GNOME 3 和 GNOME Shell 设置的流行工具。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 GNOME Tweak Tool。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n<h4 id=\"Stacer\"><a href=\"#Stacer\" class=\"headerlink\" title=\"Stacer\"></a>Stacer</h4><p><a href=\"https://github.com/oguzhaninan/Stacer\" target=\"_blank\" rel=\"noopener\">Stacer</a> 是一款用于监控和优化 Linux 系统的免费开源应用程序。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Stacer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:oguzhaninan/stacer</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install stacer</span><br></pre></td></tr></table></figure>\n<h4 id=\"BleachBit\"><a href=\"#BleachBit\" class=\"headerlink\" title=\"BleachBit\"></a>BleachBit</h4><p><a href=\"https://www.bleachbit.org/\" target=\"_blank\" rel=\"noopener\">BleachBit</a> 是一个免费的磁盘空间清理器，它也可用作隐私管理器和系统优化器。</p>\n<p>参考阅读：<a href=\"https://www.bleachbit.org/download\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 BleachBit</a></p>\n<h3 id=\"Linux-终端工具\"><a href=\"#Linux-终端工具\" class=\"headerlink\" title=\"Linux 终端工具\"></a>Linux 终端工具</h3><h4 id=\"GNOME-终端\"><a href=\"#GNOME-终端\" class=\"headerlink\" title=\"GNOME 终端\"></a>GNOME 终端</h4><p><a href=\"https://github.com/GNOME/gnome-terminal\" target=\"_blank\" rel=\"noopener\">GNOME 终端</a> 是 GNOME 的默认终端模拟器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome 终端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install gnome-terminal</span><br></pre></td></tr></table></figure>\n<h4 id=\"Konsole\"><a href=\"#Konsole\" class=\"headerlink\" title=\"Konsole\"></a>Konsole</h4><p><a href=\"https://konsole.kde.org/\" target=\"_blank\" rel=\"noopener\">Konsole</a> 是 KDE 的一个终端模拟器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Konsole。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install konsole</span><br></pre></td></tr></table></figure>\n<h4 id=\"Terminator\"><a href=\"#Terminator\" class=\"headerlink\" title=\"Terminator\"></a>Terminator</h4><p><a href=\"https://gnometerminator.blogspot.com/p/introduction.html\" target=\"_blank\" rel=\"noopener\">Terminator</a> 是一个功能丰富的终端程序，它基于 GNOME 终端，并且专注于整理终端功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Terminator。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install terminator</span><br></pre></td></tr></table></figure>\n<h4 id=\"Guake\"><a href=\"#Guake\" class=\"headerlink\" title=\"Guake\"></a>Guake</h4><p><a href=\"http://guake-project.org/\" target=\"_blank\" rel=\"noopener\">Guake</a> 是 GNOME 桌面环境下一个轻量级的可下拉式终端。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Guake。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install guake</span><br></pre></td></tr></table></figure>\n<h3 id=\"多媒体编辑工具\"><a href=\"#多媒体编辑工具\" class=\"headerlink\" title=\"多媒体编辑工具\"></a>多媒体编辑工具</h3><h4 id=\"Ardour\"><a href=\"#Ardour\" class=\"headerlink\" title=\"Ardour\"></a>Ardour</h4><p><a href=\"https://ardour.org/\" target=\"_blank\" rel=\"noopener\">Ardour</a> 是一款漂亮的的<ruby>数字音频工作站<rt>Digital Audio Workstation</rt></ruby>，可以完成专业的录制、编辑和混音工作。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Ardour。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:dobey/audiotools</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install ardour</span><br></pre></td></tr></table></figure>\n<h4 id=\"Audacity\"><a href=\"#Audacity\" class=\"headerlink\" title=\"Audacity\"></a>Audacity</h4><p><a href=\"https://www.audacityteam.org/\" target=\"_blank\" rel=\"noopener\">Audacity</a> 是最著名的音频编辑软件之一，它是一款跨平台的开源多轨音频编辑器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Audacity。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:ubuntuhandbook1/audacity</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install audacity</span><br></pre></td></tr></table></figure>\n<h4 id=\"GIMP\"><a href=\"#GIMP\" class=\"headerlink\" title=\"GIMP\"></a>GIMP</h4><p><a href=\"https://www.gimp.org/\" target=\"_blank\" rel=\"noopener\">GIMP</a> 是 Photoshop 的开源替代品中最受欢迎的。这是因为它有多种可自定义的选项、第三方插件以及活跃的用户社区。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gimp。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:otto-kesselgulasch/gimp</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install gimp</span><br></pre></td></tr></table></figure>\n<h4 id=\"Krita\"><a href=\"#Krita\" class=\"headerlink\" title=\"Krita\"></a>Krita</h4><p><a href=\"https://krita.org/en/\" target=\"_blank\" rel=\"noopener\">Krita</a> 是一款开源的绘画程序，它具有美观的 UI 和可靠的性能，也可以用作图像处理工具。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Krita。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kritalime/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install krita</span><br></pre></td></tr></table></figure>\n<h4 id=\"Lightworks\"><a href=\"#Lightworks\" class=\"headerlink\" title=\"Lightworks\"></a>Lightworks</h4><p><a href=\"https://www.lwks.com/\" target=\"_blank\" rel=\"noopener\">Lightworks</a> 是一款功能强大、灵活美观的专业视频编辑工具。它拥有上百种配套的视觉效果功能，可以处理任何编辑任务，毕竟这个软件已经有长达 25 年的视频处理经验。</p>\n<p>参考阅读：<a href=\"https://www.lwks.com/index.php?option=com_lwks&amp;view=download&amp;Itemid=206\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Lightworks</a></p>\n<h4 id=\"OpenShot\"><a href=\"#OpenShot\" class=\"headerlink\" title=\"OpenShot\"></a>OpenShot</h4><p><a href=\"https://www.openshot.org/\" target=\"_blank\" rel=\"noopener\">OpenShot</a> 是一款屡获殊荣的免费开源视频编辑器，这主要得益于其出色的性能和强大的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 `Openshot。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:openshot.developers/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install openshot-qt</span><br></pre></td></tr></table></figure>\n<h4 id=\"PiTiV\"><a href=\"#PiTiV\" class=\"headerlink\" title=\"PiTiV\"></a>PiTiV</h4><p><a href=\"http://www.pitivi.org/\" target=\"_blank\" rel=\"noopener\">Pitivi</a> 也是一个美观的视频编辑器，它有优美的代码库、优质的社区，还支持优秀的协作编辑功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 PiTiV。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flatpak install --user https://flathub.org/repo/appstream/org.pitivi.Pitivi.flatpakref</span><br><span class=\"line\">$ flatpak install --user http://flatpak.pitivi.org/pitivi.flatpakref</span><br><span class=\"line\">$ flatpak run org.pitivi.Pitivi//stable</span><br></pre></td></tr></table></figure>\n<h3 id=\"音乐播放器\"><a href=\"#音乐播放器\" class=\"headerlink\" title=\"音乐播放器\"></a>音乐播放器</h3><h4 id=\"Rhythmbox\"><a href=\"#Rhythmbox\" class=\"headerlink\" title=\"Rhythmbox\"></a>Rhythmbox</h4><p><a href=\"https://wiki.gnome.org/Apps/Rhythmbox\" target=\"_blank\" rel=\"noopener\">Rhythmbox</a> 支持海量种类的音乐，目前被认为是最可靠的音乐播放器，并由 Ubuntu 自带。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Rhythmbox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:fossfreedom/rhythmbox</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install rhythmbox</span><br></pre></td></tr></table></figure>\n<h4 id=\"Lollypop\"><a href=\"#Lollypop\" class=\"headerlink\" title=\"Lollypop\"></a>Lollypop</h4><p><a href=\"https://gnumdk.github.io/lollypop-web/\" target=\"_blank\" rel=\"noopener\">Lollypop</a> 是一款较为年轻的开源音乐播放器，它有很多高级选项，包括网络电台，滑动播放和派对模式。尽管功能繁多，它仍然尽量做到简单易管理。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Lollypop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:gnumdk/lollypop</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install lollypop</span><br></pre></td></tr></table></figure>\n<h4 id=\"Amarok\"><a href=\"#Amarok\" class=\"headerlink\" title=\"Amarok\"></a>Amarok</h4><p><a href=\"https://amarok.kde.org/en\" target=\"_blank\" rel=\"noopener\">Amarok</a> 是一款功能强大的音乐播放器，它有一个直观的 UI 和大量的高级功能，而且允许用户根据自己的偏好去发现新音乐。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Amarok。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install amarok</span><br></pre></td></tr></table></figure>\n<h4 id=\"Clementine\"><a href=\"#Clementine\" class=\"headerlink\" title=\"Clementine\"></a>Clementine</h4><p><a href=\"https://www.clementine-player.org/\" target=\"_blank\" rel=\"noopener\">Clementine</a> 是一款 Amarok 风格的音乐播放器，因此和 Amarok 相似，也有直观的用户界面、先进的控制模块，以及让用户搜索和发现新音乐的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Clementine。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:me-davidsansome/clementine</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install clementine</span><br></pre></td></tr></table></figure>\n<h4 id=\"Cmus\"><a href=\"#Cmus\" class=\"headerlink\" title=\"Cmus\"></a>Cmus</h4><p><a href=\"https://cmus.github.io/\" target=\"_blank\" rel=\"noopener\">Cmus</a> 可以说是最高效的的命令行界面音乐播放器了，它具有快速可靠的特点，也支持使用扩展。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Cmus。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jmuc/cmus</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install cmus</span><br></pre></td></tr></table></figure>\n<h3 id=\"办公软件\"><a href=\"#办公软件\" class=\"headerlink\" title=\"办公软件\"></a>办公软件</h3><h4 id=\"Calligra-套件\"><a href=\"#Calligra-套件\" class=\"headerlink\" title=\"Calligra 套件\"></a>Calligra 套件</h4><p><a href=\"https://www.calligra.org/tour/calligra-suite/\" target=\"_blank\" rel=\"noopener\">Calligra 套件</a>为用户提供了一套总共 8 个应用程序，涵盖办公、管理、图表等各个范畴。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Calligra 套件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install calligra</span><br></pre></td></tr></table></figure>\n<h4 id=\"LibreOffice\"><a href=\"#LibreOffice\" class=\"headerlink\" title=\"LibreOffice\"></a>LibreOffice</h4><p><a href=\"https://www.libreoffice.org/\" target=\"_blank\" rel=\"noopener\">LibreOffice</a> 是开源社区中开发过程最活跃的办公套件，它以可靠性著称，也可以通过扩展来添加功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 LibreOffice。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:libreoffice/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install libreoffice</span><br></pre></td></tr></table></figure>\n<h4 id=\"WPS-Office\"><a href=\"#WPS-Office\" class=\"headerlink\" title=\"WPS Office\"></a>WPS Office</h4><p><a href=\"https://www.wps.com/\" target=\"_blank\" rel=\"noopener\">WPS Office</a> 是一款漂亮的办公套件，它有一个很具现代感的 UI。</p>\n<p>参考阅读：<a href=\"http://wps-community.org/downloads\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 安装 WPS Office</a></p>\n<h3 id=\"屏幕截图工具\"><a href=\"#屏幕截图工具\" class=\"headerlink\" title=\"屏幕截图工具\"></a>屏幕截图工具</h3><h4 id=\"Shutter\"><a href=\"#Shutter\" class=\"headerlink\" title=\"Shutter\"></a>Shutter</h4><p><a href=\"http://shutter-project.org/\" target=\"_blank\" rel=\"noopener\">Shutter</a> 允许用户截取桌面的屏幕截图，然后使用一些效果进行编辑，还支持上传和在线共享。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Shutter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository -y ppa:shutter/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install shutter</span><br></pre></td></tr></table></figure>\n<h4 id=\"Kazam\"><a href=\"#Kazam\" class=\"headerlink\" title=\"Kazam\"></a>Kazam</h4><p><a href=\"https://launchpad.net/kazam\" target=\"_blank\" rel=\"noopener\">Kazam</a> 可以用于捕获屏幕截图，它的输出对于任何支持 VP8/WebM 和 PulseAudio 视频播放器都可用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Kazam。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kazam-team/unstable-series</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install kazam python3-cairo python3-xlib</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gnome-Screenshot\"><a href=\"#Gnome-Screenshot\" class=\"headerlink\" title=\"Gnome Screenshot\"></a>Gnome Screenshot</h4><p><a href=\"https://gitlab.gnome.org/GNOME/gnome-screenshot\" target=\"_blank\" rel=\"noopener\">Gnome Screenshot</a> 过去曾经和 Gnome 一起捆绑，但现在已经独立出来。它以易于共享的格式进行截屏。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome Screenshot。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gnome-screenshot</span><br></pre></td></tr></table></figure>\n<h3 id=\"录屏工具\"><a href=\"#录屏工具\" class=\"headerlink\" title=\"录屏工具\"></a>录屏工具</h3><h4 id=\"SimpleScreenRecorder\"><a href=\"#SimpleScreenRecorder\" class=\"headerlink\" title=\"SimpleScreenRecorder\"></a>SimpleScreenRecorder</h4><p><a href=\"http://www.maartenbaert.be/simplescreenrecorder/\" target=\"_blank\" rel=\"noopener\">SimpleScreenRecorder</a> 面世时已经是录屏工具中的佼佼者，现在已成为 Linux 各个发行版中最有效、最易用的录屏工具之一。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 SimpleScreenRecorder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:maarten-baert/simplescreenrecorder</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install simplescreenrecorder</span><br></pre></td></tr></table></figure>\n<h4 id=\"recordMyDesktop\"><a href=\"#recordMyDesktop\" class=\"headerlink\" title=\"recordMyDesktop\"></a>recordMyDesktop</h4><p><a href=\"http://recordmydesktop.sourceforge.net/about.php\" target=\"_blank\" rel=\"noopener\">recordMyDesktop</a> 是一个开源的会话记录器，它也能记录桌面会话的音频。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 recordMyDesktop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gtk-recordmydesktop</span><br></pre></td></tr></table></figure>\n<h3 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h3><h4 id=\"Atom\"><a href=\"#Atom\" class=\"headerlink\" title=\"Atom\"></a>Atom</h4><p><a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">Atom</a> 是由 GitHub 开发和维护的可定制文本编辑器。它是开箱即用的，但也可以使用扩展和主题自定义 UI 来增强其功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Atom。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install atom --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sublime-Text\"><a href=\"#Sublime-Text\" class=\"headerlink\" title=\"Sublime Text\"></a>Sublime Text</h4><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a> 已经成为目前最棒的文本编辑器。它可定制、轻量灵活（即使打开了大量数据文件和加入了大量扩展），最重要的是可以永久免费使用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Sublime Text。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install sublime-text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Geany\"><a href=\"#Geany\" class=\"headerlink\" title=\"Geany\"></a>Geany</h4><p><a href=\"https://www.geany.org/\" target=\"_blank\" rel=\"noopener\">Geany</a> 是一个内存友好的文本编辑器，它具有基本的IDE功能，可以显示加载时间、扩展库函数等。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Geany。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install geany</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gedit\"><a href=\"#Gedit\" class=\"headerlink\" title=\"Gedit\"></a>Gedit</h4><p><a href=\"https://wiki.gnome.org/Apps/Gedit\" target=\"_blank\" rel=\"noopener\">Gedit</a> 以其简单著称，在很多 Linux 发行版都有预装，它具有文本编辑器都具有的优秀的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gedit。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gedit</span><br></pre></td></tr></table></figure>\n<h3 id=\"备忘录软件\"><a href=\"#备忘录软件\" class=\"headerlink\" title=\"备忘录软件\"></a>备忘录软件</h3><h4 id=\"Evernote\"><a href=\"#Evernote\" class=\"headerlink\" title=\"Evernote\"></a>Evernote</h4><p><a href=\"https://everdo.net/\" target=\"_blank\" rel=\"noopener\">Evernote</a> 是一款云上的笔记程序，它带有待办列表和提醒功能，能够与不同类型的笔记完美配合。</p>\n<p>Evernote 在 Linux 上没有官方提供的软件，但可以参考 <a href=\"https://www.fossmint.com/evernote-alternatives-for-linux/\" target=\"_blank\" rel=\"noopener\">Linux 上的 6 个 Evernote 替代客户端</a> 这篇文章使用其它第三方工具。</p>\n<h4 id=\"Everdo\"><a href=\"#Everdo\" class=\"headerlink\" title=\"Everdo\"></a>Everdo</h4><p><a href=\"https://everdo.net/\" target=\"_blank\" rel=\"noopener\">Everdo</a> 是一款美观，安全，易兼容的备忘软件，可以用于处理待办事项和其它笔记。如果你认为 Evernote 有所不足，相信 Everdo 会是一个好的替代。</p>\n<p>参考阅读：<a href=\"https://everdo.net/linux/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Everdo</a></p>\n<h4 id=\"Taskwarrior\"><a href=\"#Taskwarrior\" class=\"headerlink\" title=\"Taskwarrior\"></a>Taskwarrior</h4><p><a href=\"https://taskwarrior.org/\" target=\"_blank\" rel=\"noopener\">Taskwarrior</a> 是一个用于管理个人任务的开源跨平台命令行应用，它的速度和无干扰的环境是它的两大特点。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Taskwarrior。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install taskwarrior</span><br></pre></td></tr></table></figure>\n<h3 id=\"视频播放器\"><a href=\"#视频播放器\" class=\"headerlink\" title=\"视频播放器\"></a>视频播放器</h3><h4 id=\"Banshee\"><a href=\"#Banshee\" class=\"headerlink\" title=\"Banshee\"></a>Banshee</h4><p><a href=\"http://banshee.fm/\" target=\"_blank\" rel=\"noopener\">Banshee</a> 是一个开源的支持多格式的媒体播放器，于 2005 年开始开发并逐渐成长。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Banshee。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:banshee-team/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install banshee</span><br></pre></td></tr></table></figure>\n<h4 id=\"VLC\"><a href=\"#VLC\" class=\"headerlink\" title=\"VLC\"></a>VLC</h4><p><a href=\"https://www.videolan.org/\" target=\"_blank\" rel=\"noopener\">VLC</a> 是我最喜欢的视频播放器，它几乎可以播放任何格式的音频和视频，它还可以播放网络电台、录制桌面会话以及在线播放电影。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 VLC。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:videolan/stable-daily</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install vlc</span><br></pre></td></tr></table></figure>\n<h4 id=\"Kodi\"><a href=\"#Kodi\" class=\"headerlink\" title=\"Kodi\"></a>Kodi</h4><p><a href=\"https://kodi.tv/\" target=\"_blank\" rel=\"noopener\">Kodi</a> 是世界上最着名的媒体播放器之一，它有一个成熟的媒体中心，可以播放本地和远程的多媒体文件。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Kodi。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install software-properties-common</span><br><span class=\"line\">$ sudo add-apt-repository ppa:team-xbmc/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install kodi</span><br></pre></td></tr></table></figure>\n<h4 id=\"SMPlayer\"><a href=\"#SMPlayer\" class=\"headerlink\" title=\"SMPlayer\"></a>SMPlayer</h4><p><a href=\"https://www.smplayer.info/\" target=\"_blank\" rel=\"noopener\">SMPlayer</a> 是 MPlayer 的 GUI 版本，所有流行的媒体格式它都能够处理，并且它还有从 YouTube 和 Chromcast 和下载字幕的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 SMPlayer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:rvm/smplayer</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install smplayer</span><br></pre></td></tr></table></figure>\n<h3 id=\"虚拟化工具\"><a href=\"#虚拟化工具\" class=\"headerlink\" title=\"虚拟化工具\"></a>虚拟化工具</h3><h4 id=\"VirtualBox\"><a href=\"#VirtualBox\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h4><p><a href=\"https://www.virtualbox.org/wiki/VirtualBox\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> 是一个用于操作系统虚拟化的开源应用程序，在服务器、台式机和嵌入式系统上都可以运行。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 VirtualBox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -</span><br><span class=\"line\">$ wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install virtualbox-5.2</span><br><span class=\"line\">$ virtualbox</span><br></pre></td></tr></table></figure>\n<h4 id=\"VMWare\"><a href=\"#VMWare\" class=\"headerlink\" title=\"VMWare\"></a>VMWare</h4><p><a href=\"https://www.vmware.com/\" target=\"_blank\" rel=\"noopener\">VMware</a> 是一个为客户提供平台虚拟化和云计算服务的数字工作区，是第一个成功将 x86 架构系统虚拟化的工作站。 VMware 工作站的其中一个产品就允许用户在虚拟内存中运行多个操作系统。</p>\n<p>参阅 <a href=\"https://www.tecmint.com/install-vmware-workstation-in-linux/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 上安装 VMWare Workstation Pro</a> 可以了解 VMWare 的安装。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><h4 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h4><p><a href=\"https://www.google.com/chrome/\" target=\"_blank\" rel=\"noopener\">Google Chrome</a> 无疑是最受欢迎的浏览器。Chrome 以其速度、简洁、安全、美观而受人喜爱，它遵循了 Google 的界面设计风格，是 web 开发人员不可缺少的浏览器，同时它也是免费开源的。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Google Chrome。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</span><br><span class=\"line\">$ sudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google.list&apos;</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>\n<h4 id=\"Firefox\"><a href=\"#Firefox\" class=\"headerlink\" title=\"Firefox\"></a>Firefox</h4><p><a href=\"https://www.mozilla.org/en-US/firefox/\" target=\"_blank\" rel=\"noopener\">Firefox Quantum</a> 是一款漂亮、快速、完善并且可自定义的浏览器。它也是自由开源的，包含有开发人员所需要的工具，对于初学者也没有任何使用门槛。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Firefox Quantum。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:mozillateam/firefox-next</span><br><span class=\"line\">$ sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class=\"line\">$ sudo apt install firefox</span><br></pre></td></tr></table></figure>\n<h4 id=\"Vivaldi\"><a href=\"#Vivaldi\" class=\"headerlink\" title=\"Vivaldi\"></a>Vivaldi</h4><p><a href=\"https://vivaldi.com/\" target=\"_blank\" rel=\"noopener\">Vivaldi</a> 是一个基于 Chrome 的自由开源项目，旨在通过添加扩展来使 Chrome 的功能更加完善。色彩丰富的界面，性能良好、灵活性强是它的几大特点。</p>\n<p>参考阅读：<a href=\"https://vivaldi.com/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Vivaldi</a></p>\n<p>以上就是我的推荐，你还有更好的软件向大家分享吗？欢迎评论。</p>\n<hr>\n<p>via: <a href=\"https://www.fossmint.com/most-used-linux-applications/\" target=\"_blank\" rel=\"noopener\">https://www.fossmint.com/most-used-linux-applications/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Most-Used-Ubuntu-Applications.png\" alt=\"\"></p>\n<p>对于许多应用程序来说，2018 年是非常好的一年，尤其是自由开源的应用程序。尽管各种 Linux 发行版都自带了很多默认的应用程序，但用户也可以自由地选择使用它们或者其它任何免费或付费替代方案。</p>\n<p>下面汇总了<a href=\"https://www.fossmint.com/awesome-linux-software/\" target=\"_blank\" rel=\"noopener\">一系列的 Linux 应用程序</a>，这些应用程序都能够在 Linux 系统上安装，尽管还有很多其它选择。以下汇总中的任何应用程序都属于其类别中最常用的应用程序，如果你还没有用过，欢迎试用一下！</p>\n<h3 id=\"备份工具\"><a href=\"#备份工具\" class=\"headerlink\" title=\"备份工具\"></a>备份工具</h3><h4 id=\"Rsync\"><a href=\"#Rsync\" class=\"headerlink\" title=\"Rsync\"></a>Rsync</h4><p><a href=\"https://rsync.samba.org/\" target=\"_blank\" rel=\"noopener\">Rsync</a> 是一个开源的、节约带宽的工具，它用于执行快速的增量文件传输，而且它也是一个免费工具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rsync [OPTION...] SRC... [DEST]</span><br></pre></td></tr></table></figure>\n<p>想要了解更多示例和用法，可以参考《<a href=\"https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/\" target=\"_blank\" rel=\"noopener\">10 个使用 Rsync 命令的实际例子</a>》。</p>\n<h4 id=\"Timeshift\"><a href=\"#Timeshift\" class=\"headerlink\" title=\"Timeshift\"></a>Timeshift</h4><p><a href=\"https://github.com/teejee2008/timeshift\" target=\"_blank\" rel=\"noopener\">Timeshift</a> 能够通过增量快照来保护用户的系统数据，而且可以按照日期恢复指定的快照，类似于 Mac OS 中的 Time Machine 功能和 Windows 中的系统还原功能。</p>\n<p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Timeshift-Create-Linux-Mint-Snapshot.png\" alt=\"\"></p>\n<h3 id=\"BT（BitTorrent）-客户端\"><a href=\"#BT（BitTorrent）-客户端\" class=\"headerlink\" title=\"BT（BitTorrent） 客户端\"></a>BT（BitTorrent） 客户端</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Torrent-Clients.png\" alt=\"\"></p>\n<h4 id=\"Deluge\"><a href=\"#Deluge\" class=\"headerlink\" title=\"Deluge\"></a>Deluge</h4><p><a href=\"https://deluge-torrent.org/\" target=\"_blank\" rel=\"noopener\">Deluge</a> 是一个漂亮的跨平台 BT 客户端，旨在优化 μTorrent 体验，并向用户免费提供服务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Deluge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:deluge-team/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install deluge</span><br></pre></td></tr></table></figure>\n<h4 id=\"qBittorent\"><a href=\"#qBittorent\" class=\"headerlink\" title=\"qBittorent\"></a>qBittorent</h4><p><a href=\"https://www.qbittorrent.org/\" target=\"_blank\" rel=\"noopener\">qBittorent</a> 是一个开源的 BT 客户端，旨在提供类似 μTorrent 的免费替代方案。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 qBittorent。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install qbittorrent</span><br></pre></td></tr></table></figure>\n<h4 id=\"Transmission\"><a href=\"#Transmission\" class=\"headerlink\" title=\"Transmission\"></a>Transmission</h4><p><a href=\"https://transmissionbt.com/\" target=\"_blank\" rel=\"noopener\">Transmission</a> 是一个强大的 BT 客户端，它主要关注速度和易用性，一般在很多 Linux 发行版上都有预装。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Transmission。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:transmissionbt/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install transmission-gtk transmission-cli transmission-common transmission-daemon</span><br></pre></td></tr></table></figure>\n<h3 id=\"云存储\"><a href=\"#云存储\" class=\"headerlink\" title=\"云存储\"></a>云存储</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Cloud-Storage.png\" alt=\"\"></p>\n<h4 id=\"Dropbox\"><a href=\"#Dropbox\" class=\"headerlink\" title=\"Dropbox\"></a>Dropbox</h4><p><a href=\"https://www.dropbox.com/\" target=\"_blank\" rel=\"noopener\">Dropbox</a> 团队在今年早些时候给他们的云服务换了一个名字，也为客户提供了更好的性能和集成了更多应用程序。Dropbox 会向用户免费提供 2 GB 存储空间。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Dropbox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86&quot; | tar xzf - [On 32-Bit]</span><br><span class=\"line\">$ cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86_64&quot; | tar xzf - [On 64-Bit]</span><br><span class=\"line\">$ ~/.dropbox-dist/dropboxd</span><br></pre></td></tr></table></figure>\n<h4 id=\"Google-Drive\"><a href=\"#Google-Drive\" class=\"headerlink\" title=\"Google Drive\"></a>Google Drive</h4><p><a href=\"https://www.google.com/drive/\" target=\"_blank\" rel=\"noopener\">Google Drive</a> 是 Google 提供的云服务解决方案，这已经是一个广为人知的服务了。与 Dropbox 一样，可以通过它在所有联网的设备上同步文件。它免费提供了 15 GB 存储空间，包括Gmail、Google 图片、Google 地图等服务。</p>\n<p>参考阅读：<a href=\"https://www.fossmint.com/best-google-drive-clients-for-linux/\" target=\"_blank\" rel=\"noopener\">5 个适用于 Linux 的 Google Drive 客户端</a></p>\n<h4 id=\"Mega\"><a href=\"#Mega\" class=\"headerlink\" title=\"Mega\"></a>Mega</h4><p><a href=\"https://mega.nz/\" target=\"_blank\" rel=\"noopener\">Mega</a> 也是一个出色的云存储解决方案，它的亮点除了高度的安全性之外，还有为用户免费提供高达 50 GB 的免费存储空间。它使用端到端加密，以确保用户的数据安全，所以如果忘记了恢复密钥，用户自己也无法访问到存储的数据。</p>\n<p>参考阅读：<a href=\"https://mega.nz/sync!linux\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Mega 云存储客户端</a></p>\n<h3 id=\"命令行编辑器\"><a href=\"#命令行编辑器\" class=\"headerlink\" title=\"命令行编辑器\"></a>命令行编辑器</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Commandline-Editors.png\" alt=\"\"></p>\n<h4 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h4><p><a href=\"https://www.vim.org/\" target=\"_blank\" rel=\"noopener\">Vim</a> 是 vi 文本编辑器的开源克隆版本，它的主要目的是可以高度定制化并能够处理任何类型的文本。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Vim。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jonathonf/vim</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install vim</span><br></pre></td></tr></table></figure>\n<h4 id=\"Emacs\"><a href=\"#Emacs\" class=\"headerlink\" title=\"Emacs\"></a>Emacs</h4><p><a href=\"https://www.gnu.org/s/emacs/\" target=\"_blank\" rel=\"noopener\">Emacs</a> 是一个高度可配置的文本编辑器，最流行的一个分支 GNU Emacs 是用 Lisp 和 C 编写的，它的最大特点是可以自文档化、可扩展和可自定义。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Emacs。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kelleyk/emacs</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install emacs25</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nano\"><a href=\"#Nano\" class=\"headerlink\" title=\"Nano\"></a>Nano</h4><p><a href=\"https://www.nano-editor.org/\" target=\"_blank\" rel=\"noopener\">Nano</a> 是一款功能丰富的命令行文本编辑器，比较适合高级用户。它可以通过多个终端进行不同功能的操作。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Nano。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:n-muench/programs-ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install nano</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载器\"><a href=\"#下载器\" class=\"headerlink\" title=\"下载器\"></a>下载器</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Download-Managers.png\" alt=\"\"></p>\n<h4 id=\"Aria2\"><a href=\"#Aria2\" class=\"headerlink\" title=\"Aria2\"></a>Aria2</h4><p><a href=\"https://aria2.github.io/\" target=\"_blank\" rel=\"noopener\">Aria2</a> 是一个开源的、轻量级的、多软件源和多协议的命令行下载器，它支持 Metalink、torrent、HTTP/HTTPS、SFTP 等多种协议。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Aria2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install aria2</span><br></pre></td></tr></table></figure>\n<h4 id=\"uGet\"><a href=\"#uGet\" class=\"headerlink\" title=\"uGet\"></a>uGet</h4><p><a href=\"http://ugetdm.com/\" target=\"_blank\" rel=\"noopener\">uGet</a> 已经成为 Linux 各种发行版中排名第一的开源下载器，它可以处理任何下载任务，包括多连接、队列、类目等。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 uGet。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:plushuang-tw/uget-stable</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install uget</span><br></pre></td></tr></table></figure>\n<h4 id=\"XDM\"><a href=\"#XDM\" class=\"headerlink\" title=\"XDM\"></a>XDM</h4><p><a href=\"http://xdman.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">XDM</a>（Xtreme Download Manager）是一个使用 Java 编写的开源下载软件。和其它下载器一样，它可以结合队列、种子、浏览器使用，而且还带有视频采集器和智能调度器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 XDM。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:noobslab/apps</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install xdman</span><br></pre></td></tr></table></figure>\n<h3 id=\"电子邮件客户端\"><a href=\"#电子邮件客户端\" class=\"headerlink\" title=\"电子邮件客户端\"></a>电子邮件客户端</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Email-Clients.png\" alt=\"\"></p>\n<h4 id=\"Thunderbird\"><a href=\"#Thunderbird\" class=\"headerlink\" title=\"Thunderbird\"></a>Thunderbird</h4><p><a href=\"https://www.thunderbird.net/\" target=\"_blank\" rel=\"noopener\">Thunderbird</a> 是最受欢迎的电子邮件客户端之一。它的优点包括免费、开源、可定制、功能丰富，而且最重要的是安装过程也很简便。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Thunderbird。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install thunderbird</span><br></pre></td></tr></table></figure>\n<h4 id=\"Geary\"><a href=\"#Geary\" class=\"headerlink\" title=\"Geary\"></a>Geary</h4><p><a href=\"https://github.com/GNOME/geary\" target=\"_blank\" rel=\"noopener\">Geary</a> 是一个基于 WebKitGTK+ 的开源电子邮件客户端。它是一个免费开源的功能丰富的软件，并被 GNOME 项目收录。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Geary。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:geary-team/releases</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install geary</span><br></pre></td></tr></table></figure>\n<h4 id=\"Evolution\"><a href=\"#Evolution\" class=\"headerlink\" title=\"Evolution\"></a>Evolution</h4><p><a href=\"https://github.com/GNOME/evolution\" target=\"_blank\" rel=\"noopener\">Evolution</a> 是一个免费开源的电子邮件客户端，可以用于电子邮件、会议日程、备忘录和联系人的管理。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Evolution。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:gnome3-team/gnome3-staging</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install evolution</span><br></pre></td></tr></table></figure>\n<h3 id=\"财务软件\"><a href=\"#财务软件\" class=\"headerlink\" title=\"财务软件\"></a>财务软件</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-Accounting-Software.png\" alt=\"\"></p>\n<h4 id=\"GnuCash\"><a href=\"#GnuCash\" class=\"headerlink\" title=\"GnuCash\"></a>GnuCash</h4><p><a href=\"https://www.gnucash.org/\" target=\"_blank\" rel=\"noopener\">GnuCash</a> 是一款免费的跨平台开源软件，它适用于个人和中小型企业的财务任务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 GnuCash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo sh -c &apos;echo &quot;deb http://archive.getdeb.net/ubuntu $(lsb_release -sc)-getdeb apps&quot; &gt;&gt; /etc/apt/sources.list.d/getdeb.list&apos;</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gnucash</span><br></pre></td></tr></table></figure>\n<h4 id=\"KMyMoney\"><a href=\"#KMyMoney\" class=\"headerlink\" title=\"KMyMoney\"></a>KMyMoney</h4><p><a href=\"https://kmymoney.org/\" target=\"_blank\" rel=\"noopener\">KMyMoney</a> 是一个财务管理软件，它可以提供商用或个人理财所需的大部分主要功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 KmyMoney。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:claydoh/kmymoney2-kde4</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install kmymoney</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IDE-Editors.png\" alt=\"\"></p>\n<h4 id=\"Eclipse-IDE\"><a href=\"#Eclipse-IDE\" class=\"headerlink\" title=\"Eclipse IDE\"></a>Eclipse IDE</h4><p><a href=\"https://www.eclipse.org/ide/\" target=\"_blank\" rel=\"noopener\">Eclipse</a> 是最广为使用的 Java IDE，它包括一个基本工作空间和一个用于自定义编程环境的强大的的插件配置系统。</p>\n<p>关于 Eclipse IDE 的安装，可以参考 <a href=\"https://www.tecmint.com/install-eclipse-oxygen-ide-in-ubuntu-debian/\" target=\"_blank\" rel=\"noopener\">如何在 Debian 和 Ubuntu 上安装 Eclipse IDE</a> 这一篇文章。</p>\n<h4 id=\"Netbeans-IDE\"><a href=\"#Netbeans-IDE\" class=\"headerlink\" title=\"Netbeans IDE\"></a>Netbeans IDE</h4><p><a href=\"https://netbeans.org/\" target=\"_blank\" rel=\"noopener\">Netbeans</a> 是一个相当受用户欢迎的 IDE，它支持使用 Java、PHP、HTML 5、JavaScript、C/C++ 或其他语言编写移动应用，桌面软件和 web 应用。</p>\n<p>关于 Netbeans IDE 的安装，可以参考 <a href=\"https://www.tecmint.com/install-netbeans-ide-in-ubuntu-debian-linux-mint/\" target=\"_blank\" rel=\"noopener\">如何在 Debian 和 Ubuntu 上安装 Netbeans IDE</a> 这一篇文章。</p>\n<h4 id=\"Brackets\"><a href=\"#Brackets\" class=\"headerlink\" title=\"Brackets\"></a>Brackets</h4><p><a href=\"http://brackets.io/\" target=\"_blank\" rel=\"noopener\">Brackets</a> 是由 Adobe 开发的高级文本编辑器，它带有可视化工具，支持预处理程序，以及用于 web 开发的以设计为中心的用户流程。对于熟悉它的用户，它可以发挥 IDE 的作用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Brackets。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:webupd8team/brackets</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install brackets</span><br></pre></td></tr></table></figure>\n<h4 id=\"Atom-IDE\"><a href=\"#Atom-IDE\" class=\"headerlink\" title=\"Atom IDE\"></a>Atom IDE</h4><p><a href=\"https://ide.atom.io/\" target=\"_blank\" rel=\"noopener\">Atom IDE</a> 是一个加强版的 Atom 编辑器，它添加了大量扩展和库以提高性能和增加功能。总之，它是各方面都变得更强大了的 Atom 。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Atom。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install atom --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Light-Table\"><a href=\"#Light-Table\" class=\"headerlink\" title=\"Light Table\"></a>Light Table</h4><p><a href=\"http://lighttable.com/\" target=\"_blank\" rel=\"noopener\">Light Table</a> 号称下一代的 IDE，它提供了数据流量统计和协作编程等的强大功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Light Table。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:dr-akulavich/lighttable</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install lighttable-installer</span><br></pre></td></tr></table></figure>\n<h4 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h4><p><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a> 是由微软开发的代码编辑器，它包含了文本编辑器所需要的最先进的功能，包括语法高亮、自动完成、代码调试、性能统计和图表显示等功能。</p>\n<p>参考阅读：<a href=\"https://code.visualstudio.com/download\" target=\"_blank\" rel=\"noopener\">在Ubuntu 下载 Visual Studio Code</a></p>\n<h3 id=\"即时通信工具\"><a href=\"#即时通信工具\" class=\"headerlink\" title=\"即时通信工具\"></a>即时通信工具</h3><p><img src=\"https://www.fossmint.com/wp-content/uploads/2018/07/Linux-IM-Clients.png\" alt=\"\"></p>\n<h4 id=\"Pidgin\"><a href=\"#Pidgin\" class=\"headerlink\" title=\"Pidgin\"></a>Pidgin</h4><p><a href=\"https://www.pidgin.im/\" target=\"_blank\" rel=\"noopener\">Pidgin</a> 是一个开源的即时通信工具，它几乎支持所有聊天平台，还支持额外扩展功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Pidgin。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jonathonf/backports</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install pidgin</span><br></pre></td></tr></table></figure>\n<h4 id=\"Skype\"><a href=\"#Skype\" class=\"headerlink\" title=\"Skype\"></a>Skype</h4><p><a href=\"https://www.skype.com/\" target=\"_blank\" rel=\"noopener\">Skype</a> 也是一个广为人知的软件了，任何感兴趣的用户都可以在 Linux 上使用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Skype。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install snapd</span><br><span class=\"line\">$ sudo snap install skype --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Empathy\"><a href=\"#Empathy\" class=\"headerlink\" title=\"Empathy\"></a>Empathy</h4><p><a href=\"https://wiki.gnome.org/Apps/Empathy\" target=\"_blank\" rel=\"noopener\">Empathy</a> 是一个支持多协议语音、视频聊天、文本和文件传输的即时通信工具。它还允许用户添加多个服务的帐户，并用其与所有服务的帐户进行交互。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Empathy。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install empathy</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-防病毒工具\"><a href=\"#Linux-防病毒工具\" class=\"headerlink\" title=\"Linux 防病毒工具\"></a>Linux 防病毒工具</h3><h4 id=\"ClamAV-ClamTk\"><a href=\"#ClamAV-ClamTk\" class=\"headerlink\" title=\"ClamAV/ClamTk\"></a>ClamAV/ClamTk</h4><p><a href=\"https://www.clamav.net/\" target=\"_blank\" rel=\"noopener\">ClamAV</a> 是一个开源的跨平台命令行防病毒工具，用于检测木马、病毒和其他恶意代码。而 <a href=\"https://dave-theunsub.github.io/clamtk/\" target=\"_blank\" rel=\"noopener\">ClamTk</a> 则是它的前端 GUI。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 ClamAV 和 ClamTk。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install clamav</span><br><span class=\"line\">$ sudo apt-get install clamtk</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-桌面环境\"><a href=\"#Linux-桌面环境\" class=\"headerlink\" title=\"Linux 桌面环境\"></a>Linux 桌面环境</h3><h4 id=\"Cinnamon\"><a href=\"#Cinnamon\" class=\"headerlink\" title=\"Cinnamon\"></a>Cinnamon</h4><p><a href=\"https://github.com/linuxmint/cinnamon-desktop\" target=\"_blank\" rel=\"noopener\">Cinnamon</a> 是 GNOME 3 的自由开源衍生产品，它遵循传统的 <ruby>桌面比拟<rt>desktop metaphor</rt></ruby> 约定。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Cinnamon。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:embrosyn/cinnamon</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install cinnamon-desktop-environment lightdm</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mate\"><a href=\"#Mate\" class=\"headerlink\" title=\"Mate\"></a>Mate</h4><p><a href=\"https://mate-desktop.org/\" target=\"_blank\" rel=\"noopener\">Mate</a> 桌面环境是 GNOME 2 的衍生和延续，目的是在 Linux 上通过使用传统的桌面比拟提供有一个吸引力的 UI。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Mate。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install ubuntu-mate-desktop</span><br></pre></td></tr></table></figure>\n<h4 id=\"GNOME\"><a href=\"#GNOME\" class=\"headerlink\" title=\"GNOME\"></a>GNOME</h4><p><a href=\"https://www.gnome.org/\" target=\"_blank\" rel=\"noopener\">GNOME</a> 是由一些免费和开源应用程序组成的桌面环境，它可以运行在任何 Linux 发行版和大多数 BSD 衍生版本上。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install ubuntu-desktop</span><br></pre></td></tr></table></figure>\n<h4 id=\"KDE\"><a href=\"#KDE\" class=\"headerlink\" title=\"KDE\"></a>KDE</h4><p><a href=\"https://www.kde.org/plasma-desktop\" target=\"_blank\" rel=\"noopener\">KDE</a> 由 KDE 社区开发，它为用户提供图形解决方案以控制操作系统并执行不同的计算任务。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 KDE。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install tasksel</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo tasksel install kubuntu-desktop</span><br></pre></td></tr></table></figure>\n<h3 id=\"Linux-维护工具\"><a href=\"#Linux-维护工具\" class=\"headerlink\" title=\"Linux 维护工具\"></a>Linux 维护工具</h3><h4 id=\"GNOME-Tweak-Tool\"><a href=\"#GNOME-Tweak-Tool\" class=\"headerlink\" title=\"GNOME Tweak Tool\"></a>GNOME Tweak Tool</h4><p><a href=\"https://github.com/nzjrs/gnome-tweak-tool\" target=\"_blank\" rel=\"noopener\">GNOME Tweak Tool</a> 是用于自定义和调整 GNOME 3 和 GNOME Shell 设置的流行工具。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 GNOME Tweak Tool。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n<h4 id=\"Stacer\"><a href=\"#Stacer\" class=\"headerlink\" title=\"Stacer\"></a>Stacer</h4><p><a href=\"https://github.com/oguzhaninan/Stacer\" target=\"_blank\" rel=\"noopener\">Stacer</a> 是一款用于监控和优化 Linux 系统的免费开源应用程序。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Stacer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:oguzhaninan/stacer</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install stacer</span><br></pre></td></tr></table></figure>\n<h4 id=\"BleachBit\"><a href=\"#BleachBit\" class=\"headerlink\" title=\"BleachBit\"></a>BleachBit</h4><p><a href=\"https://www.bleachbit.org/\" target=\"_blank\" rel=\"noopener\">BleachBit</a> 是一个免费的磁盘空间清理器，它也可用作隐私管理器和系统优化器。</p>\n<p>参考阅读：<a href=\"https://www.bleachbit.org/download\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 BleachBit</a></p>\n<h3 id=\"Linux-终端工具\"><a href=\"#Linux-终端工具\" class=\"headerlink\" title=\"Linux 终端工具\"></a>Linux 终端工具</h3><h4 id=\"GNOME-终端\"><a href=\"#GNOME-终端\" class=\"headerlink\" title=\"GNOME 终端\"></a>GNOME 终端</h4><p><a href=\"https://github.com/GNOME/gnome-terminal\" target=\"_blank\" rel=\"noopener\">GNOME 终端</a> 是 GNOME 的默认终端模拟器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome 终端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install gnome-terminal</span><br></pre></td></tr></table></figure>\n<h4 id=\"Konsole\"><a href=\"#Konsole\" class=\"headerlink\" title=\"Konsole\"></a>Konsole</h4><p><a href=\"https://konsole.kde.org/\" target=\"_blank\" rel=\"noopener\">Konsole</a> 是 KDE 的一个终端模拟器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Konsole。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install konsole</span><br></pre></td></tr></table></figure>\n<h4 id=\"Terminator\"><a href=\"#Terminator\" class=\"headerlink\" title=\"Terminator\"></a>Terminator</h4><p><a href=\"https://gnometerminator.blogspot.com/p/introduction.html\" target=\"_blank\" rel=\"noopener\">Terminator</a> 是一个功能丰富的终端程序，它基于 GNOME 终端，并且专注于整理终端功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Terminator。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install terminator</span><br></pre></td></tr></table></figure>\n<h4 id=\"Guake\"><a href=\"#Guake\" class=\"headerlink\" title=\"Guake\"></a>Guake</h4><p><a href=\"http://guake-project.org/\" target=\"_blank\" rel=\"noopener\">Guake</a> 是 GNOME 桌面环境下一个轻量级的可下拉式终端。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Guake。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install guake</span><br></pre></td></tr></table></figure>\n<h3 id=\"多媒体编辑工具\"><a href=\"#多媒体编辑工具\" class=\"headerlink\" title=\"多媒体编辑工具\"></a>多媒体编辑工具</h3><h4 id=\"Ardour\"><a href=\"#Ardour\" class=\"headerlink\" title=\"Ardour\"></a>Ardour</h4><p><a href=\"https://ardour.org/\" target=\"_blank\" rel=\"noopener\">Ardour</a> 是一款漂亮的的<ruby>数字音频工作站<rt>Digital Audio Workstation</rt></ruby>，可以完成专业的录制、编辑和混音工作。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Ardour。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:dobey/audiotools</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install ardour</span><br></pre></td></tr></table></figure>\n<h4 id=\"Audacity\"><a href=\"#Audacity\" class=\"headerlink\" title=\"Audacity\"></a>Audacity</h4><p><a href=\"https://www.audacityteam.org/\" target=\"_blank\" rel=\"noopener\">Audacity</a> 是最著名的音频编辑软件之一，它是一款跨平台的开源多轨音频编辑器。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Audacity。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:ubuntuhandbook1/audacity</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install audacity</span><br></pre></td></tr></table></figure>\n<h4 id=\"GIMP\"><a href=\"#GIMP\" class=\"headerlink\" title=\"GIMP\"></a>GIMP</h4><p><a href=\"https://www.gimp.org/\" target=\"_blank\" rel=\"noopener\">GIMP</a> 是 Photoshop 的开源替代品中最受欢迎的。这是因为它有多种可自定义的选项、第三方插件以及活跃的用户社区。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gimp。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:otto-kesselgulasch/gimp</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install gimp</span><br></pre></td></tr></table></figure>\n<h4 id=\"Krita\"><a href=\"#Krita\" class=\"headerlink\" title=\"Krita\"></a>Krita</h4><p><a href=\"https://krita.org/en/\" target=\"_blank\" rel=\"noopener\">Krita</a> 是一款开源的绘画程序，它具有美观的 UI 和可靠的性能，也可以用作图像处理工具。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Krita。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kritalime/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install krita</span><br></pre></td></tr></table></figure>\n<h4 id=\"Lightworks\"><a href=\"#Lightworks\" class=\"headerlink\" title=\"Lightworks\"></a>Lightworks</h4><p><a href=\"https://www.lwks.com/\" target=\"_blank\" rel=\"noopener\">Lightworks</a> 是一款功能强大、灵活美观的专业视频编辑工具。它拥有上百种配套的视觉效果功能，可以处理任何编辑任务，毕竟这个软件已经有长达 25 年的视频处理经验。</p>\n<p>参考阅读：<a href=\"https://www.lwks.com/index.php?option=com_lwks&amp;view=download&amp;Itemid=206\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Lightworks</a></p>\n<h4 id=\"OpenShot\"><a href=\"#OpenShot\" class=\"headerlink\" title=\"OpenShot\"></a>OpenShot</h4><p><a href=\"https://www.openshot.org/\" target=\"_blank\" rel=\"noopener\">OpenShot</a> 是一款屡获殊荣的免费开源视频编辑器，这主要得益于其出色的性能和强大的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 `Openshot。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:openshot.developers/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install openshot-qt</span><br></pre></td></tr></table></figure>\n<h4 id=\"PiTiV\"><a href=\"#PiTiV\" class=\"headerlink\" title=\"PiTiV\"></a>PiTiV</h4><p><a href=\"http://www.pitivi.org/\" target=\"_blank\" rel=\"noopener\">Pitivi</a> 也是一个美观的视频编辑器，它有优美的代码库、优质的社区，还支持优秀的协作编辑功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 PiTiV。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flatpak install --user https://flathub.org/repo/appstream/org.pitivi.Pitivi.flatpakref</span><br><span class=\"line\">$ flatpak install --user http://flatpak.pitivi.org/pitivi.flatpakref</span><br><span class=\"line\">$ flatpak run org.pitivi.Pitivi//stable</span><br></pre></td></tr></table></figure>\n<h3 id=\"音乐播放器\"><a href=\"#音乐播放器\" class=\"headerlink\" title=\"音乐播放器\"></a>音乐播放器</h3><h4 id=\"Rhythmbox\"><a href=\"#Rhythmbox\" class=\"headerlink\" title=\"Rhythmbox\"></a>Rhythmbox</h4><p><a href=\"https://wiki.gnome.org/Apps/Rhythmbox\" target=\"_blank\" rel=\"noopener\">Rhythmbox</a> 支持海量种类的音乐，目前被认为是最可靠的音乐播放器，并由 Ubuntu 自带。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Rhythmbox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:fossfreedom/rhythmbox</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install rhythmbox</span><br></pre></td></tr></table></figure>\n<h4 id=\"Lollypop\"><a href=\"#Lollypop\" class=\"headerlink\" title=\"Lollypop\"></a>Lollypop</h4><p><a href=\"https://gnumdk.github.io/lollypop-web/\" target=\"_blank\" rel=\"noopener\">Lollypop</a> 是一款较为年轻的开源音乐播放器，它有很多高级选项，包括网络电台，滑动播放和派对模式。尽管功能繁多，它仍然尽量做到简单易管理。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Lollypop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:gnumdk/lollypop</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install lollypop</span><br></pre></td></tr></table></figure>\n<h4 id=\"Amarok\"><a href=\"#Amarok\" class=\"headerlink\" title=\"Amarok\"></a>Amarok</h4><p><a href=\"https://amarok.kde.org/en\" target=\"_blank\" rel=\"noopener\">Amarok</a> 是一款功能强大的音乐播放器，它有一个直观的 UI 和大量的高级功能，而且允许用户根据自己的偏好去发现新音乐。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Amarok。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install amarok</span><br></pre></td></tr></table></figure>\n<h4 id=\"Clementine\"><a href=\"#Clementine\" class=\"headerlink\" title=\"Clementine\"></a>Clementine</h4><p><a href=\"https://www.clementine-player.org/\" target=\"_blank\" rel=\"noopener\">Clementine</a> 是一款 Amarok 风格的音乐播放器，因此和 Amarok 相似，也有直观的用户界面、先进的控制模块，以及让用户搜索和发现新音乐的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Clementine。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:me-davidsansome/clementine</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install clementine</span><br></pre></td></tr></table></figure>\n<h4 id=\"Cmus\"><a href=\"#Cmus\" class=\"headerlink\" title=\"Cmus\"></a>Cmus</h4><p><a href=\"https://cmus.github.io/\" target=\"_blank\" rel=\"noopener\">Cmus</a> 可以说是最高效的的命令行界面音乐播放器了，它具有快速可靠的特点，也支持使用扩展。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Cmus。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:jmuc/cmus</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install cmus</span><br></pre></td></tr></table></figure>\n<h3 id=\"办公软件\"><a href=\"#办公软件\" class=\"headerlink\" title=\"办公软件\"></a>办公软件</h3><h4 id=\"Calligra-套件\"><a href=\"#Calligra-套件\" class=\"headerlink\" title=\"Calligra 套件\"></a>Calligra 套件</h4><p><a href=\"https://www.calligra.org/tour/calligra-suite/\" target=\"_blank\" rel=\"noopener\">Calligra 套件</a>为用户提供了一套总共 8 个应用程序，涵盖办公、管理、图表等各个范畴。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Calligra 套件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install calligra</span><br></pre></td></tr></table></figure>\n<h4 id=\"LibreOffice\"><a href=\"#LibreOffice\" class=\"headerlink\" title=\"LibreOffice\"></a>LibreOffice</h4><p><a href=\"https://www.libreoffice.org/\" target=\"_blank\" rel=\"noopener\">LibreOffice</a> 是开源社区中开发过程最活跃的办公套件，它以可靠性著称，也可以通过扩展来添加功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 LibreOffice。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:libreoffice/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install libreoffice</span><br></pre></td></tr></table></figure>\n<h4 id=\"WPS-Office\"><a href=\"#WPS-Office\" class=\"headerlink\" title=\"WPS Office\"></a>WPS Office</h4><p><a href=\"https://www.wps.com/\" target=\"_blank\" rel=\"noopener\">WPS Office</a> 是一款漂亮的办公套件，它有一个很具现代感的 UI。</p>\n<p>参考阅读：<a href=\"http://wps-community.org/downloads\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 安装 WPS Office</a></p>\n<h3 id=\"屏幕截图工具\"><a href=\"#屏幕截图工具\" class=\"headerlink\" title=\"屏幕截图工具\"></a>屏幕截图工具</h3><h4 id=\"Shutter\"><a href=\"#Shutter\" class=\"headerlink\" title=\"Shutter\"></a>Shutter</h4><p><a href=\"http://shutter-project.org/\" target=\"_blank\" rel=\"noopener\">Shutter</a> 允许用户截取桌面的屏幕截图，然后使用一些效果进行编辑，还支持上传和在线共享。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Shutter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository -y ppa:shutter/ppa</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install shutter</span><br></pre></td></tr></table></figure>\n<h4 id=\"Kazam\"><a href=\"#Kazam\" class=\"headerlink\" title=\"Kazam\"></a>Kazam</h4><p><a href=\"https://launchpad.net/kazam\" target=\"_blank\" rel=\"noopener\">Kazam</a> 可以用于捕获屏幕截图，它的输出对于任何支持 VP8/WebM 和 PulseAudio 视频播放器都可用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Kazam。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:kazam-team/unstable-series</span><br><span class=\"line\">$ sudo apt update</span><br><span class=\"line\">$ sudo apt install kazam python3-cairo python3-xlib</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gnome-Screenshot\"><a href=\"#Gnome-Screenshot\" class=\"headerlink\" title=\"Gnome Screenshot\"></a>Gnome Screenshot</h4><p><a href=\"https://gitlab.gnome.org/GNOME/gnome-screenshot\" target=\"_blank\" rel=\"noopener\">Gnome Screenshot</a> 过去曾经和 Gnome 一起捆绑，但现在已经独立出来。它以易于共享的格式进行截屏。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gnome Screenshot。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gnome-screenshot</span><br></pre></td></tr></table></figure>\n<h3 id=\"录屏工具\"><a href=\"#录屏工具\" class=\"headerlink\" title=\"录屏工具\"></a>录屏工具</h3><h4 id=\"SimpleScreenRecorder\"><a href=\"#SimpleScreenRecorder\" class=\"headerlink\" title=\"SimpleScreenRecorder\"></a>SimpleScreenRecorder</h4><p><a href=\"http://www.maartenbaert.be/simplescreenrecorder/\" target=\"_blank\" rel=\"noopener\">SimpleScreenRecorder</a> 面世时已经是录屏工具中的佼佼者，现在已成为 Linux 各个发行版中最有效、最易用的录屏工具之一。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 SimpleScreenRecorder。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:maarten-baert/simplescreenrecorder</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install simplescreenrecorder</span><br></pre></td></tr></table></figure>\n<h4 id=\"recordMyDesktop\"><a href=\"#recordMyDesktop\" class=\"headerlink\" title=\"recordMyDesktop\"></a>recordMyDesktop</h4><p><a href=\"http://recordmydesktop.sourceforge.net/about.php\" target=\"_blank\" rel=\"noopener\">recordMyDesktop</a> 是一个开源的会话记录器，它也能记录桌面会话的音频。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 recordMyDesktop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gtk-recordmydesktop</span><br></pre></td></tr></table></figure>\n<h3 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h3><h4 id=\"Atom\"><a href=\"#Atom\" class=\"headerlink\" title=\"Atom\"></a>Atom</h4><p><a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">Atom</a> 是由 GitHub 开发和维护的可定制文本编辑器。它是开箱即用的，但也可以使用扩展和主题自定义 UI 来增强其功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Atom。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install atom --classic</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sublime-Text\"><a href=\"#Sublime-Text\" class=\"headerlink\" title=\"Sublime Text\"></a>Sublime Text</h4><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a> 已经成为目前最棒的文本编辑器。它可定制、轻量灵活（即使打开了大量数据文件和加入了大量扩展），最重要的是可以永久免费使用。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Sublime Text。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install snapd</span><br><span class=\"line\">$ sudo snap install sublime-text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Geany\"><a href=\"#Geany\" class=\"headerlink\" title=\"Geany\"></a>Geany</h4><p><a href=\"https://www.geany.org/\" target=\"_blank\" rel=\"noopener\">Geany</a> 是一个内存友好的文本编辑器，它具有基本的IDE功能，可以显示加载时间、扩展库函数等。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Geany。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install geany</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gedit\"><a href=\"#Gedit\" class=\"headerlink\" title=\"Gedit\"></a>Gedit</h4><p><a href=\"https://wiki.gnome.org/Apps/Gedit\" target=\"_blank\" rel=\"noopener\">Gedit</a> 以其简单著称，在很多 Linux 发行版都有预装，它具有文本编辑器都具有的优秀的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Gedit。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install gedit</span><br></pre></td></tr></table></figure>\n<h3 id=\"备忘录软件\"><a href=\"#备忘录软件\" class=\"headerlink\" title=\"备忘录软件\"></a>备忘录软件</h3><h4 id=\"Evernote\"><a href=\"#Evernote\" class=\"headerlink\" title=\"Evernote\"></a>Evernote</h4><p><a href=\"https://everdo.net/\" target=\"_blank\" rel=\"noopener\">Evernote</a> 是一款云上的笔记程序，它带有待办列表和提醒功能，能够与不同类型的笔记完美配合。</p>\n<p>Evernote 在 Linux 上没有官方提供的软件，但可以参考 <a href=\"https://www.fossmint.com/evernote-alternatives-for-linux/\" target=\"_blank\" rel=\"noopener\">Linux 上的 6 个 Evernote 替代客户端</a> 这篇文章使用其它第三方工具。</p>\n<h4 id=\"Everdo\"><a href=\"#Everdo\" class=\"headerlink\" title=\"Everdo\"></a>Everdo</h4><p><a href=\"https://everdo.net/\" target=\"_blank\" rel=\"noopener\">Everdo</a> 是一款美观，安全，易兼容的备忘软件，可以用于处理待办事项和其它笔记。如果你认为 Evernote 有所不足，相信 Everdo 会是一个好的替代。</p>\n<p>参考阅读：<a href=\"https://everdo.net/linux/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Everdo</a></p>\n<h4 id=\"Taskwarrior\"><a href=\"#Taskwarrior\" class=\"headerlink\" title=\"Taskwarrior\"></a>Taskwarrior</h4><p><a href=\"https://taskwarrior.org/\" target=\"_blank\" rel=\"noopener\">Taskwarrior</a> 是一个用于管理个人任务的开源跨平台命令行应用，它的速度和无干扰的环境是它的两大特点。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Taskwarrior。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install taskwarrior</span><br></pre></td></tr></table></figure>\n<h3 id=\"视频播放器\"><a href=\"#视频播放器\" class=\"headerlink\" title=\"视频播放器\"></a>视频播放器</h3><h4 id=\"Banshee\"><a href=\"#Banshee\" class=\"headerlink\" title=\"Banshee\"></a>Banshee</h4><p><a href=\"http://banshee.fm/\" target=\"_blank\" rel=\"noopener\">Banshee</a> 是一个开源的支持多格式的媒体播放器，于 2005 年开始开发并逐渐成长。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Banshee。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:banshee-team/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install banshee</span><br></pre></td></tr></table></figure>\n<h4 id=\"VLC\"><a href=\"#VLC\" class=\"headerlink\" title=\"VLC\"></a>VLC</h4><p><a href=\"https://www.videolan.org/\" target=\"_blank\" rel=\"noopener\">VLC</a> 是我最喜欢的视频播放器，它几乎可以播放任何格式的音频和视频，它还可以播放网络电台、录制桌面会话以及在线播放电影。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 VLC。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:videolan/stable-daily</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install vlc</span><br></pre></td></tr></table></figure>\n<h4 id=\"Kodi\"><a href=\"#Kodi\" class=\"headerlink\" title=\"Kodi\"></a>Kodi</h4><p><a href=\"https://kodi.tv/\" target=\"_blank\" rel=\"noopener\">Kodi</a> 是世界上最着名的媒体播放器之一，它有一个成熟的媒体中心，可以播放本地和远程的多媒体文件。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Kodi。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install software-properties-common</span><br><span class=\"line\">$ sudo add-apt-repository ppa:team-xbmc/ppa</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install kodi</span><br></pre></td></tr></table></figure>\n<h4 id=\"SMPlayer\"><a href=\"#SMPlayer\" class=\"headerlink\" title=\"SMPlayer\"></a>SMPlayer</h4><p><a href=\"https://www.smplayer.info/\" target=\"_blank\" rel=\"noopener\">SMPlayer</a> 是 MPlayer 的 GUI 版本，所有流行的媒体格式它都能够处理，并且它还有从 YouTube 和 Chromcast 和下载字幕的功能。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 SMPlayer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:rvm/smplayer</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install smplayer</span><br></pre></td></tr></table></figure>\n<h3 id=\"虚拟化工具\"><a href=\"#虚拟化工具\" class=\"headerlink\" title=\"虚拟化工具\"></a>虚拟化工具</h3><h4 id=\"VirtualBox\"><a href=\"#VirtualBox\" class=\"headerlink\" title=\"VirtualBox\"></a>VirtualBox</h4><p><a href=\"https://www.virtualbox.org/wiki/VirtualBox\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> 是一个用于操作系统虚拟化的开源应用程序，在服务器、台式机和嵌入式系统上都可以运行。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 VirtualBox。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -</span><br><span class=\"line\">$ wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install virtualbox-5.2</span><br><span class=\"line\">$ virtualbox</span><br></pre></td></tr></table></figure>\n<h4 id=\"VMWare\"><a href=\"#VMWare\" class=\"headerlink\" title=\"VMWare\"></a>VMWare</h4><p><a href=\"https://www.vmware.com/\" target=\"_blank\" rel=\"noopener\">VMware</a> 是一个为客户提供平台虚拟化和云计算服务的数字工作区，是第一个成功将 x86 架构系统虚拟化的工作站。 VMware 工作站的其中一个产品就允许用户在虚拟内存中运行多个操作系统。</p>\n<p>参阅 <a href=\"https://www.tecmint.com/install-vmware-workstation-in-linux/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 上安装 VMWare Workstation Pro</a> 可以了解 VMWare 的安装。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><h4 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h4><p><a href=\"https://www.google.com/chrome/\" target=\"_blank\" rel=\"noopener\">Google Chrome</a> 无疑是最受欢迎的浏览器。Chrome 以其速度、简洁、安全、美观而受人喜爱，它遵循了 Google 的界面设计风格，是 web 开发人员不可缺少的浏览器，同时它也是免费开源的。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Google Chrome。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</span><br><span class=\"line\">$ sudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google.list&apos;</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>\n<h4 id=\"Firefox\"><a href=\"#Firefox\" class=\"headerlink\" title=\"Firefox\"></a>Firefox</h4><p><a href=\"https://www.mozilla.org/en-US/firefox/\" target=\"_blank\" rel=\"noopener\">Firefox Quantum</a> 是一款漂亮、快速、完善并且可自定义的浏览器。它也是自由开源的，包含有开发人员所需要的工具，对于初学者也没有任何使用门槛。</p>\n<p>使用以下命令在 Ubuntu 和 Debian 安装 Firefox Quantum。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo add-apt-repository ppa:mozillateam/firefox-next</span><br><span class=\"line\">$ sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class=\"line\">$ sudo apt install firefox</span><br></pre></td></tr></table></figure>\n<h4 id=\"Vivaldi\"><a href=\"#Vivaldi\" class=\"headerlink\" title=\"Vivaldi\"></a>Vivaldi</h4><p><a href=\"https://vivaldi.com/\" target=\"_blank\" rel=\"noopener\">Vivaldi</a> 是一个基于 Chrome 的自由开源项目，旨在通过添加扩展来使 Chrome 的功能更加完善。色彩丰富的界面，性能良好、灵活性强是它的几大特点。</p>\n<p>参考阅读：<a href=\"https://vivaldi.com/\" target=\"_blank\" rel=\"noopener\">在 Ubuntu 下载 Vivaldi</a></p>\n<p>以上就是我的推荐，你还有更好的软件向大家分享吗？欢迎评论。</p>\n<hr>\n<p>via: <a href=\"https://www.fossmint.com/most-used-linux-applications/\" target=\"_blank\" rel=\"noopener\">https://www.fossmint.com/most-used-linux-applications/</a></p>\n"},{"title":"命令别名：定义自己的命令","date":"2018-12-24T04:53:40.000Z","_content":"\n> 学习如何创建别名：你可以将太长或难以记忆的命令打包成你自己构建的命令。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/jodi-mucha-540841-unsplash.jpg?itok=n1d1VDUV)\n\n<ruby>命令别名<rt>Alias</rt></ruby>在 Linux shell 中指的是将一些太长或者太难记的多个命令组合起来，成为一个由用户自己构建的命令。\n\n可以通过 `alias` 命令来创建命令别名。在 `alias` 后面跟上想要创建的别名名称、一个等号（`=`），以及希望使用这个别名来执行的命令，这样一个命令别名就创建好了。举个例子，`ls` 命令在默认情况下是不会对输出的内容进行着色的，这样就不能让用户一眼分辨出目录、文件和连接了。对此，可以创建这样一个命令别名，在输出目录内容的时候为输出内容着色：\n\n```\nalias lc='ls --color=auto'\n```\n\n其中 `lc` 是自定义的命令别名，代表 “list with color” 的意思。在创建命令别名的时候，需要先确认使用的别名是不是已经有对应的命令了，如果有的话，原本的命令就会被覆盖掉了。注意，定义命令别名的时候，`=` 两端是没有空格的。当运行 `lc` 的时候，就相当于执行了 `ls --color` 命令。\n\n此后，执行 `lc` 列出目录内容的时候，就会输出带有着色的内容了。\n\n你可能会发现你在执行 `ls` 的时候，本来就是输出带有着色的内容。那是因为大部分 Linux 发行版都已经将 `ls` 设定为带有着色的命令别名了。\n\n### 可以直接使用的命令别名\n\n实际上，执行不带任何内容的 `alias` 命令就可以看到当前已经设定的所有命令别名。对于不同的发行版，包含的命令别名不尽相同，但普遍都会有以下这些命令别名：\n\n  * `alias ls='ls --color=auto'`：这个命令别名在前面已经提到过了。`--color=auto` 参数会让 `ls` 命令在通过标准输出在终端中显示内容时进行着色，而其它情况（例如通过管道输出到文件）下则不进行着色。`--color` 这个参数还可以设置为 `always` 或`never`。\n  * `alias cp='cp -i'`：`-i` 参数代表“<ruby>交互<rt>interactive</rt></ruby>”。在使用 `cp` 命令复制文件的时候，可能会无意中覆盖现有的文件，在使用了 `-i` 参数之后，`cp` 命令会在一些关键操作前向用户发出询问。\n  * `alias free='free -m'`：在 `free` 命令后面加上 `-m` 参数，就可以将输出的内存信息以 MiB 这个更方面阅读和计算的单位输出，而不是默认的 Byte 单位。\n\n你使用的发行版自带的命令别名可能多多少少和上面有些差别。但你都可以在命令前面加上 `\\` 修饰符来使用命令的最基本形式（而不是别名）。例如：\n\n```\n\\free\n```\n\n就是直接执行 `free`，而不是 `free -m`。还有：\n\n```\n\\ls\n```\n\n执行的就是不带有`--color=auto` 参数的 `ls`。\n\n如果想要持久地保存命令别名，可以在 `.bashrc` 文件中进行修改，而它[来源于我们的 /etc/skel 目录][1]。\n\n### 使用命令别名纠正错误\n\n各种发行版的设计者都会尽量设置用户可能需要用到的命令别名。但是不同的用户的习惯各不相同，一些用户可能刚从其它操作系统迁移到 Linux，而不同操作系统的基本命令又因 shell 而异。因此，对于刚从 Windows/MS-DOS 系统迁移到 Linux 系统的用户，不妨使用\n\n```\nalias dir='ls'\n```\n\n这个命令别名来列出目录内容。\n\n类似地，\n\n```\nalias copy='cp'\nalias move='mv'\n```\n\n也可以在尚未完全熟悉 Linux 的时候用得顺手。\n\n还有一种情况，就是在经常出现输入错误的场合中做出容错，例如，对于我来说， Administration 这个单词就很难快速正确地输入，因此很多用户都会设置类似这样的别名：\n\n```\nalias sl='ls'\n```\n\n以及\n\n```\nalias gerp='echo \"You did it *again*!\"; grep'\n```\n\n`grep` 命令最基本的用途就是在文件中查找字符串，在熟悉这个命令之后，它一定是最常用的命令之一，因此输入错误导致不得不重输命令就很令人抓狂。\n\n在上面 `gerp` 的例子中，包含的不只是一条命令，而是两条。第一条命令 `echo \"You did it *again*!\"` 输出了一条提醒用户拼写错误的消息，然后使用分号（`；`）把两条命令隔开，再往后才是 `grep` 这一条正确的命令。\n\n在我的系统上使用 `gerp` 来搜索 `/etc/skel/.bashrc` 中包含“alias”这个单词的行，就会输出以下内容：\n\n```\n$ gerp -R alias /etc/skel/.bashrc\nYou did it *again*! \n       alias ls='ls --color=auto' \n       alias grep='grep --colour=auto' \n       alias egrep='egrep --colour=auto' \n       alias fgrep='fgrep --colour=auto' \nalias cp=\"cp -i\"\nalias df='df -h'\nalias free='free -m'\nalias np='nano -w PKGBUILD' \nalias more=less \nshopt -s expand_aliases\n```\n\n在命令别名中以固定的顺序执行多个命令，甚至更进一步，把多个命令串连起来，让后面的命令可以使用到前面的命令的执行结果。这样的做法已经非常接近 bash 脚本了。这篇文章已经接近尾声，我们将在下一篇文章中详细介绍。\n\n如果想要删除在终端中临时设置的别名，可以使用 `unalias` 命令。\n\n```\nunalias gerp\n```\n\n如果想要持久保存命令别名，可以将命令别名放在用户主目录的 `.bashrc` 文件中，具体的方法在[上一篇文章][2]中已经介绍过。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands\n\n[a]: https://www.linux.com/users/bro66\n[b]: https://github.com/lujun9972\n[1]: https://linux.cn/article-10370-1.html\n[2]: https://linux.cn/article-10374-1.html\n\n","source":"_posts/Aliases-DIY-Shell-Commands.md","raw":"---\ntitle: 命令别名：定义自己的命令\ndate: 2018-12-24 12:53:40\ntags:\n  - 命令\n  - LCTT 翻译\n---\n\n> 学习如何创建别名：你可以将太长或难以记忆的命令打包成你自己构建的命令。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/jodi-mucha-540841-unsplash.jpg?itok=n1d1VDUV)\n\n<ruby>命令别名<rt>Alias</rt></ruby>在 Linux shell 中指的是将一些太长或者太难记的多个命令组合起来，成为一个由用户自己构建的命令。\n\n可以通过 `alias` 命令来创建命令别名。在 `alias` 后面跟上想要创建的别名名称、一个等号（`=`），以及希望使用这个别名来执行的命令，这样一个命令别名就创建好了。举个例子，`ls` 命令在默认情况下是不会对输出的内容进行着色的，这样就不能让用户一眼分辨出目录、文件和连接了。对此，可以创建这样一个命令别名，在输出目录内容的时候为输出内容着色：\n\n```\nalias lc='ls --color=auto'\n```\n\n其中 `lc` 是自定义的命令别名，代表 “list with color” 的意思。在创建命令别名的时候，需要先确认使用的别名是不是已经有对应的命令了，如果有的话，原本的命令就会被覆盖掉了。注意，定义命令别名的时候，`=` 两端是没有空格的。当运行 `lc` 的时候，就相当于执行了 `ls --color` 命令。\n\n此后，执行 `lc` 列出目录内容的时候，就会输出带有着色的内容了。\n\n你可能会发现你在执行 `ls` 的时候，本来就是输出带有着色的内容。那是因为大部分 Linux 发行版都已经将 `ls` 设定为带有着色的命令别名了。\n\n### 可以直接使用的命令别名\n\n实际上，执行不带任何内容的 `alias` 命令就可以看到当前已经设定的所有命令别名。对于不同的发行版，包含的命令别名不尽相同，但普遍都会有以下这些命令别名：\n\n  * `alias ls='ls --color=auto'`：这个命令别名在前面已经提到过了。`--color=auto` 参数会让 `ls` 命令在通过标准输出在终端中显示内容时进行着色，而其它情况（例如通过管道输出到文件）下则不进行着色。`--color` 这个参数还可以设置为 `always` 或`never`。\n  * `alias cp='cp -i'`：`-i` 参数代表“<ruby>交互<rt>interactive</rt></ruby>”。在使用 `cp` 命令复制文件的时候，可能会无意中覆盖现有的文件，在使用了 `-i` 参数之后，`cp` 命令会在一些关键操作前向用户发出询问。\n  * `alias free='free -m'`：在 `free` 命令后面加上 `-m` 参数，就可以将输出的内存信息以 MiB 这个更方面阅读和计算的单位输出，而不是默认的 Byte 单位。\n\n你使用的发行版自带的命令别名可能多多少少和上面有些差别。但你都可以在命令前面加上 `\\` 修饰符来使用命令的最基本形式（而不是别名）。例如：\n\n```\n\\free\n```\n\n就是直接执行 `free`，而不是 `free -m`。还有：\n\n```\n\\ls\n```\n\n执行的就是不带有`--color=auto` 参数的 `ls`。\n\n如果想要持久地保存命令别名，可以在 `.bashrc` 文件中进行修改，而它[来源于我们的 /etc/skel 目录][1]。\n\n### 使用命令别名纠正错误\n\n各种发行版的设计者都会尽量设置用户可能需要用到的命令别名。但是不同的用户的习惯各不相同，一些用户可能刚从其它操作系统迁移到 Linux，而不同操作系统的基本命令又因 shell 而异。因此，对于刚从 Windows/MS-DOS 系统迁移到 Linux 系统的用户，不妨使用\n\n```\nalias dir='ls'\n```\n\n这个命令别名来列出目录内容。\n\n类似地，\n\n```\nalias copy='cp'\nalias move='mv'\n```\n\n也可以在尚未完全熟悉 Linux 的时候用得顺手。\n\n还有一种情况，就是在经常出现输入错误的场合中做出容错，例如，对于我来说， Administration 这个单词就很难快速正确地输入，因此很多用户都会设置类似这样的别名：\n\n```\nalias sl='ls'\n```\n\n以及\n\n```\nalias gerp='echo \"You did it *again*!\"; grep'\n```\n\n`grep` 命令最基本的用途就是在文件中查找字符串，在熟悉这个命令之后，它一定是最常用的命令之一，因此输入错误导致不得不重输命令就很令人抓狂。\n\n在上面 `gerp` 的例子中，包含的不只是一条命令，而是两条。第一条命令 `echo \"You did it *again*!\"` 输出了一条提醒用户拼写错误的消息，然后使用分号（`；`）把两条命令隔开，再往后才是 `grep` 这一条正确的命令。\n\n在我的系统上使用 `gerp` 来搜索 `/etc/skel/.bashrc` 中包含“alias”这个单词的行，就会输出以下内容：\n\n```\n$ gerp -R alias /etc/skel/.bashrc\nYou did it *again*! \n       alias ls='ls --color=auto' \n       alias grep='grep --colour=auto' \n       alias egrep='egrep --colour=auto' \n       alias fgrep='fgrep --colour=auto' \nalias cp=\"cp -i\"\nalias df='df -h'\nalias free='free -m'\nalias np='nano -w PKGBUILD' \nalias more=less \nshopt -s expand_aliases\n```\n\n在命令别名中以固定的顺序执行多个命令，甚至更进一步，把多个命令串连起来，让后面的命令可以使用到前面的命令的执行结果。这样的做法已经非常接近 bash 脚本了。这篇文章已经接近尾声，我们将在下一篇文章中详细介绍。\n\n如果想要删除在终端中临时设置的别名，可以使用 `unalias` 命令。\n\n```\nunalias gerp\n```\n\n如果想要持久保存命令别名，可以将命令别名放在用户主目录的 `.bashrc` 文件中，具体的方法在[上一篇文章][2]中已经介绍过。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands\n\n[a]: https://www.linux.com/users/bro66\n[b]: https://github.com/lujun9972\n[1]: https://linux.cn/article-10370-1.html\n[2]: https://linux.cn/article-10374-1.html\n\n","slug":"Aliases-DIY-Shell-Commands","published":1,"updated":"2019-03-28T13:17:43.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0c8000hlixuqpadi4n2","content":"<blockquote>\n<p>学习如何创建别名：你可以将太长或难以记忆的命令打包成你自己构建的命令。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/jodi-mucha-540841-unsplash.jpg?itok=n1d1VDUV\" alt=\"\"></p>\n<p><ruby>命令别名<rt>Alias</rt></ruby>在 Linux shell 中指的是将一些太长或者太难记的多个命令组合起来，成为一个由用户自己构建的命令。</p>\n<p>可以通过 <code>alias</code> 命令来创建命令别名。在 <code>alias</code> 后面跟上想要创建的别名名称、一个等号（<code>=</code>），以及希望使用这个别名来执行的命令，这样一个命令别名就创建好了。举个例子，<code>ls</code> 命令在默认情况下是不会对输出的内容进行着色的，这样就不能让用户一眼分辨出目录、文件和连接了。对此，可以创建这样一个命令别名，在输出目录内容的时候为输出内容着色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias lc=&apos;ls --color=auto&apos;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>lc</code> 是自定义的命令别名，代表 “list with color” 的意思。在创建命令别名的时候，需要先确认使用的别名是不是已经有对应的命令了，如果有的话，原本的命令就会被覆盖掉了。注意，定义命令别名的时候，<code>=</code> 两端是没有空格的。当运行 <code>lc</code> 的时候，就相当于执行了 <code>ls --color</code> 命令。</p>\n<p>此后，执行 <code>lc</code> 列出目录内容的时候，就会输出带有着色的内容了。</p>\n<p>你可能会发现你在执行 <code>ls</code> 的时候，本来就是输出带有着色的内容。那是因为大部分 Linux 发行版都已经将 <code>ls</code> 设定为带有着色的命令别名了。</p>\n<h3 id=\"可以直接使用的命令别名\"><a href=\"#可以直接使用的命令别名\" class=\"headerlink\" title=\"可以直接使用的命令别名\"></a>可以直接使用的命令别名</h3><p>实际上，执行不带任何内容的 <code>alias</code> 命令就可以看到当前已经设定的所有命令别名。对于不同的发行版，包含的命令别名不尽相同，但普遍都会有以下这些命令别名：</p>\n<ul>\n<li><code>alias ls=&#39;ls --color=auto&#39;</code>：这个命令别名在前面已经提到过了。<code>--color=auto</code> 参数会让 <code>ls</code> 命令在通过标准输出在终端中显示内容时进行着色，而其它情况（例如通过管道输出到文件）下则不进行着色。<code>--color</code> 这个参数还可以设置为 <code>always</code> 或<code>never</code>。</li>\n<li><code>alias cp=&#39;cp -i&#39;</code>：<code>-i</code> 参数代表“<ruby>交互<rt>interactive</rt></ruby>”。在使用 <code>cp</code> 命令复制文件的时候，可能会无意中覆盖现有的文件，在使用了 <code>-i</code> 参数之后，<code>cp</code> 命令会在一些关键操作前向用户发出询问。</li>\n<li><code>alias free=&#39;free -m&#39;</code>：在 <code>free</code> 命令后面加上 <code>-m</code> 参数，就可以将输出的内存信息以 MiB 这个更方面阅读和计算的单位输出，而不是默认的 Byte 单位。</li>\n</ul>\n<p>你使用的发行版自带的命令别名可能多多少少和上面有些差别。但你都可以在命令前面加上 <code>\\</code> 修饰符来使用命令的最基本形式（而不是别名）。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\free</span><br></pre></td></tr></table></figure>\n<p>就是直接执行 <code>free</code>，而不是 <code>free -m</code>。还有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\ls</span><br></pre></td></tr></table></figure>\n<p>执行的就是不带有<code>--color=auto</code> 参数的 <code>ls</code>。</p>\n<p>如果想要持久地保存命令别名，可以在 <code>.bashrc</code> 文件中进行修改，而它<a href=\"https://linux.cn/article-10370-1.html\" target=\"_blank\" rel=\"noopener\">来源于我们的 /etc/skel 目录</a>。</p>\n<h3 id=\"使用命令别名纠正错误\"><a href=\"#使用命令别名纠正错误\" class=\"headerlink\" title=\"使用命令别名纠正错误\"></a>使用命令别名纠正错误</h3><p>各种发行版的设计者都会尽量设置用户可能需要用到的命令别名。但是不同的用户的习惯各不相同，一些用户可能刚从其它操作系统迁移到 Linux，而不同操作系统的基本命令又因 shell 而异。因此，对于刚从 Windows/MS-DOS 系统迁移到 Linux 系统的用户，不妨使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias dir=&apos;ls&apos;</span><br></pre></td></tr></table></figure>\n<p>这个命令别名来列出目录内容。</p>\n<p>类似地，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias copy=&apos;cp&apos;</span><br><span class=\"line\">alias move=&apos;mv&apos;</span><br></pre></td></tr></table></figure>\n<p>也可以在尚未完全熟悉 Linux 的时候用得顺手。</p>\n<p>还有一种情况，就是在经常出现输入错误的场合中做出容错，例如，对于我来说， Administration 这个单词就很难快速正确地输入，因此很多用户都会设置类似这样的别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias sl=&apos;ls&apos;</span><br></pre></td></tr></table></figure>\n<p>以及</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias gerp=&apos;echo &quot;You did it *again*!&quot;; grep&apos;</span><br></pre></td></tr></table></figure>\n<p><code>grep</code> 命令最基本的用途就是在文件中查找字符串，在熟悉这个命令之后，它一定是最常用的命令之一，因此输入错误导致不得不重输命令就很令人抓狂。</p>\n<p>在上面 <code>gerp</code> 的例子中，包含的不只是一条命令，而是两条。第一条命令 <code>echo &quot;You did it *again*!&quot;</code> 输出了一条提醒用户拼写错误的消息，然后使用分号（<code>；</code>）把两条命令隔开，再往后才是 <code>grep</code> 这一条正确的命令。</p>\n<p>在我的系统上使用 <code>gerp</code> 来搜索 <code>/etc/skel/.bashrc</code> 中包含“alias”这个单词的行，就会输出以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gerp -R alias /etc/skel/.bashrc</span><br><span class=\"line\">You did it *again*! </span><br><span class=\"line\">       alias ls=&apos;ls --color=auto&apos; </span><br><span class=\"line\">       alias grep=&apos;grep --colour=auto&apos; </span><br><span class=\"line\">       alias egrep=&apos;egrep --colour=auto&apos; </span><br><span class=\"line\">       alias fgrep=&apos;fgrep --colour=auto&apos; </span><br><span class=\"line\">alias cp=&quot;cp -i&quot;</span><br><span class=\"line\">alias df=&apos;df -h&apos;</span><br><span class=\"line\">alias free=&apos;free -m&apos;</span><br><span class=\"line\">alias np=&apos;nano -w PKGBUILD&apos; </span><br><span class=\"line\">alias more=less </span><br><span class=\"line\">shopt -s expand_aliases</span><br></pre></td></tr></table></figure>\n<p>在命令别名中以固定的顺序执行多个命令，甚至更进一步，把多个命令串连起来，让后面的命令可以使用到前面的命令的执行结果。这样的做法已经非常接近 bash 脚本了。这篇文章已经接近尾声，我们将在下一篇文章中详细介绍。</p>\n<p>如果想要删除在终端中临时设置的别名，可以使用 <code>unalias</code> 命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unalias gerp</span><br></pre></td></tr></table></figure>\n<p>如果想要持久保存命令别名，可以将命令别名放在用户主目录的 <code>.bashrc</code> 文件中，具体的方法在<a href=\"https://linux.cn/article-10374-1.html\" target=\"_blank\" rel=\"noopener\">上一篇文章</a>中已经介绍过。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>学习如何创建别名：你可以将太长或难以记忆的命令打包成你自己构建的命令。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/jodi-mucha-540841-unsplash.jpg?itok=n1d1VDUV\" alt=\"\"></p>\n<p><ruby>命令别名<rt>Alias</rt></ruby>在 Linux shell 中指的是将一些太长或者太难记的多个命令组合起来，成为一个由用户自己构建的命令。</p>\n<p>可以通过 <code>alias</code> 命令来创建命令别名。在 <code>alias</code> 后面跟上想要创建的别名名称、一个等号（<code>=</code>），以及希望使用这个别名来执行的命令，这样一个命令别名就创建好了。举个例子，<code>ls</code> 命令在默认情况下是不会对输出的内容进行着色的，这样就不能让用户一眼分辨出目录、文件和连接了。对此，可以创建这样一个命令别名，在输出目录内容的时候为输出内容着色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias lc=&apos;ls --color=auto&apos;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>lc</code> 是自定义的命令别名，代表 “list with color” 的意思。在创建命令别名的时候，需要先确认使用的别名是不是已经有对应的命令了，如果有的话，原本的命令就会被覆盖掉了。注意，定义命令别名的时候，<code>=</code> 两端是没有空格的。当运行 <code>lc</code> 的时候，就相当于执行了 <code>ls --color</code> 命令。</p>\n<p>此后，执行 <code>lc</code> 列出目录内容的时候，就会输出带有着色的内容了。</p>\n<p>你可能会发现你在执行 <code>ls</code> 的时候，本来就是输出带有着色的内容。那是因为大部分 Linux 发行版都已经将 <code>ls</code> 设定为带有着色的命令别名了。</p>\n<h3 id=\"可以直接使用的命令别名\"><a href=\"#可以直接使用的命令别名\" class=\"headerlink\" title=\"可以直接使用的命令别名\"></a>可以直接使用的命令别名</h3><p>实际上，执行不带任何内容的 <code>alias</code> 命令就可以看到当前已经设定的所有命令别名。对于不同的发行版，包含的命令别名不尽相同，但普遍都会有以下这些命令别名：</p>\n<ul>\n<li><code>alias ls=&#39;ls --color=auto&#39;</code>：这个命令别名在前面已经提到过了。<code>--color=auto</code> 参数会让 <code>ls</code> 命令在通过标准输出在终端中显示内容时进行着色，而其它情况（例如通过管道输出到文件）下则不进行着色。<code>--color</code> 这个参数还可以设置为 <code>always</code> 或<code>never</code>。</li>\n<li><code>alias cp=&#39;cp -i&#39;</code>：<code>-i</code> 参数代表“<ruby>交互<rt>interactive</rt></ruby>”。在使用 <code>cp</code> 命令复制文件的时候，可能会无意中覆盖现有的文件，在使用了 <code>-i</code> 参数之后，<code>cp</code> 命令会在一些关键操作前向用户发出询问。</li>\n<li><code>alias free=&#39;free -m&#39;</code>：在 <code>free</code> 命令后面加上 <code>-m</code> 参数，就可以将输出的内存信息以 MiB 这个更方面阅读和计算的单位输出，而不是默认的 Byte 单位。</li>\n</ul>\n<p>你使用的发行版自带的命令别名可能多多少少和上面有些差别。但你都可以在命令前面加上 <code>\\</code> 修饰符来使用命令的最基本形式（而不是别名）。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\free</span><br></pre></td></tr></table></figure>\n<p>就是直接执行 <code>free</code>，而不是 <code>free -m</code>。还有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\ls</span><br></pre></td></tr></table></figure>\n<p>执行的就是不带有<code>--color=auto</code> 参数的 <code>ls</code>。</p>\n<p>如果想要持久地保存命令别名，可以在 <code>.bashrc</code> 文件中进行修改，而它<a href=\"https://linux.cn/article-10370-1.html\" target=\"_blank\" rel=\"noopener\">来源于我们的 /etc/skel 目录</a>。</p>\n<h3 id=\"使用命令别名纠正错误\"><a href=\"#使用命令别名纠正错误\" class=\"headerlink\" title=\"使用命令别名纠正错误\"></a>使用命令别名纠正错误</h3><p>各种发行版的设计者都会尽量设置用户可能需要用到的命令别名。但是不同的用户的习惯各不相同，一些用户可能刚从其它操作系统迁移到 Linux，而不同操作系统的基本命令又因 shell 而异。因此，对于刚从 Windows/MS-DOS 系统迁移到 Linux 系统的用户，不妨使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias dir=&apos;ls&apos;</span><br></pre></td></tr></table></figure>\n<p>这个命令别名来列出目录内容。</p>\n<p>类似地，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias copy=&apos;cp&apos;</span><br><span class=\"line\">alias move=&apos;mv&apos;</span><br></pre></td></tr></table></figure>\n<p>也可以在尚未完全熟悉 Linux 的时候用得顺手。</p>\n<p>还有一种情况，就是在经常出现输入错误的场合中做出容错，例如，对于我来说， Administration 这个单词就很难快速正确地输入，因此很多用户都会设置类似这样的别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias sl=&apos;ls&apos;</span><br></pre></td></tr></table></figure>\n<p>以及</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias gerp=&apos;echo &quot;You did it *again*!&quot;; grep&apos;</span><br></pre></td></tr></table></figure>\n<p><code>grep</code> 命令最基本的用途就是在文件中查找字符串，在熟悉这个命令之后，它一定是最常用的命令之一，因此输入错误导致不得不重输命令就很令人抓狂。</p>\n<p>在上面 <code>gerp</code> 的例子中，包含的不只是一条命令，而是两条。第一条命令 <code>echo &quot;You did it *again*!&quot;</code> 输出了一条提醒用户拼写错误的消息，然后使用分号（<code>；</code>）把两条命令隔开，再往后才是 <code>grep</code> 这一条正确的命令。</p>\n<p>在我的系统上使用 <code>gerp</code> 来搜索 <code>/etc/skel/.bashrc</code> 中包含“alias”这个单词的行，就会输出以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gerp -R alias /etc/skel/.bashrc</span><br><span class=\"line\">You did it *again*! </span><br><span class=\"line\">       alias ls=&apos;ls --color=auto&apos; </span><br><span class=\"line\">       alias grep=&apos;grep --colour=auto&apos; </span><br><span class=\"line\">       alias egrep=&apos;egrep --colour=auto&apos; </span><br><span class=\"line\">       alias fgrep=&apos;fgrep --colour=auto&apos; </span><br><span class=\"line\">alias cp=&quot;cp -i&quot;</span><br><span class=\"line\">alias df=&apos;df -h&apos;</span><br><span class=\"line\">alias free=&apos;free -m&apos;</span><br><span class=\"line\">alias np=&apos;nano -w PKGBUILD&apos; </span><br><span class=\"line\">alias more=less </span><br><span class=\"line\">shopt -s expand_aliases</span><br></pre></td></tr></table></figure>\n<p>在命令别名中以固定的顺序执行多个命令，甚至更进一步，把多个命令串连起来，让后面的命令可以使用到前面的命令的执行结果。这样的做法已经非常接近 bash 脚本了。这篇文章已经接近尾声，我们将在下一篇文章中详细介绍。</p>\n<p>如果想要删除在终端中临时设置的别名，可以使用 <code>unalias</code> 命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unalias gerp</span><br></pre></td></tr></table></figure>\n<p>如果想要持久保存命令别名，可以将命令别名放在用户主目录的 <code>.bashrc</code> 文件中，具体的方法在<a href=\"https://linux.cn/article-10374-1.html\" target=\"_blank\" rel=\"noopener\">上一篇文章</a>中已经介绍过。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/blog/learn/2018/12/aliases-diy-shell-commands</a></p>\n"},{"title":"Android 9.0 概览","date":"2018-11-29T14:51:51.000Z","_content":"\n> 第九代 Android 带来了更令人满意的用户体验。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/android-pie.jpg?itok=Sx4rbOWY)\n\n我们来谈论一下 Android。尽管 Android 只是一款内核经过修改的 Linux，但经过多年的发展，Android 开发者们（或许包括正在阅读这篇文章的你）已经为这个平台的演变做出了很多值得称道的贡献。当然，可能很多人都已经知道，但我们还是要说，Android 并不完全开源，当你使用 Google 服务的时候，就已经接触到闭源的部分了。Google Play 商店就是其中之一，它不是一个开放的服务。不过无论 Android 开源与否，这就是一个美味、营养、高效、省电的馅饼（LCTT 译注：Android 9.0 代号为 Pie）。\n\n我在我的 Essential PH-1 手机上运行了 Android 9.0（我真的很喜欢这款手机，也知道这家公司的境况并不好）。在我自己体验了一段时间之后，我认为它是会被大众接受的。那么 Android 9.0 到底好在哪里呢？下面我们就来深入探讨一下。我们的出发点是用户的角度，而不是开发人员的角度，因此我也不会深入探讨太底层的方面。\n\n### 手势操作\n\nAndroid 系统在新的手势操作方面投入了很多，但实际体验却不算太好。这个功能确实引起了我的兴趣。在这个功能发布之初，大家都对它了解甚少，纷纷猜测它会不会让用户使用多点触控的手势来浏览 Android 界面？又或者会不会是一个完全颠覆人们认知的东西？\n\n实际上，手势操作比大多数人设想的要更加微妙而简单，因为很多功能都浓缩到了 Home 键上。打开手势操作功能之后，Recent 键的功能就合并到 Home 键上了。因此，如果需要查看最近打开的应用程序，就不能简单地通过 Recent 键来查看，而应该从 Home 键向上轻扫一下。（图 1）\n\n![Android Pie][2]\n\n*图 1：Android 9.0 中的”最近的应用程序“界面。*\n\n另一个不同的地方是 App Drawer。类似于查看最近打开的应用，需要在 Home 键向上滑动才能打开 App Drawer。\n\n而后退按钮则没有去掉。在应用程序需要用到后退功能时，它就会出现在主屏幕的左下方。有时候即使应用程序自己带有后退按钮，Android 的后退按钮也会出现。\n\n当然，如果你不喜欢使用手势操作，也可以禁用这个功能。只需要按照下列步骤操作：\n\n  1. 打开”设置“\n  2. 向下滑动并进入“系统 > 手势”\n  3. 从 Home 键向上滑动\n  4. 将 On/Off 滑块（图 2）滑动至 Off 位置\n\n![](https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_2.png?itok=cs2tqZut)\n\n*图 2：关闭手势操作。*\n\n### 电池寿命\n\n人工智能已经在 Android 得到了充分的使用。现在，Android 使用人工智能大大提供了电池的续航时间，这样的新技术称为自适应电池。自适应电池可以根据用户的个人使用习惯来决定各种应用和服务的耗电优先级。通过使用人工智能技术，Android 可以分析用户对每一个应用或服务的使用情况，并适当地关闭未使用的应用程序，以免长期驻留在内存中白白消耗电池电量。\n\n对于这个功能的唯一一个警告是，如果人工智能出现问题并导致电池电量过早耗尽，就只能通过恢复出厂设置来解决这个问题了。尽管有这样的缺陷，在电池续航时间方面，Android 9.0 也比 Android 8.0 有所改善。\n\n### 分屏功能的变化\n\n分屏对于 Android 来说不是一个新功能，但在 Android 9.0 上，它的使用方式和以往相比略有不同，而且只对于手势操作有影响，不使用手势操作的用户不受影响。要在 Android 9.0 上使用分屏功能，需要按照下列步骤操作：\n\n  1. 从 Home 键向上滑动，打开“最近的应用程序”。\n  2. 找到需要放置在屏幕顶部的应用程序。\n  3. 长按应用程序顶部的图标以显示新的弹出菜单。（图 3）\n  4. 点击分屏，应用程序会在屏幕的上半部分打开。\n  5. 找到要打开的第二个应用程序，然后点击它添加到屏幕的下半部分。\n\n![Adding an app][5]\n\n*图 3：在 Android 9.0 上将应用添加到分屏模式中。*\n\n使用分屏功能关闭应用程序的方法和原来保持一致。\n\n### 应用操作\n\n这个功能在早前已经引入了，但直到 Android 9.0 发布，人们才开始对它产生明显的关注。应用操作功能可以让用户直接从应用启动器来执行应用里的某些操作。\n\n例如，长按 GMail 启动器，就可以执行回复最近的邮件、撰写新邮件等功能。在 Android 8.0 中，这个功能则以弹出动作列表的方式展现。在 Android 9.0 中，这个功能更契合 Google 的<ruby>材料设计<rt>Material Design</rt></ruby>风格（图 4）。\n\n![Actions][7]\n\n*图 4：Android 应用操作。*\n\n### 声音控制\n\n在 Android 中，声音控制的方式经常发生变化。在 Android 8.0 对“请勿打扰”功能进行调整之后，声音控制已经做得相当不错了。而在 Android 9.0 当中，声音控制再次进行了优化。\n\nAndroid 9.0 这次优化针对的是设备上快速控制声音的按钮。如果用户按下音量增大或减小按钮，就会看到一个新的弹出菜单，可以让用户控制设备的静音和震动情况。点击这个弹出菜单顶部的图标（图 5），可以在完全静音、静音和正常声音几种状态之间切换。\n\n![Sound control][9]\n\n*图 5：Android 9.0 上的声音控制。*\n\n### 屏幕截图\n\n由于我要撰写关于 Android 的文章，所以我会常常需要进行屏幕截图。而 Android 9.0 有一项我最喜欢的更新，就是分享屏幕截图。Android 9.0 可以在截取屏幕截图后，直接共享、编辑，或者删除不喜欢的截图，而不需要像以前一样打开 Google 相册、找到要共享的屏幕截图、打开图像然后共享图像。\n\n如果你想分享屏幕截图，只需要在截图后等待弹出菜单，点击分享（图 6），从标准的 Android 分享菜单中分享即可。\n\n![Sharing ][11]\n\n*图 6：共享屏幕截图变得更加容易。*\n\n### 更令人满意的 Android 体验\n\nAndroid 9.0 带来了更令人满意的用户体验。当然，以上说到的内容只是它的冰山一角。如果需要更多信息，可以查阅 Google 的官方 [Android 9.0 网站][12]。如果你的设备还没有收到升级推送，请耐心等待，Android 9.0 值得等待。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/2018/10/overview-android-pie\n\n[a]: https://www.linux.com/users/jlwallen\n[b]: https://github.com/lujun9972\n[1]: /files/images/pie1png\n[2]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_1.png?itok=BsSe8kqS \"Android Pie\"\n[3]: /licenses/category/used-permission\n[4]: /files/images/pie3png\n[5]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_3.png?itok=F-NB1dqI \"Adding an app\"\n[6]: /files/images/pie4png\n[7]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_4.png?itok=Ex-NzYSo \"Actions\"\n[8]: /files/images/pie5png\n[9]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_5.png?itok=NMW2vIlL \"Sound control\"\n[10]: /files/images/pie6png\n[11]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_6.png?itok=7Ik8_4jC \"Sharing \"\n[12]: https://www.android.com/versions/pie-9-0/\n\n","source":"_posts/An-Overview-of-Android-Pie.md","raw":"---\ntitle: Android 9.0 概览\ndate: 2018-11-29 22:51:51\ntags:\n  - Android\n  - LCTT 翻译\n---\n\n> 第九代 Android 带来了更令人满意的用户体验。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/android-pie.jpg?itok=Sx4rbOWY)\n\n我们来谈论一下 Android。尽管 Android 只是一款内核经过修改的 Linux，但经过多年的发展，Android 开发者们（或许包括正在阅读这篇文章的你）已经为这个平台的演变做出了很多值得称道的贡献。当然，可能很多人都已经知道，但我们还是要说，Android 并不完全开源，当你使用 Google 服务的时候，就已经接触到闭源的部分了。Google Play 商店就是其中之一，它不是一个开放的服务。不过无论 Android 开源与否，这就是一个美味、营养、高效、省电的馅饼（LCTT 译注：Android 9.0 代号为 Pie）。\n\n我在我的 Essential PH-1 手机上运行了 Android 9.0（我真的很喜欢这款手机，也知道这家公司的境况并不好）。在我自己体验了一段时间之后，我认为它是会被大众接受的。那么 Android 9.0 到底好在哪里呢？下面我们就来深入探讨一下。我们的出发点是用户的角度，而不是开发人员的角度，因此我也不会深入探讨太底层的方面。\n\n### 手势操作\n\nAndroid 系统在新的手势操作方面投入了很多，但实际体验却不算太好。这个功能确实引起了我的兴趣。在这个功能发布之初，大家都对它了解甚少，纷纷猜测它会不会让用户使用多点触控的手势来浏览 Android 界面？又或者会不会是一个完全颠覆人们认知的东西？\n\n实际上，手势操作比大多数人设想的要更加微妙而简单，因为很多功能都浓缩到了 Home 键上。打开手势操作功能之后，Recent 键的功能就合并到 Home 键上了。因此，如果需要查看最近打开的应用程序，就不能简单地通过 Recent 键来查看，而应该从 Home 键向上轻扫一下。（图 1）\n\n![Android Pie][2]\n\n*图 1：Android 9.0 中的”最近的应用程序“界面。*\n\n另一个不同的地方是 App Drawer。类似于查看最近打开的应用，需要在 Home 键向上滑动才能打开 App Drawer。\n\n而后退按钮则没有去掉。在应用程序需要用到后退功能时，它就会出现在主屏幕的左下方。有时候即使应用程序自己带有后退按钮，Android 的后退按钮也会出现。\n\n当然，如果你不喜欢使用手势操作，也可以禁用这个功能。只需要按照下列步骤操作：\n\n  1. 打开”设置“\n  2. 向下滑动并进入“系统 > 手势”\n  3. 从 Home 键向上滑动\n  4. 将 On/Off 滑块（图 2）滑动至 Off 位置\n\n![](https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_2.png?itok=cs2tqZut)\n\n*图 2：关闭手势操作。*\n\n### 电池寿命\n\n人工智能已经在 Android 得到了充分的使用。现在，Android 使用人工智能大大提供了电池的续航时间，这样的新技术称为自适应电池。自适应电池可以根据用户的个人使用习惯来决定各种应用和服务的耗电优先级。通过使用人工智能技术，Android 可以分析用户对每一个应用或服务的使用情况，并适当地关闭未使用的应用程序，以免长期驻留在内存中白白消耗电池电量。\n\n对于这个功能的唯一一个警告是，如果人工智能出现问题并导致电池电量过早耗尽，就只能通过恢复出厂设置来解决这个问题了。尽管有这样的缺陷，在电池续航时间方面，Android 9.0 也比 Android 8.0 有所改善。\n\n### 分屏功能的变化\n\n分屏对于 Android 来说不是一个新功能，但在 Android 9.0 上，它的使用方式和以往相比略有不同，而且只对于手势操作有影响，不使用手势操作的用户不受影响。要在 Android 9.0 上使用分屏功能，需要按照下列步骤操作：\n\n  1. 从 Home 键向上滑动，打开“最近的应用程序”。\n  2. 找到需要放置在屏幕顶部的应用程序。\n  3. 长按应用程序顶部的图标以显示新的弹出菜单。（图 3）\n  4. 点击分屏，应用程序会在屏幕的上半部分打开。\n  5. 找到要打开的第二个应用程序，然后点击它添加到屏幕的下半部分。\n\n![Adding an app][5]\n\n*图 3：在 Android 9.0 上将应用添加到分屏模式中。*\n\n使用分屏功能关闭应用程序的方法和原来保持一致。\n\n### 应用操作\n\n这个功能在早前已经引入了，但直到 Android 9.0 发布，人们才开始对它产生明显的关注。应用操作功能可以让用户直接从应用启动器来执行应用里的某些操作。\n\n例如，长按 GMail 启动器，就可以执行回复最近的邮件、撰写新邮件等功能。在 Android 8.0 中，这个功能则以弹出动作列表的方式展现。在 Android 9.0 中，这个功能更契合 Google 的<ruby>材料设计<rt>Material Design</rt></ruby>风格（图 4）。\n\n![Actions][7]\n\n*图 4：Android 应用操作。*\n\n### 声音控制\n\n在 Android 中，声音控制的方式经常发生变化。在 Android 8.0 对“请勿打扰”功能进行调整之后，声音控制已经做得相当不错了。而在 Android 9.0 当中，声音控制再次进行了优化。\n\nAndroid 9.0 这次优化针对的是设备上快速控制声音的按钮。如果用户按下音量增大或减小按钮，就会看到一个新的弹出菜单，可以让用户控制设备的静音和震动情况。点击这个弹出菜单顶部的图标（图 5），可以在完全静音、静音和正常声音几种状态之间切换。\n\n![Sound control][9]\n\n*图 5：Android 9.0 上的声音控制。*\n\n### 屏幕截图\n\n由于我要撰写关于 Android 的文章，所以我会常常需要进行屏幕截图。而 Android 9.0 有一项我最喜欢的更新，就是分享屏幕截图。Android 9.0 可以在截取屏幕截图后，直接共享、编辑，或者删除不喜欢的截图，而不需要像以前一样打开 Google 相册、找到要共享的屏幕截图、打开图像然后共享图像。\n\n如果你想分享屏幕截图，只需要在截图后等待弹出菜单，点击分享（图 6），从标准的 Android 分享菜单中分享即可。\n\n![Sharing ][11]\n\n*图 6：共享屏幕截图变得更加容易。*\n\n### 更令人满意的 Android 体验\n\nAndroid 9.0 带来了更令人满意的用户体验。当然，以上说到的内容只是它的冰山一角。如果需要更多信息，可以查阅 Google 的官方 [Android 9.0 网站][12]。如果你的设备还没有收到升级推送，请耐心等待，Android 9.0 值得等待。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/learn/2018/10/overview-android-pie\n\n[a]: https://www.linux.com/users/jlwallen\n[b]: https://github.com/lujun9972\n[1]: /files/images/pie1png\n[2]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_1.png?itok=BsSe8kqS \"Android Pie\"\n[3]: /licenses/category/used-permission\n[4]: /files/images/pie3png\n[5]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_3.png?itok=F-NB1dqI \"Adding an app\"\n[6]: /files/images/pie4png\n[7]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_4.png?itok=Ex-NzYSo \"Actions\"\n[8]: /files/images/pie5png\n[9]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_5.png?itok=NMW2vIlL \"Sound control\"\n[10]: /files/images/pie6png\n[11]: https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_6.png?itok=7Ik8_4jC \"Sharing \"\n[12]: https://www.android.com/versions/pie-9-0/\n\n","slug":"An-Overview-of-Android-Pie","published":1,"updated":"2019-03-28T13:05:46.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ca000ilixucksn2bwj","content":"<blockquote>\n<p>第九代 Android 带来了更令人满意的用户体验。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/android-pie.jpg?itok=Sx4rbOWY\" alt=\"\"></p>\n<p>我们来谈论一下 Android。尽管 Android 只是一款内核经过修改的 Linux，但经过多年的发展，Android 开发者们（或许包括正在阅读这篇文章的你）已经为这个平台的演变做出了很多值得称道的贡献。当然，可能很多人都已经知道，但我们还是要说，Android 并不完全开源，当你使用 Google 服务的时候，就已经接触到闭源的部分了。Google Play 商店就是其中之一，它不是一个开放的服务。不过无论 Android 开源与否，这就是一个美味、营养、高效、省电的馅饼（LCTT 译注：Android 9.0 代号为 Pie）。</p>\n<p>我在我的 Essential PH-1 手机上运行了 Android 9.0（我真的很喜欢这款手机，也知道这家公司的境况并不好）。在我自己体验了一段时间之后，我认为它是会被大众接受的。那么 Android 9.0 到底好在哪里呢？下面我们就来深入探讨一下。我们的出发点是用户的角度，而不是开发人员的角度，因此我也不会深入探讨太底层的方面。</p>\n<h3 id=\"手势操作\"><a href=\"#手势操作\" class=\"headerlink\" title=\"手势操作\"></a>手势操作</h3><p>Android 系统在新的手势操作方面投入了很多，但实际体验却不算太好。这个功能确实引起了我的兴趣。在这个功能发布之初，大家都对它了解甚少，纷纷猜测它会不会让用户使用多点触控的手势来浏览 Android 界面？又或者会不会是一个完全颠覆人们认知的东西？</p>\n<p>实际上，手势操作比大多数人设想的要更加微妙而简单，因为很多功能都浓缩到了 Home 键上。打开手势操作功能之后，Recent 键的功能就合并到 Home 键上了。因此，如果需要查看最近打开的应用程序，就不能简单地通过 Recent 键来查看，而应该从 Home 键向上轻扫一下。（图 1）</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_1.png?itok=BsSe8kqS\" alt=\"Android Pie\" title=\"Android Pie\"></p>\n<p><em>图 1：Android 9.0 中的”最近的应用程序“界面。</em></p>\n<p>另一个不同的地方是 App Drawer。类似于查看最近打开的应用，需要在 Home 键向上滑动才能打开 App Drawer。</p>\n<p>而后退按钮则没有去掉。在应用程序需要用到后退功能时，它就会出现在主屏幕的左下方。有时候即使应用程序自己带有后退按钮，Android 的后退按钮也会出现。</p>\n<p>当然，如果你不喜欢使用手势操作，也可以禁用这个功能。只需要按照下列步骤操作：</p>\n<ol>\n<li>打开”设置“</li>\n<li>向下滑动并进入“系统 &gt; 手势”</li>\n<li>从 Home 键向上滑动</li>\n<li>将 On/Off 滑块（图 2）滑动至 Off 位置</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_2.png?itok=cs2tqZut\" alt=\"\"></p>\n<p><em>图 2：关闭手势操作。</em></p>\n<h3 id=\"电池寿命\"><a href=\"#电池寿命\" class=\"headerlink\" title=\"电池寿命\"></a>电池寿命</h3><p>人工智能已经在 Android 得到了充分的使用。现在，Android 使用人工智能大大提供了电池的续航时间，这样的新技术称为自适应电池。自适应电池可以根据用户的个人使用习惯来决定各种应用和服务的耗电优先级。通过使用人工智能技术，Android 可以分析用户对每一个应用或服务的使用情况，并适当地关闭未使用的应用程序，以免长期驻留在内存中白白消耗电池电量。</p>\n<p>对于这个功能的唯一一个警告是，如果人工智能出现问题并导致电池电量过早耗尽，就只能通过恢复出厂设置来解决这个问题了。尽管有这样的缺陷，在电池续航时间方面，Android 9.0 也比 Android 8.0 有所改善。</p>\n<h3 id=\"分屏功能的变化\"><a href=\"#分屏功能的变化\" class=\"headerlink\" title=\"分屏功能的变化\"></a>分屏功能的变化</h3><p>分屏对于 Android 来说不是一个新功能，但在 Android 9.0 上，它的使用方式和以往相比略有不同，而且只对于手势操作有影响，不使用手势操作的用户不受影响。要在 Android 9.0 上使用分屏功能，需要按照下列步骤操作：</p>\n<ol>\n<li>从 Home 键向上滑动，打开“最近的应用程序”。</li>\n<li>找到需要放置在屏幕顶部的应用程序。</li>\n<li>长按应用程序顶部的图标以显示新的弹出菜单。（图 3）</li>\n<li>点击分屏，应用程序会在屏幕的上半部分打开。</li>\n<li>找到要打开的第二个应用程序，然后点击它添加到屏幕的下半部分。</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_3.png?itok=F-NB1dqI\" alt=\"Adding an app\" title=\"Adding an app\"></p>\n<p><em>图 3：在 Android 9.0 上将应用添加到分屏模式中。</em></p>\n<p>使用分屏功能关闭应用程序的方法和原来保持一致。</p>\n<h3 id=\"应用操作\"><a href=\"#应用操作\" class=\"headerlink\" title=\"应用操作\"></a>应用操作</h3><p>这个功能在早前已经引入了，但直到 Android 9.0 发布，人们才开始对它产生明显的关注。应用操作功能可以让用户直接从应用启动器来执行应用里的某些操作。</p>\n<p>例如，长按 GMail 启动器，就可以执行回复最近的邮件、撰写新邮件等功能。在 Android 8.0 中，这个功能则以弹出动作列表的方式展现。在 Android 9.0 中，这个功能更契合 Google 的<ruby>材料设计<rt>Material Design</rt></ruby>风格（图 4）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_4.png?itok=Ex-NzYSo\" alt=\"Actions\" title=\"Actions\"></p>\n<p><em>图 4：Android 应用操作。</em></p>\n<h3 id=\"声音控制\"><a href=\"#声音控制\" class=\"headerlink\" title=\"声音控制\"></a>声音控制</h3><p>在 Android 中，声音控制的方式经常发生变化。在 Android 8.0 对“请勿打扰”功能进行调整之后，声音控制已经做得相当不错了。而在 Android 9.0 当中，声音控制再次进行了优化。</p>\n<p>Android 9.0 这次优化针对的是设备上快速控制声音的按钮。如果用户按下音量增大或减小按钮，就会看到一个新的弹出菜单，可以让用户控制设备的静音和震动情况。点击这个弹出菜单顶部的图标（图 5），可以在完全静音、静音和正常声音几种状态之间切换。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_5.png?itok=NMW2vIlL\" alt=\"Sound control\" title=\"Sound control\"></p>\n<p><em>图 5：Android 9.0 上的声音控制。</em></p>\n<h3 id=\"屏幕截图\"><a href=\"#屏幕截图\" class=\"headerlink\" title=\"屏幕截图\"></a>屏幕截图</h3><p>由于我要撰写关于 Android 的文章，所以我会常常需要进行屏幕截图。而 Android 9.0 有一项我最喜欢的更新，就是分享屏幕截图。Android 9.0 可以在截取屏幕截图后，直接共享、编辑，或者删除不喜欢的截图，而不需要像以前一样打开 Google 相册、找到要共享的屏幕截图、打开图像然后共享图像。</p>\n<p>如果你想分享屏幕截图，只需要在截图后等待弹出菜单，点击分享（图 6），从标准的 Android 分享菜单中分享即可。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_6.png?itok=7Ik8_4jC\" alt=\"Sharing \" title=\"Sharing \"></p>\n<p><em>图 6：共享屏幕截图变得更加容易。</em></p>\n<h3 id=\"更令人满意的-Android-体验\"><a href=\"#更令人满意的-Android-体验\" class=\"headerlink\" title=\"更令人满意的 Android 体验\"></a>更令人满意的 Android 体验</h3><p>Android 9.0 带来了更令人满意的用户体验。当然，以上说到的内容只是它的冰山一角。如果需要更多信息，可以查阅 Google 的官方 <a href=\"https://www.android.com/versions/pie-9-0/\" target=\"_blank\" rel=\"noopener\">Android 9.0 网站</a>。如果你的设备还没有收到升级推送，请耐心等待，Android 9.0 值得等待。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/2018/10/overview-android-pie\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/2018/10/overview-android-pie</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第九代 Android 带来了更令人满意的用户体验。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/android-pie.jpg?itok=Sx4rbOWY\" alt=\"\"></p>\n<p>我们来谈论一下 Android。尽管 Android 只是一款内核经过修改的 Linux，但经过多年的发展，Android 开发者们（或许包括正在阅读这篇文章的你）已经为这个平台的演变做出了很多值得称道的贡献。当然，可能很多人都已经知道，但我们还是要说，Android 并不完全开源，当你使用 Google 服务的时候，就已经接触到闭源的部分了。Google Play 商店就是其中之一，它不是一个开放的服务。不过无论 Android 开源与否，这就是一个美味、营养、高效、省电的馅饼（LCTT 译注：Android 9.0 代号为 Pie）。</p>\n<p>我在我的 Essential PH-1 手机上运行了 Android 9.0（我真的很喜欢这款手机，也知道这家公司的境况并不好）。在我自己体验了一段时间之后，我认为它是会被大众接受的。那么 Android 9.0 到底好在哪里呢？下面我们就来深入探讨一下。我们的出发点是用户的角度，而不是开发人员的角度，因此我也不会深入探讨太底层的方面。</p>\n<h3 id=\"手势操作\"><a href=\"#手势操作\" class=\"headerlink\" title=\"手势操作\"></a>手势操作</h3><p>Android 系统在新的手势操作方面投入了很多，但实际体验却不算太好。这个功能确实引起了我的兴趣。在这个功能发布之初，大家都对它了解甚少，纷纷猜测它会不会让用户使用多点触控的手势来浏览 Android 界面？又或者会不会是一个完全颠覆人们认知的东西？</p>\n<p>实际上，手势操作比大多数人设想的要更加微妙而简单，因为很多功能都浓缩到了 Home 键上。打开手势操作功能之后，Recent 键的功能就合并到 Home 键上了。因此，如果需要查看最近打开的应用程序，就不能简单地通过 Recent 键来查看，而应该从 Home 键向上轻扫一下。（图 1）</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_1.png?itok=BsSe8kqS\" alt=\"Android Pie\" title=\"Android Pie\"></p>\n<p><em>图 1：Android 9.0 中的”最近的应用程序“界面。</em></p>\n<p>另一个不同的地方是 App Drawer。类似于查看最近打开的应用，需要在 Home 键向上滑动才能打开 App Drawer。</p>\n<p>而后退按钮则没有去掉。在应用程序需要用到后退功能时，它就会出现在主屏幕的左下方。有时候即使应用程序自己带有后退按钮，Android 的后退按钮也会出现。</p>\n<p>当然，如果你不喜欢使用手势操作，也可以禁用这个功能。只需要按照下列步骤操作：</p>\n<ol>\n<li>打开”设置“</li>\n<li>向下滑动并进入“系统 &gt; 手势”</li>\n<li>从 Home 键向上滑动</li>\n<li>将 On/Off 滑块（图 2）滑动至 Off 位置</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_2.png?itok=cs2tqZut\" alt=\"\"></p>\n<p><em>图 2：关闭手势操作。</em></p>\n<h3 id=\"电池寿命\"><a href=\"#电池寿命\" class=\"headerlink\" title=\"电池寿命\"></a>电池寿命</h3><p>人工智能已经在 Android 得到了充分的使用。现在，Android 使用人工智能大大提供了电池的续航时间，这样的新技术称为自适应电池。自适应电池可以根据用户的个人使用习惯来决定各种应用和服务的耗电优先级。通过使用人工智能技术，Android 可以分析用户对每一个应用或服务的使用情况，并适当地关闭未使用的应用程序，以免长期驻留在内存中白白消耗电池电量。</p>\n<p>对于这个功能的唯一一个警告是，如果人工智能出现问题并导致电池电量过早耗尽，就只能通过恢复出厂设置来解决这个问题了。尽管有这样的缺陷，在电池续航时间方面，Android 9.0 也比 Android 8.0 有所改善。</p>\n<h3 id=\"分屏功能的变化\"><a href=\"#分屏功能的变化\" class=\"headerlink\" title=\"分屏功能的变化\"></a>分屏功能的变化</h3><p>分屏对于 Android 来说不是一个新功能，但在 Android 9.0 上，它的使用方式和以往相比略有不同，而且只对于手势操作有影响，不使用手势操作的用户不受影响。要在 Android 9.0 上使用分屏功能，需要按照下列步骤操作：</p>\n<ol>\n<li>从 Home 键向上滑动，打开“最近的应用程序”。</li>\n<li>找到需要放置在屏幕顶部的应用程序。</li>\n<li>长按应用程序顶部的图标以显示新的弹出菜单。（图 3）</li>\n<li>点击分屏，应用程序会在屏幕的上半部分打开。</li>\n<li>找到要打开的第二个应用程序，然后点击它添加到屏幕的下半部分。</li>\n</ol>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_3.png?itok=F-NB1dqI\" alt=\"Adding an app\" title=\"Adding an app\"></p>\n<p><em>图 3：在 Android 9.0 上将应用添加到分屏模式中。</em></p>\n<p>使用分屏功能关闭应用程序的方法和原来保持一致。</p>\n<h3 id=\"应用操作\"><a href=\"#应用操作\" class=\"headerlink\" title=\"应用操作\"></a>应用操作</h3><p>这个功能在早前已经引入了，但直到 Android 9.0 发布，人们才开始对它产生明显的关注。应用操作功能可以让用户直接从应用启动器来执行应用里的某些操作。</p>\n<p>例如，长按 GMail 启动器，就可以执行回复最近的邮件、撰写新邮件等功能。在 Android 8.0 中，这个功能则以弹出动作列表的方式展现。在 Android 9.0 中，这个功能更契合 Google 的<ruby>材料设计<rt>Material Design</rt></ruby>风格（图 4）。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_4.png?itok=Ex-NzYSo\" alt=\"Actions\" title=\"Actions\"></p>\n<p><em>图 4：Android 应用操作。</em></p>\n<h3 id=\"声音控制\"><a href=\"#声音控制\" class=\"headerlink\" title=\"声音控制\"></a>声音控制</h3><p>在 Android 中，声音控制的方式经常发生变化。在 Android 8.0 对“请勿打扰”功能进行调整之后，声音控制已经做得相当不错了。而在 Android 9.0 当中，声音控制再次进行了优化。</p>\n<p>Android 9.0 这次优化针对的是设备上快速控制声音的按钮。如果用户按下音量增大或减小按钮，就会看到一个新的弹出菜单，可以让用户控制设备的静音和震动情况。点击这个弹出菜单顶部的图标（图 5），可以在完全静音、静音和正常声音几种状态之间切换。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_5.png?itok=NMW2vIlL\" alt=\"Sound control\" title=\"Sound control\"></p>\n<p><em>图 5：Android 9.0 上的声音控制。</em></p>\n<h3 id=\"屏幕截图\"><a href=\"#屏幕截图\" class=\"headerlink\" title=\"屏幕截图\"></a>屏幕截图</h3><p>由于我要撰写关于 Android 的文章，所以我会常常需要进行屏幕截图。而 Android 9.0 有一项我最喜欢的更新，就是分享屏幕截图。Android 9.0 可以在截取屏幕截图后，直接共享、编辑，或者删除不喜欢的截图，而不需要像以前一样打开 Google 相册、找到要共享的屏幕截图、打开图像然后共享图像。</p>\n<p>如果你想分享屏幕截图，只需要在截图后等待弹出菜单，点击分享（图 6），从标准的 Android 分享菜单中分享即可。</p>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/floated_images/public/pie_6.png?itok=7Ik8_4jC\" alt=\"Sharing \" title=\"Sharing \"></p>\n<p><em>图 6：共享屏幕截图变得更加容易。</em></p>\n<h3 id=\"更令人满意的-Android-体验\"><a href=\"#更令人满意的-Android-体验\" class=\"headerlink\" title=\"更令人满意的 Android 体验\"></a>更令人满意的 Android 体验</h3><p>Android 9.0 带来了更令人满意的用户体验。当然，以上说到的内容只是它的冰山一角。如果需要更多信息，可以查阅 Google 的官方 <a href=\"https://www.android.com/versions/pie-9-0/\" target=\"_blank\" rel=\"noopener\">Android 9.0 网站</a>。如果你的设备还没有收到升级推送，请耐心等待，Android 9.0 值得等待。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/learn/2018/10/overview-android-pie\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/learn/2018/10/overview-android-pie</a></p>\n"},{"title":"Ansible Inventory 文件","date":"2016-07-18T02:07:21.000Z","_content":"\nAnsible 的 Inventory 文件主要记录了连接主机的信息和配置，默认路径为 `/etc/ansible/hosts`。\n\n在 Inventory 文件中以行为单位直接写入主机的 `host`，如果仅填写了 `host`，则其它信息均按照默认值（如 ssh 端口为22）。也可以按照组的格式进行配置：\n\n```\n[group1]\nhost1\nhost2\n\n[group2]\nhost2\nhost3\n\n[group3:children]\ngroup1\ngroup2\n```\n\n同一个主机可以同时属于多个组，如 host2 可以同时属于 group1 组和 group2 组。组也可以作为另一个组的成员，如 group1 和 group2 就是 group3 的成员，因此 host1、host2、host3 均属于 group3 组。\n\n在每个 host 后可以使用变量来设置一些具体的参数，例如端口、登录用户名等。也可以为整个组设定变量：\n\n```\n[group1:vars]\nansible_ssh_port=2222\nansible_ssh_user=root\n```\n\n常用的 Inventory 参数：\n\n```\nansible_ssh_host\n      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n\nansible_ssh_port\n      ssh端口号.如果不是默认的端口号,通过此变量设置.\n\nansible_ssh_user\n      默认的 ssh 用户名\n\nansible_ssh_pass\n      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n\nansible_sudo_pass\n      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n\nansible_sudo_exe (new in version 1.8)\n      sudo 命令路径(适用于1.8及以上版本)\n\nansible_connection\n      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.\n\nansible_ssh_private_key_file\n      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n\nansible_shell_type\n      目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.\n\nansible_python_interpreter\n      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是\"/usr/bin/python\",比如  \\*BSD, 或者 /usr/bin/python\n      不是 2.X 版本的 Python.我们不使用 \"/usr/bin/env\" 机制,因为这要求远程用户的路径设置正确,且要求 \"python\" 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n\n      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n```\n","source":"_posts/Ansible-Inventory-file.md","raw":"---\ntitle: Ansible Inventory 文件\ndate: 2016-07-18 10:07:21\ntags:\n  - Ansible\n---\n\nAnsible 的 Inventory 文件主要记录了连接主机的信息和配置，默认路径为 `/etc/ansible/hosts`。\n\n在 Inventory 文件中以行为单位直接写入主机的 `host`，如果仅填写了 `host`，则其它信息均按照默认值（如 ssh 端口为22）。也可以按照组的格式进行配置：\n\n```\n[group1]\nhost1\nhost2\n\n[group2]\nhost2\nhost3\n\n[group3:children]\ngroup1\ngroup2\n```\n\n同一个主机可以同时属于多个组，如 host2 可以同时属于 group1 组和 group2 组。组也可以作为另一个组的成员，如 group1 和 group2 就是 group3 的成员，因此 host1、host2、host3 均属于 group3 组。\n\n在每个 host 后可以使用变量来设置一些具体的参数，例如端口、登录用户名等。也可以为整个组设定变量：\n\n```\n[group1:vars]\nansible_ssh_port=2222\nansible_ssh_user=root\n```\n\n常用的 Inventory 参数：\n\n```\nansible_ssh_host\n      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n\nansible_ssh_port\n      ssh端口号.如果不是默认的端口号,通过此变量设置.\n\nansible_ssh_user\n      默认的 ssh 用户名\n\nansible_ssh_pass\n      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n\nansible_sudo_pass\n      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n\nansible_sudo_exe (new in version 1.8)\n      sudo 命令路径(适用于1.8及以上版本)\n\nansible_connection\n      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.\n\nansible_ssh_private_key_file\n      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n\nansible_shell_type\n      目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.\n\nansible_python_interpreter\n      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是\"/usr/bin/python\",比如  \\*BSD, 或者 /usr/bin/python\n      不是 2.X 版本的 Python.我们不使用 \"/usr/bin/env\" 机制,因为这要求远程用户的路径设置正确,且要求 \"python\" 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n\n      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n```\n","slug":"Ansible-Inventory-file","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cc000klixu6lhn9i1v","content":"<p>Ansible 的 Inventory 文件主要记录了连接主机的信息和配置，默认路径为 <code>/etc/ansible/hosts</code>。</p>\n<p>在 Inventory 文件中以行为单位直接写入主机的 <code>host</code>，如果仅填写了 <code>host</code>，则其它信息均按照默认值（如 ssh 端口为22）。也可以按照组的格式进行配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[group1]</span><br><span class=\"line\">host1</span><br><span class=\"line\">host2</span><br><span class=\"line\"></span><br><span class=\"line\">[group2]</span><br><span class=\"line\">host2</span><br><span class=\"line\">host3</span><br><span class=\"line\"></span><br><span class=\"line\">[group3:children]</span><br><span class=\"line\">group1</span><br><span class=\"line\">group2</span><br></pre></td></tr></table></figure>\n<p>同一个主机可以同时属于多个组，如 host2 可以同时属于 group1 组和 group2 组。组也可以作为另一个组的成员，如 group1 和 group2 就是 group3 的成员，因此 host1、host2、host3 均属于 group3 组。</p>\n<p>在每个 host 后可以使用变量来设置一些具体的参数，例如端口、登录用户名等。也可以为整个组设定变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[group1:vars]</span><br><span class=\"line\">ansible_ssh_port=2222</span><br><span class=\"line\">ansible_ssh_user=root</span><br></pre></td></tr></table></figure>\n<p>常用的 Inventory 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible_ssh_host</span><br><span class=\"line\">      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_port</span><br><span class=\"line\">      ssh端口号.如果不是默认的端口号,通过此变量设置.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_user</span><br><span class=\"line\">      默认的 ssh 用户名</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_pass</span><br><span class=\"line\">      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_sudo_pass</span><br><span class=\"line\">      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_sudo_exe (new in version 1.8)</span><br><span class=\"line\">      sudo 命令路径(适用于1.8及以上版本)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_connection</span><br><span class=\"line\">      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_private_key_file</span><br><span class=\"line\">      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_shell_type</span><br><span class=\"line\">      目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_python_interpreter</span><br><span class=\"line\">      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \\*BSD, 或者 /usr/bin/python</span><br><span class=\"line\">      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).</span><br><span class=\"line\"></span><br><span class=\"line\">      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Ansible 的 Inventory 文件主要记录了连接主机的信息和配置，默认路径为 <code>/etc/ansible/hosts</code>。</p>\n<p>在 Inventory 文件中以行为单位直接写入主机的 <code>host</code>，如果仅填写了 <code>host</code>，则其它信息均按照默认值（如 ssh 端口为22）。也可以按照组的格式进行配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[group1]</span><br><span class=\"line\">host1</span><br><span class=\"line\">host2</span><br><span class=\"line\"></span><br><span class=\"line\">[group2]</span><br><span class=\"line\">host2</span><br><span class=\"line\">host3</span><br><span class=\"line\"></span><br><span class=\"line\">[group3:children]</span><br><span class=\"line\">group1</span><br><span class=\"line\">group2</span><br></pre></td></tr></table></figure>\n<p>同一个主机可以同时属于多个组，如 host2 可以同时属于 group1 组和 group2 组。组也可以作为另一个组的成员，如 group1 和 group2 就是 group3 的成员，因此 host1、host2、host3 均属于 group3 组。</p>\n<p>在每个 host 后可以使用变量来设置一些具体的参数，例如端口、登录用户名等。也可以为整个组设定变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[group1:vars]</span><br><span class=\"line\">ansible_ssh_port=2222</span><br><span class=\"line\">ansible_ssh_user=root</span><br></pre></td></tr></table></figure>\n<p>常用的 Inventory 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible_ssh_host</span><br><span class=\"line\">      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_port</span><br><span class=\"line\">      ssh端口号.如果不是默认的端口号,通过此变量设置.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_user</span><br><span class=\"line\">      默认的 ssh 用户名</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_pass</span><br><span class=\"line\">      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_sudo_pass</span><br><span class=\"line\">      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_sudo_exe (new in version 1.8)</span><br><span class=\"line\">      sudo 命令路径(适用于1.8及以上版本)</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_connection</span><br><span class=\"line\">      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_ssh_private_key_file</span><br><span class=\"line\">      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_shell_type</span><br><span class=\"line\">      目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.</span><br><span class=\"line\"></span><br><span class=\"line\">ansible_python_interpreter</span><br><span class=\"line\">      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \\*BSD, 或者 /usr/bin/python</span><br><span class=\"line\">      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).</span><br><span class=\"line\"></span><br><span class=\"line\">      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure>\n"},{"title":"Bash 环境变量的那些事","date":"2018-12-23T07:12:40.000Z","_content":"\n> 初学者可以在此教程中了解环境变量。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/wynand-van-poortvliet-40467-unsplash.jpg?itok=tr6Eb4N0)\n\nbash 变量，尤其是讨厌的*环境变量*，已经是一个老生常谈的话题了。我们也更应该对它有一个详细的了解，让它为我们所用。\n\n下面就打开终端，开始吧。\n\n### 环境变量\n\n`HOME` （LCTT 译注：双关语）除了是你脱下帽子惬意休息的地方，同时也是 Linux 中的一个变量，它是当前用户主目录的路径：\n\n```\necho $HOME\n```\n\n以上这个命令会显示当前用户的主目录路径，通常都在 `/home/<your username>` 下。\n\n顾名思义，变量的值是可以根据上下文变化的。实际上，Linux 系统中每一个用户的 `HOME` 变量都是不一样的，当然你也可以这样自行更改 `HOME` 变量的值：\n\n```\nHOME=/home/<your username>/Documents\n```\n\n以上这个命令将会把 `HOME` 变量设置为你的 `Documents` 目录。\n\n其中有三点需要留意：\n\n  1. `=` 符号和其两侧的内容之间不加空格。空格在 shell 中有专门的意义，不能随意地在任何地方添加空格。\n  2. 如果你需要对变量进行赋值，只需要使用变量名称就可以了。但如果需要读取或者使用变量的值，需要在变量前面加上一个 `$` 号。\n  3. 更改 `HOME` 变量具有一定的风险。有很多程序是依赖于 `HOME` 变量的，更改 `HOME` 变量可能会导致一些不可预见的结果。例如，如果按照上面的方式更改了 `HOME` 变量，然后执行不带有任何参数的 `cd` 命令，在通常情况下，会跳转到用户的主目录下，但在这个时候，会跳转到 `HOME` 变量指定的目录下。\n\n上面第 3 点中环境变量的更改并不是持久有效的，在终端关闭后重新打开终端，又或者是新建一个终端，执行 `echo $HOME` 命令输出的仍然会是初始的值，而不是重新自定义的值。\n\n在讨论如何持久地更改一个环境变量之前，我们先来看一下另一个比较重要的环境变量。\n\n### PATH 变量\n\n在 `PATH` 变量中存放了一系列目录，而且是放置了可执行程序的目录。正是由于 `PATH` 变量的存在，让你不需要知道应用程序具体安装到了什么目录，而 shell 却可以正确地找到这些应用程序。\n\n如果你查看 `PATH` 变量的值，大概会是以下这样：\n\n```\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin\n```\n\n每两个目录之间使用冒号 `:` 分隔。如果某个应用程序的所在目录不在 `PATH` 变量中，那么运行的时候就需要声明应用程序的目录让 shell 能够找到。\n\n```\n/home/<user name>/bin/my_program.sh\n```\n\n例如以上命令就会执行当前用户 `bin/` 目录下的 `my_program.sh` 文件。\n\n有一个常见的问题：如果你不希望弄乱系统的 `bin/` 目录，同时也不希望你自己的文件被其它人运行，还不想每次运行的时候都要输入完整的路径，那么，你可以在你的主目录中创建一个独立的 `bin/` 目录：\n\n```\nmkdir $HOME/bin\n```\n\n然后将这个目录添加到 `PATH` 变量中：\n\n```\nPATH=$PATH:$HOME/bin\n```\n\n然后 `/home/<user name>/bin/` 目录就会出现在 `PATH` 变量中了。但正如之前所说，这个变更只会在当前的 shell 生效，当前的 shell 一旦关闭，环境变量的值就又恢复原状了。\n\n如果要让变更对当前用户持续生效，就不能在 shell 中直接执行对应的变更，而是应该将这些变更操作写在每次启动 shell 时都会运行的文件当中。这个文件就是当前用户主目录中的 `.bashrc` 文件。文件名前面的点号表明这是一个隐藏文件，执行普通的 `ls` 命令是不会将这个文件显示出来的，但只要在 `ls` 命令中加入 `-a` 参数就可以看到这个文件了。\n\n你可以使用诸如 [kate][1]、[gedit][2]、[nano][3] 或者 [vim][4] 这些文本编辑器来打开 `.bashrc` 文件（但不要用 LibreOffice Writer，它是一个文字处理软件，跟前面几个文字编辑器完全不同）。打开 `.bashrc` 文件之后，你会看见里面放置了一些 shell 命令，是用于为当前用户设置环境的。\n\n在文件的末尾添加新行并输入以下内容：\n\n```\nexport PATH=$PATH:$HOME/bin\n```\n\n保存并关闭 `.bashrc` 文件，接下来你就会看到 `export` 语句的效果。执行以下的命令让刚才的修改立即生效：\n\n```\nsource .bashrc\n```\n\n刚才执行的 `source` 命令让 `.bashrc` 文件在当前的 shell 立即生效，并且对于之后打开的 shell 都会有效。因此另一个等效的方法是退出并重新进入 shell，但这样也太麻烦了。\n\n现在，你的 shell 就能自动寻找到 `/home/<user name>/bin/` 下的程序了，执行这个目录下的程序也不需要完整地写出程序的路径。\n\n### 自定义变量\n\n当然，你也可以定义自己的变量。刚才我们看到的变量名称都是全大写的，实际上[变量名称的定义还是比较灵活的][5]。\n\n定义新变量的过程非常直观，直接对它赋值就可以了：\n\n```\nnew_variable=\"Hello\"\n```\n\n然后可以用以下的方式读取到已定义变量的值：\n\n```\necho $new_variable\n```\n\n程序的正常工作离不开各种变量，例如要将某个选项设置为打开，又或者让程序找到所需的代码库，都需要使用变量。在 bash 中运行程序的时候会生成一个子 shell，这个子 shell 和执行原程序的父 shell 并不是完全一样的，只是继承了父 shell 的部分内容，而且默认是不继承父 shell 中的变量的。因为变量默认情况下是局部变量，出于安全原因，一个 shell 中的局部变量不会被另一个 shell 读取到，即使是子 shell 也不可以。\n\n下面举一个例子。首先定义一个变量：\n\n```\nrobots=\"R2D2 & C3PO\"\n```\n\n然后执行：\n\n```\nbash\n```\n\n现在是在 bash shell 中创建了一个子 shell。\n\n执行这个命令看看还能不能读取到刚才定义的变量：\n\n```\necho $robots\n```\n\n你会发现读取不到。\n\n还是在这个子 shell 中，为 `robots` 变量赋一个不同的值：\n\n```\nrobots=\"These aren't the ones you are looking for\"\n```\n\n再读取一次：\n\n```\n$ echo $robots\nThese aren't the ones you are looking for\n```\n\n退出这个子 shell：\n\n```\nexit\n```\n\n然后再看一下现在 `robots`  变量的值：\n\n```\n$ echo $robots\nR2D2 & C3P0\n```\n\n这一个特性可以有效避免配置过程中产生混乱，同时也会导致一个问题：如果程序中需要设置变量，但却由于子 shell 的原因无法正常访问到这个变量，该如何解决呢？这个时候就需要用到 `export` 了。\n\n重复一次刚才的过程，但这一次不是通过 `robots=\"R2D2 & C3PO\"` 方式来设置变量，而是使用 `export` 命令：\n\n```\nexport robots=\"R2D2 & C3PO\"\n```\n\n现在你会发现，在进入子 shell 之后，`robots` 变量的值仍然是最初赋予的值。\n\n要注意的是，尽管子 shell 会继承通过 `export` 导出的变量，但如果在子 shell 中对这个变量重新赋值，是不会影响到父 shell 中对应变量的。\n\n如果要查看所有通过 `export` 导出的变量，可以执行以下命令：\n\n```\nexport -p\n```\n\n自定义的变量会显示在这个列表的末尾。这个列表中还有一些常见的变量：例如 `USER` 的值是当前用户的用户名，`PWD` 的值是当前用户当前所在的目录，而 `OLDPWD` 的值则是当前用户上一个访问过的目录。因此如果执行：\n\n```\ncd -\n```\n\n就会切换到上一个访问过的目录，那是因为 `cd` 命令读取到了 `OLDPWD` 变量的值。\n\n你也可以使用 `env` 命令查看所有环境变量。\n\n如果要取消导出一个变量，可以加上 `-n` 参数：\n\n```\nexport -n robots\n```\n\n### 接下来\n\n了解过环境变量的知识之后，你已经到达了可能对自己和他人造成危险的水平，接下来就需要了解如何通过使用别名来让环境变得更安全、更友好以保护自己了。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise\n\n[a]: https://www.linux.com/users/bro66\n[b]: https://github.com/lujun9972\n[1]: https://www.kde.org/applications/utilities/kate/\n[2]: https://help.gnome.org/users/gedit/stable/\n[3]: https://www.nano-editor.org/\n[4]: https://www.vim.org/\n[5]: https://bash.cyberciti.biz/guide/Rules_for_Naming_variable_name\n\n","source":"_posts/Bash-Variables-Environmental-and-Otherwise.md","raw":"---\ntitle: Bash 环境变量的那些事\ndate: 2018-12-23 15:12:40\ntags:\n  - Bash\n  - 环境变量\n  - LCTT 翻译\n---\n\n> 初学者可以在此教程中了解环境变量。\n\n![](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/wynand-van-poortvliet-40467-unsplash.jpg?itok=tr6Eb4N0)\n\nbash 变量，尤其是讨厌的*环境变量*，已经是一个老生常谈的话题了。我们也更应该对它有一个详细的了解，让它为我们所用。\n\n下面就打开终端，开始吧。\n\n### 环境变量\n\n`HOME` （LCTT 译注：双关语）除了是你脱下帽子惬意休息的地方，同时也是 Linux 中的一个变量，它是当前用户主目录的路径：\n\n```\necho $HOME\n```\n\n以上这个命令会显示当前用户的主目录路径，通常都在 `/home/<your username>` 下。\n\n顾名思义，变量的值是可以根据上下文变化的。实际上，Linux 系统中每一个用户的 `HOME` 变量都是不一样的，当然你也可以这样自行更改 `HOME` 变量的值：\n\n```\nHOME=/home/<your username>/Documents\n```\n\n以上这个命令将会把 `HOME` 变量设置为你的 `Documents` 目录。\n\n其中有三点需要留意：\n\n  1. `=` 符号和其两侧的内容之间不加空格。空格在 shell 中有专门的意义，不能随意地在任何地方添加空格。\n  2. 如果你需要对变量进行赋值，只需要使用变量名称就可以了。但如果需要读取或者使用变量的值，需要在变量前面加上一个 `$` 号。\n  3. 更改 `HOME` 变量具有一定的风险。有很多程序是依赖于 `HOME` 变量的，更改 `HOME` 变量可能会导致一些不可预见的结果。例如，如果按照上面的方式更改了 `HOME` 变量，然后执行不带有任何参数的 `cd` 命令，在通常情况下，会跳转到用户的主目录下，但在这个时候，会跳转到 `HOME` 变量指定的目录下。\n\n上面第 3 点中环境变量的更改并不是持久有效的，在终端关闭后重新打开终端，又或者是新建一个终端，执行 `echo $HOME` 命令输出的仍然会是初始的值，而不是重新自定义的值。\n\n在讨论如何持久地更改一个环境变量之前，我们先来看一下另一个比较重要的环境变量。\n\n### PATH 变量\n\n在 `PATH` 变量中存放了一系列目录，而且是放置了可执行程序的目录。正是由于 `PATH` 变量的存在，让你不需要知道应用程序具体安装到了什么目录，而 shell 却可以正确地找到这些应用程序。\n\n如果你查看 `PATH` 变量的值，大概会是以下这样：\n\n```\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin\n```\n\n每两个目录之间使用冒号 `:` 分隔。如果某个应用程序的所在目录不在 `PATH` 变量中，那么运行的时候就需要声明应用程序的目录让 shell 能够找到。\n\n```\n/home/<user name>/bin/my_program.sh\n```\n\n例如以上命令就会执行当前用户 `bin/` 目录下的 `my_program.sh` 文件。\n\n有一个常见的问题：如果你不希望弄乱系统的 `bin/` 目录，同时也不希望你自己的文件被其它人运行，还不想每次运行的时候都要输入完整的路径，那么，你可以在你的主目录中创建一个独立的 `bin/` 目录：\n\n```\nmkdir $HOME/bin\n```\n\n然后将这个目录添加到 `PATH` 变量中：\n\n```\nPATH=$PATH:$HOME/bin\n```\n\n然后 `/home/<user name>/bin/` 目录就会出现在 `PATH` 变量中了。但正如之前所说，这个变更只会在当前的 shell 生效，当前的 shell 一旦关闭，环境变量的值就又恢复原状了。\n\n如果要让变更对当前用户持续生效，就不能在 shell 中直接执行对应的变更，而是应该将这些变更操作写在每次启动 shell 时都会运行的文件当中。这个文件就是当前用户主目录中的 `.bashrc` 文件。文件名前面的点号表明这是一个隐藏文件，执行普通的 `ls` 命令是不会将这个文件显示出来的，但只要在 `ls` 命令中加入 `-a` 参数就可以看到这个文件了。\n\n你可以使用诸如 [kate][1]、[gedit][2]、[nano][3] 或者 [vim][4] 这些文本编辑器来打开 `.bashrc` 文件（但不要用 LibreOffice Writer，它是一个文字处理软件，跟前面几个文字编辑器完全不同）。打开 `.bashrc` 文件之后，你会看见里面放置了一些 shell 命令，是用于为当前用户设置环境的。\n\n在文件的末尾添加新行并输入以下内容：\n\n```\nexport PATH=$PATH:$HOME/bin\n```\n\n保存并关闭 `.bashrc` 文件，接下来你就会看到 `export` 语句的效果。执行以下的命令让刚才的修改立即生效：\n\n```\nsource .bashrc\n```\n\n刚才执行的 `source` 命令让 `.bashrc` 文件在当前的 shell 立即生效，并且对于之后打开的 shell 都会有效。因此另一个等效的方法是退出并重新进入 shell，但这样也太麻烦了。\n\n现在，你的 shell 就能自动寻找到 `/home/<user name>/bin/` 下的程序了，执行这个目录下的程序也不需要完整地写出程序的路径。\n\n### 自定义变量\n\n当然，你也可以定义自己的变量。刚才我们看到的变量名称都是全大写的，实际上[变量名称的定义还是比较灵活的][5]。\n\n定义新变量的过程非常直观，直接对它赋值就可以了：\n\n```\nnew_variable=\"Hello\"\n```\n\n然后可以用以下的方式读取到已定义变量的值：\n\n```\necho $new_variable\n```\n\n程序的正常工作离不开各种变量，例如要将某个选项设置为打开，又或者让程序找到所需的代码库，都需要使用变量。在 bash 中运行程序的时候会生成一个子 shell，这个子 shell 和执行原程序的父 shell 并不是完全一样的，只是继承了父 shell 的部分内容，而且默认是不继承父 shell 中的变量的。因为变量默认情况下是局部变量，出于安全原因，一个 shell 中的局部变量不会被另一个 shell 读取到，即使是子 shell 也不可以。\n\n下面举一个例子。首先定义一个变量：\n\n```\nrobots=\"R2D2 & C3PO\"\n```\n\n然后执行：\n\n```\nbash\n```\n\n现在是在 bash shell 中创建了一个子 shell。\n\n执行这个命令看看还能不能读取到刚才定义的变量：\n\n```\necho $robots\n```\n\n你会发现读取不到。\n\n还是在这个子 shell 中，为 `robots` 变量赋一个不同的值：\n\n```\nrobots=\"These aren't the ones you are looking for\"\n```\n\n再读取一次：\n\n```\n$ echo $robots\nThese aren't the ones you are looking for\n```\n\n退出这个子 shell：\n\n```\nexit\n```\n\n然后再看一下现在 `robots`  变量的值：\n\n```\n$ echo $robots\nR2D2 & C3P0\n```\n\n这一个特性可以有效避免配置过程中产生混乱，同时也会导致一个问题：如果程序中需要设置变量，但却由于子 shell 的原因无法正常访问到这个变量，该如何解决呢？这个时候就需要用到 `export` 了。\n\n重复一次刚才的过程，但这一次不是通过 `robots=\"R2D2 & C3PO\"` 方式来设置变量，而是使用 `export` 命令：\n\n```\nexport robots=\"R2D2 & C3PO\"\n```\n\n现在你会发现，在进入子 shell 之后，`robots` 变量的值仍然是最初赋予的值。\n\n要注意的是，尽管子 shell 会继承通过 `export` 导出的变量，但如果在子 shell 中对这个变量重新赋值，是不会影响到父 shell 中对应变量的。\n\n如果要查看所有通过 `export` 导出的变量，可以执行以下命令：\n\n```\nexport -p\n```\n\n自定义的变量会显示在这个列表的末尾。这个列表中还有一些常见的变量：例如 `USER` 的值是当前用户的用户名，`PWD` 的值是当前用户当前所在的目录，而 `OLDPWD` 的值则是当前用户上一个访问过的目录。因此如果执行：\n\n```\ncd -\n```\n\n就会切换到上一个访问过的目录，那是因为 `cd` 命令读取到了 `OLDPWD` 变量的值。\n\n你也可以使用 `env` 命令查看所有环境变量。\n\n如果要取消导出一个变量，可以加上 `-n` 参数：\n\n```\nexport -n robots\n```\n\n### 接下来\n\n了解过环境变量的知识之后，你已经到达了可能对自己和他人造成危险的水平，接下来就需要了解如何通过使用别名来让环境变得更安全、更友好以保护自己了。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise\n\n[a]: https://www.linux.com/users/bro66\n[b]: https://github.com/lujun9972\n[1]: https://www.kde.org/applications/utilities/kate/\n[2]: https://help.gnome.org/users/gedit/stable/\n[3]: https://www.nano-editor.org/\n[4]: https://www.vim.org/\n[5]: https://bash.cyberciti.biz/guide/Rules_for_Naming_variable_name\n\n","slug":"Bash-Variables-Environmental-and-Otherwise","published":1,"updated":"2019-03-28T13:16:07.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ce000mlixu4nnf2o52","content":"<blockquote>\n<p>初学者可以在此教程中了解环境变量。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/wynand-van-poortvliet-40467-unsplash.jpg?itok=tr6Eb4N0\" alt=\"\"></p>\n<p>bash 变量，尤其是讨厌的<em>环境变量</em>，已经是一个老生常谈的话题了。我们也更应该对它有一个详细的了解，让它为我们所用。</p>\n<p>下面就打开终端，开始吧。</p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p><code>HOME</code> （LCTT 译注：双关语）除了是你脱下帽子惬意休息的地方，同时也是 Linux 中的一个变量，它是当前用户主目录的路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $HOME</span><br></pre></td></tr></table></figure>\n<p>以上这个命令会显示当前用户的主目录路径，通常都在 <code>/home/&lt;your username&gt;</code> 下。</p>\n<p>顾名思义，变量的值是可以根据上下文变化的。实际上，Linux 系统中每一个用户的 <code>HOME</code> 变量都是不一样的，当然你也可以这样自行更改 <code>HOME</code> 变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOME=/home/&lt;your username&gt;/Documents</span><br></pre></td></tr></table></figure>\n<p>以上这个命令将会把 <code>HOME</code> 变量设置为你的 <code>Documents</code> 目录。</p>\n<p>其中有三点需要留意：</p>\n<ol>\n<li><code>=</code> 符号和其两侧的内容之间不加空格。空格在 shell 中有专门的意义，不能随意地在任何地方添加空格。</li>\n<li>如果你需要对变量进行赋值，只需要使用变量名称就可以了。但如果需要读取或者使用变量的值，需要在变量前面加上一个 <code>$</code> 号。</li>\n<li>更改 <code>HOME</code> 变量具有一定的风险。有很多程序是依赖于 <code>HOME</code> 变量的，更改 <code>HOME</code> 变量可能会导致一些不可预见的结果。例如，如果按照上面的方式更改了 <code>HOME</code> 变量，然后执行不带有任何参数的 <code>cd</code> 命令，在通常情况下，会跳转到用户的主目录下，但在这个时候，会跳转到 <code>HOME</code> 变量指定的目录下。</li>\n</ol>\n<p>上面第 3 点中环境变量的更改并不是持久有效的，在终端关闭后重新打开终端，又或者是新建一个终端，执行 <code>echo $HOME</code> 命令输出的仍然会是初始的值，而不是重新自定义的值。</p>\n<p>在讨论如何持久地更改一个环境变量之前，我们先来看一下另一个比较重要的环境变量。</p>\n<h3 id=\"PATH-变量\"><a href=\"#PATH-变量\" class=\"headerlink\" title=\"PATH 变量\"></a>PATH 变量</h3><p>在 <code>PATH</code> 变量中存放了一系列目录，而且是放置了可执行程序的目录。正是由于 <code>PATH</code> 变量的存在，让你不需要知道应用程序具体安装到了什么目录，而 shell 却可以正确地找到这些应用程序。</p>\n<p>如果你查看 <code>PATH</code> 变量的值，大概会是以下这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin</span><br></pre></td></tr></table></figure>\n<p>每两个目录之间使用冒号 <code>:</code> 分隔。如果某个应用程序的所在目录不在 <code>PATH</code> 变量中，那么运行的时候就需要声明应用程序的目录让 shell 能够找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/&lt;user name&gt;/bin/my_program.sh</span><br></pre></td></tr></table></figure>\n<p>例如以上命令就会执行当前用户 <code>bin/</code> 目录下的 <code>my_program.sh</code> 文件。</p>\n<p>有一个常见的问题：如果你不希望弄乱系统的 <code>bin/</code> 目录，同时也不希望你自己的文件被其它人运行，还不想每次运行的时候都要输入完整的路径，那么，你可以在你的主目录中创建一个独立的 <code>bin/</code> 目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir $HOME/bin</span><br></pre></td></tr></table></figure>\n<p>然后将这个目录添加到 <code>PATH</code> 变量中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>\n<p>然后 <code>/home/&lt;user name&gt;/bin/</code> 目录就会出现在 <code>PATH</code> 变量中了。但正如之前所说，这个变更只会在当前的 shell 生效，当前的 shell 一旦关闭，环境变量的值就又恢复原状了。</p>\n<p>如果要让变更对当前用户持续生效，就不能在 shell 中直接执行对应的变更，而是应该将这些变更操作写在每次启动 shell 时都会运行的文件当中。这个文件就是当前用户主目录中的 <code>.bashrc</code> 文件。文件名前面的点号表明这是一个隐藏文件，执行普通的 <code>ls</code> 命令是不会将这个文件显示出来的，但只要在 <code>ls</code> 命令中加入 <code>-a</code> 参数就可以看到这个文件了。</p>\n<p>你可以使用诸如 <a href=\"https://www.kde.org/applications/utilities/kate/\" target=\"_blank\" rel=\"noopener\">kate</a>、<a href=\"https://help.gnome.org/users/gedit/stable/\" target=\"_blank\" rel=\"noopener\">gedit</a>、<a href=\"https://www.nano-editor.org/\" target=\"_blank\" rel=\"noopener\">nano</a> 或者 <a href=\"https://www.vim.org/\" target=\"_blank\" rel=\"noopener\">vim</a> 这些文本编辑器来打开 <code>.bashrc</code> 文件（但不要用 LibreOffice Writer，它是一个文字处理软件，跟前面几个文字编辑器完全不同）。打开 <code>.bashrc</code> 文件之后，你会看见里面放置了一些 shell 命令，是用于为当前用户设置环境的。</p>\n<p>在文件的末尾添加新行并输入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>\n<p>保存并关闭 <code>.bashrc</code> 文件，接下来你就会看到 <code>export</code> 语句的效果。执行以下的命令让刚才的修改立即生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .bashrc</span><br></pre></td></tr></table></figure>\n<p>刚才执行的 <code>source</code> 命令让 <code>.bashrc</code> 文件在当前的 shell 立即生效，并且对于之后打开的 shell 都会有效。因此另一个等效的方法是退出并重新进入 shell，但这样也太麻烦了。</p>\n<p>现在，你的 shell 就能自动寻找到 <code>/home/&lt;user name&gt;/bin/</code> 下的程序了，执行这个目录下的程序也不需要完整地写出程序的路径。</p>\n<h3 id=\"自定义变量\"><a href=\"#自定义变量\" class=\"headerlink\" title=\"自定义变量\"></a>自定义变量</h3><p>当然，你也可以定义自己的变量。刚才我们看到的变量名称都是全大写的，实际上<a href=\"https://bash.cyberciti.biz/guide/Rules_for_Naming_variable_name\" target=\"_blank\" rel=\"noopener\">变量名称的定义还是比较灵活的</a>。</p>\n<p>定义新变量的过程非常直观，直接对它赋值就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_variable=&quot;Hello&quot;</span><br></pre></td></tr></table></figure>\n<p>然后可以用以下的方式读取到已定义变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $new_variable</span><br></pre></td></tr></table></figure>\n<p>程序的正常工作离不开各种变量，例如要将某个选项设置为打开，又或者让程序找到所需的代码库，都需要使用变量。在 bash 中运行程序的时候会生成一个子 shell，这个子 shell 和执行原程序的父 shell 并不是完全一样的，只是继承了父 shell 的部分内容，而且默认是不继承父 shell 中的变量的。因为变量默认情况下是局部变量，出于安全原因，一个 shell 中的局部变量不会被另一个 shell 读取到，即使是子 shell 也不可以。</p>\n<p>下面举一个例子。首先定义一个变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">robots=&quot;R2D2 &amp; C3PO&quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash</span><br></pre></td></tr></table></figure>\n<p>现在是在 bash shell 中创建了一个子 shell。</p>\n<p>执行这个命令看看还能不能读取到刚才定义的变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $robots</span><br></pre></td></tr></table></figure>\n<p>你会发现读取不到。</p>\n<p>还是在这个子 shell 中，为 <code>robots</code> 变量赋一个不同的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">robots=&quot;These aren&apos;t the ones you are looking for&quot;</span><br></pre></td></tr></table></figure>\n<p>再读取一次：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $robots</span><br><span class=\"line\">These aren&apos;t the ones you are looking for</span><br></pre></td></tr></table></figure>\n<p>退出这个子 shell：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n<p>然后再看一下现在 <code>robots</code>  变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $robots</span><br><span class=\"line\">R2D2 &amp; C3P0</span><br></pre></td></tr></table></figure>\n<p>这一个特性可以有效避免配置过程中产生混乱，同时也会导致一个问题：如果程序中需要设置变量，但却由于子 shell 的原因无法正常访问到这个变量，该如何解决呢？这个时候就需要用到 <code>export</code> 了。</p>\n<p>重复一次刚才的过程，但这一次不是通过 <code>robots=&quot;R2D2 &amp; C3PO&quot;</code> 方式来设置变量，而是使用 <code>export</code> 命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export robots=&quot;R2D2 &amp; C3PO&quot;</span><br></pre></td></tr></table></figure>\n<p>现在你会发现，在进入子 shell 之后，<code>robots</code> 变量的值仍然是最初赋予的值。</p>\n<p>要注意的是，尽管子 shell 会继承通过 <code>export</code> 导出的变量，但如果在子 shell 中对这个变量重新赋值，是不会影响到父 shell 中对应变量的。</p>\n<p>如果要查看所有通过 <code>export</code> 导出的变量，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -p</span><br></pre></td></tr></table></figure>\n<p>自定义的变量会显示在这个列表的末尾。这个列表中还有一些常见的变量：例如 <code>USER</code> 的值是当前用户的用户名，<code>PWD</code> 的值是当前用户当前所在的目录，而 <code>OLDPWD</code> 的值则是当前用户上一个访问过的目录。因此如果执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd -</span><br></pre></td></tr></table></figure>\n<p>就会切换到上一个访问过的目录，那是因为 <code>cd</code> 命令读取到了 <code>OLDPWD</code> 变量的值。</p>\n<p>你也可以使用 <code>env</code> 命令查看所有环境变量。</p>\n<p>如果要取消导出一个变量，可以加上 <code>-n</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -n robots</span><br></pre></td></tr></table></figure>\n<h3 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a>接下来</h3><p>了解过环境变量的知识之后，你已经到达了可能对自己和他人造成危险的水平，接下来就需要了解如何通过使用别名来让环境变得更安全、更友好以保护自己了。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>初学者可以在此教程中了解环境变量。</p>\n</blockquote>\n<p><img src=\"https://www.linux.com/sites/lcom/files/styles/rendered_file/public/wynand-van-poortvliet-40467-unsplash.jpg?itok=tr6Eb4N0\" alt=\"\"></p>\n<p>bash 变量，尤其是讨厌的<em>环境变量</em>，已经是一个老生常谈的话题了。我们也更应该对它有一个详细的了解，让它为我们所用。</p>\n<p>下面就打开终端，开始吧。</p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p><code>HOME</code> （LCTT 译注：双关语）除了是你脱下帽子惬意休息的地方，同时也是 Linux 中的一个变量，它是当前用户主目录的路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $HOME</span><br></pre></td></tr></table></figure>\n<p>以上这个命令会显示当前用户的主目录路径，通常都在 <code>/home/&lt;your username&gt;</code> 下。</p>\n<p>顾名思义，变量的值是可以根据上下文变化的。实际上，Linux 系统中每一个用户的 <code>HOME</code> 变量都是不一样的，当然你也可以这样自行更改 <code>HOME</code> 变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOME=/home/&lt;your username&gt;/Documents</span><br></pre></td></tr></table></figure>\n<p>以上这个命令将会把 <code>HOME</code> 变量设置为你的 <code>Documents</code> 目录。</p>\n<p>其中有三点需要留意：</p>\n<ol>\n<li><code>=</code> 符号和其两侧的内容之间不加空格。空格在 shell 中有专门的意义，不能随意地在任何地方添加空格。</li>\n<li>如果你需要对变量进行赋值，只需要使用变量名称就可以了。但如果需要读取或者使用变量的值，需要在变量前面加上一个 <code>$</code> 号。</li>\n<li>更改 <code>HOME</code> 变量具有一定的风险。有很多程序是依赖于 <code>HOME</code> 变量的，更改 <code>HOME</code> 变量可能会导致一些不可预见的结果。例如，如果按照上面的方式更改了 <code>HOME</code> 变量，然后执行不带有任何参数的 <code>cd</code> 命令，在通常情况下，会跳转到用户的主目录下，但在这个时候，会跳转到 <code>HOME</code> 变量指定的目录下。</li>\n</ol>\n<p>上面第 3 点中环境变量的更改并不是持久有效的，在终端关闭后重新打开终端，又或者是新建一个终端，执行 <code>echo $HOME</code> 命令输出的仍然会是初始的值，而不是重新自定义的值。</p>\n<p>在讨论如何持久地更改一个环境变量之前，我们先来看一下另一个比较重要的环境变量。</p>\n<h3 id=\"PATH-变量\"><a href=\"#PATH-变量\" class=\"headerlink\" title=\"PATH 变量\"></a>PATH 变量</h3><p>在 <code>PATH</code> 变量中存放了一系列目录，而且是放置了可执行程序的目录。正是由于 <code>PATH</code> 变量的存在，让你不需要知道应用程序具体安装到了什么目录，而 shell 却可以正确地找到这些应用程序。</p>\n<p>如果你查看 <code>PATH</code> 变量的值，大概会是以下这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin</span><br></pre></td></tr></table></figure>\n<p>每两个目录之间使用冒号 <code>:</code> 分隔。如果某个应用程序的所在目录不在 <code>PATH</code> 变量中，那么运行的时候就需要声明应用程序的目录让 shell 能够找到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/&lt;user name&gt;/bin/my_program.sh</span><br></pre></td></tr></table></figure>\n<p>例如以上命令就会执行当前用户 <code>bin/</code> 目录下的 <code>my_program.sh</code> 文件。</p>\n<p>有一个常见的问题：如果你不希望弄乱系统的 <code>bin/</code> 目录，同时也不希望你自己的文件被其它人运行，还不想每次运行的时候都要输入完整的路径，那么，你可以在你的主目录中创建一个独立的 <code>bin/</code> 目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir $HOME/bin</span><br></pre></td></tr></table></figure>\n<p>然后将这个目录添加到 <code>PATH</code> 变量中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>\n<p>然后 <code>/home/&lt;user name&gt;/bin/</code> 目录就会出现在 <code>PATH</code> 变量中了。但正如之前所说，这个变更只会在当前的 shell 生效，当前的 shell 一旦关闭，环境变量的值就又恢复原状了。</p>\n<p>如果要让变更对当前用户持续生效，就不能在 shell 中直接执行对应的变更，而是应该将这些变更操作写在每次启动 shell 时都会运行的文件当中。这个文件就是当前用户主目录中的 <code>.bashrc</code> 文件。文件名前面的点号表明这是一个隐藏文件，执行普通的 <code>ls</code> 命令是不会将这个文件显示出来的，但只要在 <code>ls</code> 命令中加入 <code>-a</code> 参数就可以看到这个文件了。</p>\n<p>你可以使用诸如 <a href=\"https://www.kde.org/applications/utilities/kate/\" target=\"_blank\" rel=\"noopener\">kate</a>、<a href=\"https://help.gnome.org/users/gedit/stable/\" target=\"_blank\" rel=\"noopener\">gedit</a>、<a href=\"https://www.nano-editor.org/\" target=\"_blank\" rel=\"noopener\">nano</a> 或者 <a href=\"https://www.vim.org/\" target=\"_blank\" rel=\"noopener\">vim</a> 这些文本编辑器来打开 <code>.bashrc</code> 文件（但不要用 LibreOffice Writer，它是一个文字处理软件，跟前面几个文字编辑器完全不同）。打开 <code>.bashrc</code> 文件之后，你会看见里面放置了一些 shell 命令，是用于为当前用户设置环境的。</p>\n<p>在文件的末尾添加新行并输入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>\n<p>保存并关闭 <code>.bashrc</code> 文件，接下来你就会看到 <code>export</code> 语句的效果。执行以下的命令让刚才的修改立即生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .bashrc</span><br></pre></td></tr></table></figure>\n<p>刚才执行的 <code>source</code> 命令让 <code>.bashrc</code> 文件在当前的 shell 立即生效，并且对于之后打开的 shell 都会有效。因此另一个等效的方法是退出并重新进入 shell，但这样也太麻烦了。</p>\n<p>现在，你的 shell 就能自动寻找到 <code>/home/&lt;user name&gt;/bin/</code> 下的程序了，执行这个目录下的程序也不需要完整地写出程序的路径。</p>\n<h3 id=\"自定义变量\"><a href=\"#自定义变量\" class=\"headerlink\" title=\"自定义变量\"></a>自定义变量</h3><p>当然，你也可以定义自己的变量。刚才我们看到的变量名称都是全大写的，实际上<a href=\"https://bash.cyberciti.biz/guide/Rules_for_Naming_variable_name\" target=\"_blank\" rel=\"noopener\">变量名称的定义还是比较灵活的</a>。</p>\n<p>定义新变量的过程非常直观，直接对它赋值就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_variable=&quot;Hello&quot;</span><br></pre></td></tr></table></figure>\n<p>然后可以用以下的方式读取到已定义变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $new_variable</span><br></pre></td></tr></table></figure>\n<p>程序的正常工作离不开各种变量，例如要将某个选项设置为打开，又或者让程序找到所需的代码库，都需要使用变量。在 bash 中运行程序的时候会生成一个子 shell，这个子 shell 和执行原程序的父 shell 并不是完全一样的，只是继承了父 shell 的部分内容，而且默认是不继承父 shell 中的变量的。因为变量默认情况下是局部变量，出于安全原因，一个 shell 中的局部变量不会被另一个 shell 读取到，即使是子 shell 也不可以。</p>\n<p>下面举一个例子。首先定义一个变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">robots=&quot;R2D2 &amp; C3PO&quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash</span><br></pre></td></tr></table></figure>\n<p>现在是在 bash shell 中创建了一个子 shell。</p>\n<p>执行这个命令看看还能不能读取到刚才定义的变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $robots</span><br></pre></td></tr></table></figure>\n<p>你会发现读取不到。</p>\n<p>还是在这个子 shell 中，为 <code>robots</code> 变量赋一个不同的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">robots=&quot;These aren&apos;t the ones you are looking for&quot;</span><br></pre></td></tr></table></figure>\n<p>再读取一次：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $robots</span><br><span class=\"line\">These aren&apos;t the ones you are looking for</span><br></pre></td></tr></table></figure>\n<p>退出这个子 shell：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n<p>然后再看一下现在 <code>robots</code>  变量的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $robots</span><br><span class=\"line\">R2D2 &amp; C3P0</span><br></pre></td></tr></table></figure>\n<p>这一个特性可以有效避免配置过程中产生混乱，同时也会导致一个问题：如果程序中需要设置变量，但却由于子 shell 的原因无法正常访问到这个变量，该如何解决呢？这个时候就需要用到 <code>export</code> 了。</p>\n<p>重复一次刚才的过程，但这一次不是通过 <code>robots=&quot;R2D2 &amp; C3PO&quot;</code> 方式来设置变量，而是使用 <code>export</code> 命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export robots=&quot;R2D2 &amp; C3PO&quot;</span><br></pre></td></tr></table></figure>\n<p>现在你会发现，在进入子 shell 之后，<code>robots</code> 变量的值仍然是最初赋予的值。</p>\n<p>要注意的是，尽管子 shell 会继承通过 <code>export</code> 导出的变量，但如果在子 shell 中对这个变量重新赋值，是不会影响到父 shell 中对应变量的。</p>\n<p>如果要查看所有通过 <code>export</code> 导出的变量，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -p</span><br></pre></td></tr></table></figure>\n<p>自定义的变量会显示在这个列表的末尾。这个列表中还有一些常见的变量：例如 <code>USER</code> 的值是当前用户的用户名，<code>PWD</code> 的值是当前用户当前所在的目录，而 <code>OLDPWD</code> 的值则是当前用户上一个访问过的目录。因此如果执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd -</span><br></pre></td></tr></table></figure>\n<p>就会切换到上一个访问过的目录，那是因为 <code>cd</code> 命令读取到了 <code>OLDPWD</code> 变量的值。</p>\n<p>你也可以使用 <code>env</code> 命令查看所有环境变量。</p>\n<p>如果要取消导出一个变量，可以加上 <code>-n</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -n robots</span><br></pre></td></tr></table></figure>\n<h3 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a>接下来</h3><p>了解过环境变量的知识之后，你已经到达了可能对自己和他人造成危险的水平，接下来就需要了解如何通过使用别名来让环境变得更安全、更友好以保护自己了。</p>\n<hr>\n<p>via: <a href=\"https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise\" target=\"_blank\" rel=\"noopener\">https://www.linux.com/blog/learn/2018/12/bash-variables-environmental-and-otherwise</a></p>\n"},{"title":"使用极简浏览器 Min 浏览网页","date":"2018-11-04T15:11:25.000Z","_content":"\n> 并非所有 web 浏览器都要做到无所不能，Min 就是一个极简主义风格的浏览器。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/openweb-osdc-lead.png?itok=yjU4KliG)\n\n现在还有开发新的 Web 浏览器的需要吗？即使现在浏览器领域已经成为了寡头市场，但仍然不断涌现出各种前所未有的浏览器产品。\n\n[Min][1] 就是其中一个。顾名思义，Min 是一个小的浏览器，也是一个极简主义的浏览器。但它麻雀虽小五脏俱全，而且还是一个开源的浏览器，它的 Apache 2.0 许可证引起了我的注意。\n\n让我们来看看 Min 有什么值得关注的方面。\n\n### 开始\n\nMin 基于 [Electron][2] 框架开发，值得一提的是，[Atom 文本编辑器][3]也是基于这个框架开发的。它提供 Linux、MacOS 和 Windows 的[安装程序][4]，当然也可以[从 GitHub 获取它的源代码][5]自行编译安装。\n\n我使用的 Linux 发行版是 Manjaro，但没有完全匹配这个发行版的安装程序。还好，我通过 Manjaro 的包管理器也能安装 Min。\n\n安装完成后，在终端就可以直接启动 Min。\n\n![](https://opensource.com/sites/default/files/uploads/min-main.png)\n\nMin 号称是更智能、更快速的浏览器。经过尝试以后，我觉得它比我在其它电脑上使用过的 Firefox 和 Chrome 浏览器启动得更快。\n\n而使用 Min 浏览网页的过程则和 Firefox 或 Chrome 一样，只要再地址栏输入 URL，回车，就好了。\n\n### Min 的功能\n\n尽管 Min 不可能带有 Firefox 或 Chrome 等浏览器得所有功能，但它也有可取之处。\n\nMin 和其它浏览器一样，支持页面选项卡。它还有一个称为 Tasks 的功能，可以对打开的选项卡进行分组。\n\n[DuckDuckGo][6] 是我最喜欢的搜索引擎，而 Min 的默认搜索引擎恰好就是它，这正合我意。当然，如果你喜欢另一个搜索引擎，也可以在 Min 的偏好设置中配置你喜欢的搜索引擎作为默认搜索引擎。\n\nMin 没有使用类似 AdBlock 这样的插件来过滤你不想看到的内容，而是使用了一个名为 [EasyList][7] 的内置的广告拦截器，你可以使用它来屏蔽脚本和图片。另外 Min 还带有一个内置的防跟踪软件。\n\n类似 Firefox，Min 有一个名为叫做 Reading List 的阅读模式。只需点击地址栏中的对应图标，就可以去除页面中的大部分无关内容，让你专注于正在阅读的内容。网页在阅读列表中可以保留 30 天。\n\n![](https://opensource.com/sites/default/files/uploads/min-reading-list.png)\n\nMin 还有一个专注模式，可以隐藏其它选项卡并阻止你打开新的选项卡。在专注模式下，如果一个 web 页面中进行工作，需要多点击好几次才能打开一个新页面。\n\nMin 也有很多快捷键让你快速使用某个功能。你可以[在 GitHub 上][8]找到这些这些快捷键的参考文档，也可以在 Min 的偏好设置中进行更改。\n\n我发现 Min 可以在 YouTube、Vimeo、Dailymotion 等视频网站上播放视频，还可以在音乐网站 7Digital 上播放音乐。但由于我没有账号，所以没法测试是否能在 Spotify 或 Last.fm 等这些网站上播放音乐。\n\n![](https://opensource.com/sites/default/files/uploads/min-video.png)\n\n### Min 的弱点\n\nMin 确实也有自己的缺点，例如它无法将网站添加为书签。替代方案要么是查看 Min 的搜索历史来找回你需要的链接，要么是使用一个第三方的书签服务。\n\n最大的缺点是 Min 不支持插件。这对我来说不是一件坏事，因为浏览器启动速度和运行速度快的主要原因就在于此。当然也有一些人非常喜欢使用浏览器插件，Min 就不是他们的选择。\n\n### 总结\n\nMin 算是一个中规中矩的浏览器，它可以凭借轻量、快速的优点吸引很多极简主义的用户。但是对于追求多功能的用户来说，Min 就显得相当捉襟见肘了。\n\n所以，如果你想摆脱当今多功能浏览器的束缚，我觉得可以试用一下 Min。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/min-web-browser\n\n[a]: https://opensource.com/users/scottnesbitt\n[b]: https://github.com/lujun9972\n[1]: https://minbrowser.github.io/min/\n[2]: http://electron.atom.io/apps/\n[3]: https://opensource.com/article/17/5/atom-text-editor-packages-writers\n[4]: https://github.com/minbrowser/min/releases/\n[5]: https://github.com/minbrowser/min\n[6]: http://duckduckgo.com\n[7]: https://easylist.to/\n[8]: https://github.com/minbrowser/min/wiki\n\n","source":"_posts/Browsing-the-web-with-Min-a-minimalist-open-source-web-browser.md","raw":"---\ntitle: 使用极简浏览器 Min 浏览网页\ndate: 2018-11-04 23:11:25\ntags:\n  - 浏览器\n  - LCTT 翻译\n---\n\n> 并非所有 web 浏览器都要做到无所不能，Min 就是一个极简主义风格的浏览器。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/openweb-osdc-lead.png?itok=yjU4KliG)\n\n现在还有开发新的 Web 浏览器的需要吗？即使现在浏览器领域已经成为了寡头市场，但仍然不断涌现出各种前所未有的浏览器产品。\n\n[Min][1] 就是其中一个。顾名思义，Min 是一个小的浏览器，也是一个极简主义的浏览器。但它麻雀虽小五脏俱全，而且还是一个开源的浏览器，它的 Apache 2.0 许可证引起了我的注意。\n\n让我们来看看 Min 有什么值得关注的方面。\n\n### 开始\n\nMin 基于 [Electron][2] 框架开发，值得一提的是，[Atom 文本编辑器][3]也是基于这个框架开发的。它提供 Linux、MacOS 和 Windows 的[安装程序][4]，当然也可以[从 GitHub 获取它的源代码][5]自行编译安装。\n\n我使用的 Linux 发行版是 Manjaro，但没有完全匹配这个发行版的安装程序。还好，我通过 Manjaro 的包管理器也能安装 Min。\n\n安装完成后，在终端就可以直接启动 Min。\n\n![](https://opensource.com/sites/default/files/uploads/min-main.png)\n\nMin 号称是更智能、更快速的浏览器。经过尝试以后，我觉得它比我在其它电脑上使用过的 Firefox 和 Chrome 浏览器启动得更快。\n\n而使用 Min 浏览网页的过程则和 Firefox 或 Chrome 一样，只要再地址栏输入 URL，回车，就好了。\n\n### Min 的功能\n\n尽管 Min 不可能带有 Firefox 或 Chrome 等浏览器得所有功能，但它也有可取之处。\n\nMin 和其它浏览器一样，支持页面选项卡。它还有一个称为 Tasks 的功能，可以对打开的选项卡进行分组。\n\n[DuckDuckGo][6] 是我最喜欢的搜索引擎，而 Min 的默认搜索引擎恰好就是它，这正合我意。当然，如果你喜欢另一个搜索引擎，也可以在 Min 的偏好设置中配置你喜欢的搜索引擎作为默认搜索引擎。\n\nMin 没有使用类似 AdBlock 这样的插件来过滤你不想看到的内容，而是使用了一个名为 [EasyList][7] 的内置的广告拦截器，你可以使用它来屏蔽脚本和图片。另外 Min 还带有一个内置的防跟踪软件。\n\n类似 Firefox，Min 有一个名为叫做 Reading List 的阅读模式。只需点击地址栏中的对应图标，就可以去除页面中的大部分无关内容，让你专注于正在阅读的内容。网页在阅读列表中可以保留 30 天。\n\n![](https://opensource.com/sites/default/files/uploads/min-reading-list.png)\n\nMin 还有一个专注模式，可以隐藏其它选项卡并阻止你打开新的选项卡。在专注模式下，如果一个 web 页面中进行工作，需要多点击好几次才能打开一个新页面。\n\nMin 也有很多快捷键让你快速使用某个功能。你可以[在 GitHub 上][8]找到这些这些快捷键的参考文档，也可以在 Min 的偏好设置中进行更改。\n\n我发现 Min 可以在 YouTube、Vimeo、Dailymotion 等视频网站上播放视频，还可以在音乐网站 7Digital 上播放音乐。但由于我没有账号，所以没法测试是否能在 Spotify 或 Last.fm 等这些网站上播放音乐。\n\n![](https://opensource.com/sites/default/files/uploads/min-video.png)\n\n### Min 的弱点\n\nMin 确实也有自己的缺点，例如它无法将网站添加为书签。替代方案要么是查看 Min 的搜索历史来找回你需要的链接，要么是使用一个第三方的书签服务。\n\n最大的缺点是 Min 不支持插件。这对我来说不是一件坏事，因为浏览器启动速度和运行速度快的主要原因就在于此。当然也有一些人非常喜欢使用浏览器插件，Min 就不是他们的选择。\n\n### 总结\n\nMin 算是一个中规中矩的浏览器，它可以凭借轻量、快速的优点吸引很多极简主义的用户。但是对于追求多功能的用户来说，Min 就显得相当捉襟见肘了。\n\n所以，如果你想摆脱当今多功能浏览器的束缚，我觉得可以试用一下 Min。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/min-web-browser\n\n[a]: https://opensource.com/users/scottnesbitt\n[b]: https://github.com/lujun9972\n[1]: https://minbrowser.github.io/min/\n[2]: http://electron.atom.io/apps/\n[3]: https://opensource.com/article/17/5/atom-text-editor-packages-writers\n[4]: https://github.com/minbrowser/min/releases/\n[5]: https://github.com/minbrowser/min\n[6]: http://duckduckgo.com\n[7]: https://easylist.to/\n[8]: https://github.com/minbrowser/min/wiki\n\n","slug":"Browsing-the-web-with-Min-a-minimalist-open-source-web-browser","published":1,"updated":"2019-03-28T12:28:00.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cf000plixualpdrhwq","content":"<blockquote>\n<p>并非所有 web 浏览器都要做到无所不能，Min 就是一个极简主义风格的浏览器。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/openweb-osdc-lead.png?itok=yjU4KliG\" alt=\"\"></p>\n<p>现在还有开发新的 Web 浏览器的需要吗？即使现在浏览器领域已经成为了寡头市场，但仍然不断涌现出各种前所未有的浏览器产品。</p>\n<p><a href=\"https://minbrowser.github.io/min/\" target=\"_blank\" rel=\"noopener\">Min</a> 就是其中一个。顾名思义，Min 是一个小的浏览器，也是一个极简主义的浏览器。但它麻雀虽小五脏俱全，而且还是一个开源的浏览器，它的 Apache 2.0 许可证引起了我的注意。</p>\n<p>让我们来看看 Min 有什么值得关注的方面。</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>Min 基于 <a href=\"http://electron.atom.io/apps/\" target=\"_blank\" rel=\"noopener\">Electron</a> 框架开发，值得一提的是，<a href=\"https://opensource.com/article/17/5/atom-text-editor-packages-writers\" target=\"_blank\" rel=\"noopener\">Atom 文本编辑器</a>也是基于这个框架开发的。它提供 Linux、MacOS 和 Windows 的<a href=\"https://github.com/minbrowser/min/releases/\" target=\"_blank\" rel=\"noopener\">安装程序</a>，当然也可以<a href=\"https://github.com/minbrowser/min\" target=\"_blank\" rel=\"noopener\">从 GitHub 获取它的源代码</a>自行编译安装。</p>\n<p>我使用的 Linux 发行版是 Manjaro，但没有完全匹配这个发行版的安装程序。还好，我通过 Manjaro 的包管理器也能安装 Min。</p>\n<p>安装完成后，在终端就可以直接启动 Min。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-main.png\" alt=\"\"></p>\n<p>Min 号称是更智能、更快速的浏览器。经过尝试以后，我觉得它比我在其它电脑上使用过的 Firefox 和 Chrome 浏览器启动得更快。</p>\n<p>而使用 Min 浏览网页的过程则和 Firefox 或 Chrome 一样，只要再地址栏输入 URL，回车，就好了。</p>\n<h3 id=\"Min-的功能\"><a href=\"#Min-的功能\" class=\"headerlink\" title=\"Min 的功能\"></a>Min 的功能</h3><p>尽管 Min 不可能带有 Firefox 或 Chrome 等浏览器得所有功能，但它也有可取之处。</p>\n<p>Min 和其它浏览器一样，支持页面选项卡。它还有一个称为 Tasks 的功能，可以对打开的选项卡进行分组。</p>\n<p><a href=\"http://duckduckgo.com\" target=\"_blank\" rel=\"noopener\">DuckDuckGo</a> 是我最喜欢的搜索引擎，而 Min 的默认搜索引擎恰好就是它，这正合我意。当然，如果你喜欢另一个搜索引擎，也可以在 Min 的偏好设置中配置你喜欢的搜索引擎作为默认搜索引擎。</p>\n<p>Min 没有使用类似 AdBlock 这样的插件来过滤你不想看到的内容，而是使用了一个名为 <a href=\"https://easylist.to/\" target=\"_blank\" rel=\"noopener\">EasyList</a> 的内置的广告拦截器，你可以使用它来屏蔽脚本和图片。另外 Min 还带有一个内置的防跟踪软件。</p>\n<p>类似 Firefox，Min 有一个名为叫做 Reading List 的阅读模式。只需点击地址栏中的对应图标，就可以去除页面中的大部分无关内容，让你专注于正在阅读的内容。网页在阅读列表中可以保留 30 天。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-reading-list.png\" alt=\"\"></p>\n<p>Min 还有一个专注模式，可以隐藏其它选项卡并阻止你打开新的选项卡。在专注模式下，如果一个 web 页面中进行工作，需要多点击好几次才能打开一个新页面。</p>\n<p>Min 也有很多快捷键让你快速使用某个功能。你可以<a href=\"https://github.com/minbrowser/min/wiki\" target=\"_blank\" rel=\"noopener\">在 GitHub 上</a>找到这些这些快捷键的参考文档，也可以在 Min 的偏好设置中进行更改。</p>\n<p>我发现 Min 可以在 YouTube、Vimeo、Dailymotion 等视频网站上播放视频，还可以在音乐网站 7Digital 上播放音乐。但由于我没有账号，所以没法测试是否能在 Spotify 或 Last.fm 等这些网站上播放音乐。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-video.png\" alt=\"\"></p>\n<h3 id=\"Min-的弱点\"><a href=\"#Min-的弱点\" class=\"headerlink\" title=\"Min 的弱点\"></a>Min 的弱点</h3><p>Min 确实也有自己的缺点，例如它无法将网站添加为书签。替代方案要么是查看 Min 的搜索历史来找回你需要的链接，要么是使用一个第三方的书签服务。</p>\n<p>最大的缺点是 Min 不支持插件。这对我来说不是一件坏事，因为浏览器启动速度和运行速度快的主要原因就在于此。当然也有一些人非常喜欢使用浏览器插件，Min 就不是他们的选择。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Min 算是一个中规中矩的浏览器，它可以凭借轻量、快速的优点吸引很多极简主义的用户。但是对于追求多功能的用户来说，Min 就显得相当捉襟见肘了。</p>\n<p>所以，如果你想摆脱当今多功能浏览器的束缚，我觉得可以试用一下 Min。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/min-web-browser\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/min-web-browser</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>并非所有 web 浏览器都要做到无所不能，Min 就是一个极简主义风格的浏览器。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/openweb-osdc-lead.png?itok=yjU4KliG\" alt=\"\"></p>\n<p>现在还有开发新的 Web 浏览器的需要吗？即使现在浏览器领域已经成为了寡头市场，但仍然不断涌现出各种前所未有的浏览器产品。</p>\n<p><a href=\"https://minbrowser.github.io/min/\" target=\"_blank\" rel=\"noopener\">Min</a> 就是其中一个。顾名思义，Min 是一个小的浏览器，也是一个极简主义的浏览器。但它麻雀虽小五脏俱全，而且还是一个开源的浏览器，它的 Apache 2.0 许可证引起了我的注意。</p>\n<p>让我们来看看 Min 有什么值得关注的方面。</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>Min 基于 <a href=\"http://electron.atom.io/apps/\" target=\"_blank\" rel=\"noopener\">Electron</a> 框架开发，值得一提的是，<a href=\"https://opensource.com/article/17/5/atom-text-editor-packages-writers\" target=\"_blank\" rel=\"noopener\">Atom 文本编辑器</a>也是基于这个框架开发的。它提供 Linux、MacOS 和 Windows 的<a href=\"https://github.com/minbrowser/min/releases/\" target=\"_blank\" rel=\"noopener\">安装程序</a>，当然也可以<a href=\"https://github.com/minbrowser/min\" target=\"_blank\" rel=\"noopener\">从 GitHub 获取它的源代码</a>自行编译安装。</p>\n<p>我使用的 Linux 发行版是 Manjaro，但没有完全匹配这个发行版的安装程序。还好，我通过 Manjaro 的包管理器也能安装 Min。</p>\n<p>安装完成后，在终端就可以直接启动 Min。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-main.png\" alt=\"\"></p>\n<p>Min 号称是更智能、更快速的浏览器。经过尝试以后，我觉得它比我在其它电脑上使用过的 Firefox 和 Chrome 浏览器启动得更快。</p>\n<p>而使用 Min 浏览网页的过程则和 Firefox 或 Chrome 一样，只要再地址栏输入 URL，回车，就好了。</p>\n<h3 id=\"Min-的功能\"><a href=\"#Min-的功能\" class=\"headerlink\" title=\"Min 的功能\"></a>Min 的功能</h3><p>尽管 Min 不可能带有 Firefox 或 Chrome 等浏览器得所有功能，但它也有可取之处。</p>\n<p>Min 和其它浏览器一样，支持页面选项卡。它还有一个称为 Tasks 的功能，可以对打开的选项卡进行分组。</p>\n<p><a href=\"http://duckduckgo.com\" target=\"_blank\" rel=\"noopener\">DuckDuckGo</a> 是我最喜欢的搜索引擎，而 Min 的默认搜索引擎恰好就是它，这正合我意。当然，如果你喜欢另一个搜索引擎，也可以在 Min 的偏好设置中配置你喜欢的搜索引擎作为默认搜索引擎。</p>\n<p>Min 没有使用类似 AdBlock 这样的插件来过滤你不想看到的内容，而是使用了一个名为 <a href=\"https://easylist.to/\" target=\"_blank\" rel=\"noopener\">EasyList</a> 的内置的广告拦截器，你可以使用它来屏蔽脚本和图片。另外 Min 还带有一个内置的防跟踪软件。</p>\n<p>类似 Firefox，Min 有一个名为叫做 Reading List 的阅读模式。只需点击地址栏中的对应图标，就可以去除页面中的大部分无关内容，让你专注于正在阅读的内容。网页在阅读列表中可以保留 30 天。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-reading-list.png\" alt=\"\"></p>\n<p>Min 还有一个专注模式，可以隐藏其它选项卡并阻止你打开新的选项卡。在专注模式下，如果一个 web 页面中进行工作，需要多点击好几次才能打开一个新页面。</p>\n<p>Min 也有很多快捷键让你快速使用某个功能。你可以<a href=\"https://github.com/minbrowser/min/wiki\" target=\"_blank\" rel=\"noopener\">在 GitHub 上</a>找到这些这些快捷键的参考文档，也可以在 Min 的偏好设置中进行更改。</p>\n<p>我发现 Min 可以在 YouTube、Vimeo、Dailymotion 等视频网站上播放视频，还可以在音乐网站 7Digital 上播放音乐。但由于我没有账号，所以没法测试是否能在 Spotify 或 Last.fm 等这些网站上播放音乐。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/min-video.png\" alt=\"\"></p>\n<h3 id=\"Min-的弱点\"><a href=\"#Min-的弱点\" class=\"headerlink\" title=\"Min 的弱点\"></a>Min 的弱点</h3><p>Min 确实也有自己的缺点，例如它无法将网站添加为书签。替代方案要么是查看 Min 的搜索历史来找回你需要的链接，要么是使用一个第三方的书签服务。</p>\n<p>最大的缺点是 Min 不支持插件。这对我来说不是一件坏事，因为浏览器启动速度和运行速度快的主要原因就在于此。当然也有一些人非常喜欢使用浏览器插件，Min 就不是他们的选择。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Min 算是一个中规中矩的浏览器，它可以凭借轻量、快速的优点吸引很多极简主义的用户。但是对于追求多功能的用户来说，Min 就显得相当捉襟见肘了。</p>\n<p>所以，如果你想摆脱当今多功能浏览器的束缚，我觉得可以试用一下 Min。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/min-web-browser\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/min-web-browser</a></p>\n"},{"title":"查看 Linux 发行版名称和版本号的 8 种方法","date":"2018-04-28T14:49:40.000Z","_content":"\n\t\n如果你加入了一家新公司，要为开发团队安装所需的软件并重启服务，这个时候首先要弄清楚它们运行在什么发行版以及哪个版本的系统上，你才能正确完成后续的工作。作为系统管理员，充分了解系统信息是首要的任务。\n\n查看 Linux 发行版名称和版本号有很多种方法。你可能会问，为什么要去了解这些基本信息呢？\n\n因为对于诸如 RHEL、Debian、openSUSE、Arch Linux 这几种主流发行版来说，它们各自拥有不同的包管理器来管理系统上的软件包，如果不知道所使用的是哪一个发行版的系统，在软件包安装的时候就会无从下手，而且由于大多数发行版都是用 systemd 命令而不是 SysVinit 脚本，在重启服务的时候也难以执行正确的命令。\n\n下面来看看可以使用那些基本命令来查看 Linux 发行版名称和版本号。\n\n### 方法总览\n\n  * `lsb_release` 命令\n  * `/etc/*-release` 文件\n  * `uname` 命令\n  * `/proc/version` 文件\n  * `dmesg` 命令\n  * YUM 或 DNF 命令\n  * RPM 命令\n  * APT-GET 命令\n\n### 方法 1： lsb_release 命令\n\nLSB（<ruby>Linux 标准库<rt>Linux Standard Base</rt></ruby>）能够打印发行版的具体信息，包括发行版名称、版本号、代号等。\n\n```\n# lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription: Ubuntu 16.04.3 LTS\nRelease: 16.04\nCodename: xenial\n```\n\n### 方法 2： /etc/*-release 文件\n\nrelease 文件通常被视为操作系统的标识。在 `/etc` 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。下面是一组在 Ubuntu/Debian 系统上显示出来的文件内容。\n\n```\n# cat /etc/issue\nUbuntu 16.04.3 LTS \\n \\l\n\n# cat /etc/issue.net\nUbuntu 16.04.3 LTS\n\n# cat /etc/lsb-release\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.3 LTS\"\n\n# cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"16.04.3 LTS (Xenial Xerus)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 16.04.3 LTS\"\nVERSION_ID=\"16.04\"\nHOME_URL=\"http://www.ubuntu.com/\"\nSUPPORT_URL=\"http://help.ubuntu.com/\"\nBUG_REPORT_URL=\"http://bugs.launchpad.net/ubuntu/\"\nVERSION_CODENAME=xenial\nUBUNTU_CODENAME=xenial\n\n# cat /etc/debian_version\n9.3\n```\n\n下面这一组是在 RHEL/CentOS/Fedora 系统上显示出来的文件内容。其中 `/etc/redhat-release` 和 `/etc/system-release` 文件是指向 `/etc/[发行版名称]-release` 文件的一个连接。\n\n```\n# cat /etc/centos-release\nCentOS release 6.9 (Final)\n\n# cat /etc/fedora-release\nFedora release 27 (Twenty Seven)\n\n# cat /etc/os-release\nNAME=Fedora\nVERSION=\"27 (Twenty Seven)\"\nID=fedora\nVERSION_ID=27\nPRETTY_NAME=\"Fedora 27 (Twenty Seven)\"\nANSI_COLOR=\"0;34\"\nCPE_NAME=\"cpe:/o:fedoraproject:fedora:27\"\nHOME_URL=\"https://fedoraproject.org/\"\nSUPPORT_URL=\"https://fedoraproject.org/wiki/Communicating_and_getting_help\"\nBUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\nREDHAT_BUGZILLA_PRODUCT=\"Fedora\"\nREDHAT_BUGZILLA_PRODUCT_VERSION=27\nREDHAT_SUPPORT_PRODUCT=\"Fedora\"\nREDHAT_SUPPORT_PRODUCT_VERSION=27\nPRIVACY_POLICY_URL=\"https://fedoraproject.org/wiki/Legal:PrivacyPolicy\"\n\n# cat /etc/redhat-release\nFedora release 27 (Twenty Seven)\n\n# cat /etc/system-release\nFedora release 27 (Twenty Seven)\n```\n\n### 方法 3： uname 命令\n\nuname（unix name 的意思） 是一个打印系统信息的工具，包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。\n\n- **建议阅读：** [6种查看系统 Linux 内核的方法][1]\n\n```\n# uname -a\nLinux localhost.localdomain 4.12.14-300.fc26.x86_64 #1 SMP Wed Sep 20 16:28:07 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n以上运行结果说明使用的操作系统版本是 Fedora 26。\n\n### 方法 4： /proc/version 文件\n\n这个文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。\n\n```\n# cat /proc/version\nLinux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017\n```\n\n### 方法 5： dmesg 命令\n\ndmesg（<ruby>展示信息<rt>display message</rt></ruby> 或<ruby>驱动程序信息<rt>driver message</rt></ruby>）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。\n\n```\n# dmesg | grep \"Linux\"\n[ 0.000000] Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017\n[ 0.001000] SELinux: Initializing.\n[ 0.001000] SELinux: Starting in permissive mode\n[ 0.470288] SELinux: Registering netfilter hooks\n[ 0.616351] Linux agpgart interface v0.103\n[ 0.630063] usb usb1: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ehci_hcd\n[ 0.688949] usb usb2: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ohci_hcd\n[ 2.564554] SELinux: Disabled at runtime.\n[ 2.564584] SELinux: Unregistering netfilter hooks\n```\n\n### 方法 6： Yum/Dnf 命令\n\nYum（<ruby>Yellowdog 更新器修改版<rt>Yellowdog Updater Modified</rt></ruby>）是 Linux 操作系统上的一个包管理工具，而 `yum` 命令被用于一些基于 RedHat 的 Linux 发行版上安装、更新、查找、删除软件包。\n\n- **建议阅读：** [在 RHEL/CentOS 系统上使用 yum 命令管理软件包][2]\n\n```\n# yum info nano\nLoaded plugins: fastestmirror, ovl\nLoading mirror speeds from cached hostfile\n * base: centos.zswap.net\n * extras: mirror2.evolution-host.com\n * updates: centos.zswap.net\nAvailable Packages\nName : nano\nArch : x86_64\nVersion : 2.3.1\nRelease : 10.el7\nSize : 440 k\nRepo : base/7/x86_64\nSummary : A small text editor\nURL : http://www.nano-editor.org\nLicense : GPLv3+\nDescription : GNU nano is a small and friendly text editor.\n```\n\n下面的 `yum repolist` 命令执行后显示了 yum 的基础源仓库、额外源仓库、更新源仓库都来自 CentOS 7 仓库。\n\n```\n# yum repolist\nLoaded plugins: fastestmirror, ovl\nLoading mirror speeds from cached hostfile\n * base: centos.zswap.net\n * extras: mirror2.evolution-host.com\n * updates: centos.zswap.net\nrepo id repo name status\nbase/7/x86_64 CentOS-7 - Base 9591\nextras/7/x86_64 CentOS-7 - Extras 388\nupdates/7/x86_64 CentOS-7 - Updates 1929\nrepolist: 11908\n```\n\n使用 `dnf` 命令也同样可以查看发行版名称和版本号。\n\n- **建议阅读：** [在 Fedora 系统上使用 DNF（YUM 的一个分支）命令管理软件包][3]\n\n```\n# dnf info nano\nLast metadata expiration check: 0:01:25 ago on Thu Feb 15 01:59:31 2018.\nInstalled Packages\nName : nano\nVersion : 2.8.7\nRelease : 1.fc27\nArch : x86_64\nSize : 2.1 M\nSource : nano-2.8.7-1.fc27.src.rpm\nRepo : @System\nFrom repo : fedora\nSummary : A small text editor\nURL : https://www.nano-editor.org\nLicense : GPLv3+\nDescription : GNU nano is a small and friendly text editor.\n```\n\n### 方法 7： RPM 命令\n\nRPM（<ruby>红帽包管理器<rt>RedHat Package Manager</rt></ruby>）是在 CentOS、Oracle Linux、Fedora 这些基于 RedHat 的操作系统上的一个强大的命令行包管理工具，同样也可以帮助我们查看系统的版本信息。\n\n- **建议阅读：** [在基于 RHEL 的系统上使用 RPM 命令管理软件包][4]\n\n```\n# rpm -q nano\nnano-2.8.7-1.fc27.x86_64\n```\n\n### 方法 8： APT-GET 命令\n\nApt-Get（<ruby>高级打包工具<rt>Advanced Packaging Tool</rt></ruby>）是一个强大的命令行工具，可以自动下载安装新软件包、更新已有的软件包、更新软件包列表索引，甚至更新整个 Debian 系统。\n\n- **建议阅读：** [在基于 Debian 的系统上使用 Apt-Get 和 Apt-Cache 命令管理软件包][5]\n\n```\n# apt-cache policy nano\nnano:\n Installed: 2.5.3-2ubuntu2\n Candidate: 2.5.3-2ubuntu2\n Version table:\n * 2.5.3-2ubuntu2 500\n 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages\n 100 /var/lib/dpkg/status\n 2.5.3-2 500\n 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial/main amd64 Packages\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/check-find-linux-distribution-name-and-version/\n\n[a]:https://www.2daygeek.com/author/magesh/\n[1]:https://www.2daygeek.com/check-find-determine-running-installed-linux-kernel-version/\n[2]:https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\n[3]:https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\n[4]:https://www.2daygeek.com/rpm-command-examples/\n[5]:https://www.2daygeek.com/apt-get-apt-cache-command-examples-manage-packages-debian-ubuntu-systems/\n","source":"_posts/Check-Linux-Distribution-Name-and-Version.md","raw":"---\ntitle: 查看 Linux 发行版名称和版本号的 8 种方法\ndate: 2018-04-28 22:49:40\ntags:\n  - Linux\n  - 版本\n  - 发行版\n  - LCTT 翻译\n---\n\n\t\n如果你加入了一家新公司，要为开发团队安装所需的软件并重启服务，这个时候首先要弄清楚它们运行在什么发行版以及哪个版本的系统上，你才能正确完成后续的工作。作为系统管理员，充分了解系统信息是首要的任务。\n\n查看 Linux 发行版名称和版本号有很多种方法。你可能会问，为什么要去了解这些基本信息呢？\n\n因为对于诸如 RHEL、Debian、openSUSE、Arch Linux 这几种主流发行版来说，它们各自拥有不同的包管理器来管理系统上的软件包，如果不知道所使用的是哪一个发行版的系统，在软件包安装的时候就会无从下手，而且由于大多数发行版都是用 systemd 命令而不是 SysVinit 脚本，在重启服务的时候也难以执行正确的命令。\n\n下面来看看可以使用那些基本命令来查看 Linux 发行版名称和版本号。\n\n### 方法总览\n\n  * `lsb_release` 命令\n  * `/etc/*-release` 文件\n  * `uname` 命令\n  * `/proc/version` 文件\n  * `dmesg` 命令\n  * YUM 或 DNF 命令\n  * RPM 命令\n  * APT-GET 命令\n\n### 方法 1： lsb_release 命令\n\nLSB（<ruby>Linux 标准库<rt>Linux Standard Base</rt></ruby>）能够打印发行版的具体信息，包括发行版名称、版本号、代号等。\n\n```\n# lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription: Ubuntu 16.04.3 LTS\nRelease: 16.04\nCodename: xenial\n```\n\n### 方法 2： /etc/*-release 文件\n\nrelease 文件通常被视为操作系统的标识。在 `/etc` 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。下面是一组在 Ubuntu/Debian 系统上显示出来的文件内容。\n\n```\n# cat /etc/issue\nUbuntu 16.04.3 LTS \\n \\l\n\n# cat /etc/issue.net\nUbuntu 16.04.3 LTS\n\n# cat /etc/lsb-release\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.3 LTS\"\n\n# cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"16.04.3 LTS (Xenial Xerus)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 16.04.3 LTS\"\nVERSION_ID=\"16.04\"\nHOME_URL=\"http://www.ubuntu.com/\"\nSUPPORT_URL=\"http://help.ubuntu.com/\"\nBUG_REPORT_URL=\"http://bugs.launchpad.net/ubuntu/\"\nVERSION_CODENAME=xenial\nUBUNTU_CODENAME=xenial\n\n# cat /etc/debian_version\n9.3\n```\n\n下面这一组是在 RHEL/CentOS/Fedora 系统上显示出来的文件内容。其中 `/etc/redhat-release` 和 `/etc/system-release` 文件是指向 `/etc/[发行版名称]-release` 文件的一个连接。\n\n```\n# cat /etc/centos-release\nCentOS release 6.9 (Final)\n\n# cat /etc/fedora-release\nFedora release 27 (Twenty Seven)\n\n# cat /etc/os-release\nNAME=Fedora\nVERSION=\"27 (Twenty Seven)\"\nID=fedora\nVERSION_ID=27\nPRETTY_NAME=\"Fedora 27 (Twenty Seven)\"\nANSI_COLOR=\"0;34\"\nCPE_NAME=\"cpe:/o:fedoraproject:fedora:27\"\nHOME_URL=\"https://fedoraproject.org/\"\nSUPPORT_URL=\"https://fedoraproject.org/wiki/Communicating_and_getting_help\"\nBUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\nREDHAT_BUGZILLA_PRODUCT=\"Fedora\"\nREDHAT_BUGZILLA_PRODUCT_VERSION=27\nREDHAT_SUPPORT_PRODUCT=\"Fedora\"\nREDHAT_SUPPORT_PRODUCT_VERSION=27\nPRIVACY_POLICY_URL=\"https://fedoraproject.org/wiki/Legal:PrivacyPolicy\"\n\n# cat /etc/redhat-release\nFedora release 27 (Twenty Seven)\n\n# cat /etc/system-release\nFedora release 27 (Twenty Seven)\n```\n\n### 方法 3： uname 命令\n\nuname（unix name 的意思） 是一个打印系统信息的工具，包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。\n\n- **建议阅读：** [6种查看系统 Linux 内核的方法][1]\n\n```\n# uname -a\nLinux localhost.localdomain 4.12.14-300.fc26.x86_64 #1 SMP Wed Sep 20 16:28:07 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n以上运行结果说明使用的操作系统版本是 Fedora 26。\n\n### 方法 4： /proc/version 文件\n\n这个文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。\n\n```\n# cat /proc/version\nLinux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017\n```\n\n### 方法 5： dmesg 命令\n\ndmesg（<ruby>展示信息<rt>display message</rt></ruby> 或<ruby>驱动程序信息<rt>driver message</rt></ruby>）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。\n\n```\n# dmesg | grep \"Linux\"\n[ 0.000000] Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017\n[ 0.001000] SELinux: Initializing.\n[ 0.001000] SELinux: Starting in permissive mode\n[ 0.470288] SELinux: Registering netfilter hooks\n[ 0.616351] Linux agpgart interface v0.103\n[ 0.630063] usb usb1: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ehci_hcd\n[ 0.688949] usb usb2: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ohci_hcd\n[ 2.564554] SELinux: Disabled at runtime.\n[ 2.564584] SELinux: Unregistering netfilter hooks\n```\n\n### 方法 6： Yum/Dnf 命令\n\nYum（<ruby>Yellowdog 更新器修改版<rt>Yellowdog Updater Modified</rt></ruby>）是 Linux 操作系统上的一个包管理工具，而 `yum` 命令被用于一些基于 RedHat 的 Linux 发行版上安装、更新、查找、删除软件包。\n\n- **建议阅读：** [在 RHEL/CentOS 系统上使用 yum 命令管理软件包][2]\n\n```\n# yum info nano\nLoaded plugins: fastestmirror, ovl\nLoading mirror speeds from cached hostfile\n * base: centos.zswap.net\n * extras: mirror2.evolution-host.com\n * updates: centos.zswap.net\nAvailable Packages\nName : nano\nArch : x86_64\nVersion : 2.3.1\nRelease : 10.el7\nSize : 440 k\nRepo : base/7/x86_64\nSummary : A small text editor\nURL : http://www.nano-editor.org\nLicense : GPLv3+\nDescription : GNU nano is a small and friendly text editor.\n```\n\n下面的 `yum repolist` 命令执行后显示了 yum 的基础源仓库、额外源仓库、更新源仓库都来自 CentOS 7 仓库。\n\n```\n# yum repolist\nLoaded plugins: fastestmirror, ovl\nLoading mirror speeds from cached hostfile\n * base: centos.zswap.net\n * extras: mirror2.evolution-host.com\n * updates: centos.zswap.net\nrepo id repo name status\nbase/7/x86_64 CentOS-7 - Base 9591\nextras/7/x86_64 CentOS-7 - Extras 388\nupdates/7/x86_64 CentOS-7 - Updates 1929\nrepolist: 11908\n```\n\n使用 `dnf` 命令也同样可以查看发行版名称和版本号。\n\n- **建议阅读：** [在 Fedora 系统上使用 DNF（YUM 的一个分支）命令管理软件包][3]\n\n```\n# dnf info nano\nLast metadata expiration check: 0:01:25 ago on Thu Feb 15 01:59:31 2018.\nInstalled Packages\nName : nano\nVersion : 2.8.7\nRelease : 1.fc27\nArch : x86_64\nSize : 2.1 M\nSource : nano-2.8.7-1.fc27.src.rpm\nRepo : @System\nFrom repo : fedora\nSummary : A small text editor\nURL : https://www.nano-editor.org\nLicense : GPLv3+\nDescription : GNU nano is a small and friendly text editor.\n```\n\n### 方法 7： RPM 命令\n\nRPM（<ruby>红帽包管理器<rt>RedHat Package Manager</rt></ruby>）是在 CentOS、Oracle Linux、Fedora 这些基于 RedHat 的操作系统上的一个强大的命令行包管理工具，同样也可以帮助我们查看系统的版本信息。\n\n- **建议阅读：** [在基于 RHEL 的系统上使用 RPM 命令管理软件包][4]\n\n```\n# rpm -q nano\nnano-2.8.7-1.fc27.x86_64\n```\n\n### 方法 8： APT-GET 命令\n\nApt-Get（<ruby>高级打包工具<rt>Advanced Packaging Tool</rt></ruby>）是一个强大的命令行工具，可以自动下载安装新软件包、更新已有的软件包、更新软件包列表索引，甚至更新整个 Debian 系统。\n\n- **建议阅读：** [在基于 Debian 的系统上使用 Apt-Get 和 Apt-Cache 命令管理软件包][5]\n\n```\n# apt-cache policy nano\nnano:\n Installed: 2.5.3-2ubuntu2\n Candidate: 2.5.3-2ubuntu2\n Version table:\n * 2.5.3-2ubuntu2 500\n 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages\n 100 /var/lib/dpkg/status\n 2.5.3-2 500\n 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial/main amd64 Packages\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/check-find-linux-distribution-name-and-version/\n\n[a]:https://www.2daygeek.com/author/magesh/\n[1]:https://www.2daygeek.com/check-find-determine-running-installed-linux-kernel-version/\n[2]:https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\n[3]:https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\n[4]:https://www.2daygeek.com/rpm-command-examples/\n[5]:https://www.2daygeek.com/apt-get-apt-cache-command-examples-manage-packages-debian-ubuntu-systems/\n","slug":"Check-Linux-Distribution-Name-and-Version","published":1,"updated":"2019-03-28T05:43:34.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cg000qlixu68zynbjl","content":"<p>如果你加入了一家新公司，要为开发团队安装所需的软件并重启服务，这个时候首先要弄清楚它们运行在什么发行版以及哪个版本的系统上，你才能正确完成后续的工作。作为系统管理员，充分了解系统信息是首要的任务。</p>\n<p>查看 Linux 发行版名称和版本号有很多种方法。你可能会问，为什么要去了解这些基本信息呢？</p>\n<p>因为对于诸如 RHEL、Debian、openSUSE、Arch Linux 这几种主流发行版来说，它们各自拥有不同的包管理器来管理系统上的软件包，如果不知道所使用的是哪一个发行版的系统，在软件包安装的时候就会无从下手，而且由于大多数发行版都是用 systemd 命令而不是 SysVinit 脚本，在重启服务的时候也难以执行正确的命令。</p>\n<p>下面来看看可以使用那些基本命令来查看 Linux 发行版名称和版本号。</p>\n<h3 id=\"方法总览\"><a href=\"#方法总览\" class=\"headerlink\" title=\"方法总览\"></a>方法总览</h3><ul>\n<li><code>lsb_release</code> 命令</li>\n<li><code>/etc/*-release</code> 文件</li>\n<li><code>uname</code> 命令</li>\n<li><code>/proc/version</code> 文件</li>\n<li><code>dmesg</code> 命令</li>\n<li>YUM 或 DNF 命令</li>\n<li>RPM 命令</li>\n<li>APT-GET 命令</li>\n</ul>\n<h3 id=\"方法-1：-lsb-release-命令\"><a href=\"#方法-1：-lsb-release-命令\" class=\"headerlink\" title=\"方法 1： lsb_release 命令\"></a>方法 1： lsb_release 命令</h3><p>LSB（<ruby>Linux 标准库<rt>Linux Standard Base</rt></ruby>）能够打印发行版的具体信息，包括发行版名称、版本号、代号等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsb_release -a</span><br><span class=\"line\">No LSB modules are available.</span><br><span class=\"line\">Distributor ID: Ubuntu</span><br><span class=\"line\">Description: Ubuntu 16.04.3 LTS</span><br><span class=\"line\">Release: 16.04</span><br><span class=\"line\">Codename: xenial</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-2：-etc-release-文件\"><a href=\"#方法-2：-etc-release-文件\" class=\"headerlink\" title=\"方法 2： /etc/*-release 文件\"></a>方法 2： /etc/*-release 文件</h3><p>release 文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。下面是一组在 Ubuntu/Debian 系统上显示出来的文件内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /etc/issue</span><br><span class=\"line\">Ubuntu 16.04.3 LTS \\n \\l</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/issue.net</span><br><span class=\"line\">Ubuntu 16.04.3 LTS</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/lsb-release</span><br><span class=\"line\">DISTRIB_ID=Ubuntu</span><br><span class=\"line\">DISTRIB_RELEASE=16.04</span><br><span class=\"line\">DISTRIB_CODENAME=xenial</span><br><span class=\"line\">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.3 LTS&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/os-release</span><br><span class=\"line\">NAME=&quot;Ubuntu&quot;</span><br><span class=\"line\">VERSION=&quot;16.04.3 LTS (Xenial Xerus)&quot;</span><br><span class=\"line\">ID=ubuntu</span><br><span class=\"line\">ID_LIKE=debian</span><br><span class=\"line\">PRETTY_NAME=&quot;Ubuntu 16.04.3 LTS&quot;</span><br><span class=\"line\">VERSION_ID=&quot;16.04&quot;</span><br><span class=\"line\">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class=\"line\">VERSION_CODENAME=xenial</span><br><span class=\"line\">UBUNTU_CODENAME=xenial</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/debian_version</span><br><span class=\"line\">9.3</span><br></pre></td></tr></table></figure>\n<p>下面这一组是在 RHEL/CentOS/Fedora 系统上显示出来的文件内容。其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /etc/centos-release</span><br><span class=\"line\">CentOS release 6.9 (Final)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/fedora-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/os-release</span><br><span class=\"line\">NAME=Fedora</span><br><span class=\"line\">VERSION=&quot;27 (Twenty Seven)&quot;</span><br><span class=\"line\">ID=fedora</span><br><span class=\"line\">VERSION_ID=27</span><br><span class=\"line\">PRETTY_NAME=&quot;Fedora 27 (Twenty Seven)&quot;</span><br><span class=\"line\">ANSI_COLOR=&quot;0;34&quot;</span><br><span class=\"line\">CPE_NAME=&quot;cpe:/o:fedoraproject:fedora:27&quot;</span><br><span class=\"line\">HOME_URL=&quot;https://fedoraproject.org/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;https://fedoraproject.org/wiki/Communicating_and_getting_help&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;https://bugzilla.redhat.com/&quot;</span><br><span class=\"line\">REDHAT_BUGZILLA_PRODUCT=&quot;Fedora&quot;</span><br><span class=\"line\">REDHAT_BUGZILLA_PRODUCT_VERSION=27</span><br><span class=\"line\">REDHAT_SUPPORT_PRODUCT=&quot;Fedora&quot;</span><br><span class=\"line\">REDHAT_SUPPORT_PRODUCT_VERSION=27</span><br><span class=\"line\">PRIVACY_POLICY_URL=&quot;https://fedoraproject.org/wiki/Legal:PrivacyPolicy&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/redhat-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/system-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-3：-uname-命令\"><a href=\"#方法-3：-uname-命令\" class=\"headerlink\" title=\"方法 3： uname 命令\"></a>方法 3： uname 命令</h3><p>uname（unix name 的意思） 是一个打印系统信息的工具，包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/check-find-determine-running-installed-linux-kernel-version/\" target=\"_blank\" rel=\"noopener\">6种查看系统 Linux 内核的方法</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># uname -a</span><br><span class=\"line\">Linux localhost.localdomain 4.12.14-300.fc26.x86_64 #1 SMP Wed Sep 20 16:28:07 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>\n<p>以上运行结果说明使用的操作系统版本是 Fedora 26。</p>\n<h3 id=\"方法-4：-proc-version-文件\"><a href=\"#方法-4：-proc-version-文件\" class=\"headerlink\" title=\"方法 4： /proc/version 文件\"></a>方法 4： /proc/version 文件</h3><p>这个文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /proc/version</span><br><span class=\"line\">Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-5：-dmesg-命令\"><a href=\"#方法-5：-dmesg-命令\" class=\"headerlink\" title=\"方法 5： dmesg 命令\"></a>方法 5： dmesg 命令</h3><p>dmesg（<ruby>展示信息<rt>display message</rt></ruby> 或<ruby>驱动程序信息<rt>driver message</rt></ruby>）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dmesg | grep &quot;Linux&quot;</span><br><span class=\"line\">[ 0.000000] Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017</span><br><span class=\"line\">[ 0.001000] SELinux: Initializing.</span><br><span class=\"line\">[ 0.001000] SELinux: Starting in permissive mode</span><br><span class=\"line\">[ 0.470288] SELinux: Registering netfilter hooks</span><br><span class=\"line\">[ 0.616351] Linux agpgart interface v0.103</span><br><span class=\"line\">[ 0.630063] usb usb1: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ehci_hcd</span><br><span class=\"line\">[ 0.688949] usb usb2: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ohci_hcd</span><br><span class=\"line\">[ 2.564554] SELinux: Disabled at runtime.</span><br><span class=\"line\">[ 2.564584] SELinux: Unregistering netfilter hooks</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-6：-Yum-Dnf-命令\"><a href=\"#方法-6：-Yum-Dnf-命令\" class=\"headerlink\" title=\"方法 6： Yum/Dnf 命令\"></a>方法 6： Yum/Dnf 命令</h3><p>Yum（<ruby>Yellowdog 更新器修改版<rt>Yellowdog Updater Modified</rt></ruby>）是 Linux 操作系统上的一个包管理工具，而 <code>yum</code> 命令被用于一些基于 RedHat 的 Linux 发行版上安装、更新、查找、删除软件包。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\" target=\"_blank\" rel=\"noopener\">在 RHEL/CentOS 系统上使用 yum 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum info nano</span><br><span class=\"line\">Loaded plugins: fastestmirror, ovl</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: centos.zswap.net</span><br><span class=\"line\"> * extras: mirror2.evolution-host.com</span><br><span class=\"line\"> * updates: centos.zswap.net</span><br><span class=\"line\">Available Packages</span><br><span class=\"line\">Name : nano</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Version : 2.3.1</span><br><span class=\"line\">Release : 10.el7</span><br><span class=\"line\">Size : 440 k</span><br><span class=\"line\">Repo : base/7/x86_64</span><br><span class=\"line\">Summary : A small text editor</span><br><span class=\"line\">URL : http://www.nano-editor.org</span><br><span class=\"line\">License : GPLv3+</span><br><span class=\"line\">Description : GNU nano is a small and friendly text editor.</span><br></pre></td></tr></table></figure>\n<p>下面的 <code>yum repolist</code> 命令执行后显示了 yum 的基础源仓库、额外源仓库、更新源仓库都来自 CentOS 7 仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum repolist</span><br><span class=\"line\">Loaded plugins: fastestmirror, ovl</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: centos.zswap.net</span><br><span class=\"line\"> * extras: mirror2.evolution-host.com</span><br><span class=\"line\"> * updates: centos.zswap.net</span><br><span class=\"line\">repo id repo name status</span><br><span class=\"line\">base/7/x86_64 CentOS-7 - Base 9591</span><br><span class=\"line\">extras/7/x86_64 CentOS-7 - Extras 388</span><br><span class=\"line\">updates/7/x86_64 CentOS-7 - Updates 1929</span><br><span class=\"line\">repolist: 11908</span><br></pre></td></tr></table></figure>\n<p>使用 <code>dnf</code> 命令也同样可以查看发行版名称和版本号。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\" target=\"_blank\" rel=\"noopener\">在 Fedora 系统上使用 DNF（YUM 的一个分支）命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf info nano</span><br><span class=\"line\">Last metadata expiration check: 0:01:25 ago on Thu Feb 15 01:59:31 2018.</span><br><span class=\"line\">Installed Packages</span><br><span class=\"line\">Name : nano</span><br><span class=\"line\">Version : 2.8.7</span><br><span class=\"line\">Release : 1.fc27</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Size : 2.1 M</span><br><span class=\"line\">Source : nano-2.8.7-1.fc27.src.rpm</span><br><span class=\"line\">Repo : @System</span><br><span class=\"line\">From repo : fedora</span><br><span class=\"line\">Summary : A small text editor</span><br><span class=\"line\">URL : https://www.nano-editor.org</span><br><span class=\"line\">License : GPLv3+</span><br><span class=\"line\">Description : GNU nano is a small and friendly text editor.</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-7：-RPM-命令\"><a href=\"#方法-7：-RPM-命令\" class=\"headerlink\" title=\"方法 7： RPM 命令\"></a>方法 7： RPM 命令</h3><p>RPM（<ruby>红帽包管理器<rt>RedHat Package Manager</rt></ruby>）是在 CentOS、Oracle Linux、Fedora 这些基于 RedHat 的操作系统上的一个强大的命令行包管理工具，同样也可以帮助我们查看系统的版本信息。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/rpm-command-examples/\" target=\"_blank\" rel=\"noopener\">在基于 RHEL 的系统上使用 RPM 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># rpm -q nano</span><br><span class=\"line\">nano-2.8.7-1.fc27.x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-8：-APT-GET-命令\"><a href=\"#方法-8：-APT-GET-命令\" class=\"headerlink\" title=\"方法 8： APT-GET 命令\"></a>方法 8： APT-GET 命令</h3><p>Apt-Get（<ruby>高级打包工具<rt>Advanced Packaging Tool</rt></ruby>）是一个强大的命令行工具，可以自动下载安装新软件包、更新已有的软件包、更新软件包列表索引，甚至更新整个 Debian 系统。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/apt-get-apt-cache-command-examples-manage-packages-debian-ubuntu-systems/\" target=\"_blank\" rel=\"noopener\">在基于 Debian 的系统上使用 Apt-Get 和 Apt-Cache 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># apt-cache policy nano</span><br><span class=\"line\">nano:</span><br><span class=\"line\"> Installed: 2.5.3-2ubuntu2</span><br><span class=\"line\"> Candidate: 2.5.3-2ubuntu2</span><br><span class=\"line\"> Version table:</span><br><span class=\"line\"> * 2.5.3-2ubuntu2 500</span><br><span class=\"line\"> 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages</span><br><span class=\"line\"> 100 /var/lib/dpkg/status</span><br><span class=\"line\"> 2.5.3-2 500</span><br><span class=\"line\"> 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial/main amd64 Packages</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/check-find-linux-distribution-name-and-version/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/check-find-linux-distribution-name-and-version/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你加入了一家新公司，要为开发团队安装所需的软件并重启服务，这个时候首先要弄清楚它们运行在什么发行版以及哪个版本的系统上，你才能正确完成后续的工作。作为系统管理员，充分了解系统信息是首要的任务。</p>\n<p>查看 Linux 发行版名称和版本号有很多种方法。你可能会问，为什么要去了解这些基本信息呢？</p>\n<p>因为对于诸如 RHEL、Debian、openSUSE、Arch Linux 这几种主流发行版来说，它们各自拥有不同的包管理器来管理系统上的软件包，如果不知道所使用的是哪一个发行版的系统，在软件包安装的时候就会无从下手，而且由于大多数发行版都是用 systemd 命令而不是 SysVinit 脚本，在重启服务的时候也难以执行正确的命令。</p>\n<p>下面来看看可以使用那些基本命令来查看 Linux 发行版名称和版本号。</p>\n<h3 id=\"方法总览\"><a href=\"#方法总览\" class=\"headerlink\" title=\"方法总览\"></a>方法总览</h3><ul>\n<li><code>lsb_release</code> 命令</li>\n<li><code>/etc/*-release</code> 文件</li>\n<li><code>uname</code> 命令</li>\n<li><code>/proc/version</code> 文件</li>\n<li><code>dmesg</code> 命令</li>\n<li>YUM 或 DNF 命令</li>\n<li>RPM 命令</li>\n<li>APT-GET 命令</li>\n</ul>\n<h3 id=\"方法-1：-lsb-release-命令\"><a href=\"#方法-1：-lsb-release-命令\" class=\"headerlink\" title=\"方法 1： lsb_release 命令\"></a>方法 1： lsb_release 命令</h3><p>LSB（<ruby>Linux 标准库<rt>Linux Standard Base</rt></ruby>）能够打印发行版的具体信息，包括发行版名称、版本号、代号等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsb_release -a</span><br><span class=\"line\">No LSB modules are available.</span><br><span class=\"line\">Distributor ID: Ubuntu</span><br><span class=\"line\">Description: Ubuntu 16.04.3 LTS</span><br><span class=\"line\">Release: 16.04</span><br><span class=\"line\">Codename: xenial</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-2：-etc-release-文件\"><a href=\"#方法-2：-etc-release-文件\" class=\"headerlink\" title=\"方法 2： /etc/*-release 文件\"></a>方法 2： /etc/*-release 文件</h3><p>release 文件通常被视为操作系统的标识。在 <code>/etc</code> 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。下面是一组在 Ubuntu/Debian 系统上显示出来的文件内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /etc/issue</span><br><span class=\"line\">Ubuntu 16.04.3 LTS \\n \\l</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/issue.net</span><br><span class=\"line\">Ubuntu 16.04.3 LTS</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/lsb-release</span><br><span class=\"line\">DISTRIB_ID=Ubuntu</span><br><span class=\"line\">DISTRIB_RELEASE=16.04</span><br><span class=\"line\">DISTRIB_CODENAME=xenial</span><br><span class=\"line\">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.3 LTS&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/os-release</span><br><span class=\"line\">NAME=&quot;Ubuntu&quot;</span><br><span class=\"line\">VERSION=&quot;16.04.3 LTS (Xenial Xerus)&quot;</span><br><span class=\"line\">ID=ubuntu</span><br><span class=\"line\">ID_LIKE=debian</span><br><span class=\"line\">PRETTY_NAME=&quot;Ubuntu 16.04.3 LTS&quot;</span><br><span class=\"line\">VERSION_ID=&quot;16.04&quot;</span><br><span class=\"line\">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class=\"line\">VERSION_CODENAME=xenial</span><br><span class=\"line\">UBUNTU_CODENAME=xenial</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/debian_version</span><br><span class=\"line\">9.3</span><br></pre></td></tr></table></figure>\n<p>下面这一组是在 RHEL/CentOS/Fedora 系统上显示出来的文件内容。其中 <code>/etc/redhat-release</code> 和 <code>/etc/system-release</code> 文件是指向 <code>/etc/[发行版名称]-release</code> 文件的一个连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /etc/centos-release</span><br><span class=\"line\">CentOS release 6.9 (Final)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/fedora-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/os-release</span><br><span class=\"line\">NAME=Fedora</span><br><span class=\"line\">VERSION=&quot;27 (Twenty Seven)&quot;</span><br><span class=\"line\">ID=fedora</span><br><span class=\"line\">VERSION_ID=27</span><br><span class=\"line\">PRETTY_NAME=&quot;Fedora 27 (Twenty Seven)&quot;</span><br><span class=\"line\">ANSI_COLOR=&quot;0;34&quot;</span><br><span class=\"line\">CPE_NAME=&quot;cpe:/o:fedoraproject:fedora:27&quot;</span><br><span class=\"line\">HOME_URL=&quot;https://fedoraproject.org/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;https://fedoraproject.org/wiki/Communicating_and_getting_help&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;https://bugzilla.redhat.com/&quot;</span><br><span class=\"line\">REDHAT_BUGZILLA_PRODUCT=&quot;Fedora&quot;</span><br><span class=\"line\">REDHAT_BUGZILLA_PRODUCT_VERSION=27</span><br><span class=\"line\">REDHAT_SUPPORT_PRODUCT=&quot;Fedora&quot;</span><br><span class=\"line\">REDHAT_SUPPORT_PRODUCT_VERSION=27</span><br><span class=\"line\">PRIVACY_POLICY_URL=&quot;https://fedoraproject.org/wiki/Legal:PrivacyPolicy&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/redhat-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br><span class=\"line\"></span><br><span class=\"line\"># cat /etc/system-release</span><br><span class=\"line\">Fedora release 27 (Twenty Seven)</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-3：-uname-命令\"><a href=\"#方法-3：-uname-命令\" class=\"headerlink\" title=\"方法 3： uname 命令\"></a>方法 3： uname 命令</h3><p>uname（unix name 的意思） 是一个打印系统信息的工具，包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/check-find-determine-running-installed-linux-kernel-version/\" target=\"_blank\" rel=\"noopener\">6种查看系统 Linux 内核的方法</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># uname -a</span><br><span class=\"line\">Linux localhost.localdomain 4.12.14-300.fc26.x86_64 #1 SMP Wed Sep 20 16:28:07 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>\n<p>以上运行结果说明使用的操作系统版本是 Fedora 26。</p>\n<h3 id=\"方法-4：-proc-version-文件\"><a href=\"#方法-4：-proc-version-文件\" class=\"headerlink\" title=\"方法 4： /proc/version 文件\"></a>方法 4： /proc/version 文件</h3><p>这个文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cat /proc/version</span><br><span class=\"line\">Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-5：-dmesg-命令\"><a href=\"#方法-5：-dmesg-命令\" class=\"headerlink\" title=\"方法 5： dmesg 命令\"></a>方法 5： dmesg 命令</h3><p>dmesg（<ruby>展示信息<rt>display message</rt></ruby> 或<ruby>驱动程序信息<rt>driver message</rt></ruby>）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dmesg | grep &quot;Linux&quot;</span><br><span class=\"line\">[ 0.000000] Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017</span><br><span class=\"line\">[ 0.001000] SELinux: Initializing.</span><br><span class=\"line\">[ 0.001000] SELinux: Starting in permissive mode</span><br><span class=\"line\">[ 0.470288] SELinux: Registering netfilter hooks</span><br><span class=\"line\">[ 0.616351] Linux agpgart interface v0.103</span><br><span class=\"line\">[ 0.630063] usb usb1: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ehci_hcd</span><br><span class=\"line\">[ 0.688949] usb usb2: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ohci_hcd</span><br><span class=\"line\">[ 2.564554] SELinux: Disabled at runtime.</span><br><span class=\"line\">[ 2.564584] SELinux: Unregistering netfilter hooks</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-6：-Yum-Dnf-命令\"><a href=\"#方法-6：-Yum-Dnf-命令\" class=\"headerlink\" title=\"方法 6： Yum/Dnf 命令\"></a>方法 6： Yum/Dnf 命令</h3><p>Yum（<ruby>Yellowdog 更新器修改版<rt>Yellowdog Updater Modified</rt></ruby>）是 Linux 操作系统上的一个包管理工具，而 <code>yum</code> 命令被用于一些基于 RedHat 的 Linux 发行版上安装、更新、查找、删除软件包。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\" target=\"_blank\" rel=\"noopener\">在 RHEL/CentOS 系统上使用 yum 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum info nano</span><br><span class=\"line\">Loaded plugins: fastestmirror, ovl</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: centos.zswap.net</span><br><span class=\"line\"> * extras: mirror2.evolution-host.com</span><br><span class=\"line\"> * updates: centos.zswap.net</span><br><span class=\"line\">Available Packages</span><br><span class=\"line\">Name : nano</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Version : 2.3.1</span><br><span class=\"line\">Release : 10.el7</span><br><span class=\"line\">Size : 440 k</span><br><span class=\"line\">Repo : base/7/x86_64</span><br><span class=\"line\">Summary : A small text editor</span><br><span class=\"line\">URL : http://www.nano-editor.org</span><br><span class=\"line\">License : GPLv3+</span><br><span class=\"line\">Description : GNU nano is a small and friendly text editor.</span><br></pre></td></tr></table></figure>\n<p>下面的 <code>yum repolist</code> 命令执行后显示了 yum 的基础源仓库、额外源仓库、更新源仓库都来自 CentOS 7 仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum repolist</span><br><span class=\"line\">Loaded plugins: fastestmirror, ovl</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: centos.zswap.net</span><br><span class=\"line\"> * extras: mirror2.evolution-host.com</span><br><span class=\"line\"> * updates: centos.zswap.net</span><br><span class=\"line\">repo id repo name status</span><br><span class=\"line\">base/7/x86_64 CentOS-7 - Base 9591</span><br><span class=\"line\">extras/7/x86_64 CentOS-7 - Extras 388</span><br><span class=\"line\">updates/7/x86_64 CentOS-7 - Updates 1929</span><br><span class=\"line\">repolist: 11908</span><br></pre></td></tr></table></figure>\n<p>使用 <code>dnf</code> 命令也同样可以查看发行版名称和版本号。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\" target=\"_blank\" rel=\"noopener\">在 Fedora 系统上使用 DNF（YUM 的一个分支）命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf info nano</span><br><span class=\"line\">Last metadata expiration check: 0:01:25 ago on Thu Feb 15 01:59:31 2018.</span><br><span class=\"line\">Installed Packages</span><br><span class=\"line\">Name : nano</span><br><span class=\"line\">Version : 2.8.7</span><br><span class=\"line\">Release : 1.fc27</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Size : 2.1 M</span><br><span class=\"line\">Source : nano-2.8.7-1.fc27.src.rpm</span><br><span class=\"line\">Repo : @System</span><br><span class=\"line\">From repo : fedora</span><br><span class=\"line\">Summary : A small text editor</span><br><span class=\"line\">URL : https://www.nano-editor.org</span><br><span class=\"line\">License : GPLv3+</span><br><span class=\"line\">Description : GNU nano is a small and friendly text editor.</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-7：-RPM-命令\"><a href=\"#方法-7：-RPM-命令\" class=\"headerlink\" title=\"方法 7： RPM 命令\"></a>方法 7： RPM 命令</h3><p>RPM（<ruby>红帽包管理器<rt>RedHat Package Manager</rt></ruby>）是在 CentOS、Oracle Linux、Fedora 这些基于 RedHat 的操作系统上的一个强大的命令行包管理工具，同样也可以帮助我们查看系统的版本信息。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/rpm-command-examples/\" target=\"_blank\" rel=\"noopener\">在基于 RHEL 的系统上使用 RPM 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># rpm -q nano</span><br><span class=\"line\">nano-2.8.7-1.fc27.x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-8：-APT-GET-命令\"><a href=\"#方法-8：-APT-GET-命令\" class=\"headerlink\" title=\"方法 8： APT-GET 命令\"></a>方法 8： APT-GET 命令</h3><p>Apt-Get（<ruby>高级打包工具<rt>Advanced Packaging Tool</rt></ruby>）是一个强大的命令行工具，可以自动下载安装新软件包、更新已有的软件包、更新软件包列表索引，甚至更新整个 Debian 系统。</p>\n<ul>\n<li><strong>建议阅读：</strong> <a href=\"https://www.2daygeek.com/apt-get-apt-cache-command-examples-manage-packages-debian-ubuntu-systems/\" target=\"_blank\" rel=\"noopener\">在基于 Debian 的系统上使用 Apt-Get 和 Apt-Cache 命令管理软件包</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># apt-cache policy nano</span><br><span class=\"line\">nano:</span><br><span class=\"line\"> Installed: 2.5.3-2ubuntu2</span><br><span class=\"line\"> Candidate: 2.5.3-2ubuntu2</span><br><span class=\"line\"> Version table:</span><br><span class=\"line\"> * 2.5.3-2ubuntu2 500</span><br><span class=\"line\"> 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages</span><br><span class=\"line\"> 100 /var/lib/dpkg/status</span><br><span class=\"line\"> 2.5.3-2 500</span><br><span class=\"line\"> 500 http://nova.clouds.archive.ubuntu.com/ubuntu xenial/main amd64 Packages</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/check-find-linux-distribution-name-and-version/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/check-find-linux-distribution-name-and-version/</a></p>\n"},{"title":"gitbase：用 SQL 查询 Git 仓库","date":"2018-11-19T05:14:16.000Z","_content":"\n> gitbase 是一个使用 go 开发的的开源项目，它实现了在 Git 仓库上执行 SQL 查询。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bus_cloud_database.png?itok=lhhU42fg)\n\nGit 已经成为了代码版本控制的事实标准，但尽管 Git 相当普及，对代码仓库的深入分析的工作难度却没有因此而下降；而 SQL 在大型代码库的查询方面则已经是一种久经考验的语言，因此诸如 Spark 和 BigQuery 这样的项目都采用了它。\n\n所以，source{d} 很顺理成章地将这两种技术结合起来，就产生了 gitbase（LCTT 译注：source{d} 是一家开源公司，本文作者是该公司开发者关系副总裁）。gitbase 是一个<ruby>代码即数据<rt>code-as-data</rt></ruby>的解决方案，可以使用 SQL 对 git 仓库进行大规模分析。 \n\n[gitbase][1] 是一个完全开源的项目。它站在了很多巨人的肩上，因此得到了足够的发展竞争力。下面就来介绍一下其中的一些“巨人”。\n\n![](https://opensource.com/sites/default/files/uploads/gitbase.png)\n\n*[gitbase playground][2] 为 gitbase 提供了一个可视化的操作环境。*\n\n### 用 Vitess 解析 SQL\n\ngitbase 通过 SQL 与用户进行交互，因此需要能够遵循 MySQL 协议来对通过网络传入的 SQL 请求作出解析和理解，万幸由 YouTube 建立的 [Vitess][3] 项目已经在这一方面给出了解决方案。Vitess 是一个横向扩展的 MySQL 数据库集群系统。 \n\n我们只是使用了这个项目中的部分重要代码，并将其转化为一个可以让任何人在数分钟以内编写出一个 MySQL 服务器的[开源程序][4]，就像我在 [justforfunc][5] 视频系列中展示的 [CSVQL][6] 一样，它可以使用 SQL 操作 CSV 文件。\n\n### 用 go-git 读取 git 仓库\n\n在成功解析 SQL 请求之后，还需要对数据集中的 git 仓库进行查询才能返回结果。因此，我们还结合使用了 source{d} 最成功的 [go-git][7] 仓库。go-git 是使用纯 go 语言编写的具有高度可扩展性的 git 实现。\n\n借此我们就可以很方便地将存储在磁盘上的代码仓库保存为 [siva][8] 文件格式（这同样是 source{d} 的一个开源项目），也可以通过 `git clone` 来对代码仓库进行复制。\n\n### 使用 enry 检测语言、使用 babelfish 解析文件\n\ngitbase 集成了我们开源的语言检测项目 [enry][9] 以及代码解析项目 [babelfish][10]，因此在分析 git 仓库历史代码的能力也相当强大。babelfish 是一个自托管服务，普适于各种源代码解析，并将代码文件转换为<ruby>通用抽象语法树<rt>Universal Abstract Syntax Tree</rt></ruby>（UAST）。\n\n这两个功能在 gitbase 中可以被用户以函数 `LANGUAGE` 和 `UAST` 调用，诸如“查找上个月最常被修改的函数的名称”这样的请求就需要通过这两个功能实现。\n\n### 提高性能\n\ngitbase 可以对非常大的数据集进行分析，例如来自 GitHub 高达 3 TB 源代码的 Public Git Archive（[公告][11]）。面临的工作量如此巨大，因此每一点性能都必须运用到极致。于是，我们也使用到了 Rubex 和 Pilosa 这两个项目。\n\n#### 使用 Rubex 和 Oniguruma 优化正则表达式速度\n\n[Rubex][12] 是 go 的正则表达式标准库包的一个准替代品。之所以说它是准替代品，是因为它没有在 `regexp.Regexp` 类中实现 `LiteralPrefix` 方法，直到现在都还没有。\n\nRubex 的高性能是由于使用 [cgo][14] 调用了 [Oniguruma][13]，它是一个高度优化的 C 代码库。\n\n#### 使用 Pilosa 索引优化查询速度\n\n索引几乎是每个关系型数据库都拥有的特性，但 Vitess 由于不需要用到索引，因此并没有进行实现。\n\n于是我们引入了 [Pilosa][15] 这个开源项目。Pilosa 是一个使用 go 实现的分布式位图索引，可以显著提升跨多个大型数据集的查询的速度。通过 Pilosa，gitbase 才得以在巨大的数据集中进行查询。\n\n### 总结\n\n我想用这一篇文章来对开源社区表达我衷心的感谢，让我们能够不负众望的在短时间内完成 gitbase 的开发。我们 source{d} 的每一位成员都是开源的拥护者，github.com/src-d 下的每一行代码都是见证。\n\n你想使用 gitbase 吗？最简单快捷的方式是从 sourced.tech/engine 下载 source{d} 引擎，就可以通过单个命令运行 gitbase 了。\n\n想要了解更多，可以听听我在 [Go SF 大会][16]上的演讲录音。\n\n本文在 [Medium][17] 首发，并经许可在此发布。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/gitbase\n\n[a]: https://opensource.com/users/francesc\n[b]: https://github.com/lujun9972\n[1]: https://github.com/src-d/gitbase\n[2]: https://github.com/src-d/gitbase-web\n[3]: https://github.com/vitessio/vitess\n[4]: https://github.com/src-d/go-mysql-server\n[5]: http://justforfunc.com/\n[6]: https://youtu.be/bcRDXAraprk\n[7]: https://github.com/src-d/go-git\n[8]: https://github.com/src-d/siva\n[9]: https://github.com/src-d/enry\n[10]: https://github.com/bblfsh/bblfshd\n[11]: https://blog.sourced.tech/post/announcing-pga/\n[12]: https://github.com/moovweb/rubex\n[13]: https://github.com/kkos/oniguruma\n[14]: https://golang.org/cmd/cgo/\n[15]: https://github.com/pilosa/pilosa\n[16]: https://www.meetup.com/golangsf/events/251690574/\n[17]: https://medium.com/sourcedtech/gitbase-exploring-git-repos-with-sql-95ec0986386c\n\n","source":"_posts/Gitbase-Exploring-git-repos-with-SQL.md","raw":"---\ntitle: gitbase：用 SQL 查询 Git 仓库 \ndate: 2018-11-19 13:14:16\ntags:\n  - git\n  - SQL\n  - LCTT 翻译\n---\n\n> gitbase 是一个使用 go 开发的的开源项目，它实现了在 Git 仓库上执行 SQL 查询。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bus_cloud_database.png?itok=lhhU42fg)\n\nGit 已经成为了代码版本控制的事实标准，但尽管 Git 相当普及，对代码仓库的深入分析的工作难度却没有因此而下降；而 SQL 在大型代码库的查询方面则已经是一种久经考验的语言，因此诸如 Spark 和 BigQuery 这样的项目都采用了它。\n\n所以，source{d} 很顺理成章地将这两种技术结合起来，就产生了 gitbase（LCTT 译注：source{d} 是一家开源公司，本文作者是该公司开发者关系副总裁）。gitbase 是一个<ruby>代码即数据<rt>code-as-data</rt></ruby>的解决方案，可以使用 SQL 对 git 仓库进行大规模分析。 \n\n[gitbase][1] 是一个完全开源的项目。它站在了很多巨人的肩上，因此得到了足够的发展竞争力。下面就来介绍一下其中的一些“巨人”。\n\n![](https://opensource.com/sites/default/files/uploads/gitbase.png)\n\n*[gitbase playground][2] 为 gitbase 提供了一个可视化的操作环境。*\n\n### 用 Vitess 解析 SQL\n\ngitbase 通过 SQL 与用户进行交互，因此需要能够遵循 MySQL 协议来对通过网络传入的 SQL 请求作出解析和理解，万幸由 YouTube 建立的 [Vitess][3] 项目已经在这一方面给出了解决方案。Vitess 是一个横向扩展的 MySQL 数据库集群系统。 \n\n我们只是使用了这个项目中的部分重要代码，并将其转化为一个可以让任何人在数分钟以内编写出一个 MySQL 服务器的[开源程序][4]，就像我在 [justforfunc][5] 视频系列中展示的 [CSVQL][6] 一样，它可以使用 SQL 操作 CSV 文件。\n\n### 用 go-git 读取 git 仓库\n\n在成功解析 SQL 请求之后，还需要对数据集中的 git 仓库进行查询才能返回结果。因此，我们还结合使用了 source{d} 最成功的 [go-git][7] 仓库。go-git 是使用纯 go 语言编写的具有高度可扩展性的 git 实现。\n\n借此我们就可以很方便地将存储在磁盘上的代码仓库保存为 [siva][8] 文件格式（这同样是 source{d} 的一个开源项目），也可以通过 `git clone` 来对代码仓库进行复制。\n\n### 使用 enry 检测语言、使用 babelfish 解析文件\n\ngitbase 集成了我们开源的语言检测项目 [enry][9] 以及代码解析项目 [babelfish][10]，因此在分析 git 仓库历史代码的能力也相当强大。babelfish 是一个自托管服务，普适于各种源代码解析，并将代码文件转换为<ruby>通用抽象语法树<rt>Universal Abstract Syntax Tree</rt></ruby>（UAST）。\n\n这两个功能在 gitbase 中可以被用户以函数 `LANGUAGE` 和 `UAST` 调用，诸如“查找上个月最常被修改的函数的名称”这样的请求就需要通过这两个功能实现。\n\n### 提高性能\n\ngitbase 可以对非常大的数据集进行分析，例如来自 GitHub 高达 3 TB 源代码的 Public Git Archive（[公告][11]）。面临的工作量如此巨大，因此每一点性能都必须运用到极致。于是，我们也使用到了 Rubex 和 Pilosa 这两个项目。\n\n#### 使用 Rubex 和 Oniguruma 优化正则表达式速度\n\n[Rubex][12] 是 go 的正则表达式标准库包的一个准替代品。之所以说它是准替代品，是因为它没有在 `regexp.Regexp` 类中实现 `LiteralPrefix` 方法，直到现在都还没有。\n\nRubex 的高性能是由于使用 [cgo][14] 调用了 [Oniguruma][13]，它是一个高度优化的 C 代码库。\n\n#### 使用 Pilosa 索引优化查询速度\n\n索引几乎是每个关系型数据库都拥有的特性，但 Vitess 由于不需要用到索引，因此并没有进行实现。\n\n于是我们引入了 [Pilosa][15] 这个开源项目。Pilosa 是一个使用 go 实现的分布式位图索引，可以显著提升跨多个大型数据集的查询的速度。通过 Pilosa，gitbase 才得以在巨大的数据集中进行查询。\n\n### 总结\n\n我想用这一篇文章来对开源社区表达我衷心的感谢，让我们能够不负众望的在短时间内完成 gitbase 的开发。我们 source{d} 的每一位成员都是开源的拥护者，github.com/src-d 下的每一行代码都是见证。\n\n你想使用 gitbase 吗？最简单快捷的方式是从 sourced.tech/engine 下载 source{d} 引擎，就可以通过单个命令运行 gitbase 了。\n\n想要了解更多，可以听听我在 [Go SF 大会][16]上的演讲录音。\n\n本文在 [Medium][17] 首发，并经许可在此发布。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/gitbase\n\n[a]: https://opensource.com/users/francesc\n[b]: https://github.com/lujun9972\n[1]: https://github.com/src-d/gitbase\n[2]: https://github.com/src-d/gitbase-web\n[3]: https://github.com/vitessio/vitess\n[4]: https://github.com/src-d/go-mysql-server\n[5]: http://justforfunc.com/\n[6]: https://youtu.be/bcRDXAraprk\n[7]: https://github.com/src-d/go-git\n[8]: https://github.com/src-d/siva\n[9]: https://github.com/src-d/enry\n[10]: https://github.com/bblfsh/bblfshd\n[11]: https://blog.sourced.tech/post/announcing-pga/\n[12]: https://github.com/moovweb/rubex\n[13]: https://github.com/kkos/oniguruma\n[14]: https://golang.org/cmd/cgo/\n[15]: https://github.com/pilosa/pilosa\n[16]: https://www.meetup.com/golangsf/events/251690574/\n[17]: https://medium.com/sourcedtech/gitbase-exploring-git-repos-with-sql-95ec0986386c\n\n","slug":"Gitbase-Exploring-git-repos-with-SQL","published":1,"updated":"2019-03-28T12:49:31.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ci000rlixub30v0dpr","content":"<blockquote>\n<p>gitbase 是一个使用 go 开发的的开源项目，它实现了在 Git 仓库上执行 SQL 查询。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bus_cloud_database.png?itok=lhhU42fg\" alt=\"\"></p>\n<p>Git 已经成为了代码版本控制的事实标准，但尽管 Git 相当普及，对代码仓库的深入分析的工作难度却没有因此而下降；而 SQL 在大型代码库的查询方面则已经是一种久经考验的语言，因此诸如 Spark 和 BigQuery 这样的项目都采用了它。</p>\n<p>所以，source{d} 很顺理成章地将这两种技术结合起来，就产生了 gitbase（LCTT 译注：source{d} 是一家开源公司，本文作者是该公司开发者关系副总裁）。gitbase 是一个<ruby>代码即数据<rt>code-as-data</rt></ruby>的解决方案，可以使用 SQL 对 git 仓库进行大规模分析。 </p>\n<p><a href=\"https://github.com/src-d/gitbase\" target=\"_blank\" rel=\"noopener\">gitbase</a> 是一个完全开源的项目。它站在了很多巨人的肩上，因此得到了足够的发展竞争力。下面就来介绍一下其中的一些“巨人”。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/gitbase.png\" alt=\"\"></p>\n<p><em><a href=\"https://github.com/src-d/gitbase-web\" target=\"_blank\" rel=\"noopener\">gitbase playground</a> 为 gitbase 提供了一个可视化的操作环境。</em></p>\n<h3 id=\"用-Vitess-解析-SQL\"><a href=\"#用-Vitess-解析-SQL\" class=\"headerlink\" title=\"用 Vitess 解析 SQL\"></a>用 Vitess 解析 SQL</h3><p>gitbase 通过 SQL 与用户进行交互，因此需要能够遵循 MySQL 协议来对通过网络传入的 SQL 请求作出解析和理解，万幸由 YouTube 建立的 <a href=\"https://github.com/vitessio/vitess\" target=\"_blank\" rel=\"noopener\">Vitess</a> 项目已经在这一方面给出了解决方案。Vitess 是一个横向扩展的 MySQL 数据库集群系统。 </p>\n<p>我们只是使用了这个项目中的部分重要代码，并将其转化为一个可以让任何人在数分钟以内编写出一个 MySQL 服务器的<a href=\"https://github.com/src-d/go-mysql-server\" target=\"_blank\" rel=\"noopener\">开源程序</a>，就像我在 <a href=\"http://justforfunc.com/\" target=\"_blank\" rel=\"noopener\">justforfunc</a> 视频系列中展示的 <a href=\"https://youtu.be/bcRDXAraprk\" target=\"_blank\" rel=\"noopener\">CSVQL</a> 一样，它可以使用 SQL 操作 CSV 文件。</p>\n<h3 id=\"用-go-git-读取-git-仓库\"><a href=\"#用-go-git-读取-git-仓库\" class=\"headerlink\" title=\"用 go-git 读取 git 仓库\"></a>用 go-git 读取 git 仓库</h3><p>在成功解析 SQL 请求之后，还需要对数据集中的 git 仓库进行查询才能返回结果。因此，我们还结合使用了 source{d} 最成功的 <a href=\"https://github.com/src-d/go-git\" target=\"_blank\" rel=\"noopener\">go-git</a> 仓库。go-git 是使用纯 go 语言编写的具有高度可扩展性的 git 实现。</p>\n<p>借此我们就可以很方便地将存储在磁盘上的代码仓库保存为 <a href=\"https://github.com/src-d/siva\" target=\"_blank\" rel=\"noopener\">siva</a> 文件格式（这同样是 source{d} 的一个开源项目），也可以通过 <code>git clone</code> 来对代码仓库进行复制。</p>\n<h3 id=\"使用-enry-检测语言、使用-babelfish-解析文件\"><a href=\"#使用-enry-检测语言、使用-babelfish-解析文件\" class=\"headerlink\" title=\"使用 enry 检测语言、使用 babelfish 解析文件\"></a>使用 enry 检测语言、使用 babelfish 解析文件</h3><p>gitbase 集成了我们开源的语言检测项目 <a href=\"https://github.com/src-d/enry\" target=\"_blank\" rel=\"noopener\">enry</a> 以及代码解析项目 <a href=\"https://github.com/bblfsh/bblfshd\" target=\"_blank\" rel=\"noopener\">babelfish</a>，因此在分析 git 仓库历史代码的能力也相当强大。babelfish 是一个自托管服务，普适于各种源代码解析，并将代码文件转换为<ruby>通用抽象语法树<rt>Universal Abstract Syntax Tree</rt></ruby>（UAST）。</p>\n<p>这两个功能在 gitbase 中可以被用户以函数 <code>LANGUAGE</code> 和 <code>UAST</code> 调用，诸如“查找上个月最常被修改的函数的名称”这样的请求就需要通过这两个功能实现。</p>\n<h3 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h3><p>gitbase 可以对非常大的数据集进行分析，例如来自 GitHub 高达 3 TB 源代码的 Public Git Archive（<a href=\"https://blog.sourced.tech/post/announcing-pga/\" target=\"_blank\" rel=\"noopener\">公告</a>）。面临的工作量如此巨大，因此每一点性能都必须运用到极致。于是，我们也使用到了 Rubex 和 Pilosa 这两个项目。</p>\n<h4 id=\"使用-Rubex-和-Oniguruma-优化正则表达式速度\"><a href=\"#使用-Rubex-和-Oniguruma-优化正则表达式速度\" class=\"headerlink\" title=\"使用 Rubex 和 Oniguruma 优化正则表达式速度\"></a>使用 Rubex 和 Oniguruma 优化正则表达式速度</h4><p><a href=\"https://github.com/moovweb/rubex\" target=\"_blank\" rel=\"noopener\">Rubex</a> 是 go 的正则表达式标准库包的一个准替代品。之所以说它是准替代品，是因为它没有在 <code>regexp.Regexp</code> 类中实现 <code>LiteralPrefix</code> 方法，直到现在都还没有。</p>\n<p>Rubex 的高性能是由于使用 <a href=\"https://golang.org/cmd/cgo/\" target=\"_blank\" rel=\"noopener\">cgo</a> 调用了 <a href=\"https://github.com/kkos/oniguruma\" target=\"_blank\" rel=\"noopener\">Oniguruma</a>，它是一个高度优化的 C 代码库。</p>\n<h4 id=\"使用-Pilosa-索引优化查询速度\"><a href=\"#使用-Pilosa-索引优化查询速度\" class=\"headerlink\" title=\"使用 Pilosa 索引优化查询速度\"></a>使用 Pilosa 索引优化查询速度</h4><p>索引几乎是每个关系型数据库都拥有的特性，但 Vitess 由于不需要用到索引，因此并没有进行实现。</p>\n<p>于是我们引入了 <a href=\"https://github.com/pilosa/pilosa\" target=\"_blank\" rel=\"noopener\">Pilosa</a> 这个开源项目。Pilosa 是一个使用 go 实现的分布式位图索引，可以显著提升跨多个大型数据集的查询的速度。通过 Pilosa，gitbase 才得以在巨大的数据集中进行查询。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>我想用这一篇文章来对开源社区表达我衷心的感谢，让我们能够不负众望的在短时间内完成 gitbase 的开发。我们 source{d} 的每一位成员都是开源的拥护者，github.com/src-d 下的每一行代码都是见证。</p>\n<p>你想使用 gitbase 吗？最简单快捷的方式是从 sourced.tech/engine 下载 source{d} 引擎，就可以通过单个命令运行 gitbase 了。</p>\n<p>想要了解更多，可以听听我在 <a href=\"https://www.meetup.com/golangsf/events/251690574/\" target=\"_blank\" rel=\"noopener\">Go SF 大会</a>上的演讲录音。</p>\n<p>本文在 <a href=\"https://medium.com/sourcedtech/gitbase-exploring-git-repos-with-sql-95ec0986386c\" target=\"_blank\" rel=\"noopener\">Medium</a> 首发，并经许可在此发布。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/gitbase\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/gitbase</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>gitbase 是一个使用 go 开发的的开源项目，它实现了在 Git 仓库上执行 SQL 查询。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bus_cloud_database.png?itok=lhhU42fg\" alt=\"\"></p>\n<p>Git 已经成为了代码版本控制的事实标准，但尽管 Git 相当普及，对代码仓库的深入分析的工作难度却没有因此而下降；而 SQL 在大型代码库的查询方面则已经是一种久经考验的语言，因此诸如 Spark 和 BigQuery 这样的项目都采用了它。</p>\n<p>所以，source{d} 很顺理成章地将这两种技术结合起来，就产生了 gitbase（LCTT 译注：source{d} 是一家开源公司，本文作者是该公司开发者关系副总裁）。gitbase 是一个<ruby>代码即数据<rt>code-as-data</rt></ruby>的解决方案，可以使用 SQL 对 git 仓库进行大规模分析。 </p>\n<p><a href=\"https://github.com/src-d/gitbase\" target=\"_blank\" rel=\"noopener\">gitbase</a> 是一个完全开源的项目。它站在了很多巨人的肩上，因此得到了足够的发展竞争力。下面就来介绍一下其中的一些“巨人”。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/gitbase.png\" alt=\"\"></p>\n<p><em><a href=\"https://github.com/src-d/gitbase-web\" target=\"_blank\" rel=\"noopener\">gitbase playground</a> 为 gitbase 提供了一个可视化的操作环境。</em></p>\n<h3 id=\"用-Vitess-解析-SQL\"><a href=\"#用-Vitess-解析-SQL\" class=\"headerlink\" title=\"用 Vitess 解析 SQL\"></a>用 Vitess 解析 SQL</h3><p>gitbase 通过 SQL 与用户进行交互，因此需要能够遵循 MySQL 协议来对通过网络传入的 SQL 请求作出解析和理解，万幸由 YouTube 建立的 <a href=\"https://github.com/vitessio/vitess\" target=\"_blank\" rel=\"noopener\">Vitess</a> 项目已经在这一方面给出了解决方案。Vitess 是一个横向扩展的 MySQL 数据库集群系统。 </p>\n<p>我们只是使用了这个项目中的部分重要代码，并将其转化为一个可以让任何人在数分钟以内编写出一个 MySQL 服务器的<a href=\"https://github.com/src-d/go-mysql-server\" target=\"_blank\" rel=\"noopener\">开源程序</a>，就像我在 <a href=\"http://justforfunc.com/\" target=\"_blank\" rel=\"noopener\">justforfunc</a> 视频系列中展示的 <a href=\"https://youtu.be/bcRDXAraprk\" target=\"_blank\" rel=\"noopener\">CSVQL</a> 一样，它可以使用 SQL 操作 CSV 文件。</p>\n<h3 id=\"用-go-git-读取-git-仓库\"><a href=\"#用-go-git-读取-git-仓库\" class=\"headerlink\" title=\"用 go-git 读取 git 仓库\"></a>用 go-git 读取 git 仓库</h3><p>在成功解析 SQL 请求之后，还需要对数据集中的 git 仓库进行查询才能返回结果。因此，我们还结合使用了 source{d} 最成功的 <a href=\"https://github.com/src-d/go-git\" target=\"_blank\" rel=\"noopener\">go-git</a> 仓库。go-git 是使用纯 go 语言编写的具有高度可扩展性的 git 实现。</p>\n<p>借此我们就可以很方便地将存储在磁盘上的代码仓库保存为 <a href=\"https://github.com/src-d/siva\" target=\"_blank\" rel=\"noopener\">siva</a> 文件格式（这同样是 source{d} 的一个开源项目），也可以通过 <code>git clone</code> 来对代码仓库进行复制。</p>\n<h3 id=\"使用-enry-检测语言、使用-babelfish-解析文件\"><a href=\"#使用-enry-检测语言、使用-babelfish-解析文件\" class=\"headerlink\" title=\"使用 enry 检测语言、使用 babelfish 解析文件\"></a>使用 enry 检测语言、使用 babelfish 解析文件</h3><p>gitbase 集成了我们开源的语言检测项目 <a href=\"https://github.com/src-d/enry\" target=\"_blank\" rel=\"noopener\">enry</a> 以及代码解析项目 <a href=\"https://github.com/bblfsh/bblfshd\" target=\"_blank\" rel=\"noopener\">babelfish</a>，因此在分析 git 仓库历史代码的能力也相当强大。babelfish 是一个自托管服务，普适于各种源代码解析，并将代码文件转换为<ruby>通用抽象语法树<rt>Universal Abstract Syntax Tree</rt></ruby>（UAST）。</p>\n<p>这两个功能在 gitbase 中可以被用户以函数 <code>LANGUAGE</code> 和 <code>UAST</code> 调用，诸如“查找上个月最常被修改的函数的名称”这样的请求就需要通过这两个功能实现。</p>\n<h3 id=\"提高性能\"><a href=\"#提高性能\" class=\"headerlink\" title=\"提高性能\"></a>提高性能</h3><p>gitbase 可以对非常大的数据集进行分析，例如来自 GitHub 高达 3 TB 源代码的 Public Git Archive（<a href=\"https://blog.sourced.tech/post/announcing-pga/\" target=\"_blank\" rel=\"noopener\">公告</a>）。面临的工作量如此巨大，因此每一点性能都必须运用到极致。于是，我们也使用到了 Rubex 和 Pilosa 这两个项目。</p>\n<h4 id=\"使用-Rubex-和-Oniguruma-优化正则表达式速度\"><a href=\"#使用-Rubex-和-Oniguruma-优化正则表达式速度\" class=\"headerlink\" title=\"使用 Rubex 和 Oniguruma 优化正则表达式速度\"></a>使用 Rubex 和 Oniguruma 优化正则表达式速度</h4><p><a href=\"https://github.com/moovweb/rubex\" target=\"_blank\" rel=\"noopener\">Rubex</a> 是 go 的正则表达式标准库包的一个准替代品。之所以说它是准替代品，是因为它没有在 <code>regexp.Regexp</code> 类中实现 <code>LiteralPrefix</code> 方法，直到现在都还没有。</p>\n<p>Rubex 的高性能是由于使用 <a href=\"https://golang.org/cmd/cgo/\" target=\"_blank\" rel=\"noopener\">cgo</a> 调用了 <a href=\"https://github.com/kkos/oniguruma\" target=\"_blank\" rel=\"noopener\">Oniguruma</a>，它是一个高度优化的 C 代码库。</p>\n<h4 id=\"使用-Pilosa-索引优化查询速度\"><a href=\"#使用-Pilosa-索引优化查询速度\" class=\"headerlink\" title=\"使用 Pilosa 索引优化查询速度\"></a>使用 Pilosa 索引优化查询速度</h4><p>索引几乎是每个关系型数据库都拥有的特性，但 Vitess 由于不需要用到索引，因此并没有进行实现。</p>\n<p>于是我们引入了 <a href=\"https://github.com/pilosa/pilosa\" target=\"_blank\" rel=\"noopener\">Pilosa</a> 这个开源项目。Pilosa 是一个使用 go 实现的分布式位图索引，可以显著提升跨多个大型数据集的查询的速度。通过 Pilosa，gitbase 才得以在巨大的数据集中进行查询。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>我想用这一篇文章来对开源社区表达我衷心的感谢，让我们能够不负众望的在短时间内完成 gitbase 的开发。我们 source{d} 的每一位成员都是开源的拥护者，github.com/src-d 下的每一行代码都是见证。</p>\n<p>你想使用 gitbase 吗？最简单快捷的方式是从 sourced.tech/engine 下载 source{d} 引擎，就可以通过单个命令运行 gitbase 了。</p>\n<p>想要了解更多，可以听听我在 <a href=\"https://www.meetup.com/golangsf/events/251690574/\" target=\"_blank\" rel=\"noopener\">Go SF 大会</a>上的演讲录音。</p>\n<p>本文在 <a href=\"https://medium.com/sourcedtech/gitbase-exploring-git-repos-with-sql-95ec0986386c\" target=\"_blank\" rel=\"noopener\">Medium</a> 首发，并经许可在此发布。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/gitbase\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/gitbase</a></p>\n"},{"title":"在 Linux 上自定义 bash 命令提示符","date":"2018-11-26T15:19:59.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/BASH-720x340.jpg)\n\n众所周知，**bash**（the **B**ourne-**A**gain **Sh**ell）是目前绝大多数 Linux 发行版使用的默认 shell。本文将会介绍如何通过添加颜色和样式来自定义 bash 命令提示符的显示。尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。\n\n### 在 Linux 中自定义 bash 命令提示符\n\n在 bash 中，我们可以通过更改 `$PS1` 环境变量的值来自定义 bash 命令提示符。\n\n一般情况下，bash 命令提示符会是以下这样的形式：\n\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal.png)\n\n在上图这种默认显示形式当中，“sk” 是我的用户名，而 “ubuntuserver” 是我的主机名。\n\n只要插入一些以反斜杠开头的特殊转义字符串，就可以按照你的喜好修改命令提示符了。下面我来举几个例子。\n\n在开始之前，我强烈建议你预先备份 `~/.bashrc` 文件。\n\n```\n$ cp ~/.bashrc ~/.bashrc.bak\n```\n\n#### 更改 bash 命令提示符中的 username@hostname 部分\n\n如上所示，bash 命令提示符一般都带有 “username@hostname” 部分，这个部分是可以修改的。\n\n只需要编辑 `~/.bashrc` 文件：\n\n```\n$ vi ~/.bashrc\n```\n\n在文件的最后添加一行：\n\n```\nPS1=\"ostechnix> \"\n```\n\n将上面的 “ostechnix” 替换为任意一个你想使用的单词，然后按 `ESC` 并输入 `:wq` 保存、退出文件。\n\n执行以下命令使刚才的修改生效：\n\n```\n$ source ~/.bashrc\n```\n\n你就可以看见 bash 命令提示符中出现刚才添加的 “ostechnix” 了。\n\n![][3]\n\n再来看看另一个例子，比如将 “username@hostname” 替换为 “Hello@welcome>”。\n\n同样是像刚才那样修改 `~/.bashrc` 文件。\n\n```\nexport PS1=\"Hello@welcome> \"\n```\n\n然后执行 `source ~/.bashrc` 让修改结果立即生效。\n\n以下是我在 Ubuntu 18.04 LTS 上修改后的效果。\n\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-1.png)\n\n#### 仅显示用户名\n\n如果需要仅显示用户名，只需要在 `~/.bashrc` 文件中加入以下这一行。\n\n```\nexport PS1=\"\\u \"\n```\n\n这里的 `\\u` 就是一个转义字符串。\n\n下面提供了一些可以添加到 `$PS1` 环境变量中的用以改变 bash 命令提示符样式的转义字符串。每次修改之后，都需要执行 `source ~/.bashrc` 命令才能立即生效。\n\n#### 显示用户名和主机名\n\n```\nexport PS1=\"\\u\\h \"\n```\n\n命令提示符会这样显示：\n\n```\nskubuntuserver\n```\n\n#### 显示用户名和完全限定域名\n\n```\nexport PS1=\"\\u\\H \"\n```\n\n#### 在用户名和主机名之间显示其它字符\n\n如果你还需要在用户名和主机名之间显示其它字符（例如 `@`），可以使用以下格式：\n\n```\nexport PS1=\"\\u@\\h \"\n```\n\n命令提示符会这样显示：\n\n```\nsk@ubuntuserver\n```\n\n#### 显示用户名、主机名，并在末尾添加 $ 符号\n\n```\nexport PS1=\"\\u@\\h\\\\$ \"\n```\n\n#### 综合以上两种显示方式\n\n```\nexport PS1=\"\\u@\\h> \"\n```\n\n命令提示符最终会这样显示：\n\n```\nsk@ubuntuserver>\n```\n\n相似地，还可以添加其它特殊字符，例如冒号、分号、星号、下划线、空格等等。\n\n#### 显示用户名、主机名、shell 名称\n\n```\nexport PS1=\"\\u@\\h>\\s \"\n```\n\n#### 显示用户名、主机名、shell 名称以及 shell 版本\n\n```\nexport PS1=\"\\u@\\h>\\s\\v \"\n```\n\nbash 命令提示符显示样式：\n\n![][4]\n\n#### 显示用户名、主机名、当前目录\n\n```\nexport PS1=\"\\u@\\h\\w \"\n```\n\n如果当前目录是 `$HOME` ，会以一个波浪线（`~`）显示。\n\n#### 在 bash 命令提示符中显示日期\n\n除了用户名和主机名，如果还想在 bash 命令提示符中显示日期，可以在 `~/.bashrc` 文件中添加以下内容：\n\n```\nexport PS1=\"\\u@\\h>\\d \"\n```\n\n![][5]\n\n#### 在 bash 命令提示符中显示日期及 12 小时制时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\@ \"\n```\n\n#### 显示日期及 hh:mm:ss 格式时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\T \"\n```\n\n#### 显示日期及 24 小时制时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\A \"\n```\n\n#### 显示日期及 24 小时制 hh:mm:ss 格式时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\t \"\n```\n\n以上是一些常见的可以改变 bash 命令提示符的转义字符串。除此以外的其它转义字符串，可以在 bash 的 man 手册 PROMPTING 章节中查阅。\n\n你也可以随时执行以下命令查看当前的命令提示符样式。\n\n```\n$ echo $PS1\n```\n\n#### 在 bash 命令提示符中去掉 username@hostname 部分\n\n如果我不想做任何调整，直接把 username@hostname 部分整个去掉可以吗？答案是肯定的。\n\n如果你是一个技术方面的博主，你有可能会需要在网站或者博客中上传自己的 Linux 终端截图。或许你的用户名和主机名太拉风、太另类，不想让别人看到，在这种情况下，你就需要隐藏命令提示符中的 “username@hostname” 部分。\n\n如果你不想暴露自己的用户名和主机名，只需要按照以下步骤操作。\n\n编辑 `~/.bashrc` 文件：\n\n```\n$ vi ~/.bashrc\n```\n\n在文件末尾添加这一行：\n\n```\nPS1=\"\\W> \"\n```\n\n输入 `:wq` 保存并关闭文件。\n\n执行以下命令让修改立即生效。\n\n```\n$ source ~/.bashrc\n```\n\n现在看一下你的终端，“username@hostname” 部分已经消失了，只保留了一个 `~>` 标记。\n\n![][6]\n\n如果你想要尽可能简单的操作，又不想弄乱你的 `~/.bashrc` 文件，最好的办法就是在系统中创建另一个用户（例如 “user@example”、“admin@demo”）。用带有这样的命令提示符的用户去截图或者录屏，就不需要顾虑自己的用户名或主机名被别人看见了。\n\n**警告：**在某些情况下，这种做法并不推荐。例如像 zsh 这种 shell 会继承当前 shell 的设置，这个时候可能会出现一些意想不到的问题。这个技巧只用于隐藏命令提示符中的 “username@hostname” 部分，仅此而已，如果把这个技巧挪作他用，也可能会出现异常。\n\n### 为 bash 命令提示符着色\n\n目前我们也只是变更了 bash 命令提示符中的内容，下面介绍一下如何对命令提示符进行着色。\n\n通过向 `~/.bashrc` 文件写入一些配置，可以修改 bash 命令提示符的前景色（也就是文本的颜色）和背景色。\n\n例如，下面这一行配置可以令某些文本的颜色变成红色：\n\n```\nexport PS1=\"\\u@\\[\\e[31m\\]\\h\\[\\e[m\\] \"\n```\n\n添加配置后，执行 `source ~/.bashrc` 立即生效。\n\n你的 bash 命令提示符就会变成这样：\n\n![][7]\n\n类似地，可以用这样的配置来改变背景色：\n\n```\nexport PS1=\"\\u@\\[\\e[31;46m\\]\\h\\[\\e[m\\] \"\n```\n\n![][8]\n\n###  添加 emoji\n\n大家都喜欢 emoji。还可以按照以下配置把 emoji 插入到命令提示符中。\n\n```\nPS1=\"\\W 🔥 >\"\n```\n\n需要注意的是，emoji 的显示取决于使用的字体，因此某些终端可能会无法正常显示 emoji，取而代之的是一些乱码或者单色表情符号。\n\n### 自定义 bash 命令提示符有点难，有更简单的方法吗？\n\n如果你是一个新手，编辑 `$PS1` 环境变量的过程可能会有些困难，因为命令提示符中的大量转义字符串可能会让你有点晕头转向。但不要担心，有一个在线的 bash `$PS1` 生成器可以帮助你轻松生成各种 `$PS1` 环境变量值。\n\n就是这个[网站][9]：\n\n[![EzPrompt](https://www.ostechnix.com/wp-content/uploads/2017/10/EzPrompt.png)][9]\n\n只需要直接选择你想要的 bash 命令提示符样式，添加颜色、设计排序，然后就完成了。你可以预览输出，并将配置代码复制粘贴到 `~/.bashrc` 文件中。就这么简单。顺便一提，本文中大部分的示例都是通过这个网站制作的。\n\n### 我把我的 ~/.bashrc 文件弄乱了，该如何恢复？\n\n正如我在上面提到的，强烈建议在更改 `~/.bashrc` 文件前做好备份（在更改其它重要的配置文件之前也一定要记得备份）。这样一旦出现任何问题，你都可以很方便地恢复到更改之前的配置状态。当然，如果你忘记了备份，还可以按照下面这篇文章中介绍的方法恢复为默认配置。\n\n- [如何将 `~/.bashrc` 文件恢复到默认配置][10]\n\n这篇文章是基于 ubuntu 的，但也适用于其它的 Linux 发行版。不过事先声明，这篇文章的方法会将 `~/.bashrc` 文件恢复到系统最初时的状态，你对这个文件做过的任何修改都将丢失。\n\n感谢阅读！\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://www.ostechnix.com/cdn-cgi/l/email-protection\n[2]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[3]: http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-2.png\n[4]: http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-2.png\n[5]: http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-3.png\n[6]: http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-1.png\n[7]: http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-4/\n[8]: http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-5/\n[9]: http://ezprompt.net/\n[10]: https://www.ostechnix.com/restore-bashrc-file-default-settings-ubuntu/\n\n","source":"_posts/How-To-Customize-Bash-Prompt-In-Linux.md","raw":"---\ntitle: 在 Linux 上自定义 bash 命令提示符\ndate: 2018-11-26 23:19:59\ntags:\n  - Linux\n  - Bash\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/BASH-720x340.jpg)\n\n众所周知，**bash**（the **B**ourne-**A**gain **Sh**ell）是目前绝大多数 Linux 发行版使用的默认 shell。本文将会介绍如何通过添加颜色和样式来自定义 bash 命令提示符的显示。尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。\n\n### 在 Linux 中自定义 bash 命令提示符\n\n在 bash 中，我们可以通过更改 `$PS1` 环境变量的值来自定义 bash 命令提示符。\n\n一般情况下，bash 命令提示符会是以下这样的形式：\n\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal.png)\n\n在上图这种默认显示形式当中，“sk” 是我的用户名，而 “ubuntuserver” 是我的主机名。\n\n只要插入一些以反斜杠开头的特殊转义字符串，就可以按照你的喜好修改命令提示符了。下面我来举几个例子。\n\n在开始之前，我强烈建议你预先备份 `~/.bashrc` 文件。\n\n```\n$ cp ~/.bashrc ~/.bashrc.bak\n```\n\n#### 更改 bash 命令提示符中的 username@hostname 部分\n\n如上所示，bash 命令提示符一般都带有 “username@hostname” 部分，这个部分是可以修改的。\n\n只需要编辑 `~/.bashrc` 文件：\n\n```\n$ vi ~/.bashrc\n```\n\n在文件的最后添加一行：\n\n```\nPS1=\"ostechnix> \"\n```\n\n将上面的 “ostechnix” 替换为任意一个你想使用的单词，然后按 `ESC` 并输入 `:wq` 保存、退出文件。\n\n执行以下命令使刚才的修改生效：\n\n```\n$ source ~/.bashrc\n```\n\n你就可以看见 bash 命令提示符中出现刚才添加的 “ostechnix” 了。\n\n![][3]\n\n再来看看另一个例子，比如将 “username@hostname” 替换为 “Hello@welcome>”。\n\n同样是像刚才那样修改 `~/.bashrc` 文件。\n\n```\nexport PS1=\"Hello@welcome> \"\n```\n\n然后执行 `source ~/.bashrc` 让修改结果立即生效。\n\n以下是我在 Ubuntu 18.04 LTS 上修改后的效果。\n\n![](https://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-1.png)\n\n#### 仅显示用户名\n\n如果需要仅显示用户名，只需要在 `~/.bashrc` 文件中加入以下这一行。\n\n```\nexport PS1=\"\\u \"\n```\n\n这里的 `\\u` 就是一个转义字符串。\n\n下面提供了一些可以添加到 `$PS1` 环境变量中的用以改变 bash 命令提示符样式的转义字符串。每次修改之后，都需要执行 `source ~/.bashrc` 命令才能立即生效。\n\n#### 显示用户名和主机名\n\n```\nexport PS1=\"\\u\\h \"\n```\n\n命令提示符会这样显示：\n\n```\nskubuntuserver\n```\n\n#### 显示用户名和完全限定域名\n\n```\nexport PS1=\"\\u\\H \"\n```\n\n#### 在用户名和主机名之间显示其它字符\n\n如果你还需要在用户名和主机名之间显示其它字符（例如 `@`），可以使用以下格式：\n\n```\nexport PS1=\"\\u@\\h \"\n```\n\n命令提示符会这样显示：\n\n```\nsk@ubuntuserver\n```\n\n#### 显示用户名、主机名，并在末尾添加 $ 符号\n\n```\nexport PS1=\"\\u@\\h\\\\$ \"\n```\n\n#### 综合以上两种显示方式\n\n```\nexport PS1=\"\\u@\\h> \"\n```\n\n命令提示符最终会这样显示：\n\n```\nsk@ubuntuserver>\n```\n\n相似地，还可以添加其它特殊字符，例如冒号、分号、星号、下划线、空格等等。\n\n#### 显示用户名、主机名、shell 名称\n\n```\nexport PS1=\"\\u@\\h>\\s \"\n```\n\n#### 显示用户名、主机名、shell 名称以及 shell 版本\n\n```\nexport PS1=\"\\u@\\h>\\s\\v \"\n```\n\nbash 命令提示符显示样式：\n\n![][4]\n\n#### 显示用户名、主机名、当前目录\n\n```\nexport PS1=\"\\u@\\h\\w \"\n```\n\n如果当前目录是 `$HOME` ，会以一个波浪线（`~`）显示。\n\n#### 在 bash 命令提示符中显示日期\n\n除了用户名和主机名，如果还想在 bash 命令提示符中显示日期，可以在 `~/.bashrc` 文件中添加以下内容：\n\n```\nexport PS1=\"\\u@\\h>\\d \"\n```\n\n![][5]\n\n#### 在 bash 命令提示符中显示日期及 12 小时制时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\@ \"\n```\n\n#### 显示日期及 hh:mm:ss 格式时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\T \"\n```\n\n#### 显示日期及 24 小时制时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\A \"\n```\n\n#### 显示日期及 24 小时制 hh:mm:ss 格式时间\n\n```\nexport PS1=\"\\u@\\h>\\d\\t \"\n```\n\n以上是一些常见的可以改变 bash 命令提示符的转义字符串。除此以外的其它转义字符串，可以在 bash 的 man 手册 PROMPTING 章节中查阅。\n\n你也可以随时执行以下命令查看当前的命令提示符样式。\n\n```\n$ echo $PS1\n```\n\n#### 在 bash 命令提示符中去掉 username@hostname 部分\n\n如果我不想做任何调整，直接把 username@hostname 部分整个去掉可以吗？答案是肯定的。\n\n如果你是一个技术方面的博主，你有可能会需要在网站或者博客中上传自己的 Linux 终端截图。或许你的用户名和主机名太拉风、太另类，不想让别人看到，在这种情况下，你就需要隐藏命令提示符中的 “username@hostname” 部分。\n\n如果你不想暴露自己的用户名和主机名，只需要按照以下步骤操作。\n\n编辑 `~/.bashrc` 文件：\n\n```\n$ vi ~/.bashrc\n```\n\n在文件末尾添加这一行：\n\n```\nPS1=\"\\W> \"\n```\n\n输入 `:wq` 保存并关闭文件。\n\n执行以下命令让修改立即生效。\n\n```\n$ source ~/.bashrc\n```\n\n现在看一下你的终端，“username@hostname” 部分已经消失了，只保留了一个 `~>` 标记。\n\n![][6]\n\n如果你想要尽可能简单的操作，又不想弄乱你的 `~/.bashrc` 文件，最好的办法就是在系统中创建另一个用户（例如 “user@example”、“admin@demo”）。用带有这样的命令提示符的用户去截图或者录屏，就不需要顾虑自己的用户名或主机名被别人看见了。\n\n**警告：**在某些情况下，这种做法并不推荐。例如像 zsh 这种 shell 会继承当前 shell 的设置，这个时候可能会出现一些意想不到的问题。这个技巧只用于隐藏命令提示符中的 “username@hostname” 部分，仅此而已，如果把这个技巧挪作他用，也可能会出现异常。\n\n### 为 bash 命令提示符着色\n\n目前我们也只是变更了 bash 命令提示符中的内容，下面介绍一下如何对命令提示符进行着色。\n\n通过向 `~/.bashrc` 文件写入一些配置，可以修改 bash 命令提示符的前景色（也就是文本的颜色）和背景色。\n\n例如，下面这一行配置可以令某些文本的颜色变成红色：\n\n```\nexport PS1=\"\\u@\\[\\e[31m\\]\\h\\[\\e[m\\] \"\n```\n\n添加配置后，执行 `source ~/.bashrc` 立即生效。\n\n你的 bash 命令提示符就会变成这样：\n\n![][7]\n\n类似地，可以用这样的配置来改变背景色：\n\n```\nexport PS1=\"\\u@\\[\\e[31;46m\\]\\h\\[\\e[m\\] \"\n```\n\n![][8]\n\n###  添加 emoji\n\n大家都喜欢 emoji。还可以按照以下配置把 emoji 插入到命令提示符中。\n\n```\nPS1=\"\\W 🔥 >\"\n```\n\n需要注意的是，emoji 的显示取决于使用的字体，因此某些终端可能会无法正常显示 emoji，取而代之的是一些乱码或者单色表情符号。\n\n### 自定义 bash 命令提示符有点难，有更简单的方法吗？\n\n如果你是一个新手，编辑 `$PS1` 环境变量的过程可能会有些困难，因为命令提示符中的大量转义字符串可能会让你有点晕头转向。但不要担心，有一个在线的 bash `$PS1` 生成器可以帮助你轻松生成各种 `$PS1` 环境变量值。\n\n就是这个[网站][9]：\n\n[![EzPrompt](https://www.ostechnix.com/wp-content/uploads/2017/10/EzPrompt.png)][9]\n\n只需要直接选择你想要的 bash 命令提示符样式，添加颜色、设计排序，然后就完成了。你可以预览输出，并将配置代码复制粘贴到 `~/.bashrc` 文件中。就这么简单。顺便一提，本文中大部分的示例都是通过这个网站制作的。\n\n### 我把我的 ~/.bashrc 文件弄乱了，该如何恢复？\n\n正如我在上面提到的，强烈建议在更改 `~/.bashrc` 文件前做好备份（在更改其它重要的配置文件之前也一定要记得备份）。这样一旦出现任何问题，你都可以很方便地恢复到更改之前的配置状态。当然，如果你忘记了备份，还可以按照下面这篇文章中介绍的方法恢复为默认配置。\n\n- [如何将 `~/.bashrc` 文件恢复到默认配置][10]\n\n这篇文章是基于 ubuntu 的，但也适用于其它的 Linux 发行版。不过事先声明，这篇文章的方法会将 `~/.bashrc` 文件恢复到系统最初时的状态，你对这个文件做过的任何修改都将丢失。\n\n感谢阅读！\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://www.ostechnix.com/cdn-cgi/l/email-protection\n[2]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[3]: http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-2.png\n[4]: http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-2.png\n[5]: http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-3.png\n[6]: http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-1.png\n[7]: http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-4/\n[8]: http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-5/\n[9]: http://ezprompt.net/\n[10]: https://www.ostechnix.com/restore-bashrc-file-default-settings-ubuntu/\n\n","slug":"How-To-Customize-Bash-Prompt-In-Linux","published":1,"updated":"2019-03-28T13:02:29.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cj000tlixuac4ctgtj","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/BASH-720x340.jpg\" alt=\"\"></p>\n<p>众所周知，<strong>bash</strong>（the <strong>B</strong>ourne-<strong>A</strong>gain <strong>Sh</strong>ell）是目前绝大多数 Linux 发行版使用的默认 shell。本文将会介绍如何通过添加颜色和样式来自定义 bash 命令提示符的显示。尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。</p>\n<h3 id=\"在-Linux-中自定义-bash-命令提示符\"><a href=\"#在-Linux-中自定义-bash-命令提示符\" class=\"headerlink\" title=\"在 Linux 中自定义 bash 命令提示符\"></a>在 Linux 中自定义 bash 命令提示符</h3><p>在 bash 中，我们可以通过更改 <code>$PS1</code> 环境变量的值来自定义 bash 命令提示符。</p>\n<p>一般情况下，bash 命令提示符会是以下这样的形式：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal.png\" alt=\"\"></p>\n<p>在上图这种默认显示形式当中，“sk” 是我的用户名，而 “ubuntuserver” 是我的主机名。</p>\n<p>只要插入一些以反斜杠开头的特殊转义字符串，就可以按照你的喜好修改命令提示符了。下面我来举几个例子。</p>\n<p>在开始之前，我强烈建议你预先备份 <code>~/.bashrc</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp ~/.bashrc ~/.bashrc.bak</span><br></pre></td></tr></table></figure>\n<h4 id=\"更改-bash-命令提示符中的-username-hostname-部分\"><a href=\"#更改-bash-命令提示符中的-username-hostname-部分\" class=\"headerlink\" title=\"更改 bash 命令提示符中的 username@hostname 部分\"></a>更改 bash 命令提示符中的 username@hostname 部分</h4><p>如上所示，bash 命令提示符一般都带有 “username@hostname” 部分，这个部分是可以修改的。</p>\n<p>只需要编辑 <code>~/.bashrc</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在文件的最后添加一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;ostechnix&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>将上面的 “ostechnix” 替换为任意一个你想使用的单词，然后按 <code>ESC</code> 并输入 <code>:wq</code> 保存、退出文件。</p>\n<p>执行以下命令使刚才的修改生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>你就可以看见 bash 命令提示符中出现刚才添加的 “ostechnix” 了。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-2.png\" alt=\"\"></p>\n<p>再来看看另一个例子，比如将 “username@hostname” 替换为 “Hello@welcome&gt;”。</p>\n<p>同样是像刚才那样修改 <code>~/.bashrc</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;Hello@welcome&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>source ~/.bashrc</code> 让修改结果立即生效。</p>\n<p>以下是我在 Ubuntu 18.04 LTS 上修改后的效果。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-1.png\" alt=\"\"></p>\n<h4 id=\"仅显示用户名\"><a href=\"#仅显示用户名\" class=\"headerlink\" title=\"仅显示用户名\"></a>仅显示用户名</h4><p>如果需要仅显示用户名，只需要在 <code>~/.bashrc</code> 文件中加入以下这一行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u &quot;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>\\u</code> 就是一个转义字符串。</p>\n<p>下面提供了一些可以添加到 <code>$PS1</code> 环境变量中的用以改变 bash 命令提示符样式的转义字符串。每次修改之后，都需要执行 <code>source ~/.bashrc</code> 命令才能立即生效。</p>\n<h4 id=\"显示用户名和主机名\"><a href=\"#显示用户名和主机名\" class=\"headerlink\" title=\"显示用户名和主机名\"></a>显示用户名和主机名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u\\h &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skubuntuserver</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名和完全限定域名\"><a href=\"#显示用户名和完全限定域名\" class=\"headerlink\" title=\"显示用户名和完全限定域名\"></a>显示用户名和完全限定域名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u\\H &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在用户名和主机名之间显示其它字符\"><a href=\"#在用户名和主机名之间显示其它字符\" class=\"headerlink\" title=\"在用户名和主机名之间显示其它字符\"></a>在用户名和主机名之间显示其它字符</h4><p>如果你还需要在用户名和主机名之间显示其它字符（例如 <code>@</code>），可以使用以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sk@ubuntuserver</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名、主机名，并在末尾添加-符号\"><a href=\"#显示用户名、主机名，并在末尾添加-符号\" class=\"headerlink\" title=\"显示用户名、主机名，并在末尾添加 $ 符号\"></a>显示用户名、主机名，并在末尾添加 $ 符号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h\\\\$ &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"综合以上两种显示方式\"><a href=\"#综合以上两种显示方式\" class=\"headerlink\" title=\"综合以上两种显示方式\"></a>综合以上两种显示方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符最终会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sk@ubuntuserver&gt;</span><br></pre></td></tr></table></figure>\n<p>相似地，还可以添加其它特殊字符，例如冒号、分号、星号、下划线、空格等等。</p>\n<h4 id=\"显示用户名、主机名、shell-名称\"><a href=\"#显示用户名、主机名、shell-名称\" class=\"headerlink\" title=\"显示用户名、主机名、shell 名称\"></a>显示用户名、主机名、shell 名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\s &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名、主机名、shell-名称以及-shell-版本\"><a href=\"#显示用户名、主机名、shell-名称以及-shell-版本\" class=\"headerlink\" title=\"显示用户名、主机名、shell 名称以及 shell 版本\"></a>显示用户名、主机名、shell 名称以及 shell 版本</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\s\\v &quot;</span><br></pre></td></tr></table></figure>\n<p>bash 命令提示符显示样式：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-2.png\" alt=\"\"></p>\n<h4 id=\"显示用户名、主机名、当前目录\"><a href=\"#显示用户名、主机名、当前目录\" class=\"headerlink\" title=\"显示用户名、主机名、当前目录\"></a>显示用户名、主机名、当前目录</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h\\w &quot;</span><br></pre></td></tr></table></figure>\n<p>如果当前目录是 <code>$HOME</code> ，会以一个波浪线（<code>~</code>）显示。</p>\n<h4 id=\"在-bash-命令提示符中显示日期\"><a href=\"#在-bash-命令提示符中显示日期\" class=\"headerlink\" title=\"在 bash 命令提示符中显示日期\"></a>在 bash 命令提示符中显示日期</h4><p>除了用户名和主机名，如果还想在 bash 命令提示符中显示日期，可以在 <code>~/.bashrc</code> 文件中添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d &quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-3.png\" alt=\"\"></p>\n<h4 id=\"在-bash-命令提示符中显示日期及-12-小时制时间\"><a href=\"#在-bash-命令提示符中显示日期及-12-小时制时间\" class=\"headerlink\" title=\"在 bash 命令提示符中显示日期及 12 小时制时间\"></a>在 bash 命令提示符中显示日期及 12 小时制时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\@ &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-hh-mm-ss-格式时间\"><a href=\"#显示日期及-hh-mm-ss-格式时间\" class=\"headerlink\" title=\"显示日期及 hh:mm:ss 格式时间\"></a>显示日期及 hh:mm:ss 格式时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\T &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-24-小时制时间\"><a href=\"#显示日期及-24-小时制时间\" class=\"headerlink\" title=\"显示日期及 24 小时制时间\"></a>显示日期及 24 小时制时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\A &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-24-小时制-hh-mm-ss-格式时间\"><a href=\"#显示日期及-24-小时制-hh-mm-ss-格式时间\" class=\"headerlink\" title=\"显示日期及 24 小时制 hh:mm:ss 格式时间\"></a>显示日期及 24 小时制 hh:mm:ss 格式时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\t &quot;</span><br></pre></td></tr></table></figure>\n<p>以上是一些常见的可以改变 bash 命令提示符的转义字符串。除此以外的其它转义字符串，可以在 bash 的 man 手册 PROMPTING 章节中查阅。</p>\n<p>你也可以随时执行以下命令查看当前的命令提示符样式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PS1</span><br></pre></td></tr></table></figure>\n<h4 id=\"在-bash-命令提示符中去掉-username-hostname-部分\"><a href=\"#在-bash-命令提示符中去掉-username-hostname-部分\" class=\"headerlink\" title=\"在 bash 命令提示符中去掉 username@hostname 部分\"></a>在 bash 命令提示符中去掉 username@hostname 部分</h4><p>如果我不想做任何调整，直接把 username@hostname 部分整个去掉可以吗？答案是肯定的。</p>\n<p>如果你是一个技术方面的博主，你有可能会需要在网站或者博客中上传自己的 Linux 终端截图。或许你的用户名和主机名太拉风、太另类，不想让别人看到，在这种情况下，你就需要隐藏命令提示符中的 “username@hostname” 部分。</p>\n<p>如果你不想暴露自己的用户名和主机名，只需要按照以下步骤操作。</p>\n<p>编辑 <code>~/.bashrc</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;\\W&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>输入 <code>:wq</code> 保存并关闭文件。</p>\n<p>执行以下命令让修改立即生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>现在看一下你的终端，“username@hostname” 部分已经消失了，只保留了一个 <code>~&gt;</code> 标记。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-1.png\" alt=\"\"></p>\n<p>如果你想要尽可能简单的操作，又不想弄乱你的 <code>~/.bashrc</code> 文件，最好的办法就是在系统中创建另一个用户（例如 “user@example”、“admin@demo”）。用带有这样的命令提示符的用户去截图或者录屏，就不需要顾虑自己的用户名或主机名被别人看见了。</p>\n<p><strong>警告：</strong>在某些情况下，这种做法并不推荐。例如像 zsh 这种 shell 会继承当前 shell 的设置，这个时候可能会出现一些意想不到的问题。这个技巧只用于隐藏命令提示符中的 “username@hostname” 部分，仅此而已，如果把这个技巧挪作他用，也可能会出现异常。</p>\n<h3 id=\"为-bash-命令提示符着色\"><a href=\"#为-bash-命令提示符着色\" class=\"headerlink\" title=\"为 bash 命令提示符着色\"></a>为 bash 命令提示符着色</h3><p>目前我们也只是变更了 bash 命令提示符中的内容，下面介绍一下如何对命令提示符进行着色。</p>\n<p>通过向 <code>~/.bashrc</code> 文件写入一些配置，可以修改 bash 命令提示符的前景色（也就是文本的颜色）和背景色。</p>\n<p>例如，下面这一行配置可以令某些文本的颜色变成红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\[\\e[31m\\]\\h\\[\\e[m\\] &quot;</span><br></pre></td></tr></table></figure>\n<p>添加配置后，执行 <code>source ~/.bashrc</code> 立即生效。</p>\n<p>你的 bash 命令提示符就会变成这样：</p>\n<p><img src=\"http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-4/\" alt=\"\"></p>\n<p>类似地，可以用这样的配置来改变背景色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\[\\e[31;46m\\]\\h\\[\\e[m\\] &quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-5/\" alt=\"\"></p>\n<h3 id=\"添加-emoji\"><a href=\"#添加-emoji\" class=\"headerlink\" title=\"添加 emoji\"></a>添加 emoji</h3><p>大家都喜欢 emoji。还可以按照以下配置把 emoji 插入到命令提示符中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;\\W 🔥 &gt;&quot;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，emoji 的显示取决于使用的字体，因此某些终端可能会无法正常显示 emoji，取而代之的是一些乱码或者单色表情符号。</p>\n<h3 id=\"自定义-bash-命令提示符有点难，有更简单的方法吗？\"><a href=\"#自定义-bash-命令提示符有点难，有更简单的方法吗？\" class=\"headerlink\" title=\"自定义 bash 命令提示符有点难，有更简单的方法吗？\"></a>自定义 bash 命令提示符有点难，有更简单的方法吗？</h3><p>如果你是一个新手，编辑 <code>$PS1</code> 环境变量的过程可能会有些困难，因为命令提示符中的大量转义字符串可能会让你有点晕头转向。但不要担心，有一个在线的 bash <code>$PS1</code> 生成器可以帮助你轻松生成各种 <code>$PS1</code> 环境变量值。</p>\n<p>就是这个<a href=\"http://ezprompt.net/\" target=\"_blank\" rel=\"noopener\">网站</a>：</p>\n<p><a href=\"http://ezprompt.net/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/EzPrompt.png\" alt=\"EzPrompt\"></a></p>\n<p>只需要直接选择你想要的 bash 命令提示符样式，添加颜色、设计排序，然后就完成了。你可以预览输出，并将配置代码复制粘贴到 <code>~/.bashrc</code> 文件中。就这么简单。顺便一提，本文中大部分的示例都是通过这个网站制作的。</p>\n<h3 id=\"我把我的-bashrc-文件弄乱了，该如何恢复？\"><a href=\"#我把我的-bashrc-文件弄乱了，该如何恢复？\" class=\"headerlink\" title=\"我把我的 ~/.bashrc 文件弄乱了，该如何恢复？\"></a>我把我的 ~/.bashrc 文件弄乱了，该如何恢复？</h3><p>正如我在上面提到的，强烈建议在更改 <code>~/.bashrc</code> 文件前做好备份（在更改其它重要的配置文件之前也一定要记得备份）。这样一旦出现任何问题，你都可以很方便地恢复到更改之前的配置状态。当然，如果你忘记了备份，还可以按照下面这篇文章中介绍的方法恢复为默认配置。</p>\n<ul>\n<li><a href=\"https://www.ostechnix.com/restore-bashrc-file-default-settings-ubuntu/\" target=\"_blank\" rel=\"noopener\">如何将 <code>~/.bashrc</code> 文件恢复到默认配置</a></li>\n</ul>\n<p>这篇文章是基于 ubuntu 的，但也适用于其它的 Linux 发行版。不过事先声明，这篇文章的方法会将 <code>~/.bashrc</code> 文件恢复到系统最初时的状态，你对这个文件做过的任何修改都将丢失。</p>\n<p>感谢阅读！</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/BASH-720x340.jpg\" alt=\"\"></p>\n<p>众所周知，<strong>bash</strong>（the <strong>B</strong>ourne-<strong>A</strong>gain <strong>Sh</strong>ell）是目前绝大多数 Linux 发行版使用的默认 shell。本文将会介绍如何通过添加颜色和样式来自定义 bash 命令提示符的显示。尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。</p>\n<h3 id=\"在-Linux-中自定义-bash-命令提示符\"><a href=\"#在-Linux-中自定义-bash-命令提示符\" class=\"headerlink\" title=\"在 Linux 中自定义 bash 命令提示符\"></a>在 Linux 中自定义 bash 命令提示符</h3><p>在 bash 中，我们可以通过更改 <code>$PS1</code> 环境变量的值来自定义 bash 命令提示符。</p>\n<p>一般情况下，bash 命令提示符会是以下这样的形式：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal.png\" alt=\"\"></p>\n<p>在上图这种默认显示形式当中，“sk” 是我的用户名，而 “ubuntuserver” 是我的主机名。</p>\n<p>只要插入一些以反斜杠开头的特殊转义字符串，就可以按照你的喜好修改命令提示符了。下面我来举几个例子。</p>\n<p>在开始之前，我强烈建议你预先备份 <code>~/.bashrc</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cp ~/.bashrc ~/.bashrc.bak</span><br></pre></td></tr></table></figure>\n<h4 id=\"更改-bash-命令提示符中的-username-hostname-部分\"><a href=\"#更改-bash-命令提示符中的-username-hostname-部分\" class=\"headerlink\" title=\"更改 bash 命令提示符中的 username@hostname 部分\"></a>更改 bash 命令提示符中的 username@hostname 部分</h4><p>如上所示，bash 命令提示符一般都带有 “username@hostname” 部分，这个部分是可以修改的。</p>\n<p>只需要编辑 <code>~/.bashrc</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在文件的最后添加一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;ostechnix&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>将上面的 “ostechnix” 替换为任意一个你想使用的单词，然后按 <code>ESC</code> 并输入 <code>:wq</code> 保存、退出文件。</p>\n<p>执行以下命令使刚才的修改生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>你就可以看见 bash 命令提示符中出现刚才添加的 “ostechnix” 了。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-2.png\" alt=\"\"></p>\n<p>再来看看另一个例子，比如将 “username@hostname” 替换为 “Hello@welcome&gt;”。</p>\n<p>同样是像刚才那样修改 <code>~/.bashrc</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;Hello@welcome&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>source ~/.bashrc</code> 让修改结果立即生效。</p>\n<p>以下是我在 Ubuntu 18.04 LTS 上修改后的效果。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-1.png\" alt=\"\"></p>\n<h4 id=\"仅显示用户名\"><a href=\"#仅显示用户名\" class=\"headerlink\" title=\"仅显示用户名\"></a>仅显示用户名</h4><p>如果需要仅显示用户名，只需要在 <code>~/.bashrc</code> 文件中加入以下这一行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u &quot;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>\\u</code> 就是一个转义字符串。</p>\n<p>下面提供了一些可以添加到 <code>$PS1</code> 环境变量中的用以改变 bash 命令提示符样式的转义字符串。每次修改之后，都需要执行 <code>source ~/.bashrc</code> 命令才能立即生效。</p>\n<h4 id=\"显示用户名和主机名\"><a href=\"#显示用户名和主机名\" class=\"headerlink\" title=\"显示用户名和主机名\"></a>显示用户名和主机名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u\\h &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skubuntuserver</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名和完全限定域名\"><a href=\"#显示用户名和完全限定域名\" class=\"headerlink\" title=\"显示用户名和完全限定域名\"></a>显示用户名和完全限定域名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u\\H &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在用户名和主机名之间显示其它字符\"><a href=\"#在用户名和主机名之间显示其它字符\" class=\"headerlink\" title=\"在用户名和主机名之间显示其它字符\"></a>在用户名和主机名之间显示其它字符</h4><p>如果你还需要在用户名和主机名之间显示其它字符（例如 <code>@</code>），可以使用以下格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sk@ubuntuserver</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名、主机名，并在末尾添加-符号\"><a href=\"#显示用户名、主机名，并在末尾添加-符号\" class=\"headerlink\" title=\"显示用户名、主机名，并在末尾添加 $ 符号\"></a>显示用户名、主机名，并在末尾添加 $ 符号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h\\\\$ &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"综合以上两种显示方式\"><a href=\"#综合以上两种显示方式\" class=\"headerlink\" title=\"综合以上两种显示方式\"></a>综合以上两种显示方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>命令提示符最终会这样显示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sk@ubuntuserver&gt;</span><br></pre></td></tr></table></figure>\n<p>相似地，还可以添加其它特殊字符，例如冒号、分号、星号、下划线、空格等等。</p>\n<h4 id=\"显示用户名、主机名、shell-名称\"><a href=\"#显示用户名、主机名、shell-名称\" class=\"headerlink\" title=\"显示用户名、主机名、shell 名称\"></a>显示用户名、主机名、shell 名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\s &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示用户名、主机名、shell-名称以及-shell-版本\"><a href=\"#显示用户名、主机名、shell-名称以及-shell-版本\" class=\"headerlink\" title=\"显示用户名、主机名、shell 名称以及 shell 版本\"></a>显示用户名、主机名、shell 名称以及 shell 版本</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\s\\v &quot;</span><br></pre></td></tr></table></figure>\n<p>bash 命令提示符显示样式：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-2.png\" alt=\"\"></p>\n<h4 id=\"显示用户名、主机名、当前目录\"><a href=\"#显示用户名、主机名、当前目录\" class=\"headerlink\" title=\"显示用户名、主机名、当前目录\"></a>显示用户名、主机名、当前目录</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h\\w &quot;</span><br></pre></td></tr></table></figure>\n<p>如果当前目录是 <code>$HOME</code> ，会以一个波浪线（<code>~</code>）显示。</p>\n<h4 id=\"在-bash-命令提示符中显示日期\"><a href=\"#在-bash-命令提示符中显示日期\" class=\"headerlink\" title=\"在 bash 命令提示符中显示日期\"></a>在 bash 命令提示符中显示日期</h4><p>除了用户名和主机名，如果还想在 bash 命令提示符中显示日期，可以在 <code>~/.bashrc</code> 文件中添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d &quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/bash-prompt-3.png\" alt=\"\"></p>\n<h4 id=\"在-bash-命令提示符中显示日期及-12-小时制时间\"><a href=\"#在-bash-命令提示符中显示日期及-12-小时制时间\" class=\"headerlink\" title=\"在 bash 命令提示符中显示日期及 12 小时制时间\"></a>在 bash 命令提示符中显示日期及 12 小时制时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\@ &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-hh-mm-ss-格式时间\"><a href=\"#显示日期及-hh-mm-ss-格式时间\" class=\"headerlink\" title=\"显示日期及 hh:mm:ss 格式时间\"></a>显示日期及 hh:mm:ss 格式时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\T &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-24-小时制时间\"><a href=\"#显示日期及-24-小时制时间\" class=\"headerlink\" title=\"显示日期及 24 小时制时间\"></a>显示日期及 24 小时制时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\A &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显示日期及-24-小时制-hh-mm-ss-格式时间\"><a href=\"#显示日期及-24-小时制-hh-mm-ss-格式时间\" class=\"headerlink\" title=\"显示日期及 24 小时制 hh:mm:ss 格式时间\"></a>显示日期及 24 小时制 hh:mm:ss 格式时间</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\h&gt;\\d\\t &quot;</span><br></pre></td></tr></table></figure>\n<p>以上是一些常见的可以改变 bash 命令提示符的转义字符串。除此以外的其它转义字符串，可以在 bash 的 man 手册 PROMPTING 章节中查阅。</p>\n<p>你也可以随时执行以下命令查看当前的命令提示符样式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PS1</span><br></pre></td></tr></table></figure>\n<h4 id=\"在-bash-命令提示符中去掉-username-hostname-部分\"><a href=\"#在-bash-命令提示符中去掉-username-hostname-部分\" class=\"headerlink\" title=\"在 bash 命令提示符中去掉 username@hostname 部分\"></a>在 bash 命令提示符中去掉 username@hostname 部分</h4><p>如果我不想做任何调整，直接把 username@hostname 部分整个去掉可以吗？答案是肯定的。</p>\n<p>如果你是一个技术方面的博主，你有可能会需要在网站或者博客中上传自己的 Linux 终端截图。或许你的用户名和主机名太拉风、太另类，不想让别人看到，在这种情况下，你就需要隐藏命令提示符中的 “username@hostname” 部分。</p>\n<p>如果你不想暴露自己的用户名和主机名，只需要按照以下步骤操作。</p>\n<p>编辑 <code>~/.bashrc</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;\\W&gt; &quot;</span><br></pre></td></tr></table></figure>\n<p>输入 <code>:wq</code> 保存并关闭文件。</p>\n<p>执行以下命令让修改立即生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>现在看一下你的终端，“username@hostname” 部分已经消失了，只保留了一个 <code>~&gt;</code> 标记。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2017/10/Linux-Terminal-1.png\" alt=\"\"></p>\n<p>如果你想要尽可能简单的操作，又不想弄乱你的 <code>~/.bashrc</code> 文件，最好的办法就是在系统中创建另一个用户（例如 “user@example”、“admin@demo”）。用带有这样的命令提示符的用户去截图或者录屏，就不需要顾虑自己的用户名或主机名被别人看见了。</p>\n<p><strong>警告：</strong>在某些情况下，这种做法并不推荐。例如像 zsh 这种 shell 会继承当前 shell 的设置，这个时候可能会出现一些意想不到的问题。这个技巧只用于隐藏命令提示符中的 “username@hostname” 部分，仅此而已，如果把这个技巧挪作他用，也可能会出现异常。</p>\n<h3 id=\"为-bash-命令提示符着色\"><a href=\"#为-bash-命令提示符着色\" class=\"headerlink\" title=\"为 bash 命令提示符着色\"></a>为 bash 命令提示符着色</h3><p>目前我们也只是变更了 bash 命令提示符中的内容，下面介绍一下如何对命令提示符进行着色。</p>\n<p>通过向 <code>~/.bashrc</code> 文件写入一些配置，可以修改 bash 命令提示符的前景色（也就是文本的颜色）和背景色。</p>\n<p>例如，下面这一行配置可以令某些文本的颜色变成红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\[\\e[31m\\]\\h\\[\\e[m\\] &quot;</span><br></pre></td></tr></table></figure>\n<p>添加配置后，执行 <code>source ~/.bashrc</code> 立即生效。</p>\n<p>你的 bash 命令提示符就会变成这样：</p>\n<p><img src=\"http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-4/\" alt=\"\"></p>\n<p>类似地，可以用这样的配置来改变背景色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PS1=&quot;\\u@\\[\\e[31;46m\\]\\h\\[\\e[m\\] &quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/bash-prompt-5/\" alt=\"\"></p>\n<h3 id=\"添加-emoji\"><a href=\"#添加-emoji\" class=\"headerlink\" title=\"添加 emoji\"></a>添加 emoji</h3><p>大家都喜欢 emoji。还可以按照以下配置把 emoji 插入到命令提示符中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS1=&quot;\\W 🔥 &gt;&quot;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，emoji 的显示取决于使用的字体，因此某些终端可能会无法正常显示 emoji，取而代之的是一些乱码或者单色表情符号。</p>\n<h3 id=\"自定义-bash-命令提示符有点难，有更简单的方法吗？\"><a href=\"#自定义-bash-命令提示符有点难，有更简单的方法吗？\" class=\"headerlink\" title=\"自定义 bash 命令提示符有点难，有更简单的方法吗？\"></a>自定义 bash 命令提示符有点难，有更简单的方法吗？</h3><p>如果你是一个新手，编辑 <code>$PS1</code> 环境变量的过程可能会有些困难，因为命令提示符中的大量转义字符串可能会让你有点晕头转向。但不要担心，有一个在线的 bash <code>$PS1</code> 生成器可以帮助你轻松生成各种 <code>$PS1</code> 环境变量值。</p>\n<p>就是这个<a href=\"http://ezprompt.net/\" target=\"_blank\" rel=\"noopener\">网站</a>：</p>\n<p><a href=\"http://ezprompt.net/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.ostechnix.com/wp-content/uploads/2017/10/EzPrompt.png\" alt=\"EzPrompt\"></a></p>\n<p>只需要直接选择你想要的 bash 命令提示符样式，添加颜色、设计排序，然后就完成了。你可以预览输出，并将配置代码复制粘贴到 <code>~/.bashrc</code> 文件中。就这么简单。顺便一提，本文中大部分的示例都是通过这个网站制作的。</p>\n<h3 id=\"我把我的-bashrc-文件弄乱了，该如何恢复？\"><a href=\"#我把我的-bashrc-文件弄乱了，该如何恢复？\" class=\"headerlink\" title=\"我把我的 ~/.bashrc 文件弄乱了，该如何恢复？\"></a>我把我的 ~/.bashrc 文件弄乱了，该如何恢复？</h3><p>正如我在上面提到的，强烈建议在更改 <code>~/.bashrc</code> 文件前做好备份（在更改其它重要的配置文件之前也一定要记得备份）。这样一旦出现任何问题，你都可以很方便地恢复到更改之前的配置状态。当然，如果你忘记了备份，还可以按照下面这篇文章中介绍的方法恢复为默认配置。</p>\n<ul>\n<li><a href=\"https://www.ostechnix.com/restore-bashrc-file-default-settings-ubuntu/\" target=\"_blank\" rel=\"noopener\">如何将 <code>~/.bashrc</code> 文件恢复到默认配置</a></li>\n</ul>\n<p>这篇文章是基于 ubuntu 的，但也适用于其它的 Linux 发行版。不过事先声明，这篇文章的方法会将 <code>~/.bashrc</code> 文件恢复到系统最初时的状态，你对这个文件做过的任何修改都将丢失。</p>\n<p>感谢阅读！</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/hide-modify-usernamelocalhost-part-terminal/</a></p>\n"},{"title":"在 Linux 中安全且轻松地管理 Cron 定时任务","date":"2018-10-03T13:29:43.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/Crontab-UI-720x340.jpg)\n\n在 Linux 中遇到计划任务的时候，你首先会想到的大概就是 Cron 定时任务了。Cron 定时任务能帮助你在类 Unix 操作系统中计划性地执行命令或者任务。也可以参考一下我们之前的一篇《[关于 Cron 定时任务的新手指导][1]》。对于有一定 Linux 经验的人来说，设置 Cron 定时任务不是什么难事，但对于新手来说就不一定了，他们在编辑 crontab 文件的时候不知不觉中犯的一些小错误，也有可能把整个 Cron 定时任务搞挂了。如果你在处理 Cron 定时任务的时候为了以防万一，可以尝试使用 **Crontab UI**，它是一个可以在类 Unix 操作系统上安全轻松管理 Cron 定时任务的 Web 页面工具。\n\nCrontab UI 是使用 NodeJS 编写的自由开源软件。有了 Crontab UI，你在创建、删除和修改 Cron 定时任务的时候就不需要手工编辑 Crontab 文件了，只需要打开浏览器稍微操作一下，就能完成上面这些工作。你可以用 Crontab UI 轻松创建、编辑、暂停、删除、备份 Cron 定时任务，甚至还可以简单地做到导入、导出、部署其它机器上的 Cron 定时任务，它还支持错误日志、邮件发送和钩子。\n\n### 安装 Crontab UI\n\n只需要一条命令就可以安装好 Crontab UI，但前提是已经安装好 NPM。如果还没有安装 NPM，可以参考《[如何在 Linux 上安装 NodeJS][2]》这篇文章。\n\n执行这一条命令来安装 Crontab UI。\n\n```\n$ npm install -g crontab-ui\n```\n\n就是这么简单，下面继续来看看在 Crontab UI 上如何管理 Cron 定时任务。\n\n### 在 Linux 上安全轻松管理 Cron 定时任务\n\n执行这一条命令启动 Crontab UI：\n\n```\n$ crontab-ui\n```\n\n你会看到这样的输出：\n\n```\nNode version: 10.8.0\nCrontab UI is running at http://127.0.0.1:8000\n```\n\n首先在你的防火墙和路由器上放开 8000 端口，然后打开浏览器访问 `<http://127.0.0.1:8000>`。\n\n注意，默认只有在本地才能访问到 Crontab UI 的控制台页面。但如果你想让 Crontab UI 使用系统的 IP 地址和自定义端口，也就是想让其它机器也访问到本地的 Crontab UI，你需要使用以下这个命令：\n\n```\n$ HOST=0.0.0.0 PORT=9000 crontab-ui\nNode version: 10.8.0\nCrontab UI is running at http://0.0.0.0:9000\n```\n\nCrontab UI 就能够通过 `<http://IP-Address>:9000` 这样的 URL 被远程机器访问到了。\n\nCrontab UI 的控制台页面长这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard.png)\n\n从上面的截图就可以看到，Crontab UI 的界面非常简洁，所有选项的含义都能不言自明。\n\n在终端输入 `Ctrl + C` 就可以关闭 Crontab UI。\n\n#### 创建、编辑、运行、停止、删除 Cron 定时任务\n \n点击 “New”，输入 Cron 定时任务的信息并点击 “Save” 保存，就可以创建一个新的 Cron 定时任务了。\n\n  1. 为 Cron 定时任务命名，这是可选的；\n  2. 你想要执行的完整命令；\n  3. 设定计划执行的时间。你可以按照启动、每时、每日、每周、每月、每年这些指标快速指定计划任务，也可以明确指定任务执行的具体时间。指定好计划时间后，“Jobs” 区域就会显示 Cron 定时任务的句式。\n  4. 选择是否为某个 Cron 定时任务记录错误日志。\n\n这是我的一个 Cron 定时任务样例。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/create-new-cron-job.png)\n\n如你所见，我设置了一个每月清理 `pacman` 缓存的 Cron 定时任务。你也可以设置多个 Cron 定时任务，都能在控制台页面看到。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard-1.png)\n\n如果你需要更改 Cron 定时任务中的某些参数，只需要点击 “Edit” 按钮并按照你的需求更改对应的参数。点击 “Run” 按钮可以立即执行 Cron 定时任务，点击 “Stop” 则可以立即停止 Cron 定时任务。如果想要查看某个 Cron 定时任务的详细日志，可以点击 “Log” 按钮。对于不再需要的 Cron 定时任务，就可以按 “Delete” 按钮删除。\n\n#### 备份 Cron 定时任务\n\n点击控制台页面的 “Backup” 按钮并确认，就可以备份所有 Cron 定时任务。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/backup-cron-jobs.png)\n\n备份之后，一旦 Crontab 文件出现了错误，就可以使用备份来恢复了。\n\n#### 导入/导出其它机器上的 Cron 定时任务\n\nCrontab UI 还有一个令人注目的功能，就是导入、导出、部署其它机器上的 Cron 定时任务。如果同一个网络里的多台机器都需要执行同样的 Cron 定时任务，只需要点击 “Export” 按钮并选择文件的保存路径，所有的 Cron 定时任务都会导出到 `crontab.db` 文件中。\n\n以下是 `crontab.db` 文件的内容：\n\n```\n$ cat Downloads/crontab.db\n{\"name\":\"Remove Pacman Cache\",\"command\":\"rm -rf /var/cache/pacman\",\"schedule\":\"@monthly\",\"stopped\":false,\"timestamp\":\"Thu Aug 23 2018 10:34:19 GMT+0000 (Coordinated Universal Time)\",\"logging\":\"true\",\"mailing\":{},\"created\":1535020459093,\"_id\":\"lcVc1nSdaceqS1ut\"}\n```\n\n导出成文件以后，你就可以把这个 `crontab.db` 文件放置到其它机器上并导入成 Cron 定时任务，而不需要在每一台主机上手动设置 Cron 定时任务。总之，在一台机器上设置完，导出，再导入到其他机器，就完事了。\n\n#### 在 Crontab 文件获取/保存 Cron 定时任务\n\n你可能在使用 Crontab UI 之前就已经使用 `crontab` 命令创建过 Cron 定时任务。如果是这样，你可以点击控制台页面上的 “Get from crontab” 按钮来获取已有的 Cron 定时任务。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/get-from-crontab.png)\n\n同样地，你也可以使用 Crontab UI 来将新的 Cron 定时任务保存到 Crontab 文件中，只需要点击 “Save to crontab” 按钮就可以了。\n\n管理 Cron 定时任务并没有想象中那么难，即使是新手使用 Crontab UI 也能轻松管理 Cron 定时任务。赶快开始尝试并发表一下你的看法吧。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/\n\n[a]:https://www.ostechnix.com/author/sk/\n[1]:https://www.ostechnix.com/a-beginners-guide-to-cron-jobs/\n[2]:https://www.ostechnix.com/install-node-js-linux/\n\n","source":"_posts/How-To-Easily-And-Safely-Manage-Cron-Jobs-In-Linux.md","raw":"---\ntitle: 在 Linux 中安全且轻松地管理 Cron 定时任务\ndate: 2018-10-03 21:29:43\ntags:\n  - Linux\n  - cron\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/Crontab-UI-720x340.jpg)\n\n在 Linux 中遇到计划任务的时候，你首先会想到的大概就是 Cron 定时任务了。Cron 定时任务能帮助你在类 Unix 操作系统中计划性地执行命令或者任务。也可以参考一下我们之前的一篇《[关于 Cron 定时任务的新手指导][1]》。对于有一定 Linux 经验的人来说，设置 Cron 定时任务不是什么难事，但对于新手来说就不一定了，他们在编辑 crontab 文件的时候不知不觉中犯的一些小错误，也有可能把整个 Cron 定时任务搞挂了。如果你在处理 Cron 定时任务的时候为了以防万一，可以尝试使用 **Crontab UI**，它是一个可以在类 Unix 操作系统上安全轻松管理 Cron 定时任务的 Web 页面工具。\n\nCrontab UI 是使用 NodeJS 编写的自由开源软件。有了 Crontab UI，你在创建、删除和修改 Cron 定时任务的时候就不需要手工编辑 Crontab 文件了，只需要打开浏览器稍微操作一下，就能完成上面这些工作。你可以用 Crontab UI 轻松创建、编辑、暂停、删除、备份 Cron 定时任务，甚至还可以简单地做到导入、导出、部署其它机器上的 Cron 定时任务，它还支持错误日志、邮件发送和钩子。\n\n### 安装 Crontab UI\n\n只需要一条命令就可以安装好 Crontab UI，但前提是已经安装好 NPM。如果还没有安装 NPM，可以参考《[如何在 Linux 上安装 NodeJS][2]》这篇文章。\n\n执行这一条命令来安装 Crontab UI。\n\n```\n$ npm install -g crontab-ui\n```\n\n就是这么简单，下面继续来看看在 Crontab UI 上如何管理 Cron 定时任务。\n\n### 在 Linux 上安全轻松管理 Cron 定时任务\n\n执行这一条命令启动 Crontab UI：\n\n```\n$ crontab-ui\n```\n\n你会看到这样的输出：\n\n```\nNode version: 10.8.0\nCrontab UI is running at http://127.0.0.1:8000\n```\n\n首先在你的防火墙和路由器上放开 8000 端口，然后打开浏览器访问 `<http://127.0.0.1:8000>`。\n\n注意，默认只有在本地才能访问到 Crontab UI 的控制台页面。但如果你想让 Crontab UI 使用系统的 IP 地址和自定义端口，也就是想让其它机器也访问到本地的 Crontab UI，你需要使用以下这个命令：\n\n```\n$ HOST=0.0.0.0 PORT=9000 crontab-ui\nNode version: 10.8.0\nCrontab UI is running at http://0.0.0.0:9000\n```\n\nCrontab UI 就能够通过 `<http://IP-Address>:9000` 这样的 URL 被远程机器访问到了。\n\nCrontab UI 的控制台页面长这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard.png)\n\n从上面的截图就可以看到，Crontab UI 的界面非常简洁，所有选项的含义都能不言自明。\n\n在终端输入 `Ctrl + C` 就可以关闭 Crontab UI。\n\n#### 创建、编辑、运行、停止、删除 Cron 定时任务\n \n点击 “New”，输入 Cron 定时任务的信息并点击 “Save” 保存，就可以创建一个新的 Cron 定时任务了。\n\n  1. 为 Cron 定时任务命名，这是可选的；\n  2. 你想要执行的完整命令；\n  3. 设定计划执行的时间。你可以按照启动、每时、每日、每周、每月、每年这些指标快速指定计划任务，也可以明确指定任务执行的具体时间。指定好计划时间后，“Jobs” 区域就会显示 Cron 定时任务的句式。\n  4. 选择是否为某个 Cron 定时任务记录错误日志。\n\n这是我的一个 Cron 定时任务样例。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/create-new-cron-job.png)\n\n如你所见，我设置了一个每月清理 `pacman` 缓存的 Cron 定时任务。你也可以设置多个 Cron 定时任务，都能在控制台页面看到。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard-1.png)\n\n如果你需要更改 Cron 定时任务中的某些参数，只需要点击 “Edit” 按钮并按照你的需求更改对应的参数。点击 “Run” 按钮可以立即执行 Cron 定时任务，点击 “Stop” 则可以立即停止 Cron 定时任务。如果想要查看某个 Cron 定时任务的详细日志，可以点击 “Log” 按钮。对于不再需要的 Cron 定时任务，就可以按 “Delete” 按钮删除。\n\n#### 备份 Cron 定时任务\n\n点击控制台页面的 “Backup” 按钮并确认，就可以备份所有 Cron 定时任务。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/backup-cron-jobs.png)\n\n备份之后，一旦 Crontab 文件出现了错误，就可以使用备份来恢复了。\n\n#### 导入/导出其它机器上的 Cron 定时任务\n\nCrontab UI 还有一个令人注目的功能，就是导入、导出、部署其它机器上的 Cron 定时任务。如果同一个网络里的多台机器都需要执行同样的 Cron 定时任务，只需要点击 “Export” 按钮并选择文件的保存路径，所有的 Cron 定时任务都会导出到 `crontab.db` 文件中。\n\n以下是 `crontab.db` 文件的内容：\n\n```\n$ cat Downloads/crontab.db\n{\"name\":\"Remove Pacman Cache\",\"command\":\"rm -rf /var/cache/pacman\",\"schedule\":\"@monthly\",\"stopped\":false,\"timestamp\":\"Thu Aug 23 2018 10:34:19 GMT+0000 (Coordinated Universal Time)\",\"logging\":\"true\",\"mailing\":{},\"created\":1535020459093,\"_id\":\"lcVc1nSdaceqS1ut\"}\n```\n\n导出成文件以后，你就可以把这个 `crontab.db` 文件放置到其它机器上并导入成 Cron 定时任务，而不需要在每一台主机上手动设置 Cron 定时任务。总之，在一台机器上设置完，导出，再导入到其他机器，就完事了。\n\n#### 在 Crontab 文件获取/保存 Cron 定时任务\n\n你可能在使用 Crontab UI 之前就已经使用 `crontab` 命令创建过 Cron 定时任务。如果是这样，你可以点击控制台页面上的 “Get from crontab” 按钮来获取已有的 Cron 定时任务。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/08/get-from-crontab.png)\n\n同样地，你也可以使用 Crontab UI 来将新的 Cron 定时任务保存到 Crontab 文件中，只需要点击 “Save to crontab” 按钮就可以了。\n\n管理 Cron 定时任务并没有想象中那么难，即使是新手使用 Crontab UI 也能轻松管理 Cron 定时任务。赶快开始尝试并发表一下你的看法吧。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/\n\n[a]:https://www.ostechnix.com/author/sk/\n[1]:https://www.ostechnix.com/a-beginners-guide-to-cron-jobs/\n[2]:https://www.ostechnix.com/install-node-js-linux/\n\n","slug":"How-To-Easily-And-Safely-Manage-Cron-Jobs-In-Linux","published":1,"updated":"2019-03-28T11:07:55.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ck000ulixu8tkavlke","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/Crontab-UI-720x340.jpg\" alt=\"\"></p>\n<p>在 Linux 中遇到计划任务的时候，你首先会想到的大概就是 Cron 定时任务了。Cron 定时任务能帮助你在类 Unix 操作系统中计划性地执行命令或者任务。也可以参考一下我们之前的一篇《<a href=\"https://www.ostechnix.com/a-beginners-guide-to-cron-jobs/\" target=\"_blank\" rel=\"noopener\">关于 Cron 定时任务的新手指导</a>》。对于有一定 Linux 经验的人来说，设置 Cron 定时任务不是什么难事，但对于新手来说就不一定了，他们在编辑 crontab 文件的时候不知不觉中犯的一些小错误，也有可能把整个 Cron 定时任务搞挂了。如果你在处理 Cron 定时任务的时候为了以防万一，可以尝试使用 <strong>Crontab UI</strong>，它是一个可以在类 Unix 操作系统上安全轻松管理 Cron 定时任务的 Web 页面工具。</p>\n<p>Crontab UI 是使用 NodeJS 编写的自由开源软件。有了 Crontab UI，你在创建、删除和修改 Cron 定时任务的时候就不需要手工编辑 Crontab 文件了，只需要打开浏览器稍微操作一下，就能完成上面这些工作。你可以用 Crontab UI 轻松创建、编辑、暂停、删除、备份 Cron 定时任务，甚至还可以简单地做到导入、导出、部署其它机器上的 Cron 定时任务，它还支持错误日志、邮件发送和钩子。</p>\n<h3 id=\"安装-Crontab-UI\"><a href=\"#安装-Crontab-UI\" class=\"headerlink\" title=\"安装 Crontab UI\"></a>安装 Crontab UI</h3><p>只需要一条命令就可以安装好 Crontab UI，但前提是已经安装好 NPM。如果还没有安装 NPM，可以参考《<a href=\"https://www.ostechnix.com/install-node-js-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上安装 NodeJS</a>》这篇文章。</p>\n<p>执行这一条命令来安装 Crontab UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g crontab-ui</span><br></pre></td></tr></table></figure>\n<p>就是这么简单，下面继续来看看在 Crontab UI 上如何管理 Cron 定时任务。</p>\n<h3 id=\"在-Linux-上安全轻松管理-Cron-定时任务\"><a href=\"#在-Linux-上安全轻松管理-Cron-定时任务\" class=\"headerlink\" title=\"在 Linux 上安全轻松管理 Cron 定时任务\"></a>在 Linux 上安全轻松管理 Cron 定时任务</h3><p>执行这一条命令启动 Crontab UI：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab-ui</span><br></pre></td></tr></table></figure>\n<p>你会看到这样的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node version: 10.8.0</span><br><span class=\"line\">Crontab UI is running at http://127.0.0.1:8000</span><br></pre></td></tr></table></figure>\n<p>首先在你的防火墙和路由器上放开 8000 端口，然后打开浏览器访问 <code>&lt;http://127.0.0.1:8000&gt;</code>。</p>\n<p>注意，默认只有在本地才能访问到 Crontab UI 的控制台页面。但如果你想让 Crontab UI 使用系统的 IP 地址和自定义端口，也就是想让其它机器也访问到本地的 Crontab UI，你需要使用以下这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ HOST=0.0.0.0 PORT=9000 crontab-ui</span><br><span class=\"line\">Node version: 10.8.0</span><br><span class=\"line\">Crontab UI is running at http://0.0.0.0:9000</span><br></pre></td></tr></table></figure>\n<p>Crontab UI 就能够通过 <code>&lt;http://IP-Address&gt;:9000</code> 这样的 URL 被远程机器访问到了。</p>\n<p>Crontab UI 的控制台页面长这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard.png\" alt=\"\"></p>\n<p>从上面的截图就可以看到，Crontab UI 的界面非常简洁，所有选项的含义都能不言自明。</p>\n<p>在终端输入 <code>Ctrl + C</code> 就可以关闭 Crontab UI。</p>\n<h4 id=\"创建、编辑、运行、停止、删除-Cron-定时任务\"><a href=\"#创建、编辑、运行、停止、删除-Cron-定时任务\" class=\"headerlink\" title=\"创建、编辑、运行、停止、删除 Cron 定时任务\"></a>创建、编辑、运行、停止、删除 Cron 定时任务</h4><p>点击 “New”，输入 Cron 定时任务的信息并点击 “Save” 保存，就可以创建一个新的 Cron 定时任务了。</p>\n<ol>\n<li>为 Cron 定时任务命名，这是可选的；</li>\n<li>你想要执行的完整命令；</li>\n<li>设定计划执行的时间。你可以按照启动、每时、每日、每周、每月、每年这些指标快速指定计划任务，也可以明确指定任务执行的具体时间。指定好计划时间后，“Jobs” 区域就会显示 Cron 定时任务的句式。</li>\n<li>选择是否为某个 Cron 定时任务记录错误日志。</li>\n</ol>\n<p>这是我的一个 Cron 定时任务样例。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/create-new-cron-job.png\" alt=\"\"></p>\n<p>如你所见，我设置了一个每月清理 <code>pacman</code> 缓存的 Cron 定时任务。你也可以设置多个 Cron 定时任务，都能在控制台页面看到。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard-1.png\" alt=\"\"></p>\n<p>如果你需要更改 Cron 定时任务中的某些参数，只需要点击 “Edit” 按钮并按照你的需求更改对应的参数。点击 “Run” 按钮可以立即执行 Cron 定时任务，点击 “Stop” 则可以立即停止 Cron 定时任务。如果想要查看某个 Cron 定时任务的详细日志，可以点击 “Log” 按钮。对于不再需要的 Cron 定时任务，就可以按 “Delete” 按钮删除。</p>\n<h4 id=\"备份-Cron-定时任务\"><a href=\"#备份-Cron-定时任务\" class=\"headerlink\" title=\"备份 Cron 定时任务\"></a>备份 Cron 定时任务</h4><p>点击控制台页面的 “Backup” 按钮并确认，就可以备份所有 Cron 定时任务。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/backup-cron-jobs.png\" alt=\"\"></p>\n<p>备份之后，一旦 Crontab 文件出现了错误，就可以使用备份来恢复了。</p>\n<h4 id=\"导入-导出其它机器上的-Cron-定时任务\"><a href=\"#导入-导出其它机器上的-Cron-定时任务\" class=\"headerlink\" title=\"导入/导出其它机器上的 Cron 定时任务\"></a>导入/导出其它机器上的 Cron 定时任务</h4><p>Crontab UI 还有一个令人注目的功能，就是导入、导出、部署其它机器上的 Cron 定时任务。如果同一个网络里的多台机器都需要执行同样的 Cron 定时任务，只需要点击 “Export” 按钮并选择文件的保存路径，所有的 Cron 定时任务都会导出到 <code>crontab.db</code> 文件中。</p>\n<p>以下是 <code>crontab.db</code> 文件的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat Downloads/crontab.db</span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;Remove Pacman Cache&quot;,&quot;command&quot;:&quot;rm -rf /var/cache/pacman&quot;,&quot;schedule&quot;:&quot;@monthly&quot;,&quot;stopped&quot;:false,&quot;timestamp&quot;:&quot;Thu Aug 23 2018 10:34:19 GMT+0000 (Coordinated Universal Time)&quot;,&quot;logging&quot;:&quot;true&quot;,&quot;mailing&quot;:&#123;&#125;,&quot;created&quot;:1535020459093,&quot;_id&quot;:&quot;lcVc1nSdaceqS1ut&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>导出成文件以后，你就可以把这个 <code>crontab.db</code> 文件放置到其它机器上并导入成 Cron 定时任务，而不需要在每一台主机上手动设置 Cron 定时任务。总之，在一台机器上设置完，导出，再导入到其他机器，就完事了。</p>\n<h4 id=\"在-Crontab-文件获取-保存-Cron-定时任务\"><a href=\"#在-Crontab-文件获取-保存-Cron-定时任务\" class=\"headerlink\" title=\"在 Crontab 文件获取/保存 Cron 定时任务\"></a>在 Crontab 文件获取/保存 Cron 定时任务</h4><p>你可能在使用 Crontab UI 之前就已经使用 <code>crontab</code> 命令创建过 Cron 定时任务。如果是这样，你可以点击控制台页面上的 “Get from crontab” 按钮来获取已有的 Cron 定时任务。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/get-from-crontab.png\" alt=\"\"></p>\n<p>同样地，你也可以使用 Crontab UI 来将新的 Cron 定时任务保存到 Crontab 文件中，只需要点击 “Save to crontab” 按钮就可以了。</p>\n<p>管理 Cron 定时任务并没有想象中那么难，即使是新手使用 Crontab UI 也能轻松管理 Cron 定时任务。赶快开始尝试并发表一下你的看法吧。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/Crontab-UI-720x340.jpg\" alt=\"\"></p>\n<p>在 Linux 中遇到计划任务的时候，你首先会想到的大概就是 Cron 定时任务了。Cron 定时任务能帮助你在类 Unix 操作系统中计划性地执行命令或者任务。也可以参考一下我们之前的一篇《<a href=\"https://www.ostechnix.com/a-beginners-guide-to-cron-jobs/\" target=\"_blank\" rel=\"noopener\">关于 Cron 定时任务的新手指导</a>》。对于有一定 Linux 经验的人来说，设置 Cron 定时任务不是什么难事，但对于新手来说就不一定了，他们在编辑 crontab 文件的时候不知不觉中犯的一些小错误，也有可能把整个 Cron 定时任务搞挂了。如果你在处理 Cron 定时任务的时候为了以防万一，可以尝试使用 <strong>Crontab UI</strong>，它是一个可以在类 Unix 操作系统上安全轻松管理 Cron 定时任务的 Web 页面工具。</p>\n<p>Crontab UI 是使用 NodeJS 编写的自由开源软件。有了 Crontab UI，你在创建、删除和修改 Cron 定时任务的时候就不需要手工编辑 Crontab 文件了，只需要打开浏览器稍微操作一下，就能完成上面这些工作。你可以用 Crontab UI 轻松创建、编辑、暂停、删除、备份 Cron 定时任务，甚至还可以简单地做到导入、导出、部署其它机器上的 Cron 定时任务，它还支持错误日志、邮件发送和钩子。</p>\n<h3 id=\"安装-Crontab-UI\"><a href=\"#安装-Crontab-UI\" class=\"headerlink\" title=\"安装 Crontab UI\"></a>安装 Crontab UI</h3><p>只需要一条命令就可以安装好 Crontab UI，但前提是已经安装好 NPM。如果还没有安装 NPM，可以参考《<a href=\"https://www.ostechnix.com/install-node-js-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上安装 NodeJS</a>》这篇文章。</p>\n<p>执行这一条命令来安装 Crontab UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g crontab-ui</span><br></pre></td></tr></table></figure>\n<p>就是这么简单，下面继续来看看在 Crontab UI 上如何管理 Cron 定时任务。</p>\n<h3 id=\"在-Linux-上安全轻松管理-Cron-定时任务\"><a href=\"#在-Linux-上安全轻松管理-Cron-定时任务\" class=\"headerlink\" title=\"在 Linux 上安全轻松管理 Cron 定时任务\"></a>在 Linux 上安全轻松管理 Cron 定时任务</h3><p>执行这一条命令启动 Crontab UI：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab-ui</span><br></pre></td></tr></table></figure>\n<p>你会看到这样的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node version: 10.8.0</span><br><span class=\"line\">Crontab UI is running at http://127.0.0.1:8000</span><br></pre></td></tr></table></figure>\n<p>首先在你的防火墙和路由器上放开 8000 端口，然后打开浏览器访问 <code>&lt;http://127.0.0.1:8000&gt;</code>。</p>\n<p>注意，默认只有在本地才能访问到 Crontab UI 的控制台页面。但如果你想让 Crontab UI 使用系统的 IP 地址和自定义端口，也就是想让其它机器也访问到本地的 Crontab UI，你需要使用以下这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ HOST=0.0.0.0 PORT=9000 crontab-ui</span><br><span class=\"line\">Node version: 10.8.0</span><br><span class=\"line\">Crontab UI is running at http://0.0.0.0:9000</span><br></pre></td></tr></table></figure>\n<p>Crontab UI 就能够通过 <code>&lt;http://IP-Address&gt;:9000</code> 这样的 URL 被远程机器访问到了。</p>\n<p>Crontab UI 的控制台页面长这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard.png\" alt=\"\"></p>\n<p>从上面的截图就可以看到，Crontab UI 的界面非常简洁，所有选项的含义都能不言自明。</p>\n<p>在终端输入 <code>Ctrl + C</code> 就可以关闭 Crontab UI。</p>\n<h4 id=\"创建、编辑、运行、停止、删除-Cron-定时任务\"><a href=\"#创建、编辑、运行、停止、删除-Cron-定时任务\" class=\"headerlink\" title=\"创建、编辑、运行、停止、删除 Cron 定时任务\"></a>创建、编辑、运行、停止、删除 Cron 定时任务</h4><p>点击 “New”，输入 Cron 定时任务的信息并点击 “Save” 保存，就可以创建一个新的 Cron 定时任务了。</p>\n<ol>\n<li>为 Cron 定时任务命名，这是可选的；</li>\n<li>你想要执行的完整命令；</li>\n<li>设定计划执行的时间。你可以按照启动、每时、每日、每周、每月、每年这些指标快速指定计划任务，也可以明确指定任务执行的具体时间。指定好计划时间后，“Jobs” 区域就会显示 Cron 定时任务的句式。</li>\n<li>选择是否为某个 Cron 定时任务记录错误日志。</li>\n</ol>\n<p>这是我的一个 Cron 定时任务样例。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/create-new-cron-job.png\" alt=\"\"></p>\n<p>如你所见，我设置了一个每月清理 <code>pacman</code> 缓存的 Cron 定时任务。你也可以设置多个 Cron 定时任务，都能在控制台页面看到。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/crontab-ui-dashboard-1.png\" alt=\"\"></p>\n<p>如果你需要更改 Cron 定时任务中的某些参数，只需要点击 “Edit” 按钮并按照你的需求更改对应的参数。点击 “Run” 按钮可以立即执行 Cron 定时任务，点击 “Stop” 则可以立即停止 Cron 定时任务。如果想要查看某个 Cron 定时任务的详细日志，可以点击 “Log” 按钮。对于不再需要的 Cron 定时任务，就可以按 “Delete” 按钮删除。</p>\n<h4 id=\"备份-Cron-定时任务\"><a href=\"#备份-Cron-定时任务\" class=\"headerlink\" title=\"备份 Cron 定时任务\"></a>备份 Cron 定时任务</h4><p>点击控制台页面的 “Backup” 按钮并确认，就可以备份所有 Cron 定时任务。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/backup-cron-jobs.png\" alt=\"\"></p>\n<p>备份之后，一旦 Crontab 文件出现了错误，就可以使用备份来恢复了。</p>\n<h4 id=\"导入-导出其它机器上的-Cron-定时任务\"><a href=\"#导入-导出其它机器上的-Cron-定时任务\" class=\"headerlink\" title=\"导入/导出其它机器上的 Cron 定时任务\"></a>导入/导出其它机器上的 Cron 定时任务</h4><p>Crontab UI 还有一个令人注目的功能，就是导入、导出、部署其它机器上的 Cron 定时任务。如果同一个网络里的多台机器都需要执行同样的 Cron 定时任务，只需要点击 “Export” 按钮并选择文件的保存路径，所有的 Cron 定时任务都会导出到 <code>crontab.db</code> 文件中。</p>\n<p>以下是 <code>crontab.db</code> 文件的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat Downloads/crontab.db</span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;Remove Pacman Cache&quot;,&quot;command&quot;:&quot;rm -rf /var/cache/pacman&quot;,&quot;schedule&quot;:&quot;@monthly&quot;,&quot;stopped&quot;:false,&quot;timestamp&quot;:&quot;Thu Aug 23 2018 10:34:19 GMT+0000 (Coordinated Universal Time)&quot;,&quot;logging&quot;:&quot;true&quot;,&quot;mailing&quot;:&#123;&#125;,&quot;created&quot;:1535020459093,&quot;_id&quot;:&quot;lcVc1nSdaceqS1ut&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>导出成文件以后，你就可以把这个 <code>crontab.db</code> 文件放置到其它机器上并导入成 Cron 定时任务，而不需要在每一台主机上手动设置 Cron 定时任务。总之，在一台机器上设置完，导出，再导入到其他机器，就完事了。</p>\n<h4 id=\"在-Crontab-文件获取-保存-Cron-定时任务\"><a href=\"#在-Crontab-文件获取-保存-Cron-定时任务\" class=\"headerlink\" title=\"在 Crontab 文件获取/保存 Cron 定时任务\"></a>在 Crontab 文件获取/保存 Cron 定时任务</h4><p>你可能在使用 Crontab UI 之前就已经使用 <code>crontab</code> 命令创建过 Cron 定时任务。如果是这样，你可以点击控制台页面上的 “Get from crontab” 按钮来获取已有的 Cron 定时任务。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/08/get-from-crontab.png\" alt=\"\"></p>\n<p>同样地，你也可以使用 Crontab UI 来将新的 Cron 定时任务保存到 Crontab 文件中，只需要点击 “Save to crontab” 按钮就可以了。</p>\n<p>管理 Cron 定时任务并没有想象中那么难，即使是新手使用 Crontab UI 也能轻松管理 Cron 定时任务。赶快开始尝试并发表一下你的看法吧。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/how-to-easily-and-safely-manage-cron-jobs-in-linux/</a></p>\n"},{"title":"如何在 Linux 中查看进程占用的端口号","date":"2018-10-02T04:38:26.000Z","_content":"\n对于 Linux 系统管理员来说，清楚某个服务是否正确地绑定或监听某个端口，是至关重要的。如果你需要处理端口相关的问题，这篇文章可能会对你有用。\n\n端口是 Linux 系统上特定进程之间逻辑连接的标识，包括物理端口和软件端口。由于 Linux 操作系统是一个软件，因此本文只讨论软件端口。软件端口始终与主机的 IP 地址和相关的通信协议相关联，因此端口常用于区分应用程序。大部分涉及到网络的服务都必须打开一个套接字来监听传入的网络请求，而每个服务都使用一个独立的套接字。\n\n**推荐阅读：**\n\n- [在 Linux 上查看进程 ID 的 4 种方法][1]\n- [在 Linux 上终止进程的 3 种方法][2]\n\n套接字是和 IP 地址、软件端口和协议结合起来使用的，而端口号对传输控制协议（TCP）和用户数据报协议（UDP）协议都适用，TCP 和 UDP 都可以使用 0 到 65535 之间的端口号进行通信。\n\n以下是端口分配类别：\n\n  * 0 - 1023： 常用端口和系统端口\n  * 1024 - 49151： 软件的注册端口\n  * 49152 - 65535： 动态端口或私有端口\n\n在 Linux 上的 `/etc/services` 文件可以查看到更多关于保留端口的信息。\n\n```\n# less /etc/services\n# /etc/services:\n# $Id: services,v 1.55 2013/04/14 ovasik Exp $\n#\n# Network services, Internet style\n# IANA services version: last updated 2013-04-10\n#\n# Note that it is presently the policy of IANA to assign a single well-known\n# port number for both TCP and UDP; hence, most entries here have two entries\n# even if the protocol doesn't support UDP operations.\n# Updated from RFC 1700, ``Assigned Numbers'' (October 1994). Not all ports\n# are included, only the more common ones.\n#\n# The latest IANA port assignments can be gotten from\n# http://www.iana.org/assignments/port-numbers\n# The Well Known Ports are those from 0 through 1023.\n# The Registered Ports are those from 1024 through 49151\n# The Dynamic and/or Private Ports are those from 49152 through 65535\n#\n# Each line describes one service, and is of the form:\n#\n# service-name port/protocol [aliases ...] [# comment]\n\ntcpmux 1/tcp # TCP port service multiplexer\ntcpmux 1/udp # TCP port service multiplexer\nrje 5/tcp # Remote Job Entry\nrje 5/udp # Remote Job Entry\necho 7/tcp\necho 7/udp\ndiscard 9/tcp sink null\ndiscard 9/udp sink null\nsystat 11/tcp users\nsystat 11/udp users\ndaytime 13/tcp\ndaytime 13/udp\nqotd 17/tcp quote\nqotd 17/udp quote\nmsp 18/tcp # message send protocol (historic)\nmsp 18/udp # message send protocol (historic)\nchargen 19/tcp ttytst source\nchargen 19/udp ttytst source\nftp-data 20/tcp\nftp-data 20/udp\n# 21 is registered to ftp, but also used by fsp\nftp 21/tcp\nftp 21/udp fsp fspd\nssh 22/tcp # The Secure Shell (SSH) Protocol\nssh 22/udp # The Secure Shell (SSH) Protocol\ntelnet 23/tcp\ntelnet 23/udp\n# 24 - private mail system\nlmtp 24/tcp # LMTP Mail Delivery\nlmtp 24/udp # LMTP Mail Delivery\n```\n\n可以使用以下六种方法查看端口信息。\n\n  * `ss`：可以用于转储套接字统计信息。\n  * `netstat`：可以显示打开的套接字列表。\n  * `lsof`：可以列出打开的文件。\n  * `fuser`：可以列出那些打开了文件的进程的进程 ID。\n  * `nmap`：是网络检测工具和端口扫描程序。\n  * `systemctl`：是 systemd 系统的控制管理器和服务管理器。\n\n以下我们将找出 `sshd` 守护进程所使用的端口号。\n\n### 方法 1：使用 ss 命令\n\n`ss` 一般用于转储套接字统计信息。它能够输出类似于 `netstat` 输出的信息，但它可以比其它工具显示更多的 TCP 信息和状态信息。\n\n它还可以显示所有类型的套接字统计信息，包括 PACKET、TCP、UDP、DCCP、RAW、Unix 域等。\n\n```\n# ss -tnlp | grep ssh\nLISTEN 0 128 *:22 *:* users:((\"sshd\",pid=997,fd=3))\nLISTEN 0 128 :::22 :::* users:((\"sshd\",pid=997,fd=4))\n```\n\n也可以使用端口号来检查。\n\n```\n# ss -tnlp | grep \":22\"\nLISTEN 0 128 *:22 *:* users:((\"sshd\",pid=997,fd=3))\nLISTEN 0 128 :::22 :::* users:((\"sshd\",pid=997,fd=4))\n```\n\n### 方法 2：使用 netstat 命令\n\n`netstat` 能够显示网络连接、路由表、接口统计信息、伪装连接以及多播成员。\n\n默认情况下，`netstat` 会列出打开的套接字。如果不指定任何地址族，则会显示所有已配置地址族的活动套接字。但 `netstat` 已经过时了，一般会使用 `ss` 来替代。\n\n```\n# netstat -tnlp | grep ssh\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 997/sshd\ntcp6 0 0 :::22 :::* LISTEN 997/sshd\n```\n\n也可以使用端口号来检查。\n\n```\n# netstat -tnlp | grep \":22\"\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1208/sshd\ntcp6 0 0 :::22 :::* LISTEN 1208/sshd\n```\n\n### 方法 3：使用 lsof 命令\n\n`lsof` 能够列出打开的文件，并列出系统上被进程打开的文件的相关信息。\n\n```\n# lsof -i -P | grep ssh\nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\nsshd 11584 root 3u IPv4 27625 0t0 TCP *:22 (LISTEN)\nsshd 11584 root 4u IPv6 27627 0t0 TCP *:22 (LISTEN)\nsshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh->103.5.134.167:49902 (ESTABLISHED)\n```\n\n也可以使用端口号来检查。\n\n```\n# lsof -i tcp:22\nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\nsshd 1208 root 3u IPv4 20919 0t0 TCP *:ssh (LISTEN)\nsshd 1208 root 4u IPv6 20921 0t0 TCP *:ssh (LISTEN)\nsshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh->103.5.134.167:49902 (ESTABLISHED)\n```\n\n### 方法 4：使用 fuser 命令\n\n`fuser` 工具会将本地系统上打开了文件的进程的进程 ID 显示在标准输出中。\n\n```\n# fuser -v 22/tcp\n USER PID ACCESS COMMAND\n22/tcp: root 1208 F.... sshd\n root 12388 F.... sshd\n root 49339 F.... sshd\n```\n\n### 方法 5：使用 nmap 命令\n\n`nmap`（“Network Mapper”）是一款用于网络检测和安全审计的开源工具。它最初用于对大型网络进行快速扫描，但它对于单个主机的扫描也有很好的表现。\n\n`nmap` 使用原始 IP 数据包来确定网络上可用的主机，这些主机的服务（包括应用程序名称和版本）、主机运行的操作系统（包括操作系统版本等信息）、正在使用的数据包过滤器或防火墙的类型，以及很多其它信息。\n\n```\n# nmap -sV -p 22 localhost\n\nStarting Nmap 6.40 ( http://nmap.org ) at 2018-09-23 12:36 IST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.000089s latency).\nOther addresses for localhost (not scanned): 127.0.0.1\nPORT STATE SERVICE VERSION\n22/tcp open ssh OpenSSH 7.4 (protocol 2.0)\n\nService detection performed. Please report any incorrect results at http://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 0.44 seconds\n```\n\n### 方法 6：使用 systemctl 命令\n\n`systemctl` 是 systemd 系统的控制管理器和服务管理器。它取代了旧的 SysV 初始化系统管理，目前大多数现代 Linux 操作系统都采用了 systemd。\n\n**推荐阅读：**\n\n- [chkservice – Linux 终端上的 systemd 单元管理工具][3]\n- [如何查看 Linux 系统上正在运行的服务][4]\n\n```\n# systemctl status sshd\n● sshd.service - OpenSSH server daemon\n Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)\n Active: active (running) since Sun 2018-09-23 02:08:56 EDT; 6h 11min ago\n Docs: man:sshd(8)\n man:sshd_config(5)\n Main PID: 11584 (sshd)\n CGroup: /system.slice/sshd.service\n └─11584 /usr/sbin/sshd -D\n\nSep 23 02:08:56 vps.2daygeek.com systemd[1]: Starting OpenSSH server daemon...\nSep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on 0.0.0.0 port 22.\nSep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on :: port 22.\nSep 23 02:08:56 vps.2daygeek.com systemd[1]: Started OpenSSH server daemon.\nSep 23 02:09:15 vps.2daygeek.com sshd[11589]: Connection closed by 103.5.134.167 port 49899 [preauth]\nSep 23 02:09:41 vps.2daygeek.com sshd[11592]: Accepted password for root from 103.5.134.167 port 49902 ssh2\n```\n\n以上输出的内容显示了最近一次启动 `sshd` 服务时 `ssh` 服务的监听端口。但它不会将最新日志更新到输出中。\n\n```\n# systemctl status sshd\n● sshd.service - OpenSSH server daemon\n Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)\n Active: active (running) since Thu 2018-09-06 07:40:59 IST; 2 weeks 3 days ago\n Docs: man:sshd(8)\n man:sshd_config(5)\n Main PID: 1208 (sshd)\n CGroup: /system.slice/sshd.service\n ├─ 1208 /usr/sbin/sshd -D\n ├─23951 sshd: [accepted]\n └─23952 sshd: [net]\n\nSep 23 12:50:36 vps.2daygeek.com sshd[23909]: Invalid user pi from 95.210.113.142 port 51666\nSep 23 12:50:36 vps.2daygeek.com sshd[23909]: input_userauth_request: invalid user pi [preauth]\nSep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): check pass; user unknown\nSep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142\nSep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): check pass; user unknown\nSep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142\nSep 23 12:50:39 vps.2daygeek.com sshd[23911]: Failed password for invalid user pi from 95.210.113.142 port 51670 ssh2\nSep 23 12:50:39 vps.2daygeek.com sshd[23909]: Failed password for invalid user pi from 95.210.113.142 port 51666 ssh2\nSep 23 12:50:40 vps.2daygeek.com sshd[23911]: Connection closed by 95.210.113.142 port 51670 [preauth]\nSep 23 12:50:40 vps.2daygeek.com sshd[23909]: Connection closed by 95.210.113.142 port 51666 [preauth]\n```\n\n大部分情况下，以上的输出不会显示进程的实际端口号。这时更建议使用以下这个 `journalctl` 命令检查日志文件中的详细信息。\n\n```\n# journalctl | grep -i \"openssh\\|sshd\"\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[997]: Received signal 15; terminating.\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Stopping OpenSSH server daemon...\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Starting OpenSSH server daemon...\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on 0.0.0.0 port 22.\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on :: port 22.\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Started OpenSSH server daemon.\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/\n\n[a]: https://www.2daygeek.com/author/prakash/\n[1]: https://www.2daygeek.com/how-to-check-find-the-process-id-pid-ppid-of-a-running-program-in-linux/\n[2]: https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/\n[3]: https://www.2daygeek.com/chkservice-a-tool-for-managing-systemd-units-from-linux-terminal/\n[4]: https://www.2daygeek.com/how-to-check-all-running-services-in-linux/\n\n","source":"_posts/How-To-Find-Out-Which-Port-Number-A-Process-Is-Using-In-Linux.md","raw":"---\ntitle: 如何在 Linux 中查看进程占用的端口号 \ndate: 2018-10-02 12:38:26\ntags:\n  - Linux\n  - 端口\n  - LCTT 翻译\n---\n\n对于 Linux 系统管理员来说，清楚某个服务是否正确地绑定或监听某个端口，是至关重要的。如果你需要处理端口相关的问题，这篇文章可能会对你有用。\n\n端口是 Linux 系统上特定进程之间逻辑连接的标识，包括物理端口和软件端口。由于 Linux 操作系统是一个软件，因此本文只讨论软件端口。软件端口始终与主机的 IP 地址和相关的通信协议相关联，因此端口常用于区分应用程序。大部分涉及到网络的服务都必须打开一个套接字来监听传入的网络请求，而每个服务都使用一个独立的套接字。\n\n**推荐阅读：**\n\n- [在 Linux 上查看进程 ID 的 4 种方法][1]\n- [在 Linux 上终止进程的 3 种方法][2]\n\n套接字是和 IP 地址、软件端口和协议结合起来使用的，而端口号对传输控制协议（TCP）和用户数据报协议（UDP）协议都适用，TCP 和 UDP 都可以使用 0 到 65535 之间的端口号进行通信。\n\n以下是端口分配类别：\n\n  * 0 - 1023： 常用端口和系统端口\n  * 1024 - 49151： 软件的注册端口\n  * 49152 - 65535： 动态端口或私有端口\n\n在 Linux 上的 `/etc/services` 文件可以查看到更多关于保留端口的信息。\n\n```\n# less /etc/services\n# /etc/services:\n# $Id: services,v 1.55 2013/04/14 ovasik Exp $\n#\n# Network services, Internet style\n# IANA services version: last updated 2013-04-10\n#\n# Note that it is presently the policy of IANA to assign a single well-known\n# port number for both TCP and UDP; hence, most entries here have two entries\n# even if the protocol doesn't support UDP operations.\n# Updated from RFC 1700, ``Assigned Numbers'' (October 1994). Not all ports\n# are included, only the more common ones.\n#\n# The latest IANA port assignments can be gotten from\n# http://www.iana.org/assignments/port-numbers\n# The Well Known Ports are those from 0 through 1023.\n# The Registered Ports are those from 1024 through 49151\n# The Dynamic and/or Private Ports are those from 49152 through 65535\n#\n# Each line describes one service, and is of the form:\n#\n# service-name port/protocol [aliases ...] [# comment]\n\ntcpmux 1/tcp # TCP port service multiplexer\ntcpmux 1/udp # TCP port service multiplexer\nrje 5/tcp # Remote Job Entry\nrje 5/udp # Remote Job Entry\necho 7/tcp\necho 7/udp\ndiscard 9/tcp sink null\ndiscard 9/udp sink null\nsystat 11/tcp users\nsystat 11/udp users\ndaytime 13/tcp\ndaytime 13/udp\nqotd 17/tcp quote\nqotd 17/udp quote\nmsp 18/tcp # message send protocol (historic)\nmsp 18/udp # message send protocol (historic)\nchargen 19/tcp ttytst source\nchargen 19/udp ttytst source\nftp-data 20/tcp\nftp-data 20/udp\n# 21 is registered to ftp, but also used by fsp\nftp 21/tcp\nftp 21/udp fsp fspd\nssh 22/tcp # The Secure Shell (SSH) Protocol\nssh 22/udp # The Secure Shell (SSH) Protocol\ntelnet 23/tcp\ntelnet 23/udp\n# 24 - private mail system\nlmtp 24/tcp # LMTP Mail Delivery\nlmtp 24/udp # LMTP Mail Delivery\n```\n\n可以使用以下六种方法查看端口信息。\n\n  * `ss`：可以用于转储套接字统计信息。\n  * `netstat`：可以显示打开的套接字列表。\n  * `lsof`：可以列出打开的文件。\n  * `fuser`：可以列出那些打开了文件的进程的进程 ID。\n  * `nmap`：是网络检测工具和端口扫描程序。\n  * `systemctl`：是 systemd 系统的控制管理器和服务管理器。\n\n以下我们将找出 `sshd` 守护进程所使用的端口号。\n\n### 方法 1：使用 ss 命令\n\n`ss` 一般用于转储套接字统计信息。它能够输出类似于 `netstat` 输出的信息，但它可以比其它工具显示更多的 TCP 信息和状态信息。\n\n它还可以显示所有类型的套接字统计信息，包括 PACKET、TCP、UDP、DCCP、RAW、Unix 域等。\n\n```\n# ss -tnlp | grep ssh\nLISTEN 0 128 *:22 *:* users:((\"sshd\",pid=997,fd=3))\nLISTEN 0 128 :::22 :::* users:((\"sshd\",pid=997,fd=4))\n```\n\n也可以使用端口号来检查。\n\n```\n# ss -tnlp | grep \":22\"\nLISTEN 0 128 *:22 *:* users:((\"sshd\",pid=997,fd=3))\nLISTEN 0 128 :::22 :::* users:((\"sshd\",pid=997,fd=4))\n```\n\n### 方法 2：使用 netstat 命令\n\n`netstat` 能够显示网络连接、路由表、接口统计信息、伪装连接以及多播成员。\n\n默认情况下，`netstat` 会列出打开的套接字。如果不指定任何地址族，则会显示所有已配置地址族的活动套接字。但 `netstat` 已经过时了，一般会使用 `ss` 来替代。\n\n```\n# netstat -tnlp | grep ssh\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 997/sshd\ntcp6 0 0 :::22 :::* LISTEN 997/sshd\n```\n\n也可以使用端口号来检查。\n\n```\n# netstat -tnlp | grep \":22\"\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1208/sshd\ntcp6 0 0 :::22 :::* LISTEN 1208/sshd\n```\n\n### 方法 3：使用 lsof 命令\n\n`lsof` 能够列出打开的文件，并列出系统上被进程打开的文件的相关信息。\n\n```\n# lsof -i -P | grep ssh\nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\nsshd 11584 root 3u IPv4 27625 0t0 TCP *:22 (LISTEN)\nsshd 11584 root 4u IPv6 27627 0t0 TCP *:22 (LISTEN)\nsshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh->103.5.134.167:49902 (ESTABLISHED)\n```\n\n也可以使用端口号来检查。\n\n```\n# lsof -i tcp:22\nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\nsshd 1208 root 3u IPv4 20919 0t0 TCP *:ssh (LISTEN)\nsshd 1208 root 4u IPv6 20921 0t0 TCP *:ssh (LISTEN)\nsshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh->103.5.134.167:49902 (ESTABLISHED)\n```\n\n### 方法 4：使用 fuser 命令\n\n`fuser` 工具会将本地系统上打开了文件的进程的进程 ID 显示在标准输出中。\n\n```\n# fuser -v 22/tcp\n USER PID ACCESS COMMAND\n22/tcp: root 1208 F.... sshd\n root 12388 F.... sshd\n root 49339 F.... sshd\n```\n\n### 方法 5：使用 nmap 命令\n\n`nmap`（“Network Mapper”）是一款用于网络检测和安全审计的开源工具。它最初用于对大型网络进行快速扫描，但它对于单个主机的扫描也有很好的表现。\n\n`nmap` 使用原始 IP 数据包来确定网络上可用的主机，这些主机的服务（包括应用程序名称和版本）、主机运行的操作系统（包括操作系统版本等信息）、正在使用的数据包过滤器或防火墙的类型，以及很多其它信息。\n\n```\n# nmap -sV -p 22 localhost\n\nStarting Nmap 6.40 ( http://nmap.org ) at 2018-09-23 12:36 IST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.000089s latency).\nOther addresses for localhost (not scanned): 127.0.0.1\nPORT STATE SERVICE VERSION\n22/tcp open ssh OpenSSH 7.4 (protocol 2.0)\n\nService detection performed. Please report any incorrect results at http://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 0.44 seconds\n```\n\n### 方法 6：使用 systemctl 命令\n\n`systemctl` 是 systemd 系统的控制管理器和服务管理器。它取代了旧的 SysV 初始化系统管理，目前大多数现代 Linux 操作系统都采用了 systemd。\n\n**推荐阅读：**\n\n- [chkservice – Linux 终端上的 systemd 单元管理工具][3]\n- [如何查看 Linux 系统上正在运行的服务][4]\n\n```\n# systemctl status sshd\n● sshd.service - OpenSSH server daemon\n Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)\n Active: active (running) since Sun 2018-09-23 02:08:56 EDT; 6h 11min ago\n Docs: man:sshd(8)\n man:sshd_config(5)\n Main PID: 11584 (sshd)\n CGroup: /system.slice/sshd.service\n └─11584 /usr/sbin/sshd -D\n\nSep 23 02:08:56 vps.2daygeek.com systemd[1]: Starting OpenSSH server daemon...\nSep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on 0.0.0.0 port 22.\nSep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on :: port 22.\nSep 23 02:08:56 vps.2daygeek.com systemd[1]: Started OpenSSH server daemon.\nSep 23 02:09:15 vps.2daygeek.com sshd[11589]: Connection closed by 103.5.134.167 port 49899 [preauth]\nSep 23 02:09:41 vps.2daygeek.com sshd[11592]: Accepted password for root from 103.5.134.167 port 49902 ssh2\n```\n\n以上输出的内容显示了最近一次启动 `sshd` 服务时 `ssh` 服务的监听端口。但它不会将最新日志更新到输出中。\n\n```\n# systemctl status sshd\n● sshd.service - OpenSSH server daemon\n Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)\n Active: active (running) since Thu 2018-09-06 07:40:59 IST; 2 weeks 3 days ago\n Docs: man:sshd(8)\n man:sshd_config(5)\n Main PID: 1208 (sshd)\n CGroup: /system.slice/sshd.service\n ├─ 1208 /usr/sbin/sshd -D\n ├─23951 sshd: [accepted]\n └─23952 sshd: [net]\n\nSep 23 12:50:36 vps.2daygeek.com sshd[23909]: Invalid user pi from 95.210.113.142 port 51666\nSep 23 12:50:36 vps.2daygeek.com sshd[23909]: input_userauth_request: invalid user pi [preauth]\nSep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): check pass; user unknown\nSep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142\nSep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): check pass; user unknown\nSep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142\nSep 23 12:50:39 vps.2daygeek.com sshd[23911]: Failed password for invalid user pi from 95.210.113.142 port 51670 ssh2\nSep 23 12:50:39 vps.2daygeek.com sshd[23909]: Failed password for invalid user pi from 95.210.113.142 port 51666 ssh2\nSep 23 12:50:40 vps.2daygeek.com sshd[23911]: Connection closed by 95.210.113.142 port 51670 [preauth]\nSep 23 12:50:40 vps.2daygeek.com sshd[23909]: Connection closed by 95.210.113.142 port 51666 [preauth]\n```\n\n大部分情况下，以上的输出不会显示进程的实际端口号。这时更建议使用以下这个 `journalctl` 命令检查日志文件中的详细信息。\n\n```\n# journalctl | grep -i \"openssh\\|sshd\"\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[997]: Received signal 15; terminating.\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Stopping OpenSSH server daemon...\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Starting OpenSSH server daemon...\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on 0.0.0.0 port 22.\nSep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on :: port 22.\nSep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Started OpenSSH server daemon.\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/\n\n[a]: https://www.2daygeek.com/author/prakash/\n[1]: https://www.2daygeek.com/how-to-check-find-the-process-id-pid-ppid-of-a-running-program-in-linux/\n[2]: https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/\n[3]: https://www.2daygeek.com/chkservice-a-tool-for-managing-systemd-units-from-linux-terminal/\n[4]: https://www.2daygeek.com/how-to-check-all-running-services-in-linux/\n\n","slug":"How-To-Find-Out-Which-Port-Number-A-Process-Is-Using-In-Linux","published":1,"updated":"2019-03-28T11:05:20.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cm000wlixuckcucfmg","content":"<p>对于 Linux 系统管理员来说，清楚某个服务是否正确地绑定或监听某个端口，是至关重要的。如果你需要处理端口相关的问题，这篇文章可能会对你有用。</p>\n<p>端口是 Linux 系统上特定进程之间逻辑连接的标识，包括物理端口和软件端口。由于 Linux 操作系统是一个软件，因此本文只讨论软件端口。软件端口始终与主机的 IP 地址和相关的通信协议相关联，因此端口常用于区分应用程序。大部分涉及到网络的服务都必须打开一个套接字来监听传入的网络请求，而每个服务都使用一个独立的套接字。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/how-to-check-find-the-process-id-pid-ppid-of-a-running-program-in-linux/\" target=\"_blank\" rel=\"noopener\">在 Linux 上查看进程 ID 的 4 种方法</a></li>\n<li><a href=\"https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/\" target=\"_blank\" rel=\"noopener\">在 Linux 上终止进程的 3 种方法</a></li>\n</ul>\n<p>套接字是和 IP 地址、软件端口和协议结合起来使用的，而端口号对传输控制协议（TCP）和用户数据报协议（UDP）协议都适用，TCP 和 UDP 都可以使用 0 到 65535 之间的端口号进行通信。</p>\n<p>以下是端口分配类别：</p>\n<ul>\n<li>0 - 1023： 常用端口和系统端口</li>\n<li>1024 - 49151： 软件的注册端口</li>\n<li>49152 - 65535： 动态端口或私有端口</li>\n</ul>\n<p>在 Linux 上的 <code>/etc/services</code> 文件可以查看到更多关于保留端口的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># less /etc/services</span><br><span class=\"line\"># /etc/services:</span><br><span class=\"line\"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class=\"line\">#</span><br><span class=\"line\"># Network services, Internet style</span><br><span class=\"line\"># IANA services version: last updated 2013-04-10</span><br><span class=\"line\">#</span><br><span class=\"line\"># Note that it is presently the policy of IANA to assign a single well-known</span><br><span class=\"line\"># port number for both TCP and UDP; hence, most entries here have two entries</span><br><span class=\"line\"># even if the protocol doesn&apos;t support UDP operations.</span><br><span class=\"line\"># Updated from RFC 1700, ``Assigned Numbers&apos;&apos; (October 1994). Not all ports</span><br><span class=\"line\"># are included, only the more common ones.</span><br><span class=\"line\">#</span><br><span class=\"line\"># The latest IANA port assignments can be gotten from</span><br><span class=\"line\"># http://www.iana.org/assignments/port-numbers</span><br><span class=\"line\"># The Well Known Ports are those from 0 through 1023.</span><br><span class=\"line\"># The Registered Ports are those from 1024 through 49151</span><br><span class=\"line\"># The Dynamic and/or Private Ports are those from 49152 through 65535</span><br><span class=\"line\">#</span><br><span class=\"line\"># Each line describes one service, and is of the form:</span><br><span class=\"line\">#</span><br><span class=\"line\"># service-name port/protocol [aliases ...] [# comment]</span><br><span class=\"line\"></span><br><span class=\"line\">tcpmux 1/tcp # TCP port service multiplexer</span><br><span class=\"line\">tcpmux 1/udp # TCP port service multiplexer</span><br><span class=\"line\">rje 5/tcp # Remote Job Entry</span><br><span class=\"line\">rje 5/udp # Remote Job Entry</span><br><span class=\"line\">echo 7/tcp</span><br><span class=\"line\">echo 7/udp</span><br><span class=\"line\">discard 9/tcp sink null</span><br><span class=\"line\">discard 9/udp sink null</span><br><span class=\"line\">systat 11/tcp users</span><br><span class=\"line\">systat 11/udp users</span><br><span class=\"line\">daytime 13/tcp</span><br><span class=\"line\">daytime 13/udp</span><br><span class=\"line\">qotd 17/tcp quote</span><br><span class=\"line\">qotd 17/udp quote</span><br><span class=\"line\">msp 18/tcp # message send protocol (historic)</span><br><span class=\"line\">msp 18/udp # message send protocol (historic)</span><br><span class=\"line\">chargen 19/tcp ttytst source</span><br><span class=\"line\">chargen 19/udp ttytst source</span><br><span class=\"line\">ftp-data 20/tcp</span><br><span class=\"line\">ftp-data 20/udp</span><br><span class=\"line\"># 21 is registered to ftp, but also used by fsp</span><br><span class=\"line\">ftp 21/tcp</span><br><span class=\"line\">ftp 21/udp fsp fspd</span><br><span class=\"line\">ssh 22/tcp # The Secure Shell (SSH) Protocol</span><br><span class=\"line\">ssh 22/udp # The Secure Shell (SSH) Protocol</span><br><span class=\"line\">telnet 23/tcp</span><br><span class=\"line\">telnet 23/udp</span><br><span class=\"line\"># 24 - private mail system</span><br><span class=\"line\">lmtp 24/tcp # LMTP Mail Delivery</span><br><span class=\"line\">lmtp 24/udp # LMTP Mail Delivery</span><br></pre></td></tr></table></figure>\n<p>可以使用以下六种方法查看端口信息。</p>\n<ul>\n<li><code>ss</code>：可以用于转储套接字统计信息。</li>\n<li><code>netstat</code>：可以显示打开的套接字列表。</li>\n<li><code>lsof</code>：可以列出打开的文件。</li>\n<li><code>fuser</code>：可以列出那些打开了文件的进程的进程 ID。</li>\n<li><code>nmap</code>：是网络检测工具和端口扫描程序。</li>\n<li><code>systemctl</code>：是 systemd 系统的控制管理器和服务管理器。</li>\n</ul>\n<p>以下我们将找出 <code>sshd</code> 守护进程所使用的端口号。</p>\n<h3 id=\"方法-1：使用-ss-命令\"><a href=\"#方法-1：使用-ss-命令\" class=\"headerlink\" title=\"方法 1：使用 ss 命令\"></a>方法 1：使用 ss 命令</h3><p><code>ss</code> 一般用于转储套接字统计信息。它能够输出类似于 <code>netstat</code> 输出的信息，但它可以比其它工具显示更多的 TCP 信息和状态信息。</p>\n<p>它还可以显示所有类型的套接字统计信息，包括 PACKET、TCP、UDP、DCCP、RAW、Unix 域等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ss -tnlp | grep ssh</span><br><span class=\"line\">LISTEN 0 128 *:22 *:* users:((&quot;sshd&quot;,pid=997,fd=3))</span><br><span class=\"line\">LISTEN 0 128 :::22 :::* users:((&quot;sshd&quot;,pid=997,fd=4))</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ss -tnlp | grep &quot;:22&quot;</span><br><span class=\"line\">LISTEN 0 128 *:22 *:* users:((&quot;sshd&quot;,pid=997,fd=3))</span><br><span class=\"line\">LISTEN 0 128 :::22 :::* users:((&quot;sshd&quot;,pid=997,fd=4))</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-2：使用-netstat-命令\"><a href=\"#方法-2：使用-netstat-命令\" class=\"headerlink\" title=\"方法 2：使用 netstat 命令\"></a>方法 2：使用 netstat 命令</h3><p><code>netstat</code> 能够显示网络连接、路由表、接口统计信息、伪装连接以及多播成员。</p>\n<p>默认情况下，<code>netstat</code> 会列出打开的套接字。如果不指定任何地址族，则会显示所有已配置地址族的活动套接字。但 <code>netstat</code> 已经过时了，一般会使用 <code>ss</code> 来替代。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># netstat -tnlp | grep ssh</span><br><span class=\"line\">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 997/sshd</span><br><span class=\"line\">tcp6 0 0 :::22 :::* LISTEN 997/sshd</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># netstat -tnlp | grep &quot;:22&quot;</span><br><span class=\"line\">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1208/sshd</span><br><span class=\"line\">tcp6 0 0 :::22 :::* LISTEN 1208/sshd</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-3：使用-lsof-命令\"><a href=\"#方法-3：使用-lsof-命令\" class=\"headerlink\" title=\"方法 3：使用 lsof 命令\"></a>方法 3：使用 lsof 命令</h3><p><code>lsof</code> 能够列出打开的文件，并列出系统上被进程打开的文件的相关信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsof -i -P | grep ssh</span><br><span class=\"line\">COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd 11584 root 3u IPv4 27625 0t0 TCP *:22 (LISTEN)</span><br><span class=\"line\">sshd 11584 root 4u IPv6 27627 0t0 TCP *:22 (LISTEN)</span><br><span class=\"line\">sshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh-&gt;103.5.134.167:49902 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsof -i tcp:22</span><br><span class=\"line\">COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd 1208 root 3u IPv4 20919 0t0 TCP *:ssh (LISTEN)</span><br><span class=\"line\">sshd 1208 root 4u IPv6 20921 0t0 TCP *:ssh (LISTEN)</span><br><span class=\"line\">sshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh-&gt;103.5.134.167:49902 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-4：使用-fuser-命令\"><a href=\"#方法-4：使用-fuser-命令\" class=\"headerlink\" title=\"方法 4：使用 fuser 命令\"></a>方法 4：使用 fuser 命令</h3><p><code>fuser</code> 工具会将本地系统上打开了文件的进程的进程 ID 显示在标准输出中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fuser -v 22/tcp</span><br><span class=\"line\"> USER PID ACCESS COMMAND</span><br><span class=\"line\">22/tcp: root 1208 F.... sshd</span><br><span class=\"line\"> root 12388 F.... sshd</span><br><span class=\"line\"> root 49339 F.... sshd</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-5：使用-nmap-命令\"><a href=\"#方法-5：使用-nmap-命令\" class=\"headerlink\" title=\"方法 5：使用 nmap 命令\"></a>方法 5：使用 nmap 命令</h3><p><code>nmap</code>（“Network Mapper”）是一款用于网络检测和安全审计的开源工具。它最初用于对大型网络进行快速扫描，但它对于单个主机的扫描也有很好的表现。</p>\n<p><code>nmap</code> 使用原始 IP 数据包来确定网络上可用的主机，这些主机的服务（包括应用程序名称和版本）、主机运行的操作系统（包括操作系统版本等信息）、正在使用的数据包过滤器或防火墙的类型，以及很多其它信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># nmap -sV -p 22 localhost</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Nmap 6.40 ( http://nmap.org ) at 2018-09-23 12:36 IST</span><br><span class=\"line\">Nmap scan report for localhost (127.0.0.1)</span><br><span class=\"line\">Host is up (0.000089s latency).</span><br><span class=\"line\">Other addresses for localhost (not scanned): 127.0.0.1</span><br><span class=\"line\">PORT STATE SERVICE VERSION</span><br><span class=\"line\">22/tcp open ssh OpenSSH 7.4 (protocol 2.0)</span><br><span class=\"line\"></span><br><span class=\"line\">Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .</span><br><span class=\"line\">Nmap done: 1 IP address (1 host up) scanned in 0.44 seconds</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-6：使用-systemctl-命令\"><a href=\"#方法-6：使用-systemctl-命令\" class=\"headerlink\" title=\"方法 6：使用 systemctl 命令\"></a>方法 6：使用 systemctl 命令</h3><p><code>systemctl</code> 是 systemd 系统的控制管理器和服务管理器。它取代了旧的 SysV 初始化系统管理，目前大多数现代 Linux 操作系统都采用了 systemd。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/chkservice-a-tool-for-managing-systemd-units-from-linux-terminal/\" target=\"_blank\" rel=\"noopener\">chkservice – Linux 终端上的 systemd 单元管理工具</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-check-all-running-services-in-linux/\" target=\"_blank\" rel=\"noopener\">如何查看 Linux 系统上正在运行的服务</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl status sshd</span><br><span class=\"line\">● sshd.service - OpenSSH server daemon</span><br><span class=\"line\"> Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\"> Active: active (running) since Sun 2018-09-23 02:08:56 EDT; 6h 11min ago</span><br><span class=\"line\"> Docs: man:sshd(8)</span><br><span class=\"line\"> man:sshd_config(5)</span><br><span class=\"line\"> Main PID: 11584 (sshd)</span><br><span class=\"line\"> CGroup: /system.slice/sshd.service</span><br><span class=\"line\"> └─11584 /usr/sbin/sshd -D</span><br><span class=\"line\"></span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com systemd[1]: Starting OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on 0.0.0.0 port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on :: port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com systemd[1]: Started OpenSSH server daemon.</span><br><span class=\"line\">Sep 23 02:09:15 vps.2daygeek.com sshd[11589]: Connection closed by 103.5.134.167 port 49899 [preauth]</span><br><span class=\"line\">Sep 23 02:09:41 vps.2daygeek.com sshd[11592]: Accepted password for root from 103.5.134.167 port 49902 ssh2</span><br></pre></td></tr></table></figure>\n<p>以上输出的内容显示了最近一次启动 <code>sshd</code> 服务时 <code>ssh</code> 服务的监听端口。但它不会将最新日志更新到输出中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl status sshd</span><br><span class=\"line\">● sshd.service - OpenSSH server daemon</span><br><span class=\"line\"> Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\"> Active: active (running) since Thu 2018-09-06 07:40:59 IST; 2 weeks 3 days ago</span><br><span class=\"line\"> Docs: man:sshd(8)</span><br><span class=\"line\"> man:sshd_config(5)</span><br><span class=\"line\"> Main PID: 1208 (sshd)</span><br><span class=\"line\"> CGroup: /system.slice/sshd.service</span><br><span class=\"line\"> ├─ 1208 /usr/sbin/sshd -D</span><br><span class=\"line\"> ├─23951 sshd: [accepted]</span><br><span class=\"line\"> └─23952 sshd: [net]</span><br><span class=\"line\"></span><br><span class=\"line\">Sep 23 12:50:36 vps.2daygeek.com sshd[23909]: Invalid user pi from 95.210.113.142 port 51666</span><br><span class=\"line\">Sep 23 12:50:36 vps.2daygeek.com sshd[23909]: input_userauth_request: invalid user pi [preauth]</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): check pass; user unknown</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): check pass; user unknown</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142</span><br><span class=\"line\">Sep 23 12:50:39 vps.2daygeek.com sshd[23911]: Failed password for invalid user pi from 95.210.113.142 port 51670 ssh2</span><br><span class=\"line\">Sep 23 12:50:39 vps.2daygeek.com sshd[23909]: Failed password for invalid user pi from 95.210.113.142 port 51666 ssh2</span><br><span class=\"line\">Sep 23 12:50:40 vps.2daygeek.com sshd[23911]: Connection closed by 95.210.113.142 port 51670 [preauth]</span><br><span class=\"line\">Sep 23 12:50:40 vps.2daygeek.com sshd[23909]: Connection closed by 95.210.113.142 port 51666 [preauth]</span><br></pre></td></tr></table></figure>\n<p>大部分情况下，以上的输出不会显示进程的实际端口号。这时更建议使用以下这个 <code>journalctl</code> 命令检查日志文件中的详细信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># journalctl | grep -i &quot;openssh\\|sshd&quot;</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[997]: Received signal 15; terminating.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Stopping OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Starting OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on 0.0.0.0 port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on :: port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Started OpenSSH server daemon.</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于 Linux 系统管理员来说，清楚某个服务是否正确地绑定或监听某个端口，是至关重要的。如果你需要处理端口相关的问题，这篇文章可能会对你有用。</p>\n<p>端口是 Linux 系统上特定进程之间逻辑连接的标识，包括物理端口和软件端口。由于 Linux 操作系统是一个软件，因此本文只讨论软件端口。软件端口始终与主机的 IP 地址和相关的通信协议相关联，因此端口常用于区分应用程序。大部分涉及到网络的服务都必须打开一个套接字来监听传入的网络请求，而每个服务都使用一个独立的套接字。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/how-to-check-find-the-process-id-pid-ppid-of-a-running-program-in-linux/\" target=\"_blank\" rel=\"noopener\">在 Linux 上查看进程 ID 的 4 种方法</a></li>\n<li><a href=\"https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/\" target=\"_blank\" rel=\"noopener\">在 Linux 上终止进程的 3 种方法</a></li>\n</ul>\n<p>套接字是和 IP 地址、软件端口和协议结合起来使用的，而端口号对传输控制协议（TCP）和用户数据报协议（UDP）协议都适用，TCP 和 UDP 都可以使用 0 到 65535 之间的端口号进行通信。</p>\n<p>以下是端口分配类别：</p>\n<ul>\n<li>0 - 1023： 常用端口和系统端口</li>\n<li>1024 - 49151： 软件的注册端口</li>\n<li>49152 - 65535： 动态端口或私有端口</li>\n</ul>\n<p>在 Linux 上的 <code>/etc/services</code> 文件可以查看到更多关于保留端口的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># less /etc/services</span><br><span class=\"line\"># /etc/services:</span><br><span class=\"line\"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class=\"line\">#</span><br><span class=\"line\"># Network services, Internet style</span><br><span class=\"line\"># IANA services version: last updated 2013-04-10</span><br><span class=\"line\">#</span><br><span class=\"line\"># Note that it is presently the policy of IANA to assign a single well-known</span><br><span class=\"line\"># port number for both TCP and UDP; hence, most entries here have two entries</span><br><span class=\"line\"># even if the protocol doesn&apos;t support UDP operations.</span><br><span class=\"line\"># Updated from RFC 1700, ``Assigned Numbers&apos;&apos; (October 1994). Not all ports</span><br><span class=\"line\"># are included, only the more common ones.</span><br><span class=\"line\">#</span><br><span class=\"line\"># The latest IANA port assignments can be gotten from</span><br><span class=\"line\"># http://www.iana.org/assignments/port-numbers</span><br><span class=\"line\"># The Well Known Ports are those from 0 through 1023.</span><br><span class=\"line\"># The Registered Ports are those from 1024 through 49151</span><br><span class=\"line\"># The Dynamic and/or Private Ports are those from 49152 through 65535</span><br><span class=\"line\">#</span><br><span class=\"line\"># Each line describes one service, and is of the form:</span><br><span class=\"line\">#</span><br><span class=\"line\"># service-name port/protocol [aliases ...] [# comment]</span><br><span class=\"line\"></span><br><span class=\"line\">tcpmux 1/tcp # TCP port service multiplexer</span><br><span class=\"line\">tcpmux 1/udp # TCP port service multiplexer</span><br><span class=\"line\">rje 5/tcp # Remote Job Entry</span><br><span class=\"line\">rje 5/udp # Remote Job Entry</span><br><span class=\"line\">echo 7/tcp</span><br><span class=\"line\">echo 7/udp</span><br><span class=\"line\">discard 9/tcp sink null</span><br><span class=\"line\">discard 9/udp sink null</span><br><span class=\"line\">systat 11/tcp users</span><br><span class=\"line\">systat 11/udp users</span><br><span class=\"line\">daytime 13/tcp</span><br><span class=\"line\">daytime 13/udp</span><br><span class=\"line\">qotd 17/tcp quote</span><br><span class=\"line\">qotd 17/udp quote</span><br><span class=\"line\">msp 18/tcp # message send protocol (historic)</span><br><span class=\"line\">msp 18/udp # message send protocol (historic)</span><br><span class=\"line\">chargen 19/tcp ttytst source</span><br><span class=\"line\">chargen 19/udp ttytst source</span><br><span class=\"line\">ftp-data 20/tcp</span><br><span class=\"line\">ftp-data 20/udp</span><br><span class=\"line\"># 21 is registered to ftp, but also used by fsp</span><br><span class=\"line\">ftp 21/tcp</span><br><span class=\"line\">ftp 21/udp fsp fspd</span><br><span class=\"line\">ssh 22/tcp # The Secure Shell (SSH) Protocol</span><br><span class=\"line\">ssh 22/udp # The Secure Shell (SSH) Protocol</span><br><span class=\"line\">telnet 23/tcp</span><br><span class=\"line\">telnet 23/udp</span><br><span class=\"line\"># 24 - private mail system</span><br><span class=\"line\">lmtp 24/tcp # LMTP Mail Delivery</span><br><span class=\"line\">lmtp 24/udp # LMTP Mail Delivery</span><br></pre></td></tr></table></figure>\n<p>可以使用以下六种方法查看端口信息。</p>\n<ul>\n<li><code>ss</code>：可以用于转储套接字统计信息。</li>\n<li><code>netstat</code>：可以显示打开的套接字列表。</li>\n<li><code>lsof</code>：可以列出打开的文件。</li>\n<li><code>fuser</code>：可以列出那些打开了文件的进程的进程 ID。</li>\n<li><code>nmap</code>：是网络检测工具和端口扫描程序。</li>\n<li><code>systemctl</code>：是 systemd 系统的控制管理器和服务管理器。</li>\n</ul>\n<p>以下我们将找出 <code>sshd</code> 守护进程所使用的端口号。</p>\n<h3 id=\"方法-1：使用-ss-命令\"><a href=\"#方法-1：使用-ss-命令\" class=\"headerlink\" title=\"方法 1：使用 ss 命令\"></a>方法 1：使用 ss 命令</h3><p><code>ss</code> 一般用于转储套接字统计信息。它能够输出类似于 <code>netstat</code> 输出的信息，但它可以比其它工具显示更多的 TCP 信息和状态信息。</p>\n<p>它还可以显示所有类型的套接字统计信息，包括 PACKET、TCP、UDP、DCCP、RAW、Unix 域等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ss -tnlp | grep ssh</span><br><span class=\"line\">LISTEN 0 128 *:22 *:* users:((&quot;sshd&quot;,pid=997,fd=3))</span><br><span class=\"line\">LISTEN 0 128 :::22 :::* users:((&quot;sshd&quot;,pid=997,fd=4))</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ss -tnlp | grep &quot;:22&quot;</span><br><span class=\"line\">LISTEN 0 128 *:22 *:* users:((&quot;sshd&quot;,pid=997,fd=3))</span><br><span class=\"line\">LISTEN 0 128 :::22 :::* users:((&quot;sshd&quot;,pid=997,fd=4))</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-2：使用-netstat-命令\"><a href=\"#方法-2：使用-netstat-命令\" class=\"headerlink\" title=\"方法 2：使用 netstat 命令\"></a>方法 2：使用 netstat 命令</h3><p><code>netstat</code> 能够显示网络连接、路由表、接口统计信息、伪装连接以及多播成员。</p>\n<p>默认情况下，<code>netstat</code> 会列出打开的套接字。如果不指定任何地址族，则会显示所有已配置地址族的活动套接字。但 <code>netstat</code> 已经过时了，一般会使用 <code>ss</code> 来替代。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># netstat -tnlp | grep ssh</span><br><span class=\"line\">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 997/sshd</span><br><span class=\"line\">tcp6 0 0 :::22 :::* LISTEN 997/sshd</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># netstat -tnlp | grep &quot;:22&quot;</span><br><span class=\"line\">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1208/sshd</span><br><span class=\"line\">tcp6 0 0 :::22 :::* LISTEN 1208/sshd</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-3：使用-lsof-命令\"><a href=\"#方法-3：使用-lsof-命令\" class=\"headerlink\" title=\"方法 3：使用 lsof 命令\"></a>方法 3：使用 lsof 命令</h3><p><code>lsof</code> 能够列出打开的文件，并列出系统上被进程打开的文件的相关信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsof -i -P | grep ssh</span><br><span class=\"line\">COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd 11584 root 3u IPv4 27625 0t0 TCP *:22 (LISTEN)</span><br><span class=\"line\">sshd 11584 root 4u IPv6 27627 0t0 TCP *:22 (LISTEN)</span><br><span class=\"line\">sshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh-&gt;103.5.134.167:49902 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n<p>也可以使用端口号来检查。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># lsof -i tcp:22</span><br><span class=\"line\">COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd 1208 root 3u IPv4 20919 0t0 TCP *:ssh (LISTEN)</span><br><span class=\"line\">sshd 1208 root 4u IPv6 20921 0t0 TCP *:ssh (LISTEN)</span><br><span class=\"line\">sshd 11592 root 3u IPv4 27744 0t0 TCP vps.2daygeek.com:ssh-&gt;103.5.134.167:49902 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-4：使用-fuser-命令\"><a href=\"#方法-4：使用-fuser-命令\" class=\"headerlink\" title=\"方法 4：使用 fuser 命令\"></a>方法 4：使用 fuser 命令</h3><p><code>fuser</code> 工具会将本地系统上打开了文件的进程的进程 ID 显示在标准输出中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fuser -v 22/tcp</span><br><span class=\"line\"> USER PID ACCESS COMMAND</span><br><span class=\"line\">22/tcp: root 1208 F.... sshd</span><br><span class=\"line\"> root 12388 F.... sshd</span><br><span class=\"line\"> root 49339 F.... sshd</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-5：使用-nmap-命令\"><a href=\"#方法-5：使用-nmap-命令\" class=\"headerlink\" title=\"方法 5：使用 nmap 命令\"></a>方法 5：使用 nmap 命令</h3><p><code>nmap</code>（“Network Mapper”）是一款用于网络检测和安全审计的开源工具。它最初用于对大型网络进行快速扫描，但它对于单个主机的扫描也有很好的表现。</p>\n<p><code>nmap</code> 使用原始 IP 数据包来确定网络上可用的主机，这些主机的服务（包括应用程序名称和版本）、主机运行的操作系统（包括操作系统版本等信息）、正在使用的数据包过滤器或防火墙的类型，以及很多其它信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># nmap -sV -p 22 localhost</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Nmap 6.40 ( http://nmap.org ) at 2018-09-23 12:36 IST</span><br><span class=\"line\">Nmap scan report for localhost (127.0.0.1)</span><br><span class=\"line\">Host is up (0.000089s latency).</span><br><span class=\"line\">Other addresses for localhost (not scanned): 127.0.0.1</span><br><span class=\"line\">PORT STATE SERVICE VERSION</span><br><span class=\"line\">22/tcp open ssh OpenSSH 7.4 (protocol 2.0)</span><br><span class=\"line\"></span><br><span class=\"line\">Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .</span><br><span class=\"line\">Nmap done: 1 IP address (1 host up) scanned in 0.44 seconds</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法-6：使用-systemctl-命令\"><a href=\"#方法-6：使用-systemctl-命令\" class=\"headerlink\" title=\"方法 6：使用 systemctl 命令\"></a>方法 6：使用 systemctl 命令</h3><p><code>systemctl</code> 是 systemd 系统的控制管理器和服务管理器。它取代了旧的 SysV 初始化系统管理，目前大多数现代 Linux 操作系统都采用了 systemd。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/chkservice-a-tool-for-managing-systemd-units-from-linux-terminal/\" target=\"_blank\" rel=\"noopener\">chkservice – Linux 终端上的 systemd 单元管理工具</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-check-all-running-services-in-linux/\" target=\"_blank\" rel=\"noopener\">如何查看 Linux 系统上正在运行的服务</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl status sshd</span><br><span class=\"line\">● sshd.service - OpenSSH server daemon</span><br><span class=\"line\"> Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\"> Active: active (running) since Sun 2018-09-23 02:08:56 EDT; 6h 11min ago</span><br><span class=\"line\"> Docs: man:sshd(8)</span><br><span class=\"line\"> man:sshd_config(5)</span><br><span class=\"line\"> Main PID: 11584 (sshd)</span><br><span class=\"line\"> CGroup: /system.slice/sshd.service</span><br><span class=\"line\"> └─11584 /usr/sbin/sshd -D</span><br><span class=\"line\"></span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com systemd[1]: Starting OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on 0.0.0.0 port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com sshd[11584]: Server listening on :: port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps.2daygeek.com systemd[1]: Started OpenSSH server daemon.</span><br><span class=\"line\">Sep 23 02:09:15 vps.2daygeek.com sshd[11589]: Connection closed by 103.5.134.167 port 49899 [preauth]</span><br><span class=\"line\">Sep 23 02:09:41 vps.2daygeek.com sshd[11592]: Accepted password for root from 103.5.134.167 port 49902 ssh2</span><br></pre></td></tr></table></figure>\n<p>以上输出的内容显示了最近一次启动 <code>sshd</code> 服务时 <code>ssh</code> 服务的监听端口。但它不会将最新日志更新到输出中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl status sshd</span><br><span class=\"line\">● sshd.service - OpenSSH server daemon</span><br><span class=\"line\"> Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\"> Active: active (running) since Thu 2018-09-06 07:40:59 IST; 2 weeks 3 days ago</span><br><span class=\"line\"> Docs: man:sshd(8)</span><br><span class=\"line\"> man:sshd_config(5)</span><br><span class=\"line\"> Main PID: 1208 (sshd)</span><br><span class=\"line\"> CGroup: /system.slice/sshd.service</span><br><span class=\"line\"> ├─ 1208 /usr/sbin/sshd -D</span><br><span class=\"line\"> ├─23951 sshd: [accepted]</span><br><span class=\"line\"> └─23952 sshd: [net]</span><br><span class=\"line\"></span><br><span class=\"line\">Sep 23 12:50:36 vps.2daygeek.com sshd[23909]: Invalid user pi from 95.210.113.142 port 51666</span><br><span class=\"line\">Sep 23 12:50:36 vps.2daygeek.com sshd[23909]: input_userauth_request: invalid user pi [preauth]</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): check pass; user unknown</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23911]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): check pass; user unknown</span><br><span class=\"line\">Sep 23 12:50:37 vps.2daygeek.com sshd[23909]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=95.210.113.142</span><br><span class=\"line\">Sep 23 12:50:39 vps.2daygeek.com sshd[23911]: Failed password for invalid user pi from 95.210.113.142 port 51670 ssh2</span><br><span class=\"line\">Sep 23 12:50:39 vps.2daygeek.com sshd[23909]: Failed password for invalid user pi from 95.210.113.142 port 51666 ssh2</span><br><span class=\"line\">Sep 23 12:50:40 vps.2daygeek.com sshd[23911]: Connection closed by 95.210.113.142 port 51670 [preauth]</span><br><span class=\"line\">Sep 23 12:50:40 vps.2daygeek.com sshd[23909]: Connection closed by 95.210.113.142 port 51666 [preauth]</span><br></pre></td></tr></table></figure>\n<p>大部分情况下，以上的输出不会显示进程的实际端口号。这时更建议使用以下这个 <code>journalctl</code> 命令检查日志文件中的详细信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># journalctl | grep -i &quot;openssh\\|sshd&quot;</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[997]: Received signal 15; terminating.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Stopping OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Starting OpenSSH server daemon...</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on 0.0.0.0 port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca sshd[11584]: Server listening on :: port 22.</span><br><span class=\"line\">Sep 23 02:08:56 vps138235.vps.ovh.ca systemd[1]: Started OpenSSH server daemon.</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/how-to-find-out-which-port-number-a-process-is-using-in-linux/</a></p>\n"},{"title":"在 Linux 中使用 Wondershaper 限制网络带宽","date":"2018-10-05T10:53:24.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/Wondershaper-1-720x340.jpg)\n\n以下内容将向你介绍如何轻松对网络带宽做出限制，并在类 Unix 操作系统中对网络流量进行优化。通过限制网络带宽，可以节省应用程序不必要的带宽消耗，包括软件包管理器（pacman、yum、apt）、web 浏览器、torrent 客户端、下载管理器等，并防止单个或多个用户滥用网络带宽。在本文当中，将会介绍 Wondershaper 这一个实用的命令行程序，这是我认为限制 Linux 系统 Internet 或本地网络带宽的最简单、最快捷的方式之一。\n\n请注意，Wondershaper 只能限制本地网络接口的传入和传出流量，而不能限制路由器或调制解调器的接口。换句话说，Wondershaper 只会限制本地系统本身的网络带宽，而不会限制网络中的其它系统。因此 Wondershaper 主要用于限制本地系统中一个或多个网卡的带宽。\n\n下面来看一下 Wondershaper 是如何优化网络流量的。\n\n### 在 Linux 中使用 Wondershaper 限制网络带宽\n\n`wondershaper` 是用于显示系统网卡网络带宽的简单脚本。它使用了 iproute 的 `tc` 命令，但大大简化了操作过程。\n\n#### 安装 Wondershaper\n\n使用 `git clone` 克隆 Wondershaper 的版本库就可以安装最新版本：\n\n```\n$ git clone https://github.com/magnific0/wondershaper.git\n```\n\n按照以下命令进入 `wondershaper` 目录并安装：\n\n```\n$ cd wondershaper\n$ sudo make install\n```\n\n然后执行以下命令，可以让 `wondershaper` 在每次系统启动时都自动开始服务：\n\n```\n$ sudo systemctl enable wondershaper.service\n$ sudo systemctl start wondershaper.service\n```\n\n如果你不强求安装最新版本，也可以使用软件包管理器（官方和非官方均可）来进行安装。\n\n`wondershaper` 在 [Arch 用户软件仓库][1]（Arch User Repository，AUR）中可用，所以可以使用类似 [yay][2] 这些 AUR 辅助软件在基于 Arch 的系统中安装 `wondershaper` 。\n\n```\n$ yay -S wondershaper-git\n```\n\n对于 Debian、Ubuntu 和 Linux Mint 可以使用以下命令安装：\n\n```\n$ sudo apt-get install wondershaper\n```\n\n对于 Fedora 可以使用以下命令安装：\n\n```\n$ sudo dnf install wondershaper\n```\n\n对于 RHEL、CentOS，只需要启用 EPEL 仓库，就可以使用以下命令安装：\n\n```\n$ sudo yum install epel-release\n$ sudo yum install wondershaper\n```\n\n在每次系统启动时都自动启动 `wondershaper` 服务。\n\n```\n$ sudo systemctl enable wondershaper.service\n$ sudo systemctl start wondershaper.service\n```\n\n#### 用法\n\n首先需要找到网络接口的名称，通过以下几个命令都可以查询到网卡的详细信息：\n\n```\n$ ip addr\n$ route\n$ ifconfig\n```\n\n在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\n\n```\n$ sudo wondershaper -a <adapter> -d <rate> -u <rate>\n```\n\n例如，如果网卡名称是 `enp0s8`，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\n\n```\n$ sudo wondershaper -a enp0s8 -d 1024 -u 512\n```\n\n其中参数的含义是：\n\n  * `-a`：网卡名称\n  * `-d`：下行带宽\n  * `-u`：上行带宽\n\n如果要对网卡解除网络带宽的限制，只需要执行：\n\n```\n$ sudo wondershaper -c -a enp0s8\n```\n\n或者：\n\n```\n$ sudo wondershaper -c enp0s8\n```\n\n如果系统中有多个网卡，为确保稳妥，需要按照上面的方法手动设置每个网卡的上行、下行速率。\n\n如果你是通过 `git clone` 克隆 GitHub 版本库的方式安装 Wondershaper，那么在 `/etc/conf.d/` 目录中会存在一个名为 `wondershaper.conf` 的配置文件，修改这个配置文件中的相应值（包括网卡名称、上行速率、下行速率），也可以设置上行或下行速率。\n\n```\n$ sudo nano /etc/conf.d/wondershaper.conf\n\n[wondershaper]\n# Adapter\n#\nIFACE=\"eth0\"\n\n# Download rate in Kbps\n#\nDSPEED=\"2048\"\n\n# Upload rate in Kbps\n#\nUSPEED=\"512\"\n```\n\nWondershaper 使用前：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-1.png)\n\nWondershaper 使用后：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-2.png)\n\n可以看到，使用 Wondershaper 限制网络带宽之后，下行速率与限制之前相比已经大幅下降。\n\n执行以下命令可以查看更多相关信息。\n\n```\n$ wondershaper -h\n```\n\n也可以查看 Wondershaper 的用户手册：\n\n```\n$ man wondershaper\n```\n\n根据测试，Wondershaper 按照上面的方式可以有很好的效果。你可以试用一下，然后发表你的看法。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/\n\n[a]: https://www.ostechnix.com/author/sk/\n[1]: https://aur.archlinux.org/packages/wondershaper-git/\n[2]: https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\n\n","source":"_posts/How-To-Limit-Network-Bandwidth-In-Linux-Using-Wondershaper.md","raw":"---\ntitle: 在 Linux 中使用 Wondershaper 限制网络带宽\ndate: 2018-10-05 18:53:24\ntags:\n  - Linux\n  - 网络\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/Wondershaper-1-720x340.jpg)\n\n以下内容将向你介绍如何轻松对网络带宽做出限制，并在类 Unix 操作系统中对网络流量进行优化。通过限制网络带宽，可以节省应用程序不必要的带宽消耗，包括软件包管理器（pacman、yum、apt）、web 浏览器、torrent 客户端、下载管理器等，并防止单个或多个用户滥用网络带宽。在本文当中，将会介绍 Wondershaper 这一个实用的命令行程序，这是我认为限制 Linux 系统 Internet 或本地网络带宽的最简单、最快捷的方式之一。\n\n请注意，Wondershaper 只能限制本地网络接口的传入和传出流量，而不能限制路由器或调制解调器的接口。换句话说，Wondershaper 只会限制本地系统本身的网络带宽，而不会限制网络中的其它系统。因此 Wondershaper 主要用于限制本地系统中一个或多个网卡的带宽。\n\n下面来看一下 Wondershaper 是如何优化网络流量的。\n\n### 在 Linux 中使用 Wondershaper 限制网络带宽\n\n`wondershaper` 是用于显示系统网卡网络带宽的简单脚本。它使用了 iproute 的 `tc` 命令，但大大简化了操作过程。\n\n#### 安装 Wondershaper\n\n使用 `git clone` 克隆 Wondershaper 的版本库就可以安装最新版本：\n\n```\n$ git clone https://github.com/magnific0/wondershaper.git\n```\n\n按照以下命令进入 `wondershaper` 目录并安装：\n\n```\n$ cd wondershaper\n$ sudo make install\n```\n\n然后执行以下命令，可以让 `wondershaper` 在每次系统启动时都自动开始服务：\n\n```\n$ sudo systemctl enable wondershaper.service\n$ sudo systemctl start wondershaper.service\n```\n\n如果你不强求安装最新版本，也可以使用软件包管理器（官方和非官方均可）来进行安装。\n\n`wondershaper` 在 [Arch 用户软件仓库][1]（Arch User Repository，AUR）中可用，所以可以使用类似 [yay][2] 这些 AUR 辅助软件在基于 Arch 的系统中安装 `wondershaper` 。\n\n```\n$ yay -S wondershaper-git\n```\n\n对于 Debian、Ubuntu 和 Linux Mint 可以使用以下命令安装：\n\n```\n$ sudo apt-get install wondershaper\n```\n\n对于 Fedora 可以使用以下命令安装：\n\n```\n$ sudo dnf install wondershaper\n```\n\n对于 RHEL、CentOS，只需要启用 EPEL 仓库，就可以使用以下命令安装：\n\n```\n$ sudo yum install epel-release\n$ sudo yum install wondershaper\n```\n\n在每次系统启动时都自动启动 `wondershaper` 服务。\n\n```\n$ sudo systemctl enable wondershaper.service\n$ sudo systemctl start wondershaper.service\n```\n\n#### 用法\n\n首先需要找到网络接口的名称，通过以下几个命令都可以查询到网卡的详细信息：\n\n```\n$ ip addr\n$ route\n$ ifconfig\n```\n\n在确定网卡名称以后，就可以按照以下的命令限制网络带宽：\n\n```\n$ sudo wondershaper -a <adapter> -d <rate> -u <rate>\n```\n\n例如，如果网卡名称是 `enp0s8`，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：\n\n```\n$ sudo wondershaper -a enp0s8 -d 1024 -u 512\n```\n\n其中参数的含义是：\n\n  * `-a`：网卡名称\n  * `-d`：下行带宽\n  * `-u`：上行带宽\n\n如果要对网卡解除网络带宽的限制，只需要执行：\n\n```\n$ sudo wondershaper -c -a enp0s8\n```\n\n或者：\n\n```\n$ sudo wondershaper -c enp0s8\n```\n\n如果系统中有多个网卡，为确保稳妥，需要按照上面的方法手动设置每个网卡的上行、下行速率。\n\n如果你是通过 `git clone` 克隆 GitHub 版本库的方式安装 Wondershaper，那么在 `/etc/conf.d/` 目录中会存在一个名为 `wondershaper.conf` 的配置文件，修改这个配置文件中的相应值（包括网卡名称、上行速率、下行速率），也可以设置上行或下行速率。\n\n```\n$ sudo nano /etc/conf.d/wondershaper.conf\n\n[wondershaper]\n# Adapter\n#\nIFACE=\"eth0\"\n\n# Download rate in Kbps\n#\nDSPEED=\"2048\"\n\n# Upload rate in Kbps\n#\nUSPEED=\"512\"\n```\n\nWondershaper 使用前：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-1.png)\n\nWondershaper 使用后：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-2.png)\n\n可以看到，使用 Wondershaper 限制网络带宽之后，下行速率与限制之前相比已经大幅下降。\n\n执行以下命令可以查看更多相关信息。\n\n```\n$ wondershaper -h\n```\n\n也可以查看 Wondershaper 的用户手册：\n\n```\n$ man wondershaper\n```\n\n根据测试，Wondershaper 按照上面的方式可以有很好的效果。你可以试用一下，然后发表你的看法。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/\n\n[a]: https://www.ostechnix.com/author/sk/\n[1]: https://aur.archlinux.org/packages/wondershaper-git/\n[2]: https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\n\n","slug":"How-To-Limit-Network-Bandwidth-In-Linux-Using-Wondershaper","published":1,"updated":"2019-03-28T11:12:42.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cn000xlixu9ap949ky","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/Wondershaper-1-720x340.jpg\" alt=\"\"></p>\n<p>以下内容将向你介绍如何轻松对网络带宽做出限制，并在类 Unix 操作系统中对网络流量进行优化。通过限制网络带宽，可以节省应用程序不必要的带宽消耗，包括软件包管理器（pacman、yum、apt）、web 浏览器、torrent 客户端、下载管理器等，并防止单个或多个用户滥用网络带宽。在本文当中，将会介绍 Wondershaper 这一个实用的命令行程序，这是我认为限制 Linux 系统 Internet 或本地网络带宽的最简单、最快捷的方式之一。</p>\n<p>请注意，Wondershaper 只能限制本地网络接口的传入和传出流量，而不能限制路由器或调制解调器的接口。换句话说，Wondershaper 只会限制本地系统本身的网络带宽，而不会限制网络中的其它系统。因此 Wondershaper 主要用于限制本地系统中一个或多个网卡的带宽。</p>\n<p>下面来看一下 Wondershaper 是如何优化网络流量的。</p>\n<h3 id=\"在-Linux-中使用-Wondershaper-限制网络带宽\"><a href=\"#在-Linux-中使用-Wondershaper-限制网络带宽\" class=\"headerlink\" title=\"在 Linux 中使用 Wondershaper 限制网络带宽\"></a>在 Linux 中使用 Wondershaper 限制网络带宽</h3><p><code>wondershaper</code> 是用于显示系统网卡网络带宽的简单脚本。它使用了 iproute 的 <code>tc</code> 命令，但大大简化了操作过程。</p>\n<h4 id=\"安装-Wondershaper\"><a href=\"#安装-Wondershaper\" class=\"headerlink\" title=\"安装 Wondershaper\"></a>安装 Wondershaper</h4><p>使用 <code>git clone</code> 克隆 Wondershaper 的版本库就可以安装最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/magnific0/wondershaper.git</span><br></pre></td></tr></table></figure>\n<p>按照以下命令进入 <code>wondershaper</code> 目录并安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd wondershaper</span><br><span class=\"line\">$ sudo make install</span><br></pre></td></tr></table></figure>\n<p>然后执行以下命令，可以让 <code>wondershaper</code> 在每次系统启动时都自动开始服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable wondershaper.service</span><br><span class=\"line\">$ sudo systemctl start wondershaper.service</span><br></pre></td></tr></table></figure>\n<p>如果你不强求安装最新版本，也可以使用软件包管理器（官方和非官方均可）来进行安装。</p>\n<p><code>wondershaper</code> 在 <a href=\"https://aur.archlinux.org/packages/wondershaper-git/\" target=\"_blank\" rel=\"noopener\">Arch 用户软件仓库</a>（Arch User Repository，AUR）中可用，所以可以使用类似 <a href=\"https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\" target=\"_blank\" rel=\"noopener\">yay</a> 这些 AUR 辅助软件在基于 Arch 的系统中安装 <code>wondershaper</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yay -S wondershaper-git</span><br></pre></td></tr></table></figure>\n<p>对于 Debian、Ubuntu 和 Linux Mint 可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install wondershaper</span><br></pre></td></tr></table></figure>\n<p>对于 Fedora 可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo dnf install wondershaper</span><br></pre></td></tr></table></figure>\n<p>对于 RHEL、CentOS，只需要启用 EPEL 仓库，就可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install epel-release</span><br><span class=\"line\">$ sudo yum install wondershaper</span><br></pre></td></tr></table></figure>\n<p>在每次系统启动时都自动启动 <code>wondershaper</code> 服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable wondershaper.service</span><br><span class=\"line\">$ sudo systemctl start wondershaper.service</span><br></pre></td></tr></table></figure>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>首先需要找到网络接口的名称，通过以下几个命令都可以查询到网卡的详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ip addr</span><br><span class=\"line\">$ route</span><br><span class=\"line\">$ ifconfig</span><br></pre></td></tr></table></figure>\n<p>在确定网卡名称以后，就可以按照以下的命令限制网络带宽：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -a &lt;adapter&gt; -d &lt;rate&gt; -u &lt;rate&gt;</span><br></pre></td></tr></table></figure>\n<p>例如，如果网卡名称是 <code>enp0s8</code>，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -a enp0s8 -d 1024 -u 512</span><br></pre></td></tr></table></figure>\n<p>其中参数的含义是：</p>\n<ul>\n<li><code>-a</code>：网卡名称</li>\n<li><code>-d</code>：下行带宽</li>\n<li><code>-u</code>：上行带宽</li>\n</ul>\n<p>如果要对网卡解除网络带宽的限制，只需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -c -a enp0s8</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -c enp0s8</span><br></pre></td></tr></table></figure>\n<p>如果系统中有多个网卡，为确保稳妥，需要按照上面的方法手动设置每个网卡的上行、下行速率。</p>\n<p>如果你是通过 <code>git clone</code> 克隆 GitHub 版本库的方式安装 Wondershaper，那么在 <code>/etc/conf.d/</code> 目录中会存在一个名为 <code>wondershaper.conf</code> 的配置文件，修改这个配置文件中的相应值（包括网卡名称、上行速率、下行速率），也可以设置上行或下行速率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /etc/conf.d/wondershaper.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[wondershaper]</span><br><span class=\"line\"># Adapter</span><br><span class=\"line\">#</span><br><span class=\"line\">IFACE=&quot;eth0&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Download rate in Kbps</span><br><span class=\"line\">#</span><br><span class=\"line\">DSPEED=&quot;2048&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Upload rate in Kbps</span><br><span class=\"line\">#</span><br><span class=\"line\">USPEED=&quot;512&quot;</span><br></pre></td></tr></table></figure>\n<p>Wondershaper 使用前：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-1.png\" alt=\"\"></p>\n<p>Wondershaper 使用后：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-2.png\" alt=\"\"></p>\n<p>可以看到，使用 Wondershaper 限制网络带宽之后，下行速率与限制之前相比已经大幅下降。</p>\n<p>执行以下命令可以查看更多相关信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wondershaper -h</span><br></pre></td></tr></table></figure>\n<p>也可以查看 Wondershaper 的用户手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man wondershaper</span><br></pre></td></tr></table></figure>\n<p>根据测试，Wondershaper 按照上面的方式可以有很好的效果。你可以试用一下，然后发表你的看法。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/Wondershaper-1-720x340.jpg\" alt=\"\"></p>\n<p>以下内容将向你介绍如何轻松对网络带宽做出限制，并在类 Unix 操作系统中对网络流量进行优化。通过限制网络带宽，可以节省应用程序不必要的带宽消耗，包括软件包管理器（pacman、yum、apt）、web 浏览器、torrent 客户端、下载管理器等，并防止单个或多个用户滥用网络带宽。在本文当中，将会介绍 Wondershaper 这一个实用的命令行程序，这是我认为限制 Linux 系统 Internet 或本地网络带宽的最简单、最快捷的方式之一。</p>\n<p>请注意，Wondershaper 只能限制本地网络接口的传入和传出流量，而不能限制路由器或调制解调器的接口。换句话说，Wondershaper 只会限制本地系统本身的网络带宽，而不会限制网络中的其它系统。因此 Wondershaper 主要用于限制本地系统中一个或多个网卡的带宽。</p>\n<p>下面来看一下 Wondershaper 是如何优化网络流量的。</p>\n<h3 id=\"在-Linux-中使用-Wondershaper-限制网络带宽\"><a href=\"#在-Linux-中使用-Wondershaper-限制网络带宽\" class=\"headerlink\" title=\"在 Linux 中使用 Wondershaper 限制网络带宽\"></a>在 Linux 中使用 Wondershaper 限制网络带宽</h3><p><code>wondershaper</code> 是用于显示系统网卡网络带宽的简单脚本。它使用了 iproute 的 <code>tc</code> 命令，但大大简化了操作过程。</p>\n<h4 id=\"安装-Wondershaper\"><a href=\"#安装-Wondershaper\" class=\"headerlink\" title=\"安装 Wondershaper\"></a>安装 Wondershaper</h4><p>使用 <code>git clone</code> 克隆 Wondershaper 的版本库就可以安装最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/magnific0/wondershaper.git</span><br></pre></td></tr></table></figure>\n<p>按照以下命令进入 <code>wondershaper</code> 目录并安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd wondershaper</span><br><span class=\"line\">$ sudo make install</span><br></pre></td></tr></table></figure>\n<p>然后执行以下命令，可以让 <code>wondershaper</code> 在每次系统启动时都自动开始服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable wondershaper.service</span><br><span class=\"line\">$ sudo systemctl start wondershaper.service</span><br></pre></td></tr></table></figure>\n<p>如果你不强求安装最新版本，也可以使用软件包管理器（官方和非官方均可）来进行安装。</p>\n<p><code>wondershaper</code> 在 <a href=\"https://aur.archlinux.org/packages/wondershaper-git/\" target=\"_blank\" rel=\"noopener\">Arch 用户软件仓库</a>（Arch User Repository，AUR）中可用，所以可以使用类似 <a href=\"https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\" target=\"_blank\" rel=\"noopener\">yay</a> 这些 AUR 辅助软件在基于 Arch 的系统中安装 <code>wondershaper</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yay -S wondershaper-git</span><br></pre></td></tr></table></figure>\n<p>对于 Debian、Ubuntu 和 Linux Mint 可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install wondershaper</span><br></pre></td></tr></table></figure>\n<p>对于 Fedora 可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo dnf install wondershaper</span><br></pre></td></tr></table></figure>\n<p>对于 RHEL、CentOS，只需要启用 EPEL 仓库，就可以使用以下命令安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install epel-release</span><br><span class=\"line\">$ sudo yum install wondershaper</span><br></pre></td></tr></table></figure>\n<p>在每次系统启动时都自动启动 <code>wondershaper</code> 服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl enable wondershaper.service</span><br><span class=\"line\">$ sudo systemctl start wondershaper.service</span><br></pre></td></tr></table></figure>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>首先需要找到网络接口的名称，通过以下几个命令都可以查询到网卡的详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ip addr</span><br><span class=\"line\">$ route</span><br><span class=\"line\">$ ifconfig</span><br></pre></td></tr></table></figure>\n<p>在确定网卡名称以后，就可以按照以下的命令限制网络带宽：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -a &lt;adapter&gt; -d &lt;rate&gt; -u &lt;rate&gt;</span><br></pre></td></tr></table></figure>\n<p>例如，如果网卡名称是 <code>enp0s8</code>，并且需要把上行、下行速率分别限制为 1024 Kbps 和 512 Kbps，就可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -a enp0s8 -d 1024 -u 512</span><br></pre></td></tr></table></figure>\n<p>其中参数的含义是：</p>\n<ul>\n<li><code>-a</code>：网卡名称</li>\n<li><code>-d</code>：下行带宽</li>\n<li><code>-u</code>：上行带宽</li>\n</ul>\n<p>如果要对网卡解除网络带宽的限制，只需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -c -a enp0s8</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wondershaper -c enp0s8</span><br></pre></td></tr></table></figure>\n<p>如果系统中有多个网卡，为确保稳妥，需要按照上面的方法手动设置每个网卡的上行、下行速率。</p>\n<p>如果你是通过 <code>git clone</code> 克隆 GitHub 版本库的方式安装 Wondershaper，那么在 <code>/etc/conf.d/</code> 目录中会存在一个名为 <code>wondershaper.conf</code> 的配置文件，修改这个配置文件中的相应值（包括网卡名称、上行速率、下行速率），也可以设置上行或下行速率。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /etc/conf.d/wondershaper.conf</span><br><span class=\"line\"></span><br><span class=\"line\">[wondershaper]</span><br><span class=\"line\"># Adapter</span><br><span class=\"line\">#</span><br><span class=\"line\">IFACE=&quot;eth0&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Download rate in Kbps</span><br><span class=\"line\">#</span><br><span class=\"line\">DSPEED=&quot;2048&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Upload rate in Kbps</span><br><span class=\"line\">#</span><br><span class=\"line\">USPEED=&quot;512&quot;</span><br></pre></td></tr></table></figure>\n<p>Wondershaper 使用前：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-1.png\" alt=\"\"></p>\n<p>Wondershaper 使用后：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/wondershaper-2.png\" alt=\"\"></p>\n<p>可以看到，使用 Wondershaper 限制网络带宽之后，下行速率与限制之前相比已经大幅下降。</p>\n<p>执行以下命令可以查看更多相关信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wondershaper -h</span><br></pre></td></tr></table></figure>\n<p>也可以查看 Wondershaper 的用户手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man wondershaper</span><br></pre></td></tr></table></figure>\n<p>根据测试，Wondershaper 按照上面的方式可以有很好的效果。你可以试用一下，然后发表你的看法。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/how-to-limit-network-bandwidth-in-linux-using-wondershaper/</a></p>\n"},{"title":"如何在 Linux 中列出可用的软件包组","date":"2018-10-14T14:22:48.000Z","_content":"\n我们知道，如果想要在 Linux 中安装软件包，可以使用软件包管理器来进行安装。由于系统管理员需要频繁用到软件包管理器，所以它是 Linux 当中的一个重要工具。\n\n但是如果想一次性安装一个软件包组，在 Linux 中有可能吗？又如何通过命令去实现呢？\n\n在 Linux 中确实可以用软件包管理器来达到这样的目的。很多软件包管理器都有这样的选项来实现这个功能，但就我所知，`apt` 或 `apt-get` 软件包管理器却并没有这个选项。因此对基于 Debian 的系统，需要使用的命令是 `tasksel`，而不是 `apt` 或 `apt-get` 这样的官方软件包管理器。\n\n在 Linux 中安装软件包组有很多好处。对于 LAMP 来说，安装过程会包含多个软件包，但如果安装软件包组命令来安装，只安装一个包就可以了。\n\n当你的团队需要安装 LAMP，但不知道其中具体包含哪些软件包，这个时候软件包组就派上用场了。软件包组是 Linux 系统上一个很方便的工具，它能让你轻松地完成一组软件包的安装。\n\n软件包组是一组用于公共功能的软件包，包括系统工具、声音和视频。 安装软件包组的过程中，会获取到一系列的依赖包，从而大大节省了时间。\n\n**推荐阅读：**\n\n- [如何在 Linux 上按照大小列出已安装的软件包][1]\n- [如何在 Linux 上查看/列出可用的软件包更新][2]\n- [如何在 Linux 上查看软件包的安装/更新/升级/移除/卸载时间][3]\n- [如何在 Linux 上查看一个软件包的详细信息][4]\n- [如何查看一个软件包是否在你的 Linux 发行版上可用][5]\n- [萌新指导：一个可视化的 Linux 包管理工具][6]\n- [老手必会：命令行软件包管理器的用法][7]\n\n### 如何在 CentOS/RHEL 系统上列出可用的软件包组\n\nRHEL 和 CentOS 系统使用的是 RPM 软件包，因此可以使用 `yum` 软件包管理器来获取相关的软件包信息。\n\n`yum` 是 “Yellowdog Updater, Modified” 的缩写，它是一个用于基于 RPM 系统（例如 RHEL 和 CentOS）的，开源的命令行软件包管理工具。它是从发行版仓库或其它第三方库中获取、安装、删除、查询和管理 RPM 包的主要工具。\n\n**推荐阅读：** [使用 yum 命令在 RHEL/CentOS 系统上管理软件包][8]\n\n```\n# yum grouplist\nLoaded plugins: fastestmirror, security\nSetting up Group Process\nLoading mirror speeds from cached hostfile\n * epel: epel.mirror.constant.com\nInstalled Groups:\n Base\n E-mail server\n Graphical Administration Tools\n Hardware monitoring utilities\n Legacy UNIX compatibility\n Milkymist\n Networking Tools\n Performance Tools\n Perl Support\n Security Tools\nAvailable Groups:\n Additional Development\n Backup Client\n Backup Server\n CIFS file server\n Client management tools\n Compatibility libraries\n Console internet tools\n Debugging Tools\n Desktop\n.\n.\nAvailable Language Groups:\n Afrikaans Support [af]\n Albanian Support [sq]\n Amazigh Support [ber]\n Arabic Support [ar]\n Armenian Support [hy]\n Assamese Support [as]\n Azerbaijani Support [az]\n.\n.\nDone\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Performance Tools” 组相关联的软件包。\n\n```\n# yum groupinfo \"Performance Tools\"\nLoaded plugins: fastestmirror, security\nSetting up Group Process\nLoading mirror speeds from cached hostfile\n * epel: ewr.edge.kernel.org\n\nGroup: Performance Tools\n Description: Tools for diagnosing system and application-level performance problems.\n Mandatory Packages:\n blktrace\n sysstat\n Default Packages:\n dstat\n iotop\n latencytop\n latencytop-tui\n oprofile\n perf\n powertop\n seekwatcher\n Optional Packages:\n oprofile-jit\n papi\n sdparm\n sg3_utils\n tiobench\n tuned\n tuned-utils\n```\n\n### 如何在 Fedora 系统上列出可用的软件包组\n\nFedora 系统使用的是 DNF 软件包管理器，因此可以通过 DNF 软件包管理器来获取相关的信息。\n\nDNF 的含义是 “Dandified yum”。DNF 软件包管理器是 YUM 软件包管理器的一个分支，它使用 hawkey/libsolv 库作为后端。从 Fedora 18 开始，Aleš Kozumplík 开始着手 DNF 的开发，直到在 Fedora 22 开始加入到系统中。\n\n`dnf` 命令可以在 Fedora 22 及更高版本上安装、更新、搜索和删除软件包， 它可以自动解决软件包的依赖关系并其顺利安装，不会产生问题。\n\nYUM 被 DNF 取代是由于 YUM 中存在一些长期未被解决的问题。为什么 Aleš Kozumplík 没有对 yum 的这些问题作出修补呢，他认为补丁解决存在技术上的难题，而 YUM 团队也不会马上接受这些更改，还有一些重要的问题。而且 YUM 的代码量有 5.6 万行，而 DNF 只有 2.9 万行。因此已经不需要沿着 YUM 的方向继续开发了，重新开一个分支才是更好的选择。\n\n**推荐阅读：** [在 Fedora 系统上使用 DNF 命令管理软件包][9]\n\n```\n# dnf grouplist\nLast metadata expiration check: 0:00:00 ago on Sun 09 Sep 2018 07:10:36 PM IST.\nAvailable Environment Groups:\n Fedora Custom Operating System\n Minimal Install\n Fedora Server Edition\n Fedora Workstation\n Fedora Cloud Server\n KDE Plasma Workspaces\n Xfce Desktop\n LXDE Desktop\n Hawaii Desktop\n LXQt Desktop\n Cinnamon Desktop\n MATE Desktop\n Sugar Desktop Environment\n Development and Creative Workstation\n Web Server\n Infrastructure Server\n Basic Desktop\nInstalled Groups:\n C Development Tools and Libraries\n Development Tools\nAvailable Groups:\n 3D Printing\n Administration Tools\n Ansible node\n Audio Production\n Authoring and Publishing\n Books and Guides\n Cloud Infrastructure\n Cloud Management Tools\n Container Management\n D Development Tools and Libraries\n.\n.\n RPM Development Tools\n Security Lab\n Text-based Internet\n Window Managers\n GNOME Desktop Environment\n Graphical Internet\n KDE (K Desktop Environment)\n Fonts\n Games and Entertainment\n Hardware Support\n Sound and Video\n System Tools\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Editor” 组相关联的软件包。\n\n```\n# dnf groupinfo Editors\nLast metadata expiration check: 0:04:57 ago on Sun 09 Sep 2018 07:10:36 PM IST.\n\nGroup: Editors\n Description: Sometimes called text editors, these are programs that allow you to create and edit text files. This includes Emacs and Vi.\n Optional Packages:\n code-editor\n cssed\n emacs\n emacs-auctex\n emacs-bbdb\n emacs-ess\n emacs-vm\n geany\n gobby\n jed\n joe\n leafpad\n nedit\n poedit\n psgml\n vim-X11\n vim-enhanced\n xemacs\n xemacs-packages-base\n xemacs-packages-extra\n xemacs-xft\n xmlcopyeditor\n zile\n```\n\n### 如何在 openSUSE 系统上列出可用的软件包组\n\nopenSUSE 系统使用的是 zypper 软件包管理器，因此可以通过 zypper 软件包管理器来获取相关的信息。\n\nZypper 是 suse 和 openSUSE 发行版的命令行包管理器。它可以用于安装、更新、搜索和删除软件包，还有管理存储库，执行各种查询等功能。 Zypper 命令行界面用到了 ZYpp 系统管理库（libzypp）。\n\n**推荐阅读：** [在 openSUSE 和 suse 系统使用 zypper 命令管理软件包][10]\n\n```\n# zypper patterns\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\nS | Name | Version | Repository | Dependency\n---|----------------------|---------------|-----------------------|-----------\n | 64bit | 20150918-25.1 | Main Repository (OSS) |\n | apparmor | 20150918-25.1 | Main Repository (OSS) |\ni | apparmor | 20150918-25.1 | @System |\n | base | 20150918-25.1 | Main Repository (OSS) |\ni+ | base | 20150918-25.1 | @System |\n | books | 20150918-25.1 | Main Repository (OSS) |\n | console | 20150918-25.1 | Main Repository (OSS) |\n | devel_C_C++ | 20150918-25.1 | Main Repository (OSS) |\ni | enhanced_base | 20150918-25.1 | @System |\n | enlightenment | 20150918-25.1 | Main Repository (OSS) |\n | file_server | 20150918-25.1 | Main Repository (OSS) |\n | fonts | 20150918-25.1 | Main Repository (OSS) |\ni | fonts | 20150918-25.1 | @System |\n | games | 20150918-25.1 | Main Repository (OSS) |\ni | games | 20150918-25.1 | @System |\n | gnome | 20150918-25.1 | Main Repository (OSS) |\n | gnome_basis | 20150918-25.1 | Main Repository (OSS) |\ni | imaging | 20150918-25.1 | @System |\n | kde | 20150918-25.1 | Main Repository (OSS) |\ni+ | kde | 20150918-25.1 | @System |\n | kde_plasma | 20150918-25.1 | Main Repository (OSS) |\ni | kde_plasma | 20150918-25.1 | @System |\n | lamp_server | 20150918-25.1 | Main Repository (OSS) |\n | laptop | 20150918-25.1 | Main Repository (OSS) |\ni+ | laptop | 20150918-25.1 | @System |\n | lxde | 20150918-25.1 | Main Repository (OSS) |\n | lxqt | 20150918-25.1 | Main Repository (OSS) |\ni | multimedia | 20150918-25.1 | @System |\n | network_admin | 20150918-25.1 | Main Repository (OSS) |\n | non_oss | 20150918-25.1 | Main Repository (OSS) |\ni | non_oss | 20150918-25.1 | @System |\n | office | 20150918-25.1 | Main Repository (OSS) |\ni | office | 20150918-25.1 | @System |\n | print_server | 20150918-25.1 | Main Repository (OSS) |\n | remote_desktop | 20150918-25.1 | Main Repository (OSS) |\n | x11 | 20150918-25.1 | Main Repository (OSS) |\ni+ | x11 | 20150918-25.1 | @System |\n | x86 | 20150918-25.1 | Main Repository (OSS) |\n | xen_server | 20150918-25.1 | Main Repository (OSS) |\n | xfce | 20150918-25.1 | Main Repository (OSS) |\n | xfce_basis | 20150918-25.1 | Main Repository (OSS) |\n | yast2_basis | 20150918-25.1 | Main Repository (OSS) |\ni | yast2_basis | 20150918-25.1 | @System |\n | yast2_install_wf | 20150918-25.1 | Main Repository (OSS) |\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “file_server” 组相关联的软件包。另外 `zypper` 还允许用户使用不同的选项执行相同的操作。\n\n```\n# zypper info file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。\n\n```\n# zypper pattern-info file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，也可以执行以下这个命令。\n\n```\n# zypper info pattern file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，也可以执行以下这个命令。\n\n```\n# zypper info -t pattern file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n### 如何在 Debian/Ubuntu 系统上列出可用的软件包组\n\n由于 APT 或 APT-GET 软件包管理器没有为基于 Debian/Ubuntu 的系统提供这样的选项，因此需要使用 `tasksel` 命令来获取相关信息。\n\n[tasksel][11] 是 Debian/Ubuntu 系统上一个很方便的工具，只需要很少的操作就可以用它来安装好一组软件包。可以在 `/usr/share/tasksel` 目录下的 `.desc` 文件中安排软件包的安装任务。\n\n默认情况下，`tasksel` 工具是作为 Debian 系统的一部分安装的，但桌面版 Ubuntu 则没有自带 `tasksel`，这个功能类似软件包管理器中的元包（meta-packages）。\n\n`tasksel` 工具带有一个基于 zenity 的简单用户界面，例如命令行中的弹出图形对话框。\n\n**推荐阅读：** [使用 tasksel 在 Debian/Ubuntu 系统上快速安装软件包组][12]\n\n```\n# tasksel --list-task\nu kubuntu-live Kubuntu live CD\nu lubuntu-live-gtk Lubuntu live CD (GTK part)\nu ubuntu-budgie-live Ubuntu Budgie live CD\nu ubuntu-live Ubuntu live CD\nu ubuntu-mate-live Ubuntu MATE Live CD\nu ubuntustudio-dvd-live Ubuntu Studio live DVD\nu vanilla-gnome-live Ubuntu GNOME live CD\nu xubuntu-live Xubuntu live CD\nu cloud-image Ubuntu Cloud Image (instance)\nu dns-server DNS server\nu kubuntu-desktop Kubuntu desktop\nu kubuntu-full Kubuntu full\nu lamp-server LAMP server\nu lubuntu-core Lubuntu minimal installation\nu lubuntu-desktop Lubuntu Desktop\nu lubuntu-gtk-core Lubuntu minimal installation (GTK part)\nu lubuntu-gtk-desktop Lubuntu Desktop (GTK part)\nu lubuntu-qt-core Lubuntu minimal installation (Qt part)\nu lubuntu-qt-desktop Lubuntu Qt Desktop (Qt part)\nu mail-server Mail server\nu postgresql-server PostgreSQL database\ni print-server Print server\nu samba-server Samba file server\nu tomcat-server Tomcat Java server\nu ubuntu-budgie-desktop Ubuntu Budgie desktop\ni ubuntu-desktop Ubuntu desktop\nu ubuntu-mate-core Ubuntu MATE minimal\nu ubuntu-mate-desktop Ubuntu MATE desktop\ni ubuntu-usb Ubuntu desktop USB\nu ubuntustudio-audio Audio recording and editing suite\nu ubuntustudio-desktop Ubuntu Studio desktop\nu ubuntustudio-desktop-core Ubuntu Studio minimal DE installation\nu ubuntustudio-fonts Large selection of font packages\nu ubuntustudio-graphics 2D/3D creation and editing suite\nu ubuntustudio-photography Photograph touchup and editing suite\nu ubuntustudio-publishing Publishing applications\nu ubuntustudio-video Video creation and editing suite\nu vanilla-gnome-desktop Vanilla GNOME desktop\nu xubuntu-core Xubuntu minimal installation\nu xubuntu-desktop Xubuntu desktop\nu openssh-server OpenSSH server\nu server Basic Ubuntu server\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “lamp-server” 组相关联的软件包。\n\n```\n# tasksel --task-desc \"lamp-server\"\nSelects a ready-made Linux/Apache/MySQL/PHP server.\n```\n\n### 如何在基于 Arch Linux 的系统上列出可用的软件包组\n\n基于 Arch Linux 的系统使用的是 pacman 软件包管理器，因此可以通过 pacman 软件包管理器来获取相关的信息。\n\npacman 是 “package manager” 的缩写。`pacman` 可以用于安装、构建、删除和管理 Arch Linux 软件包。`pacman` 使用 libalpm（Arch Linux Package Management 库，ALPM）作为后端来执行所有操作。\n\n**推荐阅读：** [使用 pacman 在基于 Arch Linux 的系统上管理软件包][13]\n\n```\n# pacman -Sg\nbase-devel\nbase\nmultilib-devel\ngnome-extra\nkde-applications\nkdepim\nkdeutils\nkdeedu\nkf5\nkdemultimedia\ngnome\nplasma\nkdegames\nkdesdk\nkdebase\nxfce4\nfprint\nkdegraphics\nkdenetwork\nkdeadmin\nkf5-aids\nkdewebdev\n.\n.\ndlang-ldc\nlibretro\nring\nlxqt\nnon-daw\nnon\nalsa\nqtcurve\nrealtime\nsugar-fructose\ntesseract-data\nvim-plugins\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “gnome” 组相关联的软件包。\n\n```\n# pacman -Sg gnome\ngnome baobab\ngnome cheese\ngnome eog\ngnome epiphany\ngnome evince\ngnome file-roller\ngnome gdm\ngnome gedit\ngnome gnome-backgrounds\ngnome gnome-calculator\ngnome gnome-calendar\ngnome gnome-characters\ngnome gnome-clocks\ngnome gnome-color-manager\ngnome gnome-contacts\ngnome gnome-control-center\ngnome gnome-dictionary\ngnome gnome-disk-utility\ngnome gnome-documents\ngnome gnome-font-viewer\n.\n.\ngnome sushi\ngnome totem\ngnome tracker\ngnome tracker-miners\ngnome vino\ngnome xdg-user-dirs-gtk\ngnome yelp\ngnome gnome-boxes\ngnome gnome-software\ngnome simple-scan\n\n```\n\n也可以执行以下这个命令实现同样的效果。\n\n```\n# pacman -S gnome\n:: There are 64 members in group gnome:\n:: Repository extra\n 1) baobab 2) cheese 3) eog 4) epiphany 5) evince 6) file-roller 7) gdm 8) gedit 9) gnome-backgrounds 10) gnome-calculator 11) gnome-calendar 12) gnome-characters 13) gnome-clocks\n 14) gnome-color-manager 15) gnome-contacts 16) gnome-control-center 17) gnome-dictionary 18) gnome-disk-utility 19) gnome-documents 20) gnome-font-viewer 21) gnome-getting-started-docs\n 22) gnome-keyring 23) gnome-logs 24) gnome-maps 25) gnome-menus 26) gnome-music 27) gnome-photos 28) gnome-screenshot 29) gnome-session 30) gnome-settings-daemon 31) gnome-shell\n 32) gnome-shell-extensions 33) gnome-system-monitor 34) gnome-terminal 35) gnome-themes-extra 36) gnome-todo 37) gnome-user-docs 38) gnome-user-share 39) gnome-video-effects 40) grilo-plugins\n 41) gvfs 42) gvfs-afc 43) gvfs-goa 44) gvfs-google 45) gvfs-gphoto2 46) gvfs-mtp 47) gvfs-nfs 48) gvfs-smb 49) mousetweaks 50) mutter 51) nautilus 52) networkmanager 53) orca 54) rygel\n 55) sushi 56) totem 57) tracker 58) tracker-miners 59) vino 60) xdg-user-dirs-gtk 61) yelp\n:: Repository community\n 62) gnome-boxes 63) gnome-software 64) simple-scan\n\nEnter a selection (default=all): ^C\nInterrupt signal received\n\n```\n\n可以执行以下命令检查相关软件包的数量。\n\n```\n# pacman -Sg gnome | wc -l\n64\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/\n\n[a]: https://www.2daygeek.com/author/prakash/\n[1]: https://www.2daygeek.com/how-to-list-installed-packages-by-size-largest-on-linux/\n[2]: https://www.2daygeek.com/how-to-view-list-the-available-packages-updates-in-linux/\n[3]: https://www.2daygeek.com/how-to-view-a-particular-package-installed-updated-upgraded-removed-erased-date-on-linux/\n[4]: https://www.2daygeek.com/how-to-view-detailed-information-about-a-package-in-linux/\n[5]: https://www.2daygeek.com/how-to-search-if-a-package-is-available-on-your-linux-distribution-or-not/\n[6]: https://www.2daygeek.com/list-of-graphical-frontend-tool-for-linux-package-manager/\n[7]: https://www.2daygeek.com/list-of-command-line-package-manager-for-linux/\n[8]: https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\n[9]: https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\n[10]: https://www.2daygeek.com/zypper-command-examples-manage-packages-opensuse-system/\n[11]: https://wiki.debian.org/tasksel\n[12]: https://www.2daygeek.com/tasksel-install-group-of-software-in-a-single-click-or-single-command-on-debian-ubuntu/\n[13]: https://www.2daygeek.com/pacman-command-examples-manage-packages-arch-linux-system/\n\n","source":"_posts/How-To-List-An-Available-Package-Groups-In-Linux.md","raw":"---\ntitle: 如何在 Linux 中列出可用的软件包组\ndate: 2018-10-14 22:22:48\ntags:\n  - Linux\n  - 软件包\n  - LCTT 翻译\n---\n\n我们知道，如果想要在 Linux 中安装软件包，可以使用软件包管理器来进行安装。由于系统管理员需要频繁用到软件包管理器，所以它是 Linux 当中的一个重要工具。\n\n但是如果想一次性安装一个软件包组，在 Linux 中有可能吗？又如何通过命令去实现呢？\n\n在 Linux 中确实可以用软件包管理器来达到这样的目的。很多软件包管理器都有这样的选项来实现这个功能，但就我所知，`apt` 或 `apt-get` 软件包管理器却并没有这个选项。因此对基于 Debian 的系统，需要使用的命令是 `tasksel`，而不是 `apt` 或 `apt-get` 这样的官方软件包管理器。\n\n在 Linux 中安装软件包组有很多好处。对于 LAMP 来说，安装过程会包含多个软件包，但如果安装软件包组命令来安装，只安装一个包就可以了。\n\n当你的团队需要安装 LAMP，但不知道其中具体包含哪些软件包，这个时候软件包组就派上用场了。软件包组是 Linux 系统上一个很方便的工具，它能让你轻松地完成一组软件包的安装。\n\n软件包组是一组用于公共功能的软件包，包括系统工具、声音和视频。 安装软件包组的过程中，会获取到一系列的依赖包，从而大大节省了时间。\n\n**推荐阅读：**\n\n- [如何在 Linux 上按照大小列出已安装的软件包][1]\n- [如何在 Linux 上查看/列出可用的软件包更新][2]\n- [如何在 Linux 上查看软件包的安装/更新/升级/移除/卸载时间][3]\n- [如何在 Linux 上查看一个软件包的详细信息][4]\n- [如何查看一个软件包是否在你的 Linux 发行版上可用][5]\n- [萌新指导：一个可视化的 Linux 包管理工具][6]\n- [老手必会：命令行软件包管理器的用法][7]\n\n### 如何在 CentOS/RHEL 系统上列出可用的软件包组\n\nRHEL 和 CentOS 系统使用的是 RPM 软件包，因此可以使用 `yum` 软件包管理器来获取相关的软件包信息。\n\n`yum` 是 “Yellowdog Updater, Modified” 的缩写，它是一个用于基于 RPM 系统（例如 RHEL 和 CentOS）的，开源的命令行软件包管理工具。它是从发行版仓库或其它第三方库中获取、安装、删除、查询和管理 RPM 包的主要工具。\n\n**推荐阅读：** [使用 yum 命令在 RHEL/CentOS 系统上管理软件包][8]\n\n```\n# yum grouplist\nLoaded plugins: fastestmirror, security\nSetting up Group Process\nLoading mirror speeds from cached hostfile\n * epel: epel.mirror.constant.com\nInstalled Groups:\n Base\n E-mail server\n Graphical Administration Tools\n Hardware monitoring utilities\n Legacy UNIX compatibility\n Milkymist\n Networking Tools\n Performance Tools\n Perl Support\n Security Tools\nAvailable Groups:\n Additional Development\n Backup Client\n Backup Server\n CIFS file server\n Client management tools\n Compatibility libraries\n Console internet tools\n Debugging Tools\n Desktop\n.\n.\nAvailable Language Groups:\n Afrikaans Support [af]\n Albanian Support [sq]\n Amazigh Support [ber]\n Arabic Support [ar]\n Armenian Support [hy]\n Assamese Support [as]\n Azerbaijani Support [az]\n.\n.\nDone\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Performance Tools” 组相关联的软件包。\n\n```\n# yum groupinfo \"Performance Tools\"\nLoaded plugins: fastestmirror, security\nSetting up Group Process\nLoading mirror speeds from cached hostfile\n * epel: ewr.edge.kernel.org\n\nGroup: Performance Tools\n Description: Tools for diagnosing system and application-level performance problems.\n Mandatory Packages:\n blktrace\n sysstat\n Default Packages:\n dstat\n iotop\n latencytop\n latencytop-tui\n oprofile\n perf\n powertop\n seekwatcher\n Optional Packages:\n oprofile-jit\n papi\n sdparm\n sg3_utils\n tiobench\n tuned\n tuned-utils\n```\n\n### 如何在 Fedora 系统上列出可用的软件包组\n\nFedora 系统使用的是 DNF 软件包管理器，因此可以通过 DNF 软件包管理器来获取相关的信息。\n\nDNF 的含义是 “Dandified yum”。DNF 软件包管理器是 YUM 软件包管理器的一个分支，它使用 hawkey/libsolv 库作为后端。从 Fedora 18 开始，Aleš Kozumplík 开始着手 DNF 的开发，直到在 Fedora 22 开始加入到系统中。\n\n`dnf` 命令可以在 Fedora 22 及更高版本上安装、更新、搜索和删除软件包， 它可以自动解决软件包的依赖关系并其顺利安装，不会产生问题。\n\nYUM 被 DNF 取代是由于 YUM 中存在一些长期未被解决的问题。为什么 Aleš Kozumplík 没有对 yum 的这些问题作出修补呢，他认为补丁解决存在技术上的难题，而 YUM 团队也不会马上接受这些更改，还有一些重要的问题。而且 YUM 的代码量有 5.6 万行，而 DNF 只有 2.9 万行。因此已经不需要沿着 YUM 的方向继续开发了，重新开一个分支才是更好的选择。\n\n**推荐阅读：** [在 Fedora 系统上使用 DNF 命令管理软件包][9]\n\n```\n# dnf grouplist\nLast metadata expiration check: 0:00:00 ago on Sun 09 Sep 2018 07:10:36 PM IST.\nAvailable Environment Groups:\n Fedora Custom Operating System\n Minimal Install\n Fedora Server Edition\n Fedora Workstation\n Fedora Cloud Server\n KDE Plasma Workspaces\n Xfce Desktop\n LXDE Desktop\n Hawaii Desktop\n LXQt Desktop\n Cinnamon Desktop\n MATE Desktop\n Sugar Desktop Environment\n Development and Creative Workstation\n Web Server\n Infrastructure Server\n Basic Desktop\nInstalled Groups:\n C Development Tools and Libraries\n Development Tools\nAvailable Groups:\n 3D Printing\n Administration Tools\n Ansible node\n Audio Production\n Authoring and Publishing\n Books and Guides\n Cloud Infrastructure\n Cloud Management Tools\n Container Management\n D Development Tools and Libraries\n.\n.\n RPM Development Tools\n Security Lab\n Text-based Internet\n Window Managers\n GNOME Desktop Environment\n Graphical Internet\n KDE (K Desktop Environment)\n Fonts\n Games and Entertainment\n Hardware Support\n Sound and Video\n System Tools\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Editor” 组相关联的软件包。\n\n```\n# dnf groupinfo Editors\nLast metadata expiration check: 0:04:57 ago on Sun 09 Sep 2018 07:10:36 PM IST.\n\nGroup: Editors\n Description: Sometimes called text editors, these are programs that allow you to create and edit text files. This includes Emacs and Vi.\n Optional Packages:\n code-editor\n cssed\n emacs\n emacs-auctex\n emacs-bbdb\n emacs-ess\n emacs-vm\n geany\n gobby\n jed\n joe\n leafpad\n nedit\n poedit\n psgml\n vim-X11\n vim-enhanced\n xemacs\n xemacs-packages-base\n xemacs-packages-extra\n xemacs-xft\n xmlcopyeditor\n zile\n```\n\n### 如何在 openSUSE 系统上列出可用的软件包组\n\nopenSUSE 系统使用的是 zypper 软件包管理器，因此可以通过 zypper 软件包管理器来获取相关的信息。\n\nZypper 是 suse 和 openSUSE 发行版的命令行包管理器。它可以用于安装、更新、搜索和删除软件包，还有管理存储库，执行各种查询等功能。 Zypper 命令行界面用到了 ZYpp 系统管理库（libzypp）。\n\n**推荐阅读：** [在 openSUSE 和 suse 系统使用 zypper 命令管理软件包][10]\n\n```\n# zypper patterns\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\nS | Name | Version | Repository | Dependency\n---|----------------------|---------------|-----------------------|-----------\n | 64bit | 20150918-25.1 | Main Repository (OSS) |\n | apparmor | 20150918-25.1 | Main Repository (OSS) |\ni | apparmor | 20150918-25.1 | @System |\n | base | 20150918-25.1 | Main Repository (OSS) |\ni+ | base | 20150918-25.1 | @System |\n | books | 20150918-25.1 | Main Repository (OSS) |\n | console | 20150918-25.1 | Main Repository (OSS) |\n | devel_C_C++ | 20150918-25.1 | Main Repository (OSS) |\ni | enhanced_base | 20150918-25.1 | @System |\n | enlightenment | 20150918-25.1 | Main Repository (OSS) |\n | file_server | 20150918-25.1 | Main Repository (OSS) |\n | fonts | 20150918-25.1 | Main Repository (OSS) |\ni | fonts | 20150918-25.1 | @System |\n | games | 20150918-25.1 | Main Repository (OSS) |\ni | games | 20150918-25.1 | @System |\n | gnome | 20150918-25.1 | Main Repository (OSS) |\n | gnome_basis | 20150918-25.1 | Main Repository (OSS) |\ni | imaging | 20150918-25.1 | @System |\n | kde | 20150918-25.1 | Main Repository (OSS) |\ni+ | kde | 20150918-25.1 | @System |\n | kde_plasma | 20150918-25.1 | Main Repository (OSS) |\ni | kde_plasma | 20150918-25.1 | @System |\n | lamp_server | 20150918-25.1 | Main Repository (OSS) |\n | laptop | 20150918-25.1 | Main Repository (OSS) |\ni+ | laptop | 20150918-25.1 | @System |\n | lxde | 20150918-25.1 | Main Repository (OSS) |\n | lxqt | 20150918-25.1 | Main Repository (OSS) |\ni | multimedia | 20150918-25.1 | @System |\n | network_admin | 20150918-25.1 | Main Repository (OSS) |\n | non_oss | 20150918-25.1 | Main Repository (OSS) |\ni | non_oss | 20150918-25.1 | @System |\n | office | 20150918-25.1 | Main Repository (OSS) |\ni | office | 20150918-25.1 | @System |\n | print_server | 20150918-25.1 | Main Repository (OSS) |\n | remote_desktop | 20150918-25.1 | Main Repository (OSS) |\n | x11 | 20150918-25.1 | Main Repository (OSS) |\ni+ | x11 | 20150918-25.1 | @System |\n | x86 | 20150918-25.1 | Main Repository (OSS) |\n | xen_server | 20150918-25.1 | Main Repository (OSS) |\n | xfce | 20150918-25.1 | Main Repository (OSS) |\n | xfce_basis | 20150918-25.1 | Main Repository (OSS) |\n | yast2_basis | 20150918-25.1 | Main Repository (OSS) |\ni | yast2_basis | 20150918-25.1 | @System |\n | yast2_install_wf | 20150918-25.1 | Main Repository (OSS) |\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “file_server” 组相关联的软件包。另外 `zypper` 还允许用户使用不同的选项执行相同的操作。\n\n```\n# zypper info file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。\n\n```\n# zypper pattern-info file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，也可以执行以下这个命令。\n\n```\n# zypper info pattern file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n如果需要列出相关联的软件包，也可以执行以下这个命令。\n\n```\n# zypper info -t pattern file_server\nLoading repository data...\nWarning: Repository 'Update Repository (Non-Oss)' appears to be outdated. Consider using a different mirror or server.\nWarning: Repository 'Main Update Repository' appears to be outdated. Consider using a different mirror or server.\nReading installed packages...\n\n\nInformation for pattern file_server:\n------------------------------------\nRepository : Main Repository (OSS)\nName : file_server\nVersion : 20150918-25.1\nArch : x86_64\nVendor : openSUSE\nInstalled : No\nVisible to User : Yes\nSummary : File Server\nDescription :\n File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.\nContents :\n S | Name | Type | Dependency\n ---|-------------------------------|---------|------------\n i+ | patterns-openSUSE-base | package | Required\n | patterns-openSUSE-file_server | package | Required\n | nfs-kernel-server | package | Recommended\n i | nfsidmap | package | Recommended\n i | samba | package | Recommended\n i | samba-client | package | Recommended\n i | samba-winbind | package | Recommended\n | tftp | package | Recommended\n | vsftpd | package | Recommended\n | yast2-ftp-server | package | Recommended\n | yast2-nfs-server | package | Recommended\n i | yast2-samba-server | package | Recommended\n | yast2-tftp-server | package | Recommended\n```\n\n### 如何在 Debian/Ubuntu 系统上列出可用的软件包组\n\n由于 APT 或 APT-GET 软件包管理器没有为基于 Debian/Ubuntu 的系统提供这样的选项，因此需要使用 `tasksel` 命令来获取相关信息。\n\n[tasksel][11] 是 Debian/Ubuntu 系统上一个很方便的工具，只需要很少的操作就可以用它来安装好一组软件包。可以在 `/usr/share/tasksel` 目录下的 `.desc` 文件中安排软件包的安装任务。\n\n默认情况下，`tasksel` 工具是作为 Debian 系统的一部分安装的，但桌面版 Ubuntu 则没有自带 `tasksel`，这个功能类似软件包管理器中的元包（meta-packages）。\n\n`tasksel` 工具带有一个基于 zenity 的简单用户界面，例如命令行中的弹出图形对话框。\n\n**推荐阅读：** [使用 tasksel 在 Debian/Ubuntu 系统上快速安装软件包组][12]\n\n```\n# tasksel --list-task\nu kubuntu-live Kubuntu live CD\nu lubuntu-live-gtk Lubuntu live CD (GTK part)\nu ubuntu-budgie-live Ubuntu Budgie live CD\nu ubuntu-live Ubuntu live CD\nu ubuntu-mate-live Ubuntu MATE Live CD\nu ubuntustudio-dvd-live Ubuntu Studio live DVD\nu vanilla-gnome-live Ubuntu GNOME live CD\nu xubuntu-live Xubuntu live CD\nu cloud-image Ubuntu Cloud Image (instance)\nu dns-server DNS server\nu kubuntu-desktop Kubuntu desktop\nu kubuntu-full Kubuntu full\nu lamp-server LAMP server\nu lubuntu-core Lubuntu minimal installation\nu lubuntu-desktop Lubuntu Desktop\nu lubuntu-gtk-core Lubuntu minimal installation (GTK part)\nu lubuntu-gtk-desktop Lubuntu Desktop (GTK part)\nu lubuntu-qt-core Lubuntu minimal installation (Qt part)\nu lubuntu-qt-desktop Lubuntu Qt Desktop (Qt part)\nu mail-server Mail server\nu postgresql-server PostgreSQL database\ni print-server Print server\nu samba-server Samba file server\nu tomcat-server Tomcat Java server\nu ubuntu-budgie-desktop Ubuntu Budgie desktop\ni ubuntu-desktop Ubuntu desktop\nu ubuntu-mate-core Ubuntu MATE minimal\nu ubuntu-mate-desktop Ubuntu MATE desktop\ni ubuntu-usb Ubuntu desktop USB\nu ubuntustudio-audio Audio recording and editing suite\nu ubuntustudio-desktop Ubuntu Studio desktop\nu ubuntustudio-desktop-core Ubuntu Studio minimal DE installation\nu ubuntustudio-fonts Large selection of font packages\nu ubuntustudio-graphics 2D/3D creation and editing suite\nu ubuntustudio-photography Photograph touchup and editing suite\nu ubuntustudio-publishing Publishing applications\nu ubuntustudio-video Video creation and editing suite\nu vanilla-gnome-desktop Vanilla GNOME desktop\nu xubuntu-core Xubuntu minimal installation\nu xubuntu-desktop Xubuntu desktop\nu openssh-server OpenSSH server\nu server Basic Ubuntu server\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “lamp-server” 组相关联的软件包。\n\n```\n# tasksel --task-desc \"lamp-server\"\nSelects a ready-made Linux/Apache/MySQL/PHP server.\n```\n\n### 如何在基于 Arch Linux 的系统上列出可用的软件包组\n\n基于 Arch Linux 的系统使用的是 pacman 软件包管理器，因此可以通过 pacman 软件包管理器来获取相关的信息。\n\npacman 是 “package manager” 的缩写。`pacman` 可以用于安装、构建、删除和管理 Arch Linux 软件包。`pacman` 使用 libalpm（Arch Linux Package Management 库，ALPM）作为后端来执行所有操作。\n\n**推荐阅读：** [使用 pacman 在基于 Arch Linux 的系统上管理软件包][13]\n\n```\n# pacman -Sg\nbase-devel\nbase\nmultilib-devel\ngnome-extra\nkde-applications\nkdepim\nkdeutils\nkdeedu\nkf5\nkdemultimedia\ngnome\nplasma\nkdegames\nkdesdk\nkdebase\nxfce4\nfprint\nkdegraphics\nkdenetwork\nkdeadmin\nkf5-aids\nkdewebdev\n.\n.\ndlang-ldc\nlibretro\nring\nlxqt\nnon-daw\nnon\nalsa\nqtcurve\nrealtime\nsugar-fructose\ntesseract-data\nvim-plugins\n```\n\n如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “gnome” 组相关联的软件包。\n\n```\n# pacman -Sg gnome\ngnome baobab\ngnome cheese\ngnome eog\ngnome epiphany\ngnome evince\ngnome file-roller\ngnome gdm\ngnome gedit\ngnome gnome-backgrounds\ngnome gnome-calculator\ngnome gnome-calendar\ngnome gnome-characters\ngnome gnome-clocks\ngnome gnome-color-manager\ngnome gnome-contacts\ngnome gnome-control-center\ngnome gnome-dictionary\ngnome gnome-disk-utility\ngnome gnome-documents\ngnome gnome-font-viewer\n.\n.\ngnome sushi\ngnome totem\ngnome tracker\ngnome tracker-miners\ngnome vino\ngnome xdg-user-dirs-gtk\ngnome yelp\ngnome gnome-boxes\ngnome gnome-software\ngnome simple-scan\n\n```\n\n也可以执行以下这个命令实现同样的效果。\n\n```\n# pacman -S gnome\n:: There are 64 members in group gnome:\n:: Repository extra\n 1) baobab 2) cheese 3) eog 4) epiphany 5) evince 6) file-roller 7) gdm 8) gedit 9) gnome-backgrounds 10) gnome-calculator 11) gnome-calendar 12) gnome-characters 13) gnome-clocks\n 14) gnome-color-manager 15) gnome-contacts 16) gnome-control-center 17) gnome-dictionary 18) gnome-disk-utility 19) gnome-documents 20) gnome-font-viewer 21) gnome-getting-started-docs\n 22) gnome-keyring 23) gnome-logs 24) gnome-maps 25) gnome-menus 26) gnome-music 27) gnome-photos 28) gnome-screenshot 29) gnome-session 30) gnome-settings-daemon 31) gnome-shell\n 32) gnome-shell-extensions 33) gnome-system-monitor 34) gnome-terminal 35) gnome-themes-extra 36) gnome-todo 37) gnome-user-docs 38) gnome-user-share 39) gnome-video-effects 40) grilo-plugins\n 41) gvfs 42) gvfs-afc 43) gvfs-goa 44) gvfs-google 45) gvfs-gphoto2 46) gvfs-mtp 47) gvfs-nfs 48) gvfs-smb 49) mousetweaks 50) mutter 51) nautilus 52) networkmanager 53) orca 54) rygel\n 55) sushi 56) totem 57) tracker 58) tracker-miners 59) vino 60) xdg-user-dirs-gtk 61) yelp\n:: Repository community\n 62) gnome-boxes 63) gnome-software 64) simple-scan\n\nEnter a selection (default=all): ^C\nInterrupt signal received\n\n```\n\n可以执行以下命令检查相关软件包的数量。\n\n```\n# pacman -Sg gnome | wc -l\n64\n```\n\n--------------------------------------------------------------------------------\n\nvia: https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/\n\n[a]: https://www.2daygeek.com/author/prakash/\n[1]: https://www.2daygeek.com/how-to-list-installed-packages-by-size-largest-on-linux/\n[2]: https://www.2daygeek.com/how-to-view-list-the-available-packages-updates-in-linux/\n[3]: https://www.2daygeek.com/how-to-view-a-particular-package-installed-updated-upgraded-removed-erased-date-on-linux/\n[4]: https://www.2daygeek.com/how-to-view-detailed-information-about-a-package-in-linux/\n[5]: https://www.2daygeek.com/how-to-search-if-a-package-is-available-on-your-linux-distribution-or-not/\n[6]: https://www.2daygeek.com/list-of-graphical-frontend-tool-for-linux-package-manager/\n[7]: https://www.2daygeek.com/list-of-command-line-package-manager-for-linux/\n[8]: https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\n[9]: https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\n[10]: https://www.2daygeek.com/zypper-command-examples-manage-packages-opensuse-system/\n[11]: https://wiki.debian.org/tasksel\n[12]: https://www.2daygeek.com/tasksel-install-group-of-software-in-a-single-click-or-single-command-on-debian-ubuntu/\n[13]: https://www.2daygeek.com/pacman-command-examples-manage-packages-arch-linux-system/\n\n","slug":"How-To-List-An-Available-Package-Groups-In-Linux","published":1,"updated":"2019-03-28T11:57:06.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cp000zlixuvkol28oa","content":"<p>我们知道，如果想要在 Linux 中安装软件包，可以使用软件包管理器来进行安装。由于系统管理员需要频繁用到软件包管理器，所以它是 Linux 当中的一个重要工具。</p>\n<p>但是如果想一次性安装一个软件包组，在 Linux 中有可能吗？又如何通过命令去实现呢？</p>\n<p>在 Linux 中确实可以用软件包管理器来达到这样的目的。很多软件包管理器都有这样的选项来实现这个功能，但就我所知，<code>apt</code> 或 <code>apt-get</code> 软件包管理器却并没有这个选项。因此对基于 Debian 的系统，需要使用的命令是 <code>tasksel</code>，而不是 <code>apt</code> 或 <code>apt-get</code> 这样的官方软件包管理器。</p>\n<p>在 Linux 中安装软件包组有很多好处。对于 LAMP 来说，安装过程会包含多个软件包，但如果安装软件包组命令来安装，只安装一个包就可以了。</p>\n<p>当你的团队需要安装 LAMP，但不知道其中具体包含哪些软件包，这个时候软件包组就派上用场了。软件包组是 Linux 系统上一个很方便的工具，它能让你轻松地完成一组软件包的安装。</p>\n<p>软件包组是一组用于公共功能的软件包，包括系统工具、声音和视频。 安装软件包组的过程中，会获取到一系列的依赖包，从而大大节省了时间。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/how-to-list-installed-packages-by-size-largest-on-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上按照大小列出已安装的软件包</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-list-the-available-packages-updates-in-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看/列出可用的软件包更新</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-a-particular-package-installed-updated-upgraded-removed-erased-date-on-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看软件包的安装/更新/升级/移除/卸载时间</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-detailed-information-about-a-package-in-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看一个软件包的详细信息</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-search-if-a-package-is-available-on-your-linux-distribution-or-not/\" target=\"_blank\" rel=\"noopener\">如何查看一个软件包是否在你的 Linux 发行版上可用</a></li>\n<li><a href=\"https://www.2daygeek.com/list-of-graphical-frontend-tool-for-linux-package-manager/\" target=\"_blank\" rel=\"noopener\">萌新指导：一个可视化的 Linux 包管理工具</a></li>\n<li><a href=\"https://www.2daygeek.com/list-of-command-line-package-manager-for-linux/\" target=\"_blank\" rel=\"noopener\">老手必会：命令行软件包管理器的用法</a></li>\n</ul>\n<h3 id=\"如何在-CentOS-RHEL-系统上列出可用的软件包组\"><a href=\"#如何在-CentOS-RHEL-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 CentOS/RHEL 系统上列出可用的软件包组\"></a>如何在 CentOS/RHEL 系统上列出可用的软件包组</h3><p>RHEL 和 CentOS 系统使用的是 RPM 软件包，因此可以使用 <code>yum</code> 软件包管理器来获取相关的软件包信息。</p>\n<p><code>yum</code> 是 “Yellowdog Updater, Modified” 的缩写，它是一个用于基于 RPM 系统（例如 RHEL 和 CentOS）的，开源的命令行软件包管理工具。它是从发行版仓库或其它第三方库中获取、安装、删除、查询和管理 RPM 包的主要工具。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\" target=\"_blank\" rel=\"noopener\">使用 yum 命令在 RHEL/CentOS 系统上管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum grouplist</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Setting up Group Process</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * epel: epel.mirror.constant.com</span><br><span class=\"line\">Installed Groups:</span><br><span class=\"line\"> Base</span><br><span class=\"line\"> E-mail server</span><br><span class=\"line\"> Graphical Administration Tools</span><br><span class=\"line\"> Hardware monitoring utilities</span><br><span class=\"line\"> Legacy UNIX compatibility</span><br><span class=\"line\"> Milkymist</span><br><span class=\"line\"> Networking Tools</span><br><span class=\"line\"> Performance Tools</span><br><span class=\"line\"> Perl Support</span><br><span class=\"line\"> Security Tools</span><br><span class=\"line\">Available Groups:</span><br><span class=\"line\"> Additional Development</span><br><span class=\"line\"> Backup Client</span><br><span class=\"line\"> Backup Server</span><br><span class=\"line\"> CIFS file server</span><br><span class=\"line\"> Client management tools</span><br><span class=\"line\"> Compatibility libraries</span><br><span class=\"line\"> Console internet tools</span><br><span class=\"line\"> Debugging Tools</span><br><span class=\"line\"> Desktop</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">Available Language Groups:</span><br><span class=\"line\"> Afrikaans Support [af]</span><br><span class=\"line\"> Albanian Support [sq]</span><br><span class=\"line\"> Amazigh Support [ber]</span><br><span class=\"line\"> Arabic Support [ar]</span><br><span class=\"line\"> Armenian Support [hy]</span><br><span class=\"line\"> Assamese Support [as]</span><br><span class=\"line\"> Azerbaijani Support [az]</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">Done</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Performance Tools” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum groupinfo &quot;Performance Tools&quot;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Setting up Group Process</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * epel: ewr.edge.kernel.org</span><br><span class=\"line\"></span><br><span class=\"line\">Group: Performance Tools</span><br><span class=\"line\"> Description: Tools for diagnosing system and application-level performance problems.</span><br><span class=\"line\"> Mandatory Packages:</span><br><span class=\"line\"> blktrace</span><br><span class=\"line\"> sysstat</span><br><span class=\"line\"> Default Packages:</span><br><span class=\"line\"> dstat</span><br><span class=\"line\"> iotop</span><br><span class=\"line\"> latencytop</span><br><span class=\"line\"> latencytop-tui</span><br><span class=\"line\"> oprofile</span><br><span class=\"line\"> perf</span><br><span class=\"line\"> powertop</span><br><span class=\"line\"> seekwatcher</span><br><span class=\"line\"> Optional Packages:</span><br><span class=\"line\"> oprofile-jit</span><br><span class=\"line\"> papi</span><br><span class=\"line\"> sdparm</span><br><span class=\"line\"> sg3_utils</span><br><span class=\"line\"> tiobench</span><br><span class=\"line\"> tuned</span><br><span class=\"line\"> tuned-utils</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-Fedora-系统上列出可用的软件包组\"><a href=\"#如何在-Fedora-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 Fedora 系统上列出可用的软件包组\"></a>如何在 Fedora 系统上列出可用的软件包组</h3><p>Fedora 系统使用的是 DNF 软件包管理器，因此可以通过 DNF 软件包管理器来获取相关的信息。</p>\n<p>DNF 的含义是 “Dandified yum”。DNF 软件包管理器是 YUM 软件包管理器的一个分支，它使用 hawkey/libsolv 库作为后端。从 Fedora 18 开始，Aleš Kozumplík 开始着手 DNF 的开发，直到在 Fedora 22 开始加入到系统中。</p>\n<p><code>dnf</code> 命令可以在 Fedora 22 及更高版本上安装、更新、搜索和删除软件包， 它可以自动解决软件包的依赖关系并其顺利安装，不会产生问题。</p>\n<p>YUM 被 DNF 取代是由于 YUM 中存在一些长期未被解决的问题。为什么 Aleš Kozumplík 没有对 yum 的这些问题作出修补呢，他认为补丁解决存在技术上的难题，而 YUM 团队也不会马上接受这些更改，还有一些重要的问题。而且 YUM 的代码量有 5.6 万行，而 DNF 只有 2.9 万行。因此已经不需要沿着 YUM 的方向继续开发了，重新开一个分支才是更好的选择。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\" target=\"_blank\" rel=\"noopener\">在 Fedora 系统上使用 DNF 命令管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf grouplist</span><br><span class=\"line\">Last metadata expiration check: 0:00:00 ago on Sun 09 Sep 2018 07:10:36 PM IST.</span><br><span class=\"line\">Available Environment Groups:</span><br><span class=\"line\"> Fedora Custom Operating System</span><br><span class=\"line\"> Minimal Install</span><br><span class=\"line\"> Fedora Server Edition</span><br><span class=\"line\"> Fedora Workstation</span><br><span class=\"line\"> Fedora Cloud Server</span><br><span class=\"line\"> KDE Plasma Workspaces</span><br><span class=\"line\"> Xfce Desktop</span><br><span class=\"line\"> LXDE Desktop</span><br><span class=\"line\"> Hawaii Desktop</span><br><span class=\"line\"> LXQt Desktop</span><br><span class=\"line\"> Cinnamon Desktop</span><br><span class=\"line\"> MATE Desktop</span><br><span class=\"line\"> Sugar Desktop Environment</span><br><span class=\"line\"> Development and Creative Workstation</span><br><span class=\"line\"> Web Server</span><br><span class=\"line\"> Infrastructure Server</span><br><span class=\"line\"> Basic Desktop</span><br><span class=\"line\">Installed Groups:</span><br><span class=\"line\"> C Development Tools and Libraries</span><br><span class=\"line\"> Development Tools</span><br><span class=\"line\">Available Groups:</span><br><span class=\"line\"> 3D Printing</span><br><span class=\"line\"> Administration Tools</span><br><span class=\"line\"> Ansible node</span><br><span class=\"line\"> Audio Production</span><br><span class=\"line\"> Authoring and Publishing</span><br><span class=\"line\"> Books and Guides</span><br><span class=\"line\"> Cloud Infrastructure</span><br><span class=\"line\"> Cloud Management Tools</span><br><span class=\"line\"> Container Management</span><br><span class=\"line\"> D Development Tools and Libraries</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"> RPM Development Tools</span><br><span class=\"line\"> Security Lab</span><br><span class=\"line\"> Text-based Internet</span><br><span class=\"line\"> Window Managers</span><br><span class=\"line\"> GNOME Desktop Environment</span><br><span class=\"line\"> Graphical Internet</span><br><span class=\"line\"> KDE (K Desktop Environment)</span><br><span class=\"line\"> Fonts</span><br><span class=\"line\"> Games and Entertainment</span><br><span class=\"line\"> Hardware Support</span><br><span class=\"line\"> Sound and Video</span><br><span class=\"line\"> System Tools</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Editor” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf groupinfo Editors</span><br><span class=\"line\">Last metadata expiration check: 0:04:57 ago on Sun 09 Sep 2018 07:10:36 PM IST.</span><br><span class=\"line\"></span><br><span class=\"line\">Group: Editors</span><br><span class=\"line\"> Description: Sometimes called text editors, these are programs that allow you to create and edit text files. This includes Emacs and Vi.</span><br><span class=\"line\"> Optional Packages:</span><br><span class=\"line\"> code-editor</span><br><span class=\"line\"> cssed</span><br><span class=\"line\"> emacs</span><br><span class=\"line\"> emacs-auctex</span><br><span class=\"line\"> emacs-bbdb</span><br><span class=\"line\"> emacs-ess</span><br><span class=\"line\"> emacs-vm</span><br><span class=\"line\"> geany</span><br><span class=\"line\"> gobby</span><br><span class=\"line\"> jed</span><br><span class=\"line\"> joe</span><br><span class=\"line\"> leafpad</span><br><span class=\"line\"> nedit</span><br><span class=\"line\"> poedit</span><br><span class=\"line\"> psgml</span><br><span class=\"line\"> vim-X11</span><br><span class=\"line\"> vim-enhanced</span><br><span class=\"line\"> xemacs</span><br><span class=\"line\"> xemacs-packages-base</span><br><span class=\"line\"> xemacs-packages-extra</span><br><span class=\"line\"> xemacs-xft</span><br><span class=\"line\"> xmlcopyeditor</span><br><span class=\"line\"> zile</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-openSUSE-系统上列出可用的软件包组\"><a href=\"#如何在-openSUSE-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 openSUSE 系统上列出可用的软件包组\"></a>如何在 openSUSE 系统上列出可用的软件包组</h3><p>openSUSE 系统使用的是 zypper 软件包管理器，因此可以通过 zypper 软件包管理器来获取相关的信息。</p>\n<p>Zypper 是 suse 和 openSUSE 发行版的命令行包管理器。它可以用于安装、更新、搜索和删除软件包，还有管理存储库，执行各种查询等功能。 Zypper 命令行界面用到了 ZYpp 系统管理库（libzypp）。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/zypper-command-examples-manage-packages-opensuse-system/\" target=\"_blank\" rel=\"noopener\">在 openSUSE 和 suse 系统使用 zypper 命令管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper patterns</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\">S | Name | Version | Repository | Dependency</span><br><span class=\"line\">---|----------------------|---------------|-----------------------|-----------</span><br><span class=\"line\"> | 64bit | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | apparmor | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | apparmor | 20150918-25.1 | @System |</span><br><span class=\"line\"> | base | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | base | 20150918-25.1 | @System |</span><br><span class=\"line\"> | books | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | console | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | devel_C_C++ | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | enhanced_base | 20150918-25.1 | @System |</span><br><span class=\"line\"> | enlightenment | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | file_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | fonts | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | fonts | 20150918-25.1 | @System |</span><br><span class=\"line\"> | games | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | games | 20150918-25.1 | @System |</span><br><span class=\"line\"> | gnome | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | gnome_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | imaging | 20150918-25.1 | @System |</span><br><span class=\"line\"> | kde | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | kde | 20150918-25.1 | @System |</span><br><span class=\"line\"> | kde_plasma | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | kde_plasma | 20150918-25.1 | @System |</span><br><span class=\"line\"> | lamp_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | laptop | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | laptop | 20150918-25.1 | @System |</span><br><span class=\"line\"> | lxde | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | lxqt | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | multimedia | 20150918-25.1 | @System |</span><br><span class=\"line\"> | network_admin | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | non_oss | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | non_oss | 20150918-25.1 | @System |</span><br><span class=\"line\"> | office | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | office | 20150918-25.1 | @System |</span><br><span class=\"line\"> | print_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | remote_desktop | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | x11 | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | x11 | 20150918-25.1 | @System |</span><br><span class=\"line\"> | x86 | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xen_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xfce | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xfce_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | yast2_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | yast2_basis | 20150918-25.1 | @System |</span><br><span class=\"line\"> | yast2_install_wf | 20150918-25.1 | Main Repository (OSS) |</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “file_server” 组相关联的软件包。另外 <code>zypper</code> 还允许用户使用不同的选项执行相同的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper pattern-info file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，也可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info pattern file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，也可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info -t pattern file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-Debian-Ubuntu-系统上列出可用的软件包组\"><a href=\"#如何在-Debian-Ubuntu-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 Debian/Ubuntu 系统上列出可用的软件包组\"></a>如何在 Debian/Ubuntu 系统上列出可用的软件包组</h3><p>由于 APT 或 APT-GET 软件包管理器没有为基于 Debian/Ubuntu 的系统提供这样的选项，因此需要使用 <code>tasksel</code> 命令来获取相关信息。</p>\n<p><a href=\"https://wiki.debian.org/tasksel\" target=\"_blank\" rel=\"noopener\">tasksel</a> 是 Debian/Ubuntu 系统上一个很方便的工具，只需要很少的操作就可以用它来安装好一组软件包。可以在 <code>/usr/share/tasksel</code> 目录下的 <code>.desc</code> 文件中安排软件包的安装任务。</p>\n<p>默认情况下，<code>tasksel</code> 工具是作为 Debian 系统的一部分安装的，但桌面版 Ubuntu 则没有自带 <code>tasksel</code>，这个功能类似软件包管理器中的元包（meta-packages）。</p>\n<p><code>tasksel</code> 工具带有一个基于 zenity 的简单用户界面，例如命令行中的弹出图形对话框。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/tasksel-install-group-of-software-in-a-single-click-or-single-command-on-debian-ubuntu/\" target=\"_blank\" rel=\"noopener\">使用 tasksel 在 Debian/Ubuntu 系统上快速安装软件包组</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># tasksel --list-task</span><br><span class=\"line\">u kubuntu-live Kubuntu live CD</span><br><span class=\"line\">u lubuntu-live-gtk Lubuntu live CD (GTK part)</span><br><span class=\"line\">u ubuntu-budgie-live Ubuntu Budgie live CD</span><br><span class=\"line\">u ubuntu-live Ubuntu live CD</span><br><span class=\"line\">u ubuntu-mate-live Ubuntu MATE Live CD</span><br><span class=\"line\">u ubuntustudio-dvd-live Ubuntu Studio live DVD</span><br><span class=\"line\">u vanilla-gnome-live Ubuntu GNOME live CD</span><br><span class=\"line\">u xubuntu-live Xubuntu live CD</span><br><span class=\"line\">u cloud-image Ubuntu Cloud Image (instance)</span><br><span class=\"line\">u dns-server DNS server</span><br><span class=\"line\">u kubuntu-desktop Kubuntu desktop</span><br><span class=\"line\">u kubuntu-full Kubuntu full</span><br><span class=\"line\">u lamp-server LAMP server</span><br><span class=\"line\">u lubuntu-core Lubuntu minimal installation</span><br><span class=\"line\">u lubuntu-desktop Lubuntu Desktop</span><br><span class=\"line\">u lubuntu-gtk-core Lubuntu minimal installation (GTK part)</span><br><span class=\"line\">u lubuntu-gtk-desktop Lubuntu Desktop (GTK part)</span><br><span class=\"line\">u lubuntu-qt-core Lubuntu minimal installation (Qt part)</span><br><span class=\"line\">u lubuntu-qt-desktop Lubuntu Qt Desktop (Qt part)</span><br><span class=\"line\">u mail-server Mail server</span><br><span class=\"line\">u postgresql-server PostgreSQL database</span><br><span class=\"line\">i print-server Print server</span><br><span class=\"line\">u samba-server Samba file server</span><br><span class=\"line\">u tomcat-server Tomcat Java server</span><br><span class=\"line\">u ubuntu-budgie-desktop Ubuntu Budgie desktop</span><br><span class=\"line\">i ubuntu-desktop Ubuntu desktop</span><br><span class=\"line\">u ubuntu-mate-core Ubuntu MATE minimal</span><br><span class=\"line\">u ubuntu-mate-desktop Ubuntu MATE desktop</span><br><span class=\"line\">i ubuntu-usb Ubuntu desktop USB</span><br><span class=\"line\">u ubuntustudio-audio Audio recording and editing suite</span><br><span class=\"line\">u ubuntustudio-desktop Ubuntu Studio desktop</span><br><span class=\"line\">u ubuntustudio-desktop-core Ubuntu Studio minimal DE installation</span><br><span class=\"line\">u ubuntustudio-fonts Large selection of font packages</span><br><span class=\"line\">u ubuntustudio-graphics 2D/3D creation and editing suite</span><br><span class=\"line\">u ubuntustudio-photography Photograph touchup and editing suite</span><br><span class=\"line\">u ubuntustudio-publishing Publishing applications</span><br><span class=\"line\">u ubuntustudio-video Video creation and editing suite</span><br><span class=\"line\">u vanilla-gnome-desktop Vanilla GNOME desktop</span><br><span class=\"line\">u xubuntu-core Xubuntu minimal installation</span><br><span class=\"line\">u xubuntu-desktop Xubuntu desktop</span><br><span class=\"line\">u openssh-server OpenSSH server</span><br><span class=\"line\">u server Basic Ubuntu server</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “lamp-server” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># tasksel --task-desc &quot;lamp-server&quot;</span><br><span class=\"line\">Selects a ready-made Linux/Apache/MySQL/PHP server.</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在基于-Arch-Linux-的系统上列出可用的软件包组\"><a href=\"#如何在基于-Arch-Linux-的系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在基于 Arch Linux 的系统上列出可用的软件包组\"></a>如何在基于 Arch Linux 的系统上列出可用的软件包组</h3><p>基于 Arch Linux 的系统使用的是 pacman 软件包管理器，因此可以通过 pacman 软件包管理器来获取相关的信息。</p>\n<p>pacman 是 “package manager” 的缩写。<code>pacman</code> 可以用于安装、构建、删除和管理 Arch Linux 软件包。<code>pacman</code> 使用 libalpm（Arch Linux Package Management 库，ALPM）作为后端来执行所有操作。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/pacman-command-examples-manage-packages-arch-linux-system/\" target=\"_blank\" rel=\"noopener\">使用 pacman 在基于 Arch Linux 的系统上管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg</span><br><span class=\"line\">base-devel</span><br><span class=\"line\">base</span><br><span class=\"line\">multilib-devel</span><br><span class=\"line\">gnome-extra</span><br><span class=\"line\">kde-applications</span><br><span class=\"line\">kdepim</span><br><span class=\"line\">kdeutils</span><br><span class=\"line\">kdeedu</span><br><span class=\"line\">kf5</span><br><span class=\"line\">kdemultimedia</span><br><span class=\"line\">gnome</span><br><span class=\"line\">plasma</span><br><span class=\"line\">kdegames</span><br><span class=\"line\">kdesdk</span><br><span class=\"line\">kdebase</span><br><span class=\"line\">xfce4</span><br><span class=\"line\">fprint</span><br><span class=\"line\">kdegraphics</span><br><span class=\"line\">kdenetwork</span><br><span class=\"line\">kdeadmin</span><br><span class=\"line\">kf5-aids</span><br><span class=\"line\">kdewebdev</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">dlang-ldc</span><br><span class=\"line\">libretro</span><br><span class=\"line\">ring</span><br><span class=\"line\">lxqt</span><br><span class=\"line\">non-daw</span><br><span class=\"line\">non</span><br><span class=\"line\">alsa</span><br><span class=\"line\">qtcurve</span><br><span class=\"line\">realtime</span><br><span class=\"line\">sugar-fructose</span><br><span class=\"line\">tesseract-data</span><br><span class=\"line\">vim-plugins</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “gnome” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg gnome</span><br><span class=\"line\">gnome baobab</span><br><span class=\"line\">gnome cheese</span><br><span class=\"line\">gnome eog</span><br><span class=\"line\">gnome epiphany</span><br><span class=\"line\">gnome evince</span><br><span class=\"line\">gnome file-roller</span><br><span class=\"line\">gnome gdm</span><br><span class=\"line\">gnome gedit</span><br><span class=\"line\">gnome gnome-backgrounds</span><br><span class=\"line\">gnome gnome-calculator</span><br><span class=\"line\">gnome gnome-calendar</span><br><span class=\"line\">gnome gnome-characters</span><br><span class=\"line\">gnome gnome-clocks</span><br><span class=\"line\">gnome gnome-color-manager</span><br><span class=\"line\">gnome gnome-contacts</span><br><span class=\"line\">gnome gnome-control-center</span><br><span class=\"line\">gnome gnome-dictionary</span><br><span class=\"line\">gnome gnome-disk-utility</span><br><span class=\"line\">gnome gnome-documents</span><br><span class=\"line\">gnome gnome-font-viewer</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">gnome sushi</span><br><span class=\"line\">gnome totem</span><br><span class=\"line\">gnome tracker</span><br><span class=\"line\">gnome tracker-miners</span><br><span class=\"line\">gnome vino</span><br><span class=\"line\">gnome xdg-user-dirs-gtk</span><br><span class=\"line\">gnome yelp</span><br><span class=\"line\">gnome gnome-boxes</span><br><span class=\"line\">gnome gnome-software</span><br><span class=\"line\">gnome simple-scan</span><br></pre></td></tr></table></figure>\n<p>也可以执行以下这个命令实现同样的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gnome</span><br><span class=\"line\">:: There are 64 members in group gnome:</span><br><span class=\"line\">:: Repository extra</span><br><span class=\"line\"> 1) baobab 2) cheese 3) eog 4) epiphany 5) evince 6) file-roller 7) gdm 8) gedit 9) gnome-backgrounds 10) gnome-calculator 11) gnome-calendar 12) gnome-characters 13) gnome-clocks</span><br><span class=\"line\"> 14) gnome-color-manager 15) gnome-contacts 16) gnome-control-center 17) gnome-dictionary 18) gnome-disk-utility 19) gnome-documents 20) gnome-font-viewer 21) gnome-getting-started-docs</span><br><span class=\"line\"> 22) gnome-keyring 23) gnome-logs 24) gnome-maps 25) gnome-menus 26) gnome-music 27) gnome-photos 28) gnome-screenshot 29) gnome-session 30) gnome-settings-daemon 31) gnome-shell</span><br><span class=\"line\"> 32) gnome-shell-extensions 33) gnome-system-monitor 34) gnome-terminal 35) gnome-themes-extra 36) gnome-todo 37) gnome-user-docs 38) gnome-user-share 39) gnome-video-effects 40) grilo-plugins</span><br><span class=\"line\"> 41) gvfs 42) gvfs-afc 43) gvfs-goa 44) gvfs-google 45) gvfs-gphoto2 46) gvfs-mtp 47) gvfs-nfs 48) gvfs-smb 49) mousetweaks 50) mutter 51) nautilus 52) networkmanager 53) orca 54) rygel</span><br><span class=\"line\"> 55) sushi 56) totem 57) tracker 58) tracker-miners 59) vino 60) xdg-user-dirs-gtk 61) yelp</span><br><span class=\"line\">:: Repository community</span><br><span class=\"line\"> 62) gnome-boxes 63) gnome-software 64) simple-scan</span><br><span class=\"line\"></span><br><span class=\"line\">Enter a selection (default=all): ^C</span><br><span class=\"line\">Interrupt signal received</span><br></pre></td></tr></table></figure>\n<p>可以执行以下命令检查相关软件包的数量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg gnome | wc -l</span><br><span class=\"line\">64</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道，如果想要在 Linux 中安装软件包，可以使用软件包管理器来进行安装。由于系统管理员需要频繁用到软件包管理器，所以它是 Linux 当中的一个重要工具。</p>\n<p>但是如果想一次性安装一个软件包组，在 Linux 中有可能吗？又如何通过命令去实现呢？</p>\n<p>在 Linux 中确实可以用软件包管理器来达到这样的目的。很多软件包管理器都有这样的选项来实现这个功能，但就我所知，<code>apt</code> 或 <code>apt-get</code> 软件包管理器却并没有这个选项。因此对基于 Debian 的系统，需要使用的命令是 <code>tasksel</code>，而不是 <code>apt</code> 或 <code>apt-get</code> 这样的官方软件包管理器。</p>\n<p>在 Linux 中安装软件包组有很多好处。对于 LAMP 来说，安装过程会包含多个软件包，但如果安装软件包组命令来安装，只安装一个包就可以了。</p>\n<p>当你的团队需要安装 LAMP，但不知道其中具体包含哪些软件包，这个时候软件包组就派上用场了。软件包组是 Linux 系统上一个很方便的工具，它能让你轻松地完成一组软件包的安装。</p>\n<p>软件包组是一组用于公共功能的软件包，包括系统工具、声音和视频。 安装软件包组的过程中，会获取到一系列的依赖包，从而大大节省了时间。</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.2daygeek.com/how-to-list-installed-packages-by-size-largest-on-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上按照大小列出已安装的软件包</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-list-the-available-packages-updates-in-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看/列出可用的软件包更新</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-a-particular-package-installed-updated-upgraded-removed-erased-date-on-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看软件包的安装/更新/升级/移除/卸载时间</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-view-detailed-information-about-a-package-in-linux/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上查看一个软件包的详细信息</a></li>\n<li><a href=\"https://www.2daygeek.com/how-to-search-if-a-package-is-available-on-your-linux-distribution-or-not/\" target=\"_blank\" rel=\"noopener\">如何查看一个软件包是否在你的 Linux 发行版上可用</a></li>\n<li><a href=\"https://www.2daygeek.com/list-of-graphical-frontend-tool-for-linux-package-manager/\" target=\"_blank\" rel=\"noopener\">萌新指导：一个可视化的 Linux 包管理工具</a></li>\n<li><a href=\"https://www.2daygeek.com/list-of-command-line-package-manager-for-linux/\" target=\"_blank\" rel=\"noopener\">老手必会：命令行软件包管理器的用法</a></li>\n</ul>\n<h3 id=\"如何在-CentOS-RHEL-系统上列出可用的软件包组\"><a href=\"#如何在-CentOS-RHEL-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 CentOS/RHEL 系统上列出可用的软件包组\"></a>如何在 CentOS/RHEL 系统上列出可用的软件包组</h3><p>RHEL 和 CentOS 系统使用的是 RPM 软件包，因此可以使用 <code>yum</code> 软件包管理器来获取相关的软件包信息。</p>\n<p><code>yum</code> 是 “Yellowdog Updater, Modified” 的缩写，它是一个用于基于 RPM 系统（例如 RHEL 和 CentOS）的，开源的命令行软件包管理工具。它是从发行版仓库或其它第三方库中获取、安装、删除、查询和管理 RPM 包的主要工具。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/yum-command-examples-manage-packages-rhel-centos-systems/\" target=\"_blank\" rel=\"noopener\">使用 yum 命令在 RHEL/CentOS 系统上管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum grouplist</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Setting up Group Process</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * epel: epel.mirror.constant.com</span><br><span class=\"line\">Installed Groups:</span><br><span class=\"line\"> Base</span><br><span class=\"line\"> E-mail server</span><br><span class=\"line\"> Graphical Administration Tools</span><br><span class=\"line\"> Hardware monitoring utilities</span><br><span class=\"line\"> Legacy UNIX compatibility</span><br><span class=\"line\"> Milkymist</span><br><span class=\"line\"> Networking Tools</span><br><span class=\"line\"> Performance Tools</span><br><span class=\"line\"> Perl Support</span><br><span class=\"line\"> Security Tools</span><br><span class=\"line\">Available Groups:</span><br><span class=\"line\"> Additional Development</span><br><span class=\"line\"> Backup Client</span><br><span class=\"line\"> Backup Server</span><br><span class=\"line\"> CIFS file server</span><br><span class=\"line\"> Client management tools</span><br><span class=\"line\"> Compatibility libraries</span><br><span class=\"line\"> Console internet tools</span><br><span class=\"line\"> Debugging Tools</span><br><span class=\"line\"> Desktop</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">Available Language Groups:</span><br><span class=\"line\"> Afrikaans Support [af]</span><br><span class=\"line\"> Albanian Support [sq]</span><br><span class=\"line\"> Amazigh Support [ber]</span><br><span class=\"line\"> Arabic Support [ar]</span><br><span class=\"line\"> Armenian Support [hy]</span><br><span class=\"line\"> Assamese Support [as]</span><br><span class=\"line\"> Azerbaijani Support [az]</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">Done</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Performance Tools” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yum groupinfo &quot;Performance Tools&quot;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Setting up Group Process</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * epel: ewr.edge.kernel.org</span><br><span class=\"line\"></span><br><span class=\"line\">Group: Performance Tools</span><br><span class=\"line\"> Description: Tools for diagnosing system and application-level performance problems.</span><br><span class=\"line\"> Mandatory Packages:</span><br><span class=\"line\"> blktrace</span><br><span class=\"line\"> sysstat</span><br><span class=\"line\"> Default Packages:</span><br><span class=\"line\"> dstat</span><br><span class=\"line\"> iotop</span><br><span class=\"line\"> latencytop</span><br><span class=\"line\"> latencytop-tui</span><br><span class=\"line\"> oprofile</span><br><span class=\"line\"> perf</span><br><span class=\"line\"> powertop</span><br><span class=\"line\"> seekwatcher</span><br><span class=\"line\"> Optional Packages:</span><br><span class=\"line\"> oprofile-jit</span><br><span class=\"line\"> papi</span><br><span class=\"line\"> sdparm</span><br><span class=\"line\"> sg3_utils</span><br><span class=\"line\"> tiobench</span><br><span class=\"line\"> tuned</span><br><span class=\"line\"> tuned-utils</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-Fedora-系统上列出可用的软件包组\"><a href=\"#如何在-Fedora-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 Fedora 系统上列出可用的软件包组\"></a>如何在 Fedora 系统上列出可用的软件包组</h3><p>Fedora 系统使用的是 DNF 软件包管理器，因此可以通过 DNF 软件包管理器来获取相关的信息。</p>\n<p>DNF 的含义是 “Dandified yum”。DNF 软件包管理器是 YUM 软件包管理器的一个分支，它使用 hawkey/libsolv 库作为后端。从 Fedora 18 开始，Aleš Kozumplík 开始着手 DNF 的开发，直到在 Fedora 22 开始加入到系统中。</p>\n<p><code>dnf</code> 命令可以在 Fedora 22 及更高版本上安装、更新、搜索和删除软件包， 它可以自动解决软件包的依赖关系并其顺利安装，不会产生问题。</p>\n<p>YUM 被 DNF 取代是由于 YUM 中存在一些长期未被解决的问题。为什么 Aleš Kozumplík 没有对 yum 的这些问题作出修补呢，他认为补丁解决存在技术上的难题，而 YUM 团队也不会马上接受这些更改，还有一些重要的问题。而且 YUM 的代码量有 5.6 万行，而 DNF 只有 2.9 万行。因此已经不需要沿着 YUM 的方向继续开发了，重新开一个分支才是更好的选择。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/dnf-command-examples-manage-packages-fedora-system/\" target=\"_blank\" rel=\"noopener\">在 Fedora 系统上使用 DNF 命令管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf grouplist</span><br><span class=\"line\">Last metadata expiration check: 0:00:00 ago on Sun 09 Sep 2018 07:10:36 PM IST.</span><br><span class=\"line\">Available Environment Groups:</span><br><span class=\"line\"> Fedora Custom Operating System</span><br><span class=\"line\"> Minimal Install</span><br><span class=\"line\"> Fedora Server Edition</span><br><span class=\"line\"> Fedora Workstation</span><br><span class=\"line\"> Fedora Cloud Server</span><br><span class=\"line\"> KDE Plasma Workspaces</span><br><span class=\"line\"> Xfce Desktop</span><br><span class=\"line\"> LXDE Desktop</span><br><span class=\"line\"> Hawaii Desktop</span><br><span class=\"line\"> LXQt Desktop</span><br><span class=\"line\"> Cinnamon Desktop</span><br><span class=\"line\"> MATE Desktop</span><br><span class=\"line\"> Sugar Desktop Environment</span><br><span class=\"line\"> Development and Creative Workstation</span><br><span class=\"line\"> Web Server</span><br><span class=\"line\"> Infrastructure Server</span><br><span class=\"line\"> Basic Desktop</span><br><span class=\"line\">Installed Groups:</span><br><span class=\"line\"> C Development Tools and Libraries</span><br><span class=\"line\"> Development Tools</span><br><span class=\"line\">Available Groups:</span><br><span class=\"line\"> 3D Printing</span><br><span class=\"line\"> Administration Tools</span><br><span class=\"line\"> Ansible node</span><br><span class=\"line\"> Audio Production</span><br><span class=\"line\"> Authoring and Publishing</span><br><span class=\"line\"> Books and Guides</span><br><span class=\"line\"> Cloud Infrastructure</span><br><span class=\"line\"> Cloud Management Tools</span><br><span class=\"line\"> Container Management</span><br><span class=\"line\"> D Development Tools and Libraries</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"> RPM Development Tools</span><br><span class=\"line\"> Security Lab</span><br><span class=\"line\"> Text-based Internet</span><br><span class=\"line\"> Window Managers</span><br><span class=\"line\"> GNOME Desktop Environment</span><br><span class=\"line\"> Graphical Internet</span><br><span class=\"line\"> KDE (K Desktop Environment)</span><br><span class=\"line\"> Fonts</span><br><span class=\"line\"> Games and Entertainment</span><br><span class=\"line\"> Hardware Support</span><br><span class=\"line\"> Sound and Video</span><br><span class=\"line\"> System Tools</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “Editor” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># dnf groupinfo Editors</span><br><span class=\"line\">Last metadata expiration check: 0:04:57 ago on Sun 09 Sep 2018 07:10:36 PM IST.</span><br><span class=\"line\"></span><br><span class=\"line\">Group: Editors</span><br><span class=\"line\"> Description: Sometimes called text editors, these are programs that allow you to create and edit text files. This includes Emacs and Vi.</span><br><span class=\"line\"> Optional Packages:</span><br><span class=\"line\"> code-editor</span><br><span class=\"line\"> cssed</span><br><span class=\"line\"> emacs</span><br><span class=\"line\"> emacs-auctex</span><br><span class=\"line\"> emacs-bbdb</span><br><span class=\"line\"> emacs-ess</span><br><span class=\"line\"> emacs-vm</span><br><span class=\"line\"> geany</span><br><span class=\"line\"> gobby</span><br><span class=\"line\"> jed</span><br><span class=\"line\"> joe</span><br><span class=\"line\"> leafpad</span><br><span class=\"line\"> nedit</span><br><span class=\"line\"> poedit</span><br><span class=\"line\"> psgml</span><br><span class=\"line\"> vim-X11</span><br><span class=\"line\"> vim-enhanced</span><br><span class=\"line\"> xemacs</span><br><span class=\"line\"> xemacs-packages-base</span><br><span class=\"line\"> xemacs-packages-extra</span><br><span class=\"line\"> xemacs-xft</span><br><span class=\"line\"> xmlcopyeditor</span><br><span class=\"line\"> zile</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-openSUSE-系统上列出可用的软件包组\"><a href=\"#如何在-openSUSE-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 openSUSE 系统上列出可用的软件包组\"></a>如何在 openSUSE 系统上列出可用的软件包组</h3><p>openSUSE 系统使用的是 zypper 软件包管理器，因此可以通过 zypper 软件包管理器来获取相关的信息。</p>\n<p>Zypper 是 suse 和 openSUSE 发行版的命令行包管理器。它可以用于安装、更新、搜索和删除软件包，还有管理存储库，执行各种查询等功能。 Zypper 命令行界面用到了 ZYpp 系统管理库（libzypp）。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/zypper-command-examples-manage-packages-opensuse-system/\" target=\"_blank\" rel=\"noopener\">在 openSUSE 和 suse 系统使用 zypper 命令管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper patterns</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\">S | Name | Version | Repository | Dependency</span><br><span class=\"line\">---|----------------------|---------------|-----------------------|-----------</span><br><span class=\"line\"> | 64bit | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | apparmor | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | apparmor | 20150918-25.1 | @System |</span><br><span class=\"line\"> | base | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | base | 20150918-25.1 | @System |</span><br><span class=\"line\"> | books | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | console | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | devel_C_C++ | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | enhanced_base | 20150918-25.1 | @System |</span><br><span class=\"line\"> | enlightenment | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | file_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | fonts | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | fonts | 20150918-25.1 | @System |</span><br><span class=\"line\"> | games | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | games | 20150918-25.1 | @System |</span><br><span class=\"line\"> | gnome | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | gnome_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | imaging | 20150918-25.1 | @System |</span><br><span class=\"line\"> | kde | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | kde | 20150918-25.1 | @System |</span><br><span class=\"line\"> | kde_plasma | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | kde_plasma | 20150918-25.1 | @System |</span><br><span class=\"line\"> | lamp_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | laptop | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | laptop | 20150918-25.1 | @System |</span><br><span class=\"line\"> | lxde | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | lxqt | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | multimedia | 20150918-25.1 | @System |</span><br><span class=\"line\"> | network_admin | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | non_oss | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | non_oss | 20150918-25.1 | @System |</span><br><span class=\"line\"> | office | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | office | 20150918-25.1 | @System |</span><br><span class=\"line\"> | print_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | remote_desktop | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | x11 | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i+ | x11 | 20150918-25.1 | @System |</span><br><span class=\"line\"> | x86 | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xen_server | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xfce | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | xfce_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\"> | yast2_basis | 20150918-25.1 | Main Repository (OSS) |</span><br><span class=\"line\">i | yast2_basis | 20150918-25.1 | @System |</span><br><span class=\"line\"> | yast2_install_wf | 20150918-25.1 | Main Repository (OSS) |</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “file_server” 组相关联的软件包。另外 <code>zypper</code> 还允许用户使用不同的选项执行相同的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper pattern-info file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，也可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info pattern file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，也可以执行以下这个命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># zypper info -t pattern file_server</span><br><span class=\"line\">Loading repository data...</span><br><span class=\"line\">Warning: Repository &apos;Update Repository (Non-Oss)&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Warning: Repository &apos;Main Update Repository&apos; appears to be outdated. Consider using a different mirror or server.</span><br><span class=\"line\">Reading installed packages...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Information for pattern file_server:</span><br><span class=\"line\">------------------------------------</span><br><span class=\"line\">Repository : Main Repository (OSS)</span><br><span class=\"line\">Name : file_server</span><br><span class=\"line\">Version : 20150918-25.1</span><br><span class=\"line\">Arch : x86_64</span><br><span class=\"line\">Vendor : openSUSE</span><br><span class=\"line\">Installed : No</span><br><span class=\"line\">Visible to User : Yes</span><br><span class=\"line\">Summary : File Server</span><br><span class=\"line\">Description :</span><br><span class=\"line\"> File services to host files so that they may be accessed or retrieved by other computers on the same network. This includes the FTP, SMB, and NFS protocols.</span><br><span class=\"line\">Contents :</span><br><span class=\"line\"> S | Name | Type | Dependency</span><br><span class=\"line\"> ---|-------------------------------|---------|------------</span><br><span class=\"line\"> i+ | patterns-openSUSE-base | package | Required</span><br><span class=\"line\"> | patterns-openSUSE-file_server | package | Required</span><br><span class=\"line\"> | nfs-kernel-server | package | Recommended</span><br><span class=\"line\"> i | nfsidmap | package | Recommended</span><br><span class=\"line\"> i | samba | package | Recommended</span><br><span class=\"line\"> i | samba-client | package | Recommended</span><br><span class=\"line\"> i | samba-winbind | package | Recommended</span><br><span class=\"line\"> | tftp | package | Recommended</span><br><span class=\"line\"> | vsftpd | package | Recommended</span><br><span class=\"line\"> | yast2-ftp-server | package | Recommended</span><br><span class=\"line\"> | yast2-nfs-server | package | Recommended</span><br><span class=\"line\"> i | yast2-samba-server | package | Recommended</span><br><span class=\"line\"> | yast2-tftp-server | package | Recommended</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在-Debian-Ubuntu-系统上列出可用的软件包组\"><a href=\"#如何在-Debian-Ubuntu-系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在 Debian/Ubuntu 系统上列出可用的软件包组\"></a>如何在 Debian/Ubuntu 系统上列出可用的软件包组</h3><p>由于 APT 或 APT-GET 软件包管理器没有为基于 Debian/Ubuntu 的系统提供这样的选项，因此需要使用 <code>tasksel</code> 命令来获取相关信息。</p>\n<p><a href=\"https://wiki.debian.org/tasksel\" target=\"_blank\" rel=\"noopener\">tasksel</a> 是 Debian/Ubuntu 系统上一个很方便的工具，只需要很少的操作就可以用它来安装好一组软件包。可以在 <code>/usr/share/tasksel</code> 目录下的 <code>.desc</code> 文件中安排软件包的安装任务。</p>\n<p>默认情况下，<code>tasksel</code> 工具是作为 Debian 系统的一部分安装的，但桌面版 Ubuntu 则没有自带 <code>tasksel</code>，这个功能类似软件包管理器中的元包（meta-packages）。</p>\n<p><code>tasksel</code> 工具带有一个基于 zenity 的简单用户界面，例如命令行中的弹出图形对话框。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/tasksel-install-group-of-software-in-a-single-click-or-single-command-on-debian-ubuntu/\" target=\"_blank\" rel=\"noopener\">使用 tasksel 在 Debian/Ubuntu 系统上快速安装软件包组</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># tasksel --list-task</span><br><span class=\"line\">u kubuntu-live Kubuntu live CD</span><br><span class=\"line\">u lubuntu-live-gtk Lubuntu live CD (GTK part)</span><br><span class=\"line\">u ubuntu-budgie-live Ubuntu Budgie live CD</span><br><span class=\"line\">u ubuntu-live Ubuntu live CD</span><br><span class=\"line\">u ubuntu-mate-live Ubuntu MATE Live CD</span><br><span class=\"line\">u ubuntustudio-dvd-live Ubuntu Studio live DVD</span><br><span class=\"line\">u vanilla-gnome-live Ubuntu GNOME live CD</span><br><span class=\"line\">u xubuntu-live Xubuntu live CD</span><br><span class=\"line\">u cloud-image Ubuntu Cloud Image (instance)</span><br><span class=\"line\">u dns-server DNS server</span><br><span class=\"line\">u kubuntu-desktop Kubuntu desktop</span><br><span class=\"line\">u kubuntu-full Kubuntu full</span><br><span class=\"line\">u lamp-server LAMP server</span><br><span class=\"line\">u lubuntu-core Lubuntu minimal installation</span><br><span class=\"line\">u lubuntu-desktop Lubuntu Desktop</span><br><span class=\"line\">u lubuntu-gtk-core Lubuntu minimal installation (GTK part)</span><br><span class=\"line\">u lubuntu-gtk-desktop Lubuntu Desktop (GTK part)</span><br><span class=\"line\">u lubuntu-qt-core Lubuntu minimal installation (Qt part)</span><br><span class=\"line\">u lubuntu-qt-desktop Lubuntu Qt Desktop (Qt part)</span><br><span class=\"line\">u mail-server Mail server</span><br><span class=\"line\">u postgresql-server PostgreSQL database</span><br><span class=\"line\">i print-server Print server</span><br><span class=\"line\">u samba-server Samba file server</span><br><span class=\"line\">u tomcat-server Tomcat Java server</span><br><span class=\"line\">u ubuntu-budgie-desktop Ubuntu Budgie desktop</span><br><span class=\"line\">i ubuntu-desktop Ubuntu desktop</span><br><span class=\"line\">u ubuntu-mate-core Ubuntu MATE minimal</span><br><span class=\"line\">u ubuntu-mate-desktop Ubuntu MATE desktop</span><br><span class=\"line\">i ubuntu-usb Ubuntu desktop USB</span><br><span class=\"line\">u ubuntustudio-audio Audio recording and editing suite</span><br><span class=\"line\">u ubuntustudio-desktop Ubuntu Studio desktop</span><br><span class=\"line\">u ubuntustudio-desktop-core Ubuntu Studio minimal DE installation</span><br><span class=\"line\">u ubuntustudio-fonts Large selection of font packages</span><br><span class=\"line\">u ubuntustudio-graphics 2D/3D creation and editing suite</span><br><span class=\"line\">u ubuntustudio-photography Photograph touchup and editing suite</span><br><span class=\"line\">u ubuntustudio-publishing Publishing applications</span><br><span class=\"line\">u ubuntustudio-video Video creation and editing suite</span><br><span class=\"line\">u vanilla-gnome-desktop Vanilla GNOME desktop</span><br><span class=\"line\">u xubuntu-core Xubuntu minimal installation</span><br><span class=\"line\">u xubuntu-desktop Xubuntu desktop</span><br><span class=\"line\">u openssh-server OpenSSH server</span><br><span class=\"line\">u server Basic Ubuntu server</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “lamp-server” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># tasksel --task-desc &quot;lamp-server&quot;</span><br><span class=\"line\">Selects a ready-made Linux/Apache/MySQL/PHP server.</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何在基于-Arch-Linux-的系统上列出可用的软件包组\"><a href=\"#如何在基于-Arch-Linux-的系统上列出可用的软件包组\" class=\"headerlink\" title=\"如何在基于 Arch Linux 的系统上列出可用的软件包组\"></a>如何在基于 Arch Linux 的系统上列出可用的软件包组</h3><p>基于 Arch Linux 的系统使用的是 pacman 软件包管理器，因此可以通过 pacman 软件包管理器来获取相关的信息。</p>\n<p>pacman 是 “package manager” 的缩写。<code>pacman</code> 可以用于安装、构建、删除和管理 Arch Linux 软件包。<code>pacman</code> 使用 libalpm（Arch Linux Package Management 库，ALPM）作为后端来执行所有操作。</p>\n<p><strong>推荐阅读：</strong> <a href=\"https://www.2daygeek.com/pacman-command-examples-manage-packages-arch-linux-system/\" target=\"_blank\" rel=\"noopener\">使用 pacman 在基于 Arch Linux 的系统上管理软件包</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg</span><br><span class=\"line\">base-devel</span><br><span class=\"line\">base</span><br><span class=\"line\">multilib-devel</span><br><span class=\"line\">gnome-extra</span><br><span class=\"line\">kde-applications</span><br><span class=\"line\">kdepim</span><br><span class=\"line\">kdeutils</span><br><span class=\"line\">kdeedu</span><br><span class=\"line\">kf5</span><br><span class=\"line\">kdemultimedia</span><br><span class=\"line\">gnome</span><br><span class=\"line\">plasma</span><br><span class=\"line\">kdegames</span><br><span class=\"line\">kdesdk</span><br><span class=\"line\">kdebase</span><br><span class=\"line\">xfce4</span><br><span class=\"line\">fprint</span><br><span class=\"line\">kdegraphics</span><br><span class=\"line\">kdenetwork</span><br><span class=\"line\">kdeadmin</span><br><span class=\"line\">kf5-aids</span><br><span class=\"line\">kdewebdev</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">dlang-ldc</span><br><span class=\"line\">libretro</span><br><span class=\"line\">ring</span><br><span class=\"line\">lxqt</span><br><span class=\"line\">non-daw</span><br><span class=\"line\">non</span><br><span class=\"line\">alsa</span><br><span class=\"line\">qtcurve</span><br><span class=\"line\">realtime</span><br><span class=\"line\">sugar-fructose</span><br><span class=\"line\">tesseract-data</span><br><span class=\"line\">vim-plugins</span><br></pre></td></tr></table></figure>\n<p>如果需要列出相关联的软件包，可以执行以下这个命令。下面的例子是列出和 “gnome” 组相关联的软件包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg gnome</span><br><span class=\"line\">gnome baobab</span><br><span class=\"line\">gnome cheese</span><br><span class=\"line\">gnome eog</span><br><span class=\"line\">gnome epiphany</span><br><span class=\"line\">gnome evince</span><br><span class=\"line\">gnome file-roller</span><br><span class=\"line\">gnome gdm</span><br><span class=\"line\">gnome gedit</span><br><span class=\"line\">gnome gnome-backgrounds</span><br><span class=\"line\">gnome gnome-calculator</span><br><span class=\"line\">gnome gnome-calendar</span><br><span class=\"line\">gnome gnome-characters</span><br><span class=\"line\">gnome gnome-clocks</span><br><span class=\"line\">gnome gnome-color-manager</span><br><span class=\"line\">gnome gnome-contacts</span><br><span class=\"line\">gnome gnome-control-center</span><br><span class=\"line\">gnome gnome-dictionary</span><br><span class=\"line\">gnome gnome-disk-utility</span><br><span class=\"line\">gnome gnome-documents</span><br><span class=\"line\">gnome gnome-font-viewer</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">gnome sushi</span><br><span class=\"line\">gnome totem</span><br><span class=\"line\">gnome tracker</span><br><span class=\"line\">gnome tracker-miners</span><br><span class=\"line\">gnome vino</span><br><span class=\"line\">gnome xdg-user-dirs-gtk</span><br><span class=\"line\">gnome yelp</span><br><span class=\"line\">gnome gnome-boxes</span><br><span class=\"line\">gnome gnome-software</span><br><span class=\"line\">gnome simple-scan</span><br></pre></td></tr></table></figure>\n<p>也可以执行以下这个命令实现同样的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gnome</span><br><span class=\"line\">:: There are 64 members in group gnome:</span><br><span class=\"line\">:: Repository extra</span><br><span class=\"line\"> 1) baobab 2) cheese 3) eog 4) epiphany 5) evince 6) file-roller 7) gdm 8) gedit 9) gnome-backgrounds 10) gnome-calculator 11) gnome-calendar 12) gnome-characters 13) gnome-clocks</span><br><span class=\"line\"> 14) gnome-color-manager 15) gnome-contacts 16) gnome-control-center 17) gnome-dictionary 18) gnome-disk-utility 19) gnome-documents 20) gnome-font-viewer 21) gnome-getting-started-docs</span><br><span class=\"line\"> 22) gnome-keyring 23) gnome-logs 24) gnome-maps 25) gnome-menus 26) gnome-music 27) gnome-photos 28) gnome-screenshot 29) gnome-session 30) gnome-settings-daemon 31) gnome-shell</span><br><span class=\"line\"> 32) gnome-shell-extensions 33) gnome-system-monitor 34) gnome-terminal 35) gnome-themes-extra 36) gnome-todo 37) gnome-user-docs 38) gnome-user-share 39) gnome-video-effects 40) grilo-plugins</span><br><span class=\"line\"> 41) gvfs 42) gvfs-afc 43) gvfs-goa 44) gvfs-google 45) gvfs-gphoto2 46) gvfs-mtp 47) gvfs-nfs 48) gvfs-smb 49) mousetweaks 50) mutter 51) nautilus 52) networkmanager 53) orca 54) rygel</span><br><span class=\"line\"> 55) sushi 56) totem 57) tracker 58) tracker-miners 59) vino 60) xdg-user-dirs-gtk 61) yelp</span><br><span class=\"line\">:: Repository community</span><br><span class=\"line\"> 62) gnome-boxes 63) gnome-software 64) simple-scan</span><br><span class=\"line\"></span><br><span class=\"line\">Enter a selection (default=all): ^C</span><br><span class=\"line\">Interrupt signal received</span><br></pre></td></tr></table></figure>\n<p>可以执行以下命令检查相关软件包的数量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -Sg gnome | wc -l</span><br><span class=\"line\">64</span><br></pre></td></tr></table></figure>\n<hr>\n<p>via: <a href=\"https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/\" target=\"_blank\" rel=\"noopener\">https://www.2daygeek.com/how-to-list-an-available-package-groups-in-linux/</a></p>\n"},{"title":"如何在双系统引导下替换 Linux 发行版","date":"2018-10-20T16:22:05.000Z","_content":"\n> 在双系统引导的状态下，你可以将已安装的 Linux 发行版替换为另一个发行版，同时还可以保留原本的个人数据。\n\n![How to Replace One Linux Distribution With Another From Dual Boot][1]\n\n假设你的电脑上已经[以双系统的形式安装了 Ubuntu 和 Windows][2]，但经过[将 Linux Mint 与 Ubuntu 比较][3]之后，你又觉得 [Linux Mint][4] 会更适合自己的时候，你会怎样做？又该如何在[删除 Ubuntu][5] 的同时[在双系统中安装 Mint][6] 呢？\n\n你或许觉得应该首先从在双系统中卸载 [Ubuntu][7]，然后使用 Linux Mint 重新安装成双系统。但实际上并不需要这么麻烦。\n\n如果你已经在双系统引导中安装了一种 Linux 发行版，就可以轻松替换成另一个发行版了，而且也不必卸载已有的 Linux 发行版，只需要删除其所在的分区，然后在腾出的磁盘空间上安装另一个 Linux 发行版就可以了。\n\n与此同时，更换 Linux 发行版后，仍然会保留原本 home 目录中包含所有文件。\n\n下面就来详细介绍一下。\n\n### 在双系统引导中替换 Linux 发行版\n\n<https://youtu.be/ptF2RUehbKs>\n\n这是我的演示范例。我使用双系统引导同时安装了 Windows 10 和 Linux Mint 19，然后我会把 Linux Mint 19 替换成 Elementary OS 5，同时在替换后保留我的个人文件（包括音乐、图片、视频和 home 目录中的文件）。\n\n你需要做好以下这些准备：\n\n  * 使用 Linux 和 Windows 双系统引导\n  * 需要安装的 Linux 发行版的 USB live 版\n  * 在外部磁盘备份 Windows 和 Linux 中的重要文件（并非必要，但建议备份一下）\n\n#### 在替换 Linux 发行版时要记住保留你的 home 目录\n\n如果想让个人文件在安装新 Linux 系统的过程中不受影响，原有的 Linux 系统必须具有单独的 root 目录和 home 目录。你可能会发现我的[双系统引导教程][8]在安装过程中不选择“与 Windows 共存”选项，而选择“其它”选项，然后手动创建 root 和 home 分区。所以，手动创建单独的 home 分区也算是一个磨刀不误砍柴工的操作。因为如果要在不丢失文件的情况下，将现有的 Linux 发行版替换为另一个发行版，需要将 home 目录存放在一个单独的分区上。\n\n不过，你必须记住现有 Linux 系统的用户名和密码才能使用与新系统中相同的 home 目录。\n\n如果你没有单独的 home 分区，也可以后续再进行创建。但这并不是推荐做法，因为这个过程会比较复杂，有可能会把你的系统搞乱。\n\n下面来看看如何替换到另一个 Linux 发行版。\n\n#### 步骤 1：为新的 Linux 发行版创建一个 USB live 版\n\n尽管上文中已经提到了它，但我还是要重复一次以免忽略。\n\n你可以使用 Windows 或 Linux 中的启动盘创建器（例如 [Etcher][9]）来创建 USB live 版，这个过程比较简单，这里不再详细叙述。\n\n#### 步骤 2：启动 USB live 版并安装 Linux\n\n你应该已经使用过双系统启动，对这个过程不会陌生。使用 USB live 版重新启动系统，在启动时反复按 F10 或 F12 进入 BIOS 设置。选择从 USB 启动，就可以看到进入 live 环境或立即安装的选项。\n\n在安装过程中，进入“安装类型”界面时，选择“其它”选项。\n\n![Replacing one Linux with another from dual boot][10]\n\n*在这里选择“其它”选项*\n\n#### 步骤 3：准备分区操作\n\n下图是分区界面。你会看到使用 Ext4 文件系统类型来安装 Linux。\n\n![Identifying Linux partition in dual boot][11]\n\n*确定 Linux 的安装位置*\n\n在上图中，标记为 Linux Mint 19 的 Ext4 分区是 root 分区，大小为 82691 MB 的第二个 Ext4 分区是 home 分区。在这里我这里没有使用[交换空间][12]。\n\n如果你只有一个 Ext4 分区，就意味着你的 home 目录与 root 目录位于同一分区。在这种情况下，你就无法保留 home 目录中的文件了，这个时候我建议将重要文件复制到外部磁盘，否则这些文件将不会保留。\n\n然后是删除 root 分区。选择 root 分区，然后点击 `-` 号，这个操作释放了一些磁盘空间。\n\n![Delete root partition of your existing Linux install][13]\n\n*删除 root 分区*\n\n磁盘空间释放出来后，点击 `+` 号。\n\n![Create root partition for the new Linux][14]\n\n*创建新的 root 分区*\n\n现在已经在可用空间中创建一个新分区。如果你之前的 Linux 系统中只有一个 root 分区，就应该在这里创建 root 分区和 home 分区。如果需要，还可以创建交换分区。\n\n如果你之前已经有 root 分区和 home 分区，那么只需要从已删除的 root 分区创建 root 分区就可以了。\n\n![Create root partition for the new Linux][15]\n\n*创建 root 分区*\n\n你可能有疑问，为什么要经过“删除”和“添加”两个过程，而不使用“更改”选项。这是因为以前使用“更改”选项好像没有效果，所以我更喜欢用 `-` 和 `+`。这是迷信吗？也许是吧。\n\n这里有一个重要的步骤，对新创建的 root 分区进行格式化。在没有更改分区大小的情况下，默认是不会对分区进行格式化的。如果分区没有被格式化，之后可能会出现问题。\n\n![][16]\n\n*格式化 root 分区很重要*\n\n如果你在新的 Linux 系统上已经划分了单独的 home 分区，选中它并点击更改。\n\n![Recreate home partition][17]\n\n*修改已有的 home 分区*\n\n然后指定将其作为 home 分区挂载即可。\n\n![Specify the home mount point][18]\n\n*指定 home 分区的挂载点*\n\n如果你还有交换分区，可以重复与 home 分区相同的步骤，唯一不同的是要指定将空间用作交换空间。\n\n现在的状态应该是有一个 root 分区（将被格式化）和一个 home 分区（如果需要，还可以使用交换分区）。点击“立即安装”可以开始安装。\n\n![Verify partitions while replacing one Linux with another][19]\n\n*检查分区情况*\n\n接下来的几个界面就很熟悉了，要重点注意的是创建用户和密码的步骤。如果你之前有一个单独的 home 分区，并且还想使用相同的 home 目录，那你必须使用和之前相同的用户名和密码，至于设备名称则可以任意指定。\n\n![To keep the home partition intact, use the previous user and password][20]\n\n*要保持 home 分区不变，请使用之前的用户名和密码*\n\n接下来只要静待安装完成，不需执行任何操作。\n\n![Wait for installation to finish][21]\n\n*等待安装完成*\n\n安装完成后重新启动系统，你就能使用新的 Linux 发行版。\n\n在以上的例子中，我可以在新的 Linux Mint 19 中使用原有的 Elementary OS 中的整个 home 目录，并且其中所有视频和图片都原封不动。岂不美哉？\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/replace-linux-from-dual-boot/\n\n[a]: https://itsfoss.com/author/abhishek/\n[1]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Replace-Linux-Distro-from-dual-boot.png\n[2]: https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\n[3]: https://itsfoss.com/linux-mint-vs-ubuntu/\n[4]: https://www.linuxmint.com/\n[5]: https://itsfoss.com/uninstall-ubuntu-linux-windows-dual-boot/\n[6]: https://itsfoss.com/guide-install-linux-mint-16-dual-boot-windows/\n[7]: https://www.ubuntu.com/\n[8]: https://itsfoss.com/guide-install-elementary-os-luna/\n[9]: https://etcher.io/\n[10]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-1.jpg\n[11]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-2.jpg\n[12]: https://itsfoss.com/swap-size/\n[13]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-3.jpg\n[14]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-4.jpg\n[15]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-5.jpg\n[16]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-6.jpg\n[17]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-7.jpg\n[18]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-8.jpg\n[19]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-9.jpg\n[20]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-10.jpg\n[21]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-11.jpg\n\n","source":"_posts/How-to-Replace-one-Linux-Distro-With-Another-in-Dual-Boot-Guide.md","raw":"---\ntitle: 如何在双系统引导下替换 Linux 发行版\ndate: 2018-10-21 00:22:05\ntags:\n  - Linux\n  - 双系统\n  - LCTT 翻译\n---\n\n> 在双系统引导的状态下，你可以将已安装的 Linux 发行版替换为另一个发行版，同时还可以保留原本的个人数据。\n\n![How to Replace One Linux Distribution With Another From Dual Boot][1]\n\n假设你的电脑上已经[以双系统的形式安装了 Ubuntu 和 Windows][2]，但经过[将 Linux Mint 与 Ubuntu 比较][3]之后，你又觉得 [Linux Mint][4] 会更适合自己的时候，你会怎样做？又该如何在[删除 Ubuntu][5] 的同时[在双系统中安装 Mint][6] 呢？\n\n你或许觉得应该首先从在双系统中卸载 [Ubuntu][7]，然后使用 Linux Mint 重新安装成双系统。但实际上并不需要这么麻烦。\n\n如果你已经在双系统引导中安装了一种 Linux 发行版，就可以轻松替换成另一个发行版了，而且也不必卸载已有的 Linux 发行版，只需要删除其所在的分区，然后在腾出的磁盘空间上安装另一个 Linux 发行版就可以了。\n\n与此同时，更换 Linux 发行版后，仍然会保留原本 home 目录中包含所有文件。\n\n下面就来详细介绍一下。\n\n### 在双系统引导中替换 Linux 发行版\n\n<https://youtu.be/ptF2RUehbKs>\n\n这是我的演示范例。我使用双系统引导同时安装了 Windows 10 和 Linux Mint 19，然后我会把 Linux Mint 19 替换成 Elementary OS 5，同时在替换后保留我的个人文件（包括音乐、图片、视频和 home 目录中的文件）。\n\n你需要做好以下这些准备：\n\n  * 使用 Linux 和 Windows 双系统引导\n  * 需要安装的 Linux 发行版的 USB live 版\n  * 在外部磁盘备份 Windows 和 Linux 中的重要文件（并非必要，但建议备份一下）\n\n#### 在替换 Linux 发行版时要记住保留你的 home 目录\n\n如果想让个人文件在安装新 Linux 系统的过程中不受影响，原有的 Linux 系统必须具有单独的 root 目录和 home 目录。你可能会发现我的[双系统引导教程][8]在安装过程中不选择“与 Windows 共存”选项，而选择“其它”选项，然后手动创建 root 和 home 分区。所以，手动创建单独的 home 分区也算是一个磨刀不误砍柴工的操作。因为如果要在不丢失文件的情况下，将现有的 Linux 发行版替换为另一个发行版，需要将 home 目录存放在一个单独的分区上。\n\n不过，你必须记住现有 Linux 系统的用户名和密码才能使用与新系统中相同的 home 目录。\n\n如果你没有单独的 home 分区，也可以后续再进行创建。但这并不是推荐做法，因为这个过程会比较复杂，有可能会把你的系统搞乱。\n\n下面来看看如何替换到另一个 Linux 发行版。\n\n#### 步骤 1：为新的 Linux 发行版创建一个 USB live 版\n\n尽管上文中已经提到了它，但我还是要重复一次以免忽略。\n\n你可以使用 Windows 或 Linux 中的启动盘创建器（例如 [Etcher][9]）来创建 USB live 版，这个过程比较简单，这里不再详细叙述。\n\n#### 步骤 2：启动 USB live 版并安装 Linux\n\n你应该已经使用过双系统启动，对这个过程不会陌生。使用 USB live 版重新启动系统，在启动时反复按 F10 或 F12 进入 BIOS 设置。选择从 USB 启动，就可以看到进入 live 环境或立即安装的选项。\n\n在安装过程中，进入“安装类型”界面时，选择“其它”选项。\n\n![Replacing one Linux with another from dual boot][10]\n\n*在这里选择“其它”选项*\n\n#### 步骤 3：准备分区操作\n\n下图是分区界面。你会看到使用 Ext4 文件系统类型来安装 Linux。\n\n![Identifying Linux partition in dual boot][11]\n\n*确定 Linux 的安装位置*\n\n在上图中，标记为 Linux Mint 19 的 Ext4 分区是 root 分区，大小为 82691 MB 的第二个 Ext4 分区是 home 分区。在这里我这里没有使用[交换空间][12]。\n\n如果你只有一个 Ext4 分区，就意味着你的 home 目录与 root 目录位于同一分区。在这种情况下，你就无法保留 home 目录中的文件了，这个时候我建议将重要文件复制到外部磁盘，否则这些文件将不会保留。\n\n然后是删除 root 分区。选择 root 分区，然后点击 `-` 号，这个操作释放了一些磁盘空间。\n\n![Delete root partition of your existing Linux install][13]\n\n*删除 root 分区*\n\n磁盘空间释放出来后，点击 `+` 号。\n\n![Create root partition for the new Linux][14]\n\n*创建新的 root 分区*\n\n现在已经在可用空间中创建一个新分区。如果你之前的 Linux 系统中只有一个 root 分区，就应该在这里创建 root 分区和 home 分区。如果需要，还可以创建交换分区。\n\n如果你之前已经有 root 分区和 home 分区，那么只需要从已删除的 root 分区创建 root 分区就可以了。\n\n![Create root partition for the new Linux][15]\n\n*创建 root 分区*\n\n你可能有疑问，为什么要经过“删除”和“添加”两个过程，而不使用“更改”选项。这是因为以前使用“更改”选项好像没有效果，所以我更喜欢用 `-` 和 `+`。这是迷信吗？也许是吧。\n\n这里有一个重要的步骤，对新创建的 root 分区进行格式化。在没有更改分区大小的情况下，默认是不会对分区进行格式化的。如果分区没有被格式化，之后可能会出现问题。\n\n![][16]\n\n*格式化 root 分区很重要*\n\n如果你在新的 Linux 系统上已经划分了单独的 home 分区，选中它并点击更改。\n\n![Recreate home partition][17]\n\n*修改已有的 home 分区*\n\n然后指定将其作为 home 分区挂载即可。\n\n![Specify the home mount point][18]\n\n*指定 home 分区的挂载点*\n\n如果你还有交换分区，可以重复与 home 分区相同的步骤，唯一不同的是要指定将空间用作交换空间。\n\n现在的状态应该是有一个 root 分区（将被格式化）和一个 home 分区（如果需要，还可以使用交换分区）。点击“立即安装”可以开始安装。\n\n![Verify partitions while replacing one Linux with another][19]\n\n*检查分区情况*\n\n接下来的几个界面就很熟悉了，要重点注意的是创建用户和密码的步骤。如果你之前有一个单独的 home 分区，并且还想使用相同的 home 目录，那你必须使用和之前相同的用户名和密码，至于设备名称则可以任意指定。\n\n![To keep the home partition intact, use the previous user and password][20]\n\n*要保持 home 分区不变，请使用之前的用户名和密码*\n\n接下来只要静待安装完成，不需执行任何操作。\n\n![Wait for installation to finish][21]\n\n*等待安装完成*\n\n安装完成后重新启动系统，你就能使用新的 Linux 发行版。\n\n在以上的例子中，我可以在新的 Linux Mint 19 中使用原有的 Elementary OS 中的整个 home 目录，并且其中所有视频和图片都原封不动。岂不美哉？\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/replace-linux-from-dual-boot/\n\n[a]: https://itsfoss.com/author/abhishek/\n[1]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Replace-Linux-Distro-from-dual-boot.png\n[2]: https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\n[3]: https://itsfoss.com/linux-mint-vs-ubuntu/\n[4]: https://www.linuxmint.com/\n[5]: https://itsfoss.com/uninstall-ubuntu-linux-windows-dual-boot/\n[6]: https://itsfoss.com/guide-install-linux-mint-16-dual-boot-windows/\n[7]: https://www.ubuntu.com/\n[8]: https://itsfoss.com/guide-install-elementary-os-luna/\n[9]: https://etcher.io/\n[10]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-1.jpg\n[11]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-2.jpg\n[12]: https://itsfoss.com/swap-size/\n[13]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-3.jpg\n[14]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-4.jpg\n[15]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-5.jpg\n[16]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-6.jpg\n[17]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-7.jpg\n[18]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-8.jpg\n[19]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-9.jpg\n[20]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-10.jpg\n[21]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-11.jpg\n\n","slug":"How-to-Replace-one-Linux-Distro-With-Another-in-Dual-Boot-Guide","published":1,"updated":"2019-03-28T12:00:14.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cq0011lixuj6sjr57g","content":"<blockquote>\n<p>在双系统引导的状态下，你可以将已安装的 Linux 发行版替换为另一个发行版，同时还可以保留原本的个人数据。</p>\n</blockquote>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Replace-Linux-Distro-from-dual-boot.png\" alt=\"How to Replace One Linux Distribution With Another From Dual Boot\"></p>\n<p>假设你的电脑上已经<a href=\"https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\" target=\"_blank\" rel=\"noopener\">以双系统的形式安装了 Ubuntu 和 Windows</a>，但经过<a href=\"https://itsfoss.com/linux-mint-vs-ubuntu/\" target=\"_blank\" rel=\"noopener\">将 Linux Mint 与 Ubuntu 比较</a>之后，你又觉得 <a href=\"https://www.linuxmint.com/\" target=\"_blank\" rel=\"noopener\">Linux Mint</a> 会更适合自己的时候，你会怎样做？又该如何在<a href=\"https://itsfoss.com/uninstall-ubuntu-linux-windows-dual-boot/\" target=\"_blank\" rel=\"noopener\">删除 Ubuntu</a> 的同时<a href=\"https://itsfoss.com/guide-install-linux-mint-16-dual-boot-windows/\" target=\"_blank\" rel=\"noopener\">在双系统中安装 Mint</a> 呢？</p>\n<p>你或许觉得应该首先从在双系统中卸载 <a href=\"https://www.ubuntu.com/\" target=\"_blank\" rel=\"noopener\">Ubuntu</a>，然后使用 Linux Mint 重新安装成双系统。但实际上并不需要这么麻烦。</p>\n<p>如果你已经在双系统引导中安装了一种 Linux 发行版，就可以轻松替换成另一个发行版了，而且也不必卸载已有的 Linux 发行版，只需要删除其所在的分区，然后在腾出的磁盘空间上安装另一个 Linux 发行版就可以了。</p>\n<p>与此同时，更换 Linux 发行版后，仍然会保留原本 home 目录中包含所有文件。</p>\n<p>下面就来详细介绍一下。</p>\n<h3 id=\"在双系统引导中替换-Linux-发行版\"><a href=\"#在双系统引导中替换-Linux-发行版\" class=\"headerlink\" title=\"在双系统引导中替换 Linux 发行版\"></a>在双系统引导中替换 Linux 发行版</h3><p><a href=\"https://youtu.be/ptF2RUehbKs\" target=\"_blank\" rel=\"noopener\">https://youtu.be/ptF2RUehbKs</a></p>\n<p>这是我的演示范例。我使用双系统引导同时安装了 Windows 10 和 Linux Mint 19，然后我会把 Linux Mint 19 替换成 Elementary OS 5，同时在替换后保留我的个人文件（包括音乐、图片、视频和 home 目录中的文件）。</p>\n<p>你需要做好以下这些准备：</p>\n<ul>\n<li>使用 Linux 和 Windows 双系统引导</li>\n<li>需要安装的 Linux 发行版的 USB live 版</li>\n<li>在外部磁盘备份 Windows 和 Linux 中的重要文件（并非必要，但建议备份一下）</li>\n</ul>\n<h4 id=\"在替换-Linux-发行版时要记住保留你的-home-目录\"><a href=\"#在替换-Linux-发行版时要记住保留你的-home-目录\" class=\"headerlink\" title=\"在替换 Linux 发行版时要记住保留你的 home 目录\"></a>在替换 Linux 发行版时要记住保留你的 home 目录</h4><p>如果想让个人文件在安装新 Linux 系统的过程中不受影响，原有的 Linux 系统必须具有单独的 root 目录和 home 目录。你可能会发现我的<a href=\"https://itsfoss.com/guide-install-elementary-os-luna/\" target=\"_blank\" rel=\"noopener\">双系统引导教程</a>在安装过程中不选择“与 Windows 共存”选项，而选择“其它”选项，然后手动创建 root 和 home 分区。所以，手动创建单独的 home 分区也算是一个磨刀不误砍柴工的操作。因为如果要在不丢失文件的情况下，将现有的 Linux 发行版替换为另一个发行版，需要将 home 目录存放在一个单独的分区上。</p>\n<p>不过，你必须记住现有 Linux 系统的用户名和密码才能使用与新系统中相同的 home 目录。</p>\n<p>如果你没有单独的 home 分区，也可以后续再进行创建。但这并不是推荐做法，因为这个过程会比较复杂，有可能会把你的系统搞乱。</p>\n<p>下面来看看如何替换到另一个 Linux 发行版。</p>\n<h4 id=\"步骤-1：为新的-Linux-发行版创建一个-USB-live-版\"><a href=\"#步骤-1：为新的-Linux-发行版创建一个-USB-live-版\" class=\"headerlink\" title=\"步骤 1：为新的 Linux 发行版创建一个 USB live 版\"></a>步骤 1：为新的 Linux 发行版创建一个 USB live 版</h4><p>尽管上文中已经提到了它，但我还是要重复一次以免忽略。</p>\n<p>你可以使用 Windows 或 Linux 中的启动盘创建器（例如 <a href=\"https://etcher.io/\" target=\"_blank\" rel=\"noopener\">Etcher</a>）来创建 USB live 版，这个过程比较简单，这里不再详细叙述。</p>\n<h4 id=\"步骤-2：启动-USB-live-版并安装-Linux\"><a href=\"#步骤-2：启动-USB-live-版并安装-Linux\" class=\"headerlink\" title=\"步骤 2：启动 USB live 版并安装 Linux\"></a>步骤 2：启动 USB live 版并安装 Linux</h4><p>你应该已经使用过双系统启动，对这个过程不会陌生。使用 USB live 版重新启动系统，在启动时反复按 F10 或 F12 进入 BIOS 设置。选择从 USB 启动，就可以看到进入 live 环境或立即安装的选项。</p>\n<p>在安装过程中，进入“安装类型”界面时，选择“其它”选项。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-1.jpg\" alt=\"Replacing one Linux with another from dual boot\"></p>\n<p><em>在这里选择“其它”选项</em></p>\n<h4 id=\"步骤-3：准备分区操作\"><a href=\"#步骤-3：准备分区操作\" class=\"headerlink\" title=\"步骤 3：准备分区操作\"></a>步骤 3：准备分区操作</h4><p>下图是分区界面。你会看到使用 Ext4 文件系统类型来安装 Linux。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-2.jpg\" alt=\"Identifying Linux partition in dual boot\"></p>\n<p><em>确定 Linux 的安装位置</em></p>\n<p>在上图中，标记为 Linux Mint 19 的 Ext4 分区是 root 分区，大小为 82691 MB 的第二个 Ext4 分区是 home 分区。在这里我这里没有使用<a href=\"https://itsfoss.com/swap-size/\" target=\"_blank\" rel=\"noopener\">交换空间</a>。</p>\n<p>如果你只有一个 Ext4 分区，就意味着你的 home 目录与 root 目录位于同一分区。在这种情况下，你就无法保留 home 目录中的文件了，这个时候我建议将重要文件复制到外部磁盘，否则这些文件将不会保留。</p>\n<p>然后是删除 root 分区。选择 root 分区，然后点击 <code>-</code> 号，这个操作释放了一些磁盘空间。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-3.jpg\" alt=\"Delete root partition of your existing Linux install\"></p>\n<p><em>删除 root 分区</em></p>\n<p>磁盘空间释放出来后，点击 <code>+</code> 号。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-4.jpg\" alt=\"Create root partition for the new Linux\"></p>\n<p><em>创建新的 root 分区</em></p>\n<p>现在已经在可用空间中创建一个新分区。如果你之前的 Linux 系统中只有一个 root 分区，就应该在这里创建 root 分区和 home 分区。如果需要，还可以创建交换分区。</p>\n<p>如果你之前已经有 root 分区和 home 分区，那么只需要从已删除的 root 分区创建 root 分区就可以了。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-5.jpg\" alt=\"Create root partition for the new Linux\"></p>\n<p><em>创建 root 分区</em></p>\n<p>你可能有疑问，为什么要经过“删除”和“添加”两个过程，而不使用“更改”选项。这是因为以前使用“更改”选项好像没有效果，所以我更喜欢用 <code>-</code> 和 <code>+</code>。这是迷信吗？也许是吧。</p>\n<p>这里有一个重要的步骤，对新创建的 root 分区进行格式化。在没有更改分区大小的情况下，默认是不会对分区进行格式化的。如果分区没有被格式化，之后可能会出现问题。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-6.jpg\" alt=\"\"></p>\n<p><em>格式化 root 分区很重要</em></p>\n<p>如果你在新的 Linux 系统上已经划分了单独的 home 分区，选中它并点击更改。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-7.jpg\" alt=\"Recreate home partition\"></p>\n<p><em>修改已有的 home 分区</em></p>\n<p>然后指定将其作为 home 分区挂载即可。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-8.jpg\" alt=\"Specify the home mount point\"></p>\n<p><em>指定 home 分区的挂载点</em></p>\n<p>如果你还有交换分区，可以重复与 home 分区相同的步骤，唯一不同的是要指定将空间用作交换空间。</p>\n<p>现在的状态应该是有一个 root 分区（将被格式化）和一个 home 分区（如果需要，还可以使用交换分区）。点击“立即安装”可以开始安装。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-9.jpg\" alt=\"Verify partitions while replacing one Linux with another\"></p>\n<p><em>检查分区情况</em></p>\n<p>接下来的几个界面就很熟悉了，要重点注意的是创建用户和密码的步骤。如果你之前有一个单独的 home 分区，并且还想使用相同的 home 目录，那你必须使用和之前相同的用户名和密码，至于设备名称则可以任意指定。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-10.jpg\" alt=\"To keep the home partition intact, use the previous user and password\"></p>\n<p><em>要保持 home 分区不变，请使用之前的用户名和密码</em></p>\n<p>接下来只要静待安装完成，不需执行任何操作。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-11.jpg\" alt=\"Wait for installation to finish\"></p>\n<p><em>等待安装完成</em></p>\n<p>安装完成后重新启动系统，你就能使用新的 Linux 发行版。</p>\n<p>在以上的例子中，我可以在新的 Linux Mint 19 中使用原有的 Elementary OS 中的整个 home 目录，并且其中所有视频和图片都原封不动。岂不美哉？</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/replace-linux-from-dual-boot/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/replace-linux-from-dual-boot/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在双系统引导的状态下，你可以将已安装的 Linux 发行版替换为另一个发行版，同时还可以保留原本的个人数据。</p>\n</blockquote>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/Replace-Linux-Distro-from-dual-boot.png\" alt=\"How to Replace One Linux Distribution With Another From Dual Boot\"></p>\n<p>假设你的电脑上已经<a href=\"https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/\" target=\"_blank\" rel=\"noopener\">以双系统的形式安装了 Ubuntu 和 Windows</a>，但经过<a href=\"https://itsfoss.com/linux-mint-vs-ubuntu/\" target=\"_blank\" rel=\"noopener\">将 Linux Mint 与 Ubuntu 比较</a>之后，你又觉得 <a href=\"https://www.linuxmint.com/\" target=\"_blank\" rel=\"noopener\">Linux Mint</a> 会更适合自己的时候，你会怎样做？又该如何在<a href=\"https://itsfoss.com/uninstall-ubuntu-linux-windows-dual-boot/\" target=\"_blank\" rel=\"noopener\">删除 Ubuntu</a> 的同时<a href=\"https://itsfoss.com/guide-install-linux-mint-16-dual-boot-windows/\" target=\"_blank\" rel=\"noopener\">在双系统中安装 Mint</a> 呢？</p>\n<p>你或许觉得应该首先从在双系统中卸载 <a href=\"https://www.ubuntu.com/\" target=\"_blank\" rel=\"noopener\">Ubuntu</a>，然后使用 Linux Mint 重新安装成双系统。但实际上并不需要这么麻烦。</p>\n<p>如果你已经在双系统引导中安装了一种 Linux 发行版，就可以轻松替换成另一个发行版了，而且也不必卸载已有的 Linux 发行版，只需要删除其所在的分区，然后在腾出的磁盘空间上安装另一个 Linux 发行版就可以了。</p>\n<p>与此同时，更换 Linux 发行版后，仍然会保留原本 home 目录中包含所有文件。</p>\n<p>下面就来详细介绍一下。</p>\n<h3 id=\"在双系统引导中替换-Linux-发行版\"><a href=\"#在双系统引导中替换-Linux-发行版\" class=\"headerlink\" title=\"在双系统引导中替换 Linux 发行版\"></a>在双系统引导中替换 Linux 发行版</h3><p><a href=\"https://youtu.be/ptF2RUehbKs\" target=\"_blank\" rel=\"noopener\">https://youtu.be/ptF2RUehbKs</a></p>\n<p>这是我的演示范例。我使用双系统引导同时安装了 Windows 10 和 Linux Mint 19，然后我会把 Linux Mint 19 替换成 Elementary OS 5，同时在替换后保留我的个人文件（包括音乐、图片、视频和 home 目录中的文件）。</p>\n<p>你需要做好以下这些准备：</p>\n<ul>\n<li>使用 Linux 和 Windows 双系统引导</li>\n<li>需要安装的 Linux 发行版的 USB live 版</li>\n<li>在外部磁盘备份 Windows 和 Linux 中的重要文件（并非必要，但建议备份一下）</li>\n</ul>\n<h4 id=\"在替换-Linux-发行版时要记住保留你的-home-目录\"><a href=\"#在替换-Linux-发行版时要记住保留你的-home-目录\" class=\"headerlink\" title=\"在替换 Linux 发行版时要记住保留你的 home 目录\"></a>在替换 Linux 发行版时要记住保留你的 home 目录</h4><p>如果想让个人文件在安装新 Linux 系统的过程中不受影响，原有的 Linux 系统必须具有单独的 root 目录和 home 目录。你可能会发现我的<a href=\"https://itsfoss.com/guide-install-elementary-os-luna/\" target=\"_blank\" rel=\"noopener\">双系统引导教程</a>在安装过程中不选择“与 Windows 共存”选项，而选择“其它”选项，然后手动创建 root 和 home 分区。所以，手动创建单独的 home 分区也算是一个磨刀不误砍柴工的操作。因为如果要在不丢失文件的情况下，将现有的 Linux 发行版替换为另一个发行版，需要将 home 目录存放在一个单独的分区上。</p>\n<p>不过，你必须记住现有 Linux 系统的用户名和密码才能使用与新系统中相同的 home 目录。</p>\n<p>如果你没有单独的 home 分区，也可以后续再进行创建。但这并不是推荐做法，因为这个过程会比较复杂，有可能会把你的系统搞乱。</p>\n<p>下面来看看如何替换到另一个 Linux 发行版。</p>\n<h4 id=\"步骤-1：为新的-Linux-发行版创建一个-USB-live-版\"><a href=\"#步骤-1：为新的-Linux-发行版创建一个-USB-live-版\" class=\"headerlink\" title=\"步骤 1：为新的 Linux 发行版创建一个 USB live 版\"></a>步骤 1：为新的 Linux 发行版创建一个 USB live 版</h4><p>尽管上文中已经提到了它，但我还是要重复一次以免忽略。</p>\n<p>你可以使用 Windows 或 Linux 中的启动盘创建器（例如 <a href=\"https://etcher.io/\" target=\"_blank\" rel=\"noopener\">Etcher</a>）来创建 USB live 版，这个过程比较简单，这里不再详细叙述。</p>\n<h4 id=\"步骤-2：启动-USB-live-版并安装-Linux\"><a href=\"#步骤-2：启动-USB-live-版并安装-Linux\" class=\"headerlink\" title=\"步骤 2：启动 USB live 版并安装 Linux\"></a>步骤 2：启动 USB live 版并安装 Linux</h4><p>你应该已经使用过双系统启动，对这个过程不会陌生。使用 USB live 版重新启动系统，在启动时反复按 F10 或 F12 进入 BIOS 设置。选择从 USB 启动，就可以看到进入 live 环境或立即安装的选项。</p>\n<p>在安装过程中，进入“安装类型”界面时，选择“其它”选项。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-1.jpg\" alt=\"Replacing one Linux with another from dual boot\"></p>\n<p><em>在这里选择“其它”选项</em></p>\n<h4 id=\"步骤-3：准备分区操作\"><a href=\"#步骤-3：准备分区操作\" class=\"headerlink\" title=\"步骤 3：准备分区操作\"></a>步骤 3：准备分区操作</h4><p>下图是分区界面。你会看到使用 Ext4 文件系统类型来安装 Linux。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-2.jpg\" alt=\"Identifying Linux partition in dual boot\"></p>\n<p><em>确定 Linux 的安装位置</em></p>\n<p>在上图中，标记为 Linux Mint 19 的 Ext4 分区是 root 分区，大小为 82691 MB 的第二个 Ext4 分区是 home 分区。在这里我这里没有使用<a href=\"https://itsfoss.com/swap-size/\" target=\"_blank\" rel=\"noopener\">交换空间</a>。</p>\n<p>如果你只有一个 Ext4 分区，就意味着你的 home 目录与 root 目录位于同一分区。在这种情况下，你就无法保留 home 目录中的文件了，这个时候我建议将重要文件复制到外部磁盘，否则这些文件将不会保留。</p>\n<p>然后是删除 root 分区。选择 root 分区，然后点击 <code>-</code> 号，这个操作释放了一些磁盘空间。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-3.jpg\" alt=\"Delete root partition of your existing Linux install\"></p>\n<p><em>删除 root 分区</em></p>\n<p>磁盘空间释放出来后，点击 <code>+</code> 号。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-4.jpg\" alt=\"Create root partition for the new Linux\"></p>\n<p><em>创建新的 root 分区</em></p>\n<p>现在已经在可用空间中创建一个新分区。如果你之前的 Linux 系统中只有一个 root 分区，就应该在这里创建 root 分区和 home 分区。如果需要，还可以创建交换分区。</p>\n<p>如果你之前已经有 root 分区和 home 分区，那么只需要从已删除的 root 分区创建 root 分区就可以了。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-5.jpg\" alt=\"Create root partition for the new Linux\"></p>\n<p><em>创建 root 分区</em></p>\n<p>你可能有疑问，为什么要经过“删除”和“添加”两个过程，而不使用“更改”选项。这是因为以前使用“更改”选项好像没有效果，所以我更喜欢用 <code>-</code> 和 <code>+</code>。这是迷信吗？也许是吧。</p>\n<p>这里有一个重要的步骤，对新创建的 root 分区进行格式化。在没有更改分区大小的情况下，默认是不会对分区进行格式化的。如果分区没有被格式化，之后可能会出现问题。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-6.jpg\" alt=\"\"></p>\n<p><em>格式化 root 分区很重要</em></p>\n<p>如果你在新的 Linux 系统上已经划分了单独的 home 分区，选中它并点击更改。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-7.jpg\" alt=\"Recreate home partition\"></p>\n<p><em>修改已有的 home 分区</em></p>\n<p>然后指定将其作为 home 分区挂载即可。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-8.jpg\" alt=\"Specify the home mount point\"></p>\n<p><em>指定 home 分区的挂载点</em></p>\n<p>如果你还有交换分区，可以重复与 home 分区相同的步骤，唯一不同的是要指定将空间用作交换空间。</p>\n<p>现在的状态应该是有一个 root 分区（将被格式化）和一个 home 分区（如果需要，还可以使用交换分区）。点击“立即安装”可以开始安装。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-9.jpg\" alt=\"Verify partitions while replacing one Linux with another\"></p>\n<p><em>检查分区情况</em></p>\n<p>接下来的几个界面就很熟悉了，要重点注意的是创建用户和密码的步骤。如果你之前有一个单独的 home 分区，并且还想使用相同的 home 目录，那你必须使用和之前相同的用户名和密码，至于设备名称则可以任意指定。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-10.jpg\" alt=\"To keep the home partition intact, use the previous user and password\"></p>\n<p><em>要保持 home 分区不变，请使用之前的用户名和密码</em></p>\n<p>接下来只要静待安装完成，不需执行任何操作。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/replace-linux-with-another-11.jpg\" alt=\"Wait for installation to finish\"></p>\n<p><em>等待安装完成</em></p>\n<p>安装完成后重新启动系统，你就能使用新的 Linux 发行版。</p>\n<p>在以上的例子中，我可以在新的 Linux Mint 19 中使用原有的 Elementary OS 中的整个 home 目录，并且其中所有视频和图片都原封不动。岂不美哉？</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/replace-linux-from-dual-boot/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/replace-linux-from-dual-boot/</a></p>\n"},{"title":"如何在 Ubuntu Linux 中使用 RAR 文件","date":"2018-10-03T13:39:34.000Z","_content":"\n[RAR][1] 是一种非常好的归档文件格式。但相比之下 7-zip 能提供了更好的压缩率，并且默认情况下还可以在多个平台上轻松支持 Zip 文件。不过 RAR 仍然是最流行的归档格式之一。然而 [Ubuntu][2] 自带的归档管理器却不支持提取 RAR 文件，也不允许创建 RAR 文件。\n\n办法总比问题多。只要安装 `unrar` 这款由 [RARLAB][3] 提供的免费软件，就能在 Ubuntu 上支持提取 RAR 文件了。你也可以安装 `rar`  试用版来创建和管理 RAR 文件。\n\n![RAR files in Ubuntu Linux][4]\n\n### 提取 RAR 文件\n\n在未安装 `unrar` 的情况下，提取 RAR 文件会报出“未能提取”错误，就像下面这样（以 [Ubuntu 18.04][5] 为例）：\n\n![Error in RAR extraction in Ubuntu][6]\n\n如果要解决这个错误并提取 RAR 文件，请按照以下步骤安装 `unrar`：\n\n打开终端并输入：\n\n```\nsudo apt-get install unrar\n```\n\n安装 `unrar` 后，直接输入 `unrar` 就可以看到它的用法以及如何使用这个工具处理 RAR 文件。\n\n最常用到的功能是提取 RAR 文件。因此，可以**通过右键单击 RAR 文件并执行提取**，也可以借助此以下命令通过终端执行操作：\n\n```\nunrar x FileName.rar\n```\n\n结果类似以下这样：\n\n![Using unrar in Ubuntu][7]\n\n如果压缩文件没放在家目录中，就必须使用 `cd` 命令移动到目标目录下。例如 RAR 文件如果在 `Music` 目录下，只需要使用 `cd Music` 就可以移动到相应的目录，然后提取 RAR 文件。\n\n### 创建和管理 RAR 文件\n\n![Using rar archive in Ubuntu Linux][8]\n\n`unrar` 不允许创建 RAR 文件。因此还需要安装 `rar` 命令行工具才能创建 RAR 文件。\n\n要创建 RAR 文件，首先需要通过以下命令安装 `rar`：\n\n```\nsudo apt-get install rar\n```\n\n按照下面的命令语法创建 RAR 文件：\n\n```\nrar a ArchiveName File_1 File_2 Dir_1 Dir_2\n```\n\n按照这个格式输入命令时，它会将目录中的每个文件添加到 RAR 文件中。如果需要某一个特定的文件，就要指定文件确切的名称或路径。\n\n默认情况下，RAR 文件会放置在**家目录**中。\n\n以类似的方式，可以更新或管理 RAR 文件。同样是使用以下的命令语法：\n\n```\nrar u ArchiveName Filename\n```\n\n在终端输入 `rar` 就可以列出 RAR 工具的相关命令。\n\n### 总结\n\n现在你已经知道如何在 Ubuntu 上管理 RAR 文件了，你会更喜欢使用 7-zip、Zip 或 Tar.xz 吗？\n\n欢迎在评论区中评论。\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/use-rar-ubuntu-linux/\n\n[a]: https://itsfoss.com/author/ankush/\n[1]: https://www.rarlab.com/rar_file.htm\n[2]: https://www.ubuntu.com/\n[3]: https://www.rarlab.com/\n[4]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-ubuntu-linux.png\n[5]: https://itsfoss.com/things-to-do-after-installing-ubuntu-18-04/\n[6]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/extract-rar-error.jpg\n[7]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/unrar-rar-extraction.jpg\n[8]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-update-create.jpg\n\n","source":"_posts/How-to-Use-RAR-files-in-Ubuntu-Linux.md","raw":"---\ntitle: 如何在 Ubuntu Linux 中使用 RAR 文件\ndate: 2018-10-03 21:39:34\ntags:\n  - Linux\n  - rar\n  - LCTT 翻译\n---\n\n[RAR][1] 是一种非常好的归档文件格式。但相比之下 7-zip 能提供了更好的压缩率，并且默认情况下还可以在多个平台上轻松支持 Zip 文件。不过 RAR 仍然是最流行的归档格式之一。然而 [Ubuntu][2] 自带的归档管理器却不支持提取 RAR 文件，也不允许创建 RAR 文件。\n\n办法总比问题多。只要安装 `unrar` 这款由 [RARLAB][3] 提供的免费软件，就能在 Ubuntu 上支持提取 RAR 文件了。你也可以安装 `rar`  试用版来创建和管理 RAR 文件。\n\n![RAR files in Ubuntu Linux][4]\n\n### 提取 RAR 文件\n\n在未安装 `unrar` 的情况下，提取 RAR 文件会报出“未能提取”错误，就像下面这样（以 [Ubuntu 18.04][5] 为例）：\n\n![Error in RAR extraction in Ubuntu][6]\n\n如果要解决这个错误并提取 RAR 文件，请按照以下步骤安装 `unrar`：\n\n打开终端并输入：\n\n```\nsudo apt-get install unrar\n```\n\n安装 `unrar` 后，直接输入 `unrar` 就可以看到它的用法以及如何使用这个工具处理 RAR 文件。\n\n最常用到的功能是提取 RAR 文件。因此，可以**通过右键单击 RAR 文件并执行提取**，也可以借助此以下命令通过终端执行操作：\n\n```\nunrar x FileName.rar\n```\n\n结果类似以下这样：\n\n![Using unrar in Ubuntu][7]\n\n如果压缩文件没放在家目录中，就必须使用 `cd` 命令移动到目标目录下。例如 RAR 文件如果在 `Music` 目录下，只需要使用 `cd Music` 就可以移动到相应的目录，然后提取 RAR 文件。\n\n### 创建和管理 RAR 文件\n\n![Using rar archive in Ubuntu Linux][8]\n\n`unrar` 不允许创建 RAR 文件。因此还需要安装 `rar` 命令行工具才能创建 RAR 文件。\n\n要创建 RAR 文件，首先需要通过以下命令安装 `rar`：\n\n```\nsudo apt-get install rar\n```\n\n按照下面的命令语法创建 RAR 文件：\n\n```\nrar a ArchiveName File_1 File_2 Dir_1 Dir_2\n```\n\n按照这个格式输入命令时，它会将目录中的每个文件添加到 RAR 文件中。如果需要某一个特定的文件，就要指定文件确切的名称或路径。\n\n默认情况下，RAR 文件会放置在**家目录**中。\n\n以类似的方式，可以更新或管理 RAR 文件。同样是使用以下的命令语法：\n\n```\nrar u ArchiveName Filename\n```\n\n在终端输入 `rar` 就可以列出 RAR 工具的相关命令。\n\n### 总结\n\n现在你已经知道如何在 Ubuntu 上管理 RAR 文件了，你会更喜欢使用 7-zip、Zip 或 Tar.xz 吗？\n\n欢迎在评论区中评论。\n\n--------------------------------------------------------------------------------\n\nvia: https://itsfoss.com/use-rar-ubuntu-linux/\n\n[a]: https://itsfoss.com/author/ankush/\n[1]: https://www.rarlab.com/rar_file.htm\n[2]: https://www.ubuntu.com/\n[3]: https://www.rarlab.com/\n[4]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-ubuntu-linux.png\n[5]: https://itsfoss.com/things-to-do-after-installing-ubuntu-18-04/\n[6]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/extract-rar-error.jpg\n[7]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/unrar-rar-extraction.jpg\n[8]: https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-update-create.jpg\n\n","slug":"How-to-Use-RAR-files-in-Ubuntu-Linux","published":1,"updated":"2019-03-28T11:10:59.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cu0014lixu44033qke","content":"<p><a href=\"https://www.rarlab.com/rar_file.htm\" target=\"_blank\" rel=\"noopener\">RAR</a> 是一种非常好的归档文件格式。但相比之下 7-zip 能提供了更好的压缩率，并且默认情况下还可以在多个平台上轻松支持 Zip 文件。不过 RAR 仍然是最流行的归档格式之一。然而 <a href=\"https://www.ubuntu.com/\" target=\"_blank\" rel=\"noopener\">Ubuntu</a> 自带的归档管理器却不支持提取 RAR 文件，也不允许创建 RAR 文件。</p>\n<p>办法总比问题多。只要安装 <code>unrar</code> 这款由 <a href=\"https://www.rarlab.com/\" target=\"_blank\" rel=\"noopener\">RARLAB</a> 提供的免费软件，就能在 Ubuntu 上支持提取 RAR 文件了。你也可以安装 <code>rar</code>  试用版来创建和管理 RAR 文件。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-ubuntu-linux.png\" alt=\"RAR files in Ubuntu Linux\"></p>\n<h3 id=\"提取-RAR-文件\"><a href=\"#提取-RAR-文件\" class=\"headerlink\" title=\"提取 RAR 文件\"></a>提取 RAR 文件</h3><p>在未安装 <code>unrar</code> 的情况下，提取 RAR 文件会报出“未能提取”错误，就像下面这样（以 <a href=\"https://itsfoss.com/things-to-do-after-installing-ubuntu-18-04/\" target=\"_blank\" rel=\"noopener\">Ubuntu 18.04</a> 为例）：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/extract-rar-error.jpg\" alt=\"Error in RAR extraction in Ubuntu\"></p>\n<p>如果要解决这个错误并提取 RAR 文件，请按照以下步骤安装 <code>unrar</code>：</p>\n<p>打开终端并输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install unrar</span><br></pre></td></tr></table></figure>\n<p>安装 <code>unrar</code> 后，直接输入 <code>unrar</code> 就可以看到它的用法以及如何使用这个工具处理 RAR 文件。</p>\n<p>最常用到的功能是提取 RAR 文件。因此，可以<strong>通过右键单击 RAR 文件并执行提取</strong>，也可以借助此以下命令通过终端执行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unrar x FileName.rar</span><br></pre></td></tr></table></figure>\n<p>结果类似以下这样：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/unrar-rar-extraction.jpg\" alt=\"Using unrar in Ubuntu\"></p>\n<p>如果压缩文件没放在家目录中，就必须使用 <code>cd</code> 命令移动到目标目录下。例如 RAR 文件如果在 <code>Music</code> 目录下，只需要使用 <code>cd Music</code> 就可以移动到相应的目录，然后提取 RAR 文件。</p>\n<h3 id=\"创建和管理-RAR-文件\"><a href=\"#创建和管理-RAR-文件\" class=\"headerlink\" title=\"创建和管理 RAR 文件\"></a>创建和管理 RAR 文件</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-update-create.jpg\" alt=\"Using rar archive in Ubuntu Linux\"></p>\n<p><code>unrar</code> 不允许创建 RAR 文件。因此还需要安装 <code>rar</code> 命令行工具才能创建 RAR 文件。</p>\n<p>要创建 RAR 文件，首先需要通过以下命令安装 <code>rar</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install rar</span><br></pre></td></tr></table></figure>\n<p>按照下面的命令语法创建 RAR 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rar a ArchiveName File_1 File_2 Dir_1 Dir_2</span><br></pre></td></tr></table></figure>\n<p>按照这个格式输入命令时，它会将目录中的每个文件添加到 RAR 文件中。如果需要某一个特定的文件，就要指定文件确切的名称或路径。</p>\n<p>默认情况下，RAR 文件会放置在<strong>家目录</strong>中。</p>\n<p>以类似的方式，可以更新或管理 RAR 文件。同样是使用以下的命令语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rar u ArchiveName Filename</span><br></pre></td></tr></table></figure>\n<p>在终端输入 <code>rar</code> 就可以列出 RAR 工具的相关命令。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你已经知道如何在 Ubuntu 上管理 RAR 文件了，你会更喜欢使用 7-zip、Zip 或 Tar.xz 吗？</p>\n<p>欢迎在评论区中评论。</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/use-rar-ubuntu-linux/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/use-rar-ubuntu-linux/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.rarlab.com/rar_file.htm\" target=\"_blank\" rel=\"noopener\">RAR</a> 是一种非常好的归档文件格式。但相比之下 7-zip 能提供了更好的压缩率，并且默认情况下还可以在多个平台上轻松支持 Zip 文件。不过 RAR 仍然是最流行的归档格式之一。然而 <a href=\"https://www.ubuntu.com/\" target=\"_blank\" rel=\"noopener\">Ubuntu</a> 自带的归档管理器却不支持提取 RAR 文件，也不允许创建 RAR 文件。</p>\n<p>办法总比问题多。只要安装 <code>unrar</code> 这款由 <a href=\"https://www.rarlab.com/\" target=\"_blank\" rel=\"noopener\">RARLAB</a> 提供的免费软件，就能在 Ubuntu 上支持提取 RAR 文件了。你也可以安装 <code>rar</code>  试用版来创建和管理 RAR 文件。</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-ubuntu-linux.png\" alt=\"RAR files in Ubuntu Linux\"></p>\n<h3 id=\"提取-RAR-文件\"><a href=\"#提取-RAR-文件\" class=\"headerlink\" title=\"提取 RAR 文件\"></a>提取 RAR 文件</h3><p>在未安装 <code>unrar</code> 的情况下，提取 RAR 文件会报出“未能提取”错误，就像下面这样（以 <a href=\"https://itsfoss.com/things-to-do-after-installing-ubuntu-18-04/\" target=\"_blank\" rel=\"noopener\">Ubuntu 18.04</a> 为例）：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/extract-rar-error.jpg\" alt=\"Error in RAR extraction in Ubuntu\"></p>\n<p>如果要解决这个错误并提取 RAR 文件，请按照以下步骤安装 <code>unrar</code>：</p>\n<p>打开终端并输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install unrar</span><br></pre></td></tr></table></figure>\n<p>安装 <code>unrar</code> 后，直接输入 <code>unrar</code> 就可以看到它的用法以及如何使用这个工具处理 RAR 文件。</p>\n<p>最常用到的功能是提取 RAR 文件。因此，可以<strong>通过右键单击 RAR 文件并执行提取</strong>，也可以借助此以下命令通过终端执行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unrar x FileName.rar</span><br></pre></td></tr></table></figure>\n<p>结果类似以下这样：</p>\n<p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/08/unrar-rar-extraction.jpg\" alt=\"Using unrar in Ubuntu\"></p>\n<p>如果压缩文件没放在家目录中，就必须使用 <code>cd</code> 命令移动到目标目录下。例如 RAR 文件如果在 <code>Music</code> 目录下，只需要使用 <code>cd Music</code> 就可以移动到相应的目录，然后提取 RAR 文件。</p>\n<h3 id=\"创建和管理-RAR-文件\"><a href=\"#创建和管理-RAR-文件\" class=\"headerlink\" title=\"创建和管理 RAR 文件\"></a>创建和管理 RAR 文件</h3><p><img src=\"https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2018/09/rar-update-create.jpg\" alt=\"Using rar archive in Ubuntu Linux\"></p>\n<p><code>unrar</code> 不允许创建 RAR 文件。因此还需要安装 <code>rar</code> 命令行工具才能创建 RAR 文件。</p>\n<p>要创建 RAR 文件，首先需要通过以下命令安装 <code>rar</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install rar</span><br></pre></td></tr></table></figure>\n<p>按照下面的命令语法创建 RAR 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rar a ArchiveName File_1 File_2 Dir_1 Dir_2</span><br></pre></td></tr></table></figure>\n<p>按照这个格式输入命令时，它会将目录中的每个文件添加到 RAR 文件中。如果需要某一个特定的文件，就要指定文件确切的名称或路径。</p>\n<p>默认情况下，RAR 文件会放置在<strong>家目录</strong>中。</p>\n<p>以类似的方式，可以更新或管理 RAR 文件。同样是使用以下的命令语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rar u ArchiveName Filename</span><br></pre></td></tr></table></figure>\n<p>在终端输入 <code>rar</code> 就可以列出 RAR 工具的相关命令。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你已经知道如何在 Ubuntu 上管理 RAR 文件了，你会更喜欢使用 7-zip、Zip 或 Tar.xz 吗？</p>\n<p>欢迎在评论区中评论。</p>\n<hr>\n<p>via: <a href=\"https://itsfoss.com/use-rar-ubuntu-linux/\" target=\"_blank\" rel=\"noopener\">https://itsfoss.com/use-rar-ubuntu-linux/</a></p>\n"},{"title":"如何使用树莓派测定颗粒物（PM 2.5）","date":"2018-05-08T15:51:59.000Z","_content":"\n> 使用两个简单的硬件设备和几行代码构建一个空气质量探测器。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bubblehands_fromRHT_520_0612LL.png?itok=_iQ2dO3S)\n\n我们在东南亚的学校定期测定空气中的颗粒物。这里的测定值非常高，尤其是在二到五月之间，干燥炎热、土地干旱等各种因素都对空气质量产生了不利的影响。我将会在这篇文章中展示如何使用树莓派来测定颗粒物。\n\n### 什么是颗粒物？\n\n颗粒物就是粉尘或者空气中的微小颗粒。其中 PM10 和 PM2.5 之间的差别就是 PM10 指的是粒径小于 10 微米的颗粒，而 PM2.5 指的是粒径小于 2.5 微米的颗粒。在粒径小于 2.5 微米的的情况下，由于它们能被吸入肺泡中并且对呼吸系统造成影响，因此颗粒越小，对人的健康危害越大。\n\n世界卫生组织的建议[颗粒物浓度][1]是：\n\n  * 年均 PM10 不高于 20 µg/m³\n  * 年均 PM2.5 不高于 10 µg/m³\n  * 不允许超标时，日均 PM10 不高于 50 µg/m³\n  * 不允许超标时，日均 PM2.5 不高于 25 µg/m³\n\n以上数值实际上是低于大多数国家的标准的，例如欧盟对于 PM10 所允许的年均值是不高于 40 µg/m³。\n\n### 什么是<ruby>空气质量指数<rt>Air Quality Index</rt></ruby>（AQI）？\n\n空气质量指数是按照颗粒物的测定值来评价空气质量的好坏，然而由于各国之间的计算方式有所不同，这个指数并没有统一的标准。维基百科上关于[空气质量指数][2]的词条对此给出了一个概述。我们学校则以<ruby>[美国环境保护协会][3]<rt>Environment Protection Agency</rt></ruby>（EPA）建立的分类法来作为依据。\n\n![空气质量指数][5]\n\n*空气质量指数*\n\n### 测定颗粒物需要哪些准备？\n\n测定颗粒物只需要以下两种器材：\n\n  * 树莓派（款式不限，最好带有 WiFi）\n  * SDS011 颗粒物传感器\n\n![颗粒物传感器][7]\n\n*颗粒物传感器*\n\n如果是只带有 Micro USB 的树莓派 Zero W，那还需要一根连接到标准 USB 端口的适配线，只需要 20 美元，而传感器则自带适配串行接口的 USB 适配器。\n\n### 安装过程\n\n对于树莓派，只需要下载对应的 Raspbian Lite 镜像并且[写入到 Micro SD 卡][8]上就可以了（网上很多教程都有介绍如何设置 WLAN 连接，我就不细说了）。\n\n如果要使用 SSH，那还需要在启动分区建立一个名为 `ssh` 的空文件。树莓派的 IP 通过路由器或者 DHCP 服务器获取，随后就可以通过 SSH 登录到树莓派了（默认密码是 raspberry）：\n\n```\n$ ssh pi@192.168.1.5\n```\n\n首先我们需要在树莓派上安装一下这些包：\n\n```\n$ sudo apt install git-core python-serial python-enum lighttpd\n```\n\n在开始之前，我们可以用 `dmesg` 来获取 USB 适配器连接的串行接口：\n\n```\n$ dmesg\n[ 5.559802] usbcore: registered new interface driver usbserial\n[ 5.559930] usbcore: registered new interface driver usbserial_generic\n[ 5.560049] usbserial: USB Serial support registered for generic\n[ 5.569938] usbcore: registered new interface driver ch341\n[ 5.570079] usbserial: USB Serial support registered for ch341-uart\n[ 5.570217] ch341 1–1.4:1.0: ch341-uart converter detected\n[ 5.575686] usb 1–1.4: ch341-uart converter now attached to ttyUSB0\n```\n\n在最后一行，可以看到接口 `ttyUSB0`。然后我们需要写一个 Python 脚本来读取传感器的数据并以 JSON 格式存储，在通过一个 HTML 页面就可以把数据展示出来了。\n\n### 在树莓派上读取数据\n\n首先创建一个传感器实例，每 5 分钟读取一次传感器的数据，持续 30 秒，这些数值后续都可以调整。在每两次测定的间隔，我们把传感器调到睡眠模式以延长它的使用寿命（厂商认为元件的寿命大约 8000 小时）。\n\n我们可以使用以下命令来下载 Python 脚本：\n\n```\n$ wget -O /home/pi/aqi.py https://raw.githubusercontent.com/zefanja/aqi/master/python/aqi.py\n```\n\n另外还需要执行以下两条命令来保证脚本正常运行：\n\n```\n$ sudo chown pi:pi /var/www/html/\n$ echo '[]' > /var/www/html/aqi.json\n```\n\n下面就可以执行脚本了：\n\n```\n$ chmod +x aqi.p\n$ ./aqi.py\nPM2.5:55.3, PM10:47.5\nPM2.5:55.5, PM10:47.7\nPM2.5:55.7, PM10:47.8\nPM2.5:53.9, PM10:47.6\nPM2.5:53.6, PM10:47.4\nPM2.5:54.2, PM10:47.3\n…\n```\n\n### 自动化执行脚本\n\n只需要使用诸如 crontab 的服务，我们就不需要每次都手动启动脚本了。按照以下命令打开 crontab 文件：\n\n```\n$ crontab -e\n```\n\n在文件末尾添加这一行：\n\n```\n@reboot cd /home/pi/ && ./aqi.py\n```\n\n现在我们的脚本就会在树莓派每次重启后自动执行了。\n\n### 展示颗粒物测定值和空气质量指数的 HTML 页面\n\n我们在前面已经安装了一个轻量级的 web 服务器 `lighttpd`，所以我们需要把 HTML、JavaScript、CSS 文件放置在 `/var/www/html` 目录中，这样就能通过电脑和智能手机访问到相关数据了。执行下面的三条命令，可以下载到对应的文件：\n\n```\n$ wget -O /var/www/html/index.html https://raw.githubusercontent.com/zefanja/aqi/master/html/index.html\n$ wget -O /var/www/html/aqi.js https://raw.githubusercontent.com/zefanja/aqi/master/html/aqi.js\n$ wget -O /var/www/html/style.css https://raw.githubusercontent.com/zefanja/aqi/master/html/style.css\n```\n\n在 JavaScript 文件中，实现了打开 JSON 文件、提取数据、计算空气质量指数的过程，随后页面的背景颜色将会根据 EPA 的划分标准而变化。\n\n你只需要用浏览器访问树莓派的地址，就可以看到当前颗粒物浓度值等数据了： [http://192.168.1.5:][9]\n\n这个页面比较简单而且可扩展，比如可以添加一个展示过去数小时历史数据的表格等等。\n\n这是[Github上的完整源代码][10]。\n\n### 总结\n\n在资金相对紧张的情况下，树莓派是一种选择。除此以外，还有很多可以用来测定颗粒物的应用，包括室外固定装置、移动测定设备等等。我们学校则同时采用了这两种：固定装置在室外测定全天颗粒物浓度，而移动测定设备在室内检测空调过滤器的效果。\n\n[Luftdaten.info][12] 提供了一个如何设计类似的传感器的介绍，其中的软件效果出众，而且因为它没有使用树莓派，所以硬件更是小巧。\n\n对于学生来说，设计一个颗粒物传感器确实算得上是一个优秀的课外项目。\n\n你又打算如何使用你的[树莓派][13]呢？\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi\n\n[a]:https://opensource.com/users/stephan\n[1]:https://en.wikipedia.org/wiki/Particulates\n[2]:https://en.wikipedia.org/wiki/Air_quality_index\n[3]:https://en.wikipedia.org/wiki/United_States_Environmental_Protection_Agency\n[5]:https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/air_quality_index.png?itok=FwmGf1ZS (Air quality index)\n[7]:https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/particulate_sensor.jpg?itok=ddH3bBwO (Particulate sensor)\n[8]:https://www.raspberrypi.org/documentation/installation/installing-images/README.md\n[9]:http://192.168.1.5/\n[10]:https://github.com/zefanja/aqi\n[11]:https://opensource.com/article/18/3/raspberry-pi-week-giveaway\n[12]:http://luftdaten.info/\n[13]:https://openschoolsolutions.org/shutdown-servers-case-power-failure%e2%80%8a-%e2%80%8aups-nut-co/\n","source":"_posts/How-to-measure-particulate-matter-with-a-Raspberry-Pi.md","raw":"---\ntitle: 如何使用树莓派测定颗粒物（PM 2.5）\ndate: 2018-05-08 23:51:59\ntags:\n  - 树莓派\n  - LCTT 翻译\n---\n\n> 使用两个简单的硬件设备和几行代码构建一个空气质量探测器。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bubblehands_fromRHT_520_0612LL.png?itok=_iQ2dO3S)\n\n我们在东南亚的学校定期测定空气中的颗粒物。这里的测定值非常高，尤其是在二到五月之间，干燥炎热、土地干旱等各种因素都对空气质量产生了不利的影响。我将会在这篇文章中展示如何使用树莓派来测定颗粒物。\n\n### 什么是颗粒物？\n\n颗粒物就是粉尘或者空气中的微小颗粒。其中 PM10 和 PM2.5 之间的差别就是 PM10 指的是粒径小于 10 微米的颗粒，而 PM2.5 指的是粒径小于 2.5 微米的颗粒。在粒径小于 2.5 微米的的情况下，由于它们能被吸入肺泡中并且对呼吸系统造成影响，因此颗粒越小，对人的健康危害越大。\n\n世界卫生组织的建议[颗粒物浓度][1]是：\n\n  * 年均 PM10 不高于 20 µg/m³\n  * 年均 PM2.5 不高于 10 µg/m³\n  * 不允许超标时，日均 PM10 不高于 50 µg/m³\n  * 不允许超标时，日均 PM2.5 不高于 25 µg/m³\n\n以上数值实际上是低于大多数国家的标准的，例如欧盟对于 PM10 所允许的年均值是不高于 40 µg/m³。\n\n### 什么是<ruby>空气质量指数<rt>Air Quality Index</rt></ruby>（AQI）？\n\n空气质量指数是按照颗粒物的测定值来评价空气质量的好坏，然而由于各国之间的计算方式有所不同，这个指数并没有统一的标准。维基百科上关于[空气质量指数][2]的词条对此给出了一个概述。我们学校则以<ruby>[美国环境保护协会][3]<rt>Environment Protection Agency</rt></ruby>（EPA）建立的分类法来作为依据。\n\n![空气质量指数][5]\n\n*空气质量指数*\n\n### 测定颗粒物需要哪些准备？\n\n测定颗粒物只需要以下两种器材：\n\n  * 树莓派（款式不限，最好带有 WiFi）\n  * SDS011 颗粒物传感器\n\n![颗粒物传感器][7]\n\n*颗粒物传感器*\n\n如果是只带有 Micro USB 的树莓派 Zero W，那还需要一根连接到标准 USB 端口的适配线，只需要 20 美元，而传感器则自带适配串行接口的 USB 适配器。\n\n### 安装过程\n\n对于树莓派，只需要下载对应的 Raspbian Lite 镜像并且[写入到 Micro SD 卡][8]上就可以了（网上很多教程都有介绍如何设置 WLAN 连接，我就不细说了）。\n\n如果要使用 SSH，那还需要在启动分区建立一个名为 `ssh` 的空文件。树莓派的 IP 通过路由器或者 DHCP 服务器获取，随后就可以通过 SSH 登录到树莓派了（默认密码是 raspberry）：\n\n```\n$ ssh pi@192.168.1.5\n```\n\n首先我们需要在树莓派上安装一下这些包：\n\n```\n$ sudo apt install git-core python-serial python-enum lighttpd\n```\n\n在开始之前，我们可以用 `dmesg` 来获取 USB 适配器连接的串行接口：\n\n```\n$ dmesg\n[ 5.559802] usbcore: registered new interface driver usbserial\n[ 5.559930] usbcore: registered new interface driver usbserial_generic\n[ 5.560049] usbserial: USB Serial support registered for generic\n[ 5.569938] usbcore: registered new interface driver ch341\n[ 5.570079] usbserial: USB Serial support registered for ch341-uart\n[ 5.570217] ch341 1–1.4:1.0: ch341-uart converter detected\n[ 5.575686] usb 1–1.4: ch341-uart converter now attached to ttyUSB0\n```\n\n在最后一行，可以看到接口 `ttyUSB0`。然后我们需要写一个 Python 脚本来读取传感器的数据并以 JSON 格式存储，在通过一个 HTML 页面就可以把数据展示出来了。\n\n### 在树莓派上读取数据\n\n首先创建一个传感器实例，每 5 分钟读取一次传感器的数据，持续 30 秒，这些数值后续都可以调整。在每两次测定的间隔，我们把传感器调到睡眠模式以延长它的使用寿命（厂商认为元件的寿命大约 8000 小时）。\n\n我们可以使用以下命令来下载 Python 脚本：\n\n```\n$ wget -O /home/pi/aqi.py https://raw.githubusercontent.com/zefanja/aqi/master/python/aqi.py\n```\n\n另外还需要执行以下两条命令来保证脚本正常运行：\n\n```\n$ sudo chown pi:pi /var/www/html/\n$ echo '[]' > /var/www/html/aqi.json\n```\n\n下面就可以执行脚本了：\n\n```\n$ chmod +x aqi.p\n$ ./aqi.py\nPM2.5:55.3, PM10:47.5\nPM2.5:55.5, PM10:47.7\nPM2.5:55.7, PM10:47.8\nPM2.5:53.9, PM10:47.6\nPM2.5:53.6, PM10:47.4\nPM2.5:54.2, PM10:47.3\n…\n```\n\n### 自动化执行脚本\n\n只需要使用诸如 crontab 的服务，我们就不需要每次都手动启动脚本了。按照以下命令打开 crontab 文件：\n\n```\n$ crontab -e\n```\n\n在文件末尾添加这一行：\n\n```\n@reboot cd /home/pi/ && ./aqi.py\n```\n\n现在我们的脚本就会在树莓派每次重启后自动执行了。\n\n### 展示颗粒物测定值和空气质量指数的 HTML 页面\n\n我们在前面已经安装了一个轻量级的 web 服务器 `lighttpd`，所以我们需要把 HTML、JavaScript、CSS 文件放置在 `/var/www/html` 目录中，这样就能通过电脑和智能手机访问到相关数据了。执行下面的三条命令，可以下载到对应的文件：\n\n```\n$ wget -O /var/www/html/index.html https://raw.githubusercontent.com/zefanja/aqi/master/html/index.html\n$ wget -O /var/www/html/aqi.js https://raw.githubusercontent.com/zefanja/aqi/master/html/aqi.js\n$ wget -O /var/www/html/style.css https://raw.githubusercontent.com/zefanja/aqi/master/html/style.css\n```\n\n在 JavaScript 文件中，实现了打开 JSON 文件、提取数据、计算空气质量指数的过程，随后页面的背景颜色将会根据 EPA 的划分标准而变化。\n\n你只需要用浏览器访问树莓派的地址，就可以看到当前颗粒物浓度值等数据了： [http://192.168.1.5:][9]\n\n这个页面比较简单而且可扩展，比如可以添加一个展示过去数小时历史数据的表格等等。\n\n这是[Github上的完整源代码][10]。\n\n### 总结\n\n在资金相对紧张的情况下，树莓派是一种选择。除此以外，还有很多可以用来测定颗粒物的应用，包括室外固定装置、移动测定设备等等。我们学校则同时采用了这两种：固定装置在室外测定全天颗粒物浓度，而移动测定设备在室内检测空调过滤器的效果。\n\n[Luftdaten.info][12] 提供了一个如何设计类似的传感器的介绍，其中的软件效果出众，而且因为它没有使用树莓派，所以硬件更是小巧。\n\n对于学生来说，设计一个颗粒物传感器确实算得上是一个优秀的课外项目。\n\n你又打算如何使用你的[树莓派][13]呢？\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi\n\n[a]:https://opensource.com/users/stephan\n[1]:https://en.wikipedia.org/wiki/Particulates\n[2]:https://en.wikipedia.org/wiki/Air_quality_index\n[3]:https://en.wikipedia.org/wiki/United_States_Environmental_Protection_Agency\n[5]:https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/air_quality_index.png?itok=FwmGf1ZS (Air quality index)\n[7]:https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/particulate_sensor.jpg?itok=ddH3bBwO (Particulate sensor)\n[8]:https://www.raspberrypi.org/documentation/installation/installing-images/README.md\n[9]:http://192.168.1.5/\n[10]:https://github.com/zefanja/aqi\n[11]:https://opensource.com/article/18/3/raspberry-pi-week-giveaway\n[12]:http://luftdaten.info/\n[13]:https://openschoolsolutions.org/shutdown-servers-case-power-failure%e2%80%8a-%e2%80%8aups-nut-co/\n","slug":"How-to-measure-particulate-matter-with-a-Raspberry-Pi","published":1,"updated":"2019-03-28T05:44:08.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cv0016lixu5pot2ugp","content":"<blockquote>\n<p>使用两个简单的硬件设备和几行代码构建一个空气质量探测器。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bubblehands_fromRHT_520_0612LL.png?itok=_iQ2dO3S\" alt=\"\"></p>\n<p>我们在东南亚的学校定期测定空气中的颗粒物。这里的测定值非常高，尤其是在二到五月之间，干燥炎热、土地干旱等各种因素都对空气质量产生了不利的影响。我将会在这篇文章中展示如何使用树莓派来测定颗粒物。</p>\n<h3 id=\"什么是颗粒物？\"><a href=\"#什么是颗粒物？\" class=\"headerlink\" title=\"什么是颗粒物？\"></a>什么是颗粒物？</h3><p>颗粒物就是粉尘或者空气中的微小颗粒。其中 PM10 和 PM2.5 之间的差别就是 PM10 指的是粒径小于 10 微米的颗粒，而 PM2.5 指的是粒径小于 2.5 微米的颗粒。在粒径小于 2.5 微米的的情况下，由于它们能被吸入肺泡中并且对呼吸系统造成影响，因此颗粒越小，对人的健康危害越大。</p>\n<p>世界卫生组织的建议<a href=\"https://en.wikipedia.org/wiki/Particulates\" target=\"_blank\" rel=\"noopener\">颗粒物浓度</a>是：</p>\n<ul>\n<li>年均 PM10 不高于 20 µg/m³</li>\n<li>年均 PM2.5 不高于 10 µg/m³</li>\n<li>不允许超标时，日均 PM10 不高于 50 µg/m³</li>\n<li>不允许超标时，日均 PM2.5 不高于 25 µg/m³</li>\n</ul>\n<p>以上数值实际上是低于大多数国家的标准的，例如欧盟对于 PM10 所允许的年均值是不高于 40 µg/m³。</p>\n<h3 id=\"什么是空气质量指数Air-Quality-Index（AQI）？\"><a href=\"#什么是空气质量指数Air-Quality-Index（AQI）？\" class=\"headerlink\" title=\"什么是空气质量指数Air Quality Index（AQI）？\"></a>什么是<ruby>空气质量指数<rt>Air Quality Index</rt></ruby>（AQI）？</h3><p>空气质量指数是按照颗粒物的测定值来评价空气质量的好坏，然而由于各国之间的计算方式有所不同，这个指数并没有统一的标准。维基百科上关于<a href=\"https://en.wikipedia.org/wiki/Air_quality_index\" target=\"_blank\" rel=\"noopener\">空气质量指数</a>的词条对此给出了一个概述。我们学校则以<ruby><a href=\"https://en.wikipedia.org/wiki/United_States_Environmental_Protection_Agency\" target=\"_blank\" rel=\"noopener\">美国环境保护协会</a><rt>Environment Protection Agency</rt></ruby>（EPA）建立的分类法来作为依据。</p>\n<p><img src=\"https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/air_quality_index.png?itok=FwmGf1ZS\" alt=\"空气质量指数\" title=\"Air quality index\"></p>\n<p><em>空气质量指数</em></p>\n<h3 id=\"测定颗粒物需要哪些准备？\"><a href=\"#测定颗粒物需要哪些准备？\" class=\"headerlink\" title=\"测定颗粒物需要哪些准备？\"></a>测定颗粒物需要哪些准备？</h3><p>测定颗粒物只需要以下两种器材：</p>\n<ul>\n<li>树莓派（款式不限，最好带有 WiFi）</li>\n<li>SDS011 颗粒物传感器</li>\n</ul>\n<p><img src=\"https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/particulate_sensor.jpg?itok=ddH3bBwO\" alt=\"颗粒物传感器\" title=\"Particulate sensor\"></p>\n<p><em>颗粒物传感器</em></p>\n<p>如果是只带有 Micro USB 的树莓派 Zero W，那还需要一根连接到标准 USB 端口的适配线，只需要 20 美元，而传感器则自带适配串行接口的 USB 适配器。</p>\n<h3 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h3><p>对于树莓派，只需要下载对应的 Raspbian Lite 镜像并且<a href=\"https://www.raspberrypi.org/documentation/installation/installing-images/README.md\" target=\"_blank\" rel=\"noopener\">写入到 Micro SD 卡</a>上就可以了（网上很多教程都有介绍如何设置 WLAN 连接，我就不细说了）。</p>\n<p>如果要使用 SSH，那还需要在启动分区建立一个名为 <code>ssh</code> 的空文件。树莓派的 IP 通过路由器或者 DHCP 服务器获取，随后就可以通过 SSH 登录到树莓派了（默认密码是 raspberry）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh pi@192.168.1.5</span><br></pre></td></tr></table></figure>\n<p>首先我们需要在树莓派上安装一下这些包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install git-core python-serial python-enum lighttpd</span><br></pre></td></tr></table></figure>\n<p>在开始之前，我们可以用 <code>dmesg</code> 来获取 USB 适配器连接的串行接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dmesg</span><br><span class=\"line\">[ 5.559802] usbcore: registered new interface driver usbserial</span><br><span class=\"line\">[ 5.559930] usbcore: registered new interface driver usbserial_generic</span><br><span class=\"line\">[ 5.560049] usbserial: USB Serial support registered for generic</span><br><span class=\"line\">[ 5.569938] usbcore: registered new interface driver ch341</span><br><span class=\"line\">[ 5.570079] usbserial: USB Serial support registered for ch341-uart</span><br><span class=\"line\">[ 5.570217] ch341 1–1.4:1.0: ch341-uart converter detected</span><br><span class=\"line\">[ 5.575686] usb 1–1.4: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure>\n<p>在最后一行，可以看到接口 <code>ttyUSB0</code>。然后我们需要写一个 Python 脚本来读取传感器的数据并以 JSON 格式存储，在通过一个 HTML 页面就可以把数据展示出来了。</p>\n<h3 id=\"在树莓派上读取数据\"><a href=\"#在树莓派上读取数据\" class=\"headerlink\" title=\"在树莓派上读取数据\"></a>在树莓派上读取数据</h3><p>首先创建一个传感器实例，每 5 分钟读取一次传感器的数据，持续 30 秒，这些数值后续都可以调整。在每两次测定的间隔，我们把传感器调到睡眠模式以延长它的使用寿命（厂商认为元件的寿命大约 8000 小时）。</p>\n<p>我们可以使用以下命令来下载 Python 脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O /home/pi/aqi.py https://raw.githubusercontent.com/zefanja/aqi/master/python/aqi.py</span><br></pre></td></tr></table></figure>\n<p>另外还需要执行以下两条命令来保证脚本正常运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chown pi:pi /var/www/html/</span><br><span class=\"line\">$ echo &apos;[]&apos; &gt; /var/www/html/aqi.json</span><br></pre></td></tr></table></figure>\n<p>下面就可以执行脚本了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod +x aqi.p</span><br><span class=\"line\">$ ./aqi.py</span><br><span class=\"line\">PM2.5:55.3, PM10:47.5</span><br><span class=\"line\">PM2.5:55.5, PM10:47.7</span><br><span class=\"line\">PM2.5:55.7, PM10:47.8</span><br><span class=\"line\">PM2.5:53.9, PM10:47.6</span><br><span class=\"line\">PM2.5:53.6, PM10:47.4</span><br><span class=\"line\">PM2.5:54.2, PM10:47.3</span><br><span class=\"line\">…</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动化执行脚本\"><a href=\"#自动化执行脚本\" class=\"headerlink\" title=\"自动化执行脚本\"></a>自动化执行脚本</h3><p>只需要使用诸如 crontab 的服务，我们就不需要每次都手动启动脚本了。按照以下命令打开 crontab 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab -e</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@reboot cd /home/pi/ &amp;&amp; ./aqi.py</span><br></pre></td></tr></table></figure>\n<p>现在我们的脚本就会在树莓派每次重启后自动执行了。</p>\n<h3 id=\"展示颗粒物测定值和空气质量指数的-HTML-页面\"><a href=\"#展示颗粒物测定值和空气质量指数的-HTML-页面\" class=\"headerlink\" title=\"展示颗粒物测定值和空气质量指数的 HTML 页面\"></a>展示颗粒物测定值和空气质量指数的 HTML 页面</h3><p>我们在前面已经安装了一个轻量级的 web 服务器 <code>lighttpd</code>，所以我们需要把 HTML、JavaScript、CSS 文件放置在 <code>/var/www/html</code> 目录中，这样就能通过电脑和智能手机访问到相关数据了。执行下面的三条命令，可以下载到对应的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O /var/www/html/index.html https://raw.githubusercontent.com/zefanja/aqi/master/html/index.html</span><br><span class=\"line\">$ wget -O /var/www/html/aqi.js https://raw.githubusercontent.com/zefanja/aqi/master/html/aqi.js</span><br><span class=\"line\">$ wget -O /var/www/html/style.css https://raw.githubusercontent.com/zefanja/aqi/master/html/style.css</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 文件中，实现了打开 JSON 文件、提取数据、计算空气质量指数的过程，随后页面的背景颜色将会根据 EPA 的划分标准而变化。</p>\n<p>你只需要用浏览器访问树莓派的地址，就可以看到当前颗粒物浓度值等数据了： <a href=\"http://192.168.1.5/\" target=\"_blank\" rel=\"noopener\">http://192.168.1.5:</a></p>\n<p>这个页面比较简单而且可扩展，比如可以添加一个展示过去数小时历史数据的表格等等。</p>\n<p>这是<a href=\"https://github.com/zefanja/aqi\" target=\"_blank\" rel=\"noopener\">Github上的完整源代码</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在资金相对紧张的情况下，树莓派是一种选择。除此以外，还有很多可以用来测定颗粒物的应用，包括室外固定装置、移动测定设备等等。我们学校则同时采用了这两种：固定装置在室外测定全天颗粒物浓度，而移动测定设备在室内检测空调过滤器的效果。</p>\n<p><a href=\"http://luftdaten.info/\" target=\"_blank\" rel=\"noopener\">Luftdaten.info</a> 提供了一个如何设计类似的传感器的介绍，其中的软件效果出众，而且因为它没有使用树莓派，所以硬件更是小巧。</p>\n<p>对于学生来说，设计一个颗粒物传感器确实算得上是一个优秀的课外项目。</p>\n<p>你又打算如何使用你的<a href=\"https://openschoolsolutions.org/shutdown-servers-case-power-failure%e2%80%8a-%e2%80%8aups-nut-co/\" target=\"_blank\" rel=\"noopener\">树莓派</a>呢？</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用两个简单的硬件设备和几行代码构建一个空气质量探测器。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bubblehands_fromRHT_520_0612LL.png?itok=_iQ2dO3S\" alt=\"\"></p>\n<p>我们在东南亚的学校定期测定空气中的颗粒物。这里的测定值非常高，尤其是在二到五月之间，干燥炎热、土地干旱等各种因素都对空气质量产生了不利的影响。我将会在这篇文章中展示如何使用树莓派来测定颗粒物。</p>\n<h3 id=\"什么是颗粒物？\"><a href=\"#什么是颗粒物？\" class=\"headerlink\" title=\"什么是颗粒物？\"></a>什么是颗粒物？</h3><p>颗粒物就是粉尘或者空气中的微小颗粒。其中 PM10 和 PM2.5 之间的差别就是 PM10 指的是粒径小于 10 微米的颗粒，而 PM2.5 指的是粒径小于 2.5 微米的颗粒。在粒径小于 2.5 微米的的情况下，由于它们能被吸入肺泡中并且对呼吸系统造成影响，因此颗粒越小，对人的健康危害越大。</p>\n<p>世界卫生组织的建议<a href=\"https://en.wikipedia.org/wiki/Particulates\" target=\"_blank\" rel=\"noopener\">颗粒物浓度</a>是：</p>\n<ul>\n<li>年均 PM10 不高于 20 µg/m³</li>\n<li>年均 PM2.5 不高于 10 µg/m³</li>\n<li>不允许超标时，日均 PM10 不高于 50 µg/m³</li>\n<li>不允许超标时，日均 PM2.5 不高于 25 µg/m³</li>\n</ul>\n<p>以上数值实际上是低于大多数国家的标准的，例如欧盟对于 PM10 所允许的年均值是不高于 40 µg/m³。</p>\n<h3 id=\"什么是空气质量指数Air-Quality-Index（AQI）？\"><a href=\"#什么是空气质量指数Air-Quality-Index（AQI）？\" class=\"headerlink\" title=\"什么是空气质量指数Air Quality Index（AQI）？\"></a>什么是<ruby>空气质量指数<rt>Air Quality Index</rt></ruby>（AQI）？</h3><p>空气质量指数是按照颗粒物的测定值来评价空气质量的好坏，然而由于各国之间的计算方式有所不同，这个指数并没有统一的标准。维基百科上关于<a href=\"https://en.wikipedia.org/wiki/Air_quality_index\" target=\"_blank\" rel=\"noopener\">空气质量指数</a>的词条对此给出了一个概述。我们学校则以<ruby><a href=\"https://en.wikipedia.org/wiki/United_States_Environmental_Protection_Agency\" target=\"_blank\" rel=\"noopener\">美国环境保护协会</a><rt>Environment Protection Agency</rt></ruby>（EPA）建立的分类法来作为依据。</p>\n<p><img src=\"https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/air_quality_index.png?itok=FwmGf1ZS\" alt=\"空气质量指数\" title=\"Air quality index\"></p>\n<p><em>空气质量指数</em></p>\n<h3 id=\"测定颗粒物需要哪些准备？\"><a href=\"#测定颗粒物需要哪些准备？\" class=\"headerlink\" title=\"测定颗粒物需要哪些准备？\"></a>测定颗粒物需要哪些准备？</h3><p>测定颗粒物只需要以下两种器材：</p>\n<ul>\n<li>树莓派（款式不限，最好带有 WiFi）</li>\n<li>SDS011 颗粒物传感器</li>\n</ul>\n<p><img src=\"https://opensource.com/sites/default/files/styles/panopoly_image_original/public/images/life-uploads/particulate_sensor.jpg?itok=ddH3bBwO\" alt=\"颗粒物传感器\" title=\"Particulate sensor\"></p>\n<p><em>颗粒物传感器</em></p>\n<p>如果是只带有 Micro USB 的树莓派 Zero W，那还需要一根连接到标准 USB 端口的适配线，只需要 20 美元，而传感器则自带适配串行接口的 USB 适配器。</p>\n<h3 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h3><p>对于树莓派，只需要下载对应的 Raspbian Lite 镜像并且<a href=\"https://www.raspberrypi.org/documentation/installation/installing-images/README.md\" target=\"_blank\" rel=\"noopener\">写入到 Micro SD 卡</a>上就可以了（网上很多教程都有介绍如何设置 WLAN 连接，我就不细说了）。</p>\n<p>如果要使用 SSH，那还需要在启动分区建立一个名为 <code>ssh</code> 的空文件。树莓派的 IP 通过路由器或者 DHCP 服务器获取，随后就可以通过 SSH 登录到树莓派了（默认密码是 raspberry）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh pi@192.168.1.5</span><br></pre></td></tr></table></figure>\n<p>首先我们需要在树莓派上安装一下这些包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install git-core python-serial python-enum lighttpd</span><br></pre></td></tr></table></figure>\n<p>在开始之前，我们可以用 <code>dmesg</code> 来获取 USB 适配器连接的串行接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dmesg</span><br><span class=\"line\">[ 5.559802] usbcore: registered new interface driver usbserial</span><br><span class=\"line\">[ 5.559930] usbcore: registered new interface driver usbserial_generic</span><br><span class=\"line\">[ 5.560049] usbserial: USB Serial support registered for generic</span><br><span class=\"line\">[ 5.569938] usbcore: registered new interface driver ch341</span><br><span class=\"line\">[ 5.570079] usbserial: USB Serial support registered for ch341-uart</span><br><span class=\"line\">[ 5.570217] ch341 1–1.4:1.0: ch341-uart converter detected</span><br><span class=\"line\">[ 5.575686] usb 1–1.4: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure>\n<p>在最后一行，可以看到接口 <code>ttyUSB0</code>。然后我们需要写一个 Python 脚本来读取传感器的数据并以 JSON 格式存储，在通过一个 HTML 页面就可以把数据展示出来了。</p>\n<h3 id=\"在树莓派上读取数据\"><a href=\"#在树莓派上读取数据\" class=\"headerlink\" title=\"在树莓派上读取数据\"></a>在树莓派上读取数据</h3><p>首先创建一个传感器实例，每 5 分钟读取一次传感器的数据，持续 30 秒，这些数值后续都可以调整。在每两次测定的间隔，我们把传感器调到睡眠模式以延长它的使用寿命（厂商认为元件的寿命大约 8000 小时）。</p>\n<p>我们可以使用以下命令来下载 Python 脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O /home/pi/aqi.py https://raw.githubusercontent.com/zefanja/aqi/master/python/aqi.py</span><br></pre></td></tr></table></figure>\n<p>另外还需要执行以下两条命令来保证脚本正常运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chown pi:pi /var/www/html/</span><br><span class=\"line\">$ echo &apos;[]&apos; &gt; /var/www/html/aqi.json</span><br></pre></td></tr></table></figure>\n<p>下面就可以执行脚本了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod +x aqi.p</span><br><span class=\"line\">$ ./aqi.py</span><br><span class=\"line\">PM2.5:55.3, PM10:47.5</span><br><span class=\"line\">PM2.5:55.5, PM10:47.7</span><br><span class=\"line\">PM2.5:55.7, PM10:47.8</span><br><span class=\"line\">PM2.5:53.9, PM10:47.6</span><br><span class=\"line\">PM2.5:53.6, PM10:47.4</span><br><span class=\"line\">PM2.5:54.2, PM10:47.3</span><br><span class=\"line\">…</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动化执行脚本\"><a href=\"#自动化执行脚本\" class=\"headerlink\" title=\"自动化执行脚本\"></a>自动化执行脚本</h3><p>只需要使用诸如 crontab 的服务，我们就不需要每次都手动启动脚本了。按照以下命令打开 crontab 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ crontab -e</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@reboot cd /home/pi/ &amp;&amp; ./aqi.py</span><br></pre></td></tr></table></figure>\n<p>现在我们的脚本就会在树莓派每次重启后自动执行了。</p>\n<h3 id=\"展示颗粒物测定值和空气质量指数的-HTML-页面\"><a href=\"#展示颗粒物测定值和空气质量指数的-HTML-页面\" class=\"headerlink\" title=\"展示颗粒物测定值和空气质量指数的 HTML 页面\"></a>展示颗粒物测定值和空气质量指数的 HTML 页面</h3><p>我们在前面已经安装了一个轻量级的 web 服务器 <code>lighttpd</code>，所以我们需要把 HTML、JavaScript、CSS 文件放置在 <code>/var/www/html</code> 目录中，这样就能通过电脑和智能手机访问到相关数据了。执行下面的三条命令，可以下载到对应的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -O /var/www/html/index.html https://raw.githubusercontent.com/zefanja/aqi/master/html/index.html</span><br><span class=\"line\">$ wget -O /var/www/html/aqi.js https://raw.githubusercontent.com/zefanja/aqi/master/html/aqi.js</span><br><span class=\"line\">$ wget -O /var/www/html/style.css https://raw.githubusercontent.com/zefanja/aqi/master/html/style.css</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 文件中，实现了打开 JSON 文件、提取数据、计算空气质量指数的过程，随后页面的背景颜色将会根据 EPA 的划分标准而变化。</p>\n<p>你只需要用浏览器访问树莓派的地址，就可以看到当前颗粒物浓度值等数据了： <a href=\"http://192.168.1.5/\" target=\"_blank\" rel=\"noopener\">http://192.168.1.5:</a></p>\n<p>这个页面比较简单而且可扩展，比如可以添加一个展示过去数小时历史数据的表格等等。</p>\n<p>这是<a href=\"https://github.com/zefanja/aqi\" target=\"_blank\" rel=\"noopener\">Github上的完整源代码</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在资金相对紧张的情况下，树莓派是一种选择。除此以外，还有很多可以用来测定颗粒物的应用，包括室外固定装置、移动测定设备等等。我们学校则同时采用了这两种：固定装置在室外测定全天颗粒物浓度，而移动测定设备在室内检测空调过滤器的效果。</p>\n<p><a href=\"http://luftdaten.info/\" target=\"_blank\" rel=\"noopener\">Luftdaten.info</a> 提供了一个如何设计类似的传感器的介绍，其中的软件效果出众，而且因为它没有使用树莓派，所以硬件更是小巧。</p>\n<p>对于学生来说，设计一个颗粒物传感器确实算得上是一个优秀的课外项目。</p>\n<p>你又打算如何使用你的<a href=\"https://openschoolsolutions.org/shutdown-servers-case-power-failure%e2%80%8a-%e2%80%8aups-nut-co/\" target=\"_blank\" rel=\"noopener\">树莓派</a>呢？</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/how-measure-particulate-matter-raspberry-pi</a></p>\n"},{"title":"如何使用 Ansible 打补丁以及安装应用","date":"2018-05-19T19:59:07.000Z","_content":"\n> 使用  Ansible IT 自动化引擎节省更新的时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/tools_osyearbook2016_sysadmin_cc.png?itok=Y1AHCKI4)\n\n你有没有想过，如何打补丁、重启系统，然后继续工作？\n\n如果你的回答是肯定的，那就需要了解一下 [Ansible][1] 了。它是一个配置管理工具，对于一些复杂的有时候需要几个小时才能完成的系统管理任务，又或者对安全性有比较高要求的时候，使用 Ansible 能够大大简化工作流程。\n\n以我作为系统管理员的经验，打补丁是一项最有难度的工作。每次遇到<ruby>公共漏洞批露<rt>Common Vulnearbilities and Exposure</rt></ruby>（CVE）通知或者<ruby>信息保障漏洞预警<rt>Information Assurance Vulnerability Alert</rt></ruby>（IAVA）时都必须要高度关注安全漏洞，否则安全部门将会严肃追究自己的责任。\n\n使用 Ansible 可以通过运行[封装模块][2]以缩短打补丁的时间，下面以 [yum 模块][3]更新系统为例，使用 Ansible 可以执行安装、更新、删除、从其它地方安装（例如持续集成/持续开发中的 `rpmbuild`）。以下是系统更新的任务：\n\n```\n  - name: update the system\n    yum:\n      name: \"*\"\n      state: latest\n```\n\n在第一行，我们给这个任务命名，这样可以清楚 Ansible 的工作内容。第二行表示使用 `yum` 模块在CentOS虚拟机中执行更新操作。第三行 `name: \"*\"` 表示更新所有程序。最后一行 `state: latest` 表示更新到最新的 RPM。\n\n系统更新结束之后，需要重新启动并重新连接：\n\n```\n  - name: restart system to reboot to newest kernel\n    shell: \"sleep 5 && reboot\"\n    async: 1\n    poll: 0\n\n  - name: wait for 10 seconds\n    pause:\n      seconds: 10\n\n  - name: wait for the system to reboot\n    wait_for_connection:\n      connect_timeout: 20\n      sleep: 5\n      delay: 5\n      timeout: 60\n\n  - name: install epel-release\n    yum:\n      name: epel-release\n      state: latest\n```\n\n`shell` 模块中的命令让系统在 5 秒休眠之后重新启动，我们使用 `sleep` 来保持连接不断开，使用 `async` 设定最大等待时长以避免发生超时，`poll` 设置为 0 表示直接执行不需要等待执行结果。暂停 10 秒钟以等待虚拟机恢复，使用 `wait_for_connection` 在虚拟机恢复连接后尽快连接。随后由 `install epel-release` 任务检查 RPM 的安装情况。你可以对这个剧本执行多次来验证它的幂等性，唯一会显示造成影响的是重启操作，因为我们使用了 `shell` 模块。如果不想造成实际的影响，可以在使用 `shell` 模块的时候 `changed_when: False`。\n\n现在我们已经知道如何对系统进行更新、重启虚拟机、重新连接、安装 RPM 包。下面我们通过 [Ansible Lightbulb][4] 来安装 NGINX:\n\n```\n  - name: Ensure nginx packages are present\n    yum:\n      name: nginx, python-pip, python-devel, devel\n      state: present\n    notify: restart-nginx-service\n\n  - name: Ensure uwsgi package is present\n    pip:\n      name: uwsgi\n      state: present\n    notify: restart-nginx-service\n\n  - name: Ensure latest default.conf is present\n    template:\n      src: templates/nginx.conf.j2\n      dest: /etc/nginx/nginx.conf\n      backup: yes\n    notify: restart-nginx-service\n\n  - name: Ensure latest index.html is present\n    template:\n      src: templates/index.html.j2\n      dest: /usr/share/nginx/html/index.html\n\n  - name: Ensure nginx service is started and enabled\n    service:\n      name: nginx\n      state: started\n      enabled: yes\n\n  - name: Ensure proper response from localhost can be received\n    uri:\n      url: \"http://localhost:80/\"\n      return_content: yes\n    register: response\n    until: 'nginx_test_message in response.content'\n    retries: 10\n    delay: 1\n```\n\n以及用来重启 nginx 服务的操作文件：\n\n```\n# 安装 nginx 的操作文件\n  - name: restart-nginx-service\n    service:\n      name: nginx\n      state: restarted\n```\n\n在这个角色里，我们使用 RPM 安装了 `nginx`、`python-pip`、`python-devel`、`devel`，用 PIP 安装了 `uwsgi`，接下来使用 `template` 模块复制 `nginx.conf` 和 `index.html` 以显示页面，并确保服务在系统启动时启动。然后就可以使用 `uri` 模块检查到页面的连接了。\n\n这个是一个系统更新、系统重启、安装 RPM 包的剧本示例，后续可以继续安装 nginx，当然这里可以替换成任何你想要的角色和应用程序。\n\n```\n  - hosts: all\n    roles:\n      - centos-update\n      - nginx-simple\n```\n\n观看演示视频了解了解这个过程。\n\n[demo](https://asciinema.org/a/166437/embed?)\n\n这只是关于如何更新系统、重启以及后续工作的示例。简单起见，我只添加了不带[变量][5]的包，当你在操作大量主机的时候，你就需要修改其中的一些设置了：\n\n- [async & poll](https://docs.ansible.com/ansible/latest/playbooks_async.html)\n- [serial](https://docs.ansible.com/ansible/latest/playbooks_delegation.html#rolling-update-batch-size)\n- [forks](https://docs.ansible.com/ansible/latest/intro_configuration.html#forks)\n\n这是由于在生产环境中如果你想逐一更新每一台主机的系统，你需要花相当一段时间去等待主机重启才能够继续下去。\n\n有关 Ansible 进行自动化工作的更多用法，请查阅[其它文章][6]。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/ansible-patch-systems\n\n[a]:https://opensource.com/users/jlozadad\n[1]:https://www.ansible.com/overview/how-ansible-works\n[2]:https://docs.ansible.com/ansible/latest/list_of_packaging_modules.html\n[3]:https://docs.ansible.com/ansible/latest/yum_module.html\n[4]:https://github.com/ansible/lightbulb/tree/master/examples/nginx-role\n[5]:https://docs.ansible.com/ansible/latest/playbooks_variables.html\n[6]:https://opensource.com/tags/ansible\n","source":"_posts/How-to-use-Ansible-to-patch-systems-and-install-applications.md","raw":"---\ntitle: 如何使用 Ansible 打补丁以及安装应用\ndate: 2018-05-20 03:59:07\ntags:\n  - Ansible\n  - LCTT 翻译\n---\n\n> 使用  Ansible IT 自动化引擎节省更新的时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/tools_osyearbook2016_sysadmin_cc.png?itok=Y1AHCKI4)\n\n你有没有想过，如何打补丁、重启系统，然后继续工作？\n\n如果你的回答是肯定的，那就需要了解一下 [Ansible][1] 了。它是一个配置管理工具，对于一些复杂的有时候需要几个小时才能完成的系统管理任务，又或者对安全性有比较高要求的时候，使用 Ansible 能够大大简化工作流程。\n\n以我作为系统管理员的经验，打补丁是一项最有难度的工作。每次遇到<ruby>公共漏洞批露<rt>Common Vulnearbilities and Exposure</rt></ruby>（CVE）通知或者<ruby>信息保障漏洞预警<rt>Information Assurance Vulnerability Alert</rt></ruby>（IAVA）时都必须要高度关注安全漏洞，否则安全部门将会严肃追究自己的责任。\n\n使用 Ansible 可以通过运行[封装模块][2]以缩短打补丁的时间，下面以 [yum 模块][3]更新系统为例，使用 Ansible 可以执行安装、更新、删除、从其它地方安装（例如持续集成/持续开发中的 `rpmbuild`）。以下是系统更新的任务：\n\n```\n  - name: update the system\n    yum:\n      name: \"*\"\n      state: latest\n```\n\n在第一行，我们给这个任务命名，这样可以清楚 Ansible 的工作内容。第二行表示使用 `yum` 模块在CentOS虚拟机中执行更新操作。第三行 `name: \"*\"` 表示更新所有程序。最后一行 `state: latest` 表示更新到最新的 RPM。\n\n系统更新结束之后，需要重新启动并重新连接：\n\n```\n  - name: restart system to reboot to newest kernel\n    shell: \"sleep 5 && reboot\"\n    async: 1\n    poll: 0\n\n  - name: wait for 10 seconds\n    pause:\n      seconds: 10\n\n  - name: wait for the system to reboot\n    wait_for_connection:\n      connect_timeout: 20\n      sleep: 5\n      delay: 5\n      timeout: 60\n\n  - name: install epel-release\n    yum:\n      name: epel-release\n      state: latest\n```\n\n`shell` 模块中的命令让系统在 5 秒休眠之后重新启动，我们使用 `sleep` 来保持连接不断开，使用 `async` 设定最大等待时长以避免发生超时，`poll` 设置为 0 表示直接执行不需要等待执行结果。暂停 10 秒钟以等待虚拟机恢复，使用 `wait_for_connection` 在虚拟机恢复连接后尽快连接。随后由 `install epel-release` 任务检查 RPM 的安装情况。你可以对这个剧本执行多次来验证它的幂等性，唯一会显示造成影响的是重启操作，因为我们使用了 `shell` 模块。如果不想造成实际的影响，可以在使用 `shell` 模块的时候 `changed_when: False`。\n\n现在我们已经知道如何对系统进行更新、重启虚拟机、重新连接、安装 RPM 包。下面我们通过 [Ansible Lightbulb][4] 来安装 NGINX:\n\n```\n  - name: Ensure nginx packages are present\n    yum:\n      name: nginx, python-pip, python-devel, devel\n      state: present\n    notify: restart-nginx-service\n\n  - name: Ensure uwsgi package is present\n    pip:\n      name: uwsgi\n      state: present\n    notify: restart-nginx-service\n\n  - name: Ensure latest default.conf is present\n    template:\n      src: templates/nginx.conf.j2\n      dest: /etc/nginx/nginx.conf\n      backup: yes\n    notify: restart-nginx-service\n\n  - name: Ensure latest index.html is present\n    template:\n      src: templates/index.html.j2\n      dest: /usr/share/nginx/html/index.html\n\n  - name: Ensure nginx service is started and enabled\n    service:\n      name: nginx\n      state: started\n      enabled: yes\n\n  - name: Ensure proper response from localhost can be received\n    uri:\n      url: \"http://localhost:80/\"\n      return_content: yes\n    register: response\n    until: 'nginx_test_message in response.content'\n    retries: 10\n    delay: 1\n```\n\n以及用来重启 nginx 服务的操作文件：\n\n```\n# 安装 nginx 的操作文件\n  - name: restart-nginx-service\n    service:\n      name: nginx\n      state: restarted\n```\n\n在这个角色里，我们使用 RPM 安装了 `nginx`、`python-pip`、`python-devel`、`devel`，用 PIP 安装了 `uwsgi`，接下来使用 `template` 模块复制 `nginx.conf` 和 `index.html` 以显示页面，并确保服务在系统启动时启动。然后就可以使用 `uri` 模块检查到页面的连接了。\n\n这个是一个系统更新、系统重启、安装 RPM 包的剧本示例，后续可以继续安装 nginx，当然这里可以替换成任何你想要的角色和应用程序。\n\n```\n  - hosts: all\n    roles:\n      - centos-update\n      - nginx-simple\n```\n\n观看演示视频了解了解这个过程。\n\n[demo](https://asciinema.org/a/166437/embed?)\n\n这只是关于如何更新系统、重启以及后续工作的示例。简单起见，我只添加了不带[变量][5]的包，当你在操作大量主机的时候，你就需要修改其中的一些设置了：\n\n- [async & poll](https://docs.ansible.com/ansible/latest/playbooks_async.html)\n- [serial](https://docs.ansible.com/ansible/latest/playbooks_delegation.html#rolling-update-batch-size)\n- [forks](https://docs.ansible.com/ansible/latest/intro_configuration.html#forks)\n\n这是由于在生产环境中如果你想逐一更新每一台主机的系统，你需要花相当一段时间去等待主机重启才能够继续下去。\n\n有关 Ansible 进行自动化工作的更多用法，请查阅[其它文章][6]。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/ansible-patch-systems\n\n[a]:https://opensource.com/users/jlozadad\n[1]:https://www.ansible.com/overview/how-ansible-works\n[2]:https://docs.ansible.com/ansible/latest/list_of_packaging_modules.html\n[3]:https://docs.ansible.com/ansible/latest/yum_module.html\n[4]:https://github.com/ansible/lightbulb/tree/master/examples/nginx-role\n[5]:https://docs.ansible.com/ansible/latest/playbooks_variables.html\n[6]:https://opensource.com/tags/ansible\n","slug":"How-to-use-Ansible-to-patch-systems-and-install-applications","published":1,"updated":"2019-03-28T05:52:14.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cw0019lixu2s2fmh1u","content":"<blockquote>\n<p>使用  Ansible IT 自动化引擎节省更新的时间。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/tools_osyearbook2016_sysadmin_cc.png?itok=Y1AHCKI4\" alt=\"\"></p>\n<p>你有没有想过，如何打补丁、重启系统，然后继续工作？</p>\n<p>如果你的回答是肯定的，那就需要了解一下 <a href=\"https://www.ansible.com/overview/how-ansible-works\" target=\"_blank\" rel=\"noopener\">Ansible</a> 了。它是一个配置管理工具，对于一些复杂的有时候需要几个小时才能完成的系统管理任务，又或者对安全性有比较高要求的时候，使用 Ansible 能够大大简化工作流程。</p>\n<p>以我作为系统管理员的经验，打补丁是一项最有难度的工作。每次遇到<ruby>公共漏洞批露<rt>Common Vulnearbilities and Exposure</rt></ruby>（CVE）通知或者<ruby>信息保障漏洞预警<rt>Information Assurance Vulnerability Alert</rt></ruby>（IAVA）时都必须要高度关注安全漏洞，否则安全部门将会严肃追究自己的责任。</p>\n<p>使用 Ansible 可以通过运行<a href=\"https://docs.ansible.com/ansible/latest/list_of_packaging_modules.html\" target=\"_blank\" rel=\"noopener\">封装模块</a>以缩短打补丁的时间，下面以 <a href=\"https://docs.ansible.com/ansible/latest/yum_module.html\" target=\"_blank\" rel=\"noopener\">yum 模块</a>更新系统为例，使用 Ansible 可以执行安装、更新、删除、从其它地方安装（例如持续集成/持续开发中的 <code>rpmbuild</code>）。以下是系统更新的任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: update the system</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: &quot;*&quot;</span><br><span class=\"line\">    state: latest</span><br></pre></td></tr></table></figure>\n<p>在第一行，我们给这个任务命名，这样可以清楚 Ansible 的工作内容。第二行表示使用 <code>yum</code> 模块在CentOS虚拟机中执行更新操作。第三行 <code>name: &quot;*&quot;</code> 表示更新所有程序。最后一行 <code>state: latest</code> 表示更新到最新的 RPM。</p>\n<p>系统更新结束之后，需要重新启动并重新连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: restart system to reboot to newest kernel</span><br><span class=\"line\">  shell: &quot;sleep 5 &amp;&amp; reboot&quot;</span><br><span class=\"line\">  async: 1</span><br><span class=\"line\">  poll: 0</span><br><span class=\"line\"></span><br><span class=\"line\">- name: wait for 10 seconds</span><br><span class=\"line\">  pause:</span><br><span class=\"line\">    seconds: 10</span><br><span class=\"line\"></span><br><span class=\"line\">- name: wait for the system to reboot</span><br><span class=\"line\">  wait_for_connection:</span><br><span class=\"line\">    connect_timeout: 20</span><br><span class=\"line\">    sleep: 5</span><br><span class=\"line\">    delay: 5</span><br><span class=\"line\">    timeout: 60</span><br><span class=\"line\"></span><br><span class=\"line\">- name: install epel-release</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: epel-release</span><br><span class=\"line\">    state: latest</span><br></pre></td></tr></table></figure>\n<p><code>shell</code> 模块中的命令让系统在 5 秒休眠之后重新启动，我们使用 <code>sleep</code> 来保持连接不断开，使用 <code>async</code> 设定最大等待时长以避免发生超时，<code>poll</code> 设置为 0 表示直接执行不需要等待执行结果。暂停 10 秒钟以等待虚拟机恢复，使用 <code>wait_for_connection</code> 在虚拟机恢复连接后尽快连接。随后由 <code>install epel-release</code> 任务检查 RPM 的安装情况。你可以对这个剧本执行多次来验证它的幂等性，唯一会显示造成影响的是重启操作，因为我们使用了 <code>shell</code> 模块。如果不想造成实际的影响，可以在使用 <code>shell</code> 模块的时候 <code>changed_when: False</code>。</p>\n<p>现在我们已经知道如何对系统进行更新、重启虚拟机、重新连接、安装 RPM 包。下面我们通过 <a href=\"https://github.com/ansible/lightbulb/tree/master/examples/nginx-role\" target=\"_blank\" rel=\"noopener\">Ansible Lightbulb</a> 来安装 NGINX:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ensure nginx packages are present</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: nginx, python-pip, python-devel, devel</span><br><span class=\"line\">    state: present</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure uwsgi package is present</span><br><span class=\"line\">  pip:</span><br><span class=\"line\">    name: uwsgi</span><br><span class=\"line\">    state: present</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure latest default.conf is present</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    src: templates/nginx.conf.j2</span><br><span class=\"line\">    dest: /etc/nginx/nginx.conf</span><br><span class=\"line\">    backup: yes</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure latest index.html is present</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    src: templates/index.html.j2</span><br><span class=\"line\">    dest: /usr/share/nginx/html/index.html</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure nginx service is started and enabled</span><br><span class=\"line\">  service:</span><br><span class=\"line\">    name: nginx</span><br><span class=\"line\">    state: started</span><br><span class=\"line\">    enabled: yes</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure proper response from localhost can be received</span><br><span class=\"line\">  uri:</span><br><span class=\"line\">    url: &quot;http://localhost:80/&quot;</span><br><span class=\"line\">    return_content: yes</span><br><span class=\"line\">  register: response</span><br><span class=\"line\">  until: &apos;nginx_test_message in response.content&apos;</span><br><span class=\"line\">  retries: 10</span><br><span class=\"line\">  delay: 1</span><br></pre></td></tr></table></figure>\n<p>以及用来重启 nginx 服务的操作文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装 nginx 的操作文件</span><br><span class=\"line\">  - name: restart-nginx-service</span><br><span class=\"line\">    service:</span><br><span class=\"line\">      name: nginx</span><br><span class=\"line\">      state: restarted</span><br></pre></td></tr></table></figure>\n<p>在这个角色里，我们使用 RPM 安装了 <code>nginx</code>、<code>python-pip</code>、<code>python-devel</code>、<code>devel</code>，用 PIP 安装了 <code>uwsgi</code>，接下来使用 <code>template</code> 模块复制 <code>nginx.conf</code> 和 <code>index.html</code> 以显示页面，并确保服务在系统启动时启动。然后就可以使用 <code>uri</code> 模块检查到页面的连接了。</p>\n<p>这个是一个系统更新、系统重启、安装 RPM 包的剧本示例，后续可以继续安装 nginx，当然这里可以替换成任何你想要的角色和应用程序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - centos-update</span><br><span class=\"line\">    - nginx-simple</span><br></pre></td></tr></table></figure>\n<p>观看演示视频了解了解这个过程。</p>\n<p><a href=\"https://asciinema.org/a/166437/embed?\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>这只是关于如何更新系统、重启以及后续工作的示例。简单起见，我只添加了不带<a href=\"https://docs.ansible.com/ansible/latest/playbooks_variables.html\" target=\"_blank\" rel=\"noopener\">变量</a>的包，当你在操作大量主机的时候，你就需要修改其中的一些设置了：</p>\n<ul>\n<li><a href=\"https://docs.ansible.com/ansible/latest/playbooks_async.html\" target=\"_blank\" rel=\"noopener\">async &amp; poll</a></li>\n<li><a href=\"https://docs.ansible.com/ansible/latest/playbooks_delegation.html#rolling-update-batch-size\" target=\"_blank\" rel=\"noopener\">serial</a></li>\n<li><a href=\"https://docs.ansible.com/ansible/latest/intro_configuration.html#forks\" target=\"_blank\" rel=\"noopener\">forks</a></li>\n</ul>\n<p>这是由于在生产环境中如果你想逐一更新每一台主机的系统，你需要花相当一段时间去等待主机重启才能够继续下去。</p>\n<p>有关 Ansible 进行自动化工作的更多用法，请查阅<a href=\"https://opensource.com/tags/ansible\" target=\"_blank\" rel=\"noopener\">其它文章</a>。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/ansible-patch-systems\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/ansible-patch-systems</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用  Ansible IT 自动化引擎节省更新的时间。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/tools_osyearbook2016_sysadmin_cc.png?itok=Y1AHCKI4\" alt=\"\"></p>\n<p>你有没有想过，如何打补丁、重启系统，然后继续工作？</p>\n<p>如果你的回答是肯定的，那就需要了解一下 <a href=\"https://www.ansible.com/overview/how-ansible-works\" target=\"_blank\" rel=\"noopener\">Ansible</a> 了。它是一个配置管理工具，对于一些复杂的有时候需要几个小时才能完成的系统管理任务，又或者对安全性有比较高要求的时候，使用 Ansible 能够大大简化工作流程。</p>\n<p>以我作为系统管理员的经验，打补丁是一项最有难度的工作。每次遇到<ruby>公共漏洞批露<rt>Common Vulnearbilities and Exposure</rt></ruby>（CVE）通知或者<ruby>信息保障漏洞预警<rt>Information Assurance Vulnerability Alert</rt></ruby>（IAVA）时都必须要高度关注安全漏洞，否则安全部门将会严肃追究自己的责任。</p>\n<p>使用 Ansible 可以通过运行<a href=\"https://docs.ansible.com/ansible/latest/list_of_packaging_modules.html\" target=\"_blank\" rel=\"noopener\">封装模块</a>以缩短打补丁的时间，下面以 <a href=\"https://docs.ansible.com/ansible/latest/yum_module.html\" target=\"_blank\" rel=\"noopener\">yum 模块</a>更新系统为例，使用 Ansible 可以执行安装、更新、删除、从其它地方安装（例如持续集成/持续开发中的 <code>rpmbuild</code>）。以下是系统更新的任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: update the system</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: &quot;*&quot;</span><br><span class=\"line\">    state: latest</span><br></pre></td></tr></table></figure>\n<p>在第一行，我们给这个任务命名，这样可以清楚 Ansible 的工作内容。第二行表示使用 <code>yum</code> 模块在CentOS虚拟机中执行更新操作。第三行 <code>name: &quot;*&quot;</code> 表示更新所有程序。最后一行 <code>state: latest</code> 表示更新到最新的 RPM。</p>\n<p>系统更新结束之后，需要重新启动并重新连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: restart system to reboot to newest kernel</span><br><span class=\"line\">  shell: &quot;sleep 5 &amp;&amp; reboot&quot;</span><br><span class=\"line\">  async: 1</span><br><span class=\"line\">  poll: 0</span><br><span class=\"line\"></span><br><span class=\"line\">- name: wait for 10 seconds</span><br><span class=\"line\">  pause:</span><br><span class=\"line\">    seconds: 10</span><br><span class=\"line\"></span><br><span class=\"line\">- name: wait for the system to reboot</span><br><span class=\"line\">  wait_for_connection:</span><br><span class=\"line\">    connect_timeout: 20</span><br><span class=\"line\">    sleep: 5</span><br><span class=\"line\">    delay: 5</span><br><span class=\"line\">    timeout: 60</span><br><span class=\"line\"></span><br><span class=\"line\">- name: install epel-release</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: epel-release</span><br><span class=\"line\">    state: latest</span><br></pre></td></tr></table></figure>\n<p><code>shell</code> 模块中的命令让系统在 5 秒休眠之后重新启动，我们使用 <code>sleep</code> 来保持连接不断开，使用 <code>async</code> 设定最大等待时长以避免发生超时，<code>poll</code> 设置为 0 表示直接执行不需要等待执行结果。暂停 10 秒钟以等待虚拟机恢复，使用 <code>wait_for_connection</code> 在虚拟机恢复连接后尽快连接。随后由 <code>install epel-release</code> 任务检查 RPM 的安装情况。你可以对这个剧本执行多次来验证它的幂等性，唯一会显示造成影响的是重启操作，因为我们使用了 <code>shell</code> 模块。如果不想造成实际的影响，可以在使用 <code>shell</code> 模块的时候 <code>changed_when: False</code>。</p>\n<p>现在我们已经知道如何对系统进行更新、重启虚拟机、重新连接、安装 RPM 包。下面我们通过 <a href=\"https://github.com/ansible/lightbulb/tree/master/examples/nginx-role\" target=\"_blank\" rel=\"noopener\">Ansible Lightbulb</a> 来安装 NGINX:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ensure nginx packages are present</span><br><span class=\"line\">  yum:</span><br><span class=\"line\">    name: nginx, python-pip, python-devel, devel</span><br><span class=\"line\">    state: present</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure uwsgi package is present</span><br><span class=\"line\">  pip:</span><br><span class=\"line\">    name: uwsgi</span><br><span class=\"line\">    state: present</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure latest default.conf is present</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    src: templates/nginx.conf.j2</span><br><span class=\"line\">    dest: /etc/nginx/nginx.conf</span><br><span class=\"line\">    backup: yes</span><br><span class=\"line\">  notify: restart-nginx-service</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure latest index.html is present</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    src: templates/index.html.j2</span><br><span class=\"line\">    dest: /usr/share/nginx/html/index.html</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure nginx service is started and enabled</span><br><span class=\"line\">  service:</span><br><span class=\"line\">    name: nginx</span><br><span class=\"line\">    state: started</span><br><span class=\"line\">    enabled: yes</span><br><span class=\"line\"></span><br><span class=\"line\">- name: Ensure proper response from localhost can be received</span><br><span class=\"line\">  uri:</span><br><span class=\"line\">    url: &quot;http://localhost:80/&quot;</span><br><span class=\"line\">    return_content: yes</span><br><span class=\"line\">  register: response</span><br><span class=\"line\">  until: &apos;nginx_test_message in response.content&apos;</span><br><span class=\"line\">  retries: 10</span><br><span class=\"line\">  delay: 1</span><br></pre></td></tr></table></figure>\n<p>以及用来重启 nginx 服务的操作文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装 nginx 的操作文件</span><br><span class=\"line\">  - name: restart-nginx-service</span><br><span class=\"line\">    service:</span><br><span class=\"line\">      name: nginx</span><br><span class=\"line\">      state: restarted</span><br></pre></td></tr></table></figure>\n<p>在这个角色里，我们使用 RPM 安装了 <code>nginx</code>、<code>python-pip</code>、<code>python-devel</code>、<code>devel</code>，用 PIP 安装了 <code>uwsgi</code>，接下来使用 <code>template</code> 模块复制 <code>nginx.conf</code> 和 <code>index.html</code> 以显示页面，并确保服务在系统启动时启动。然后就可以使用 <code>uri</code> 模块检查到页面的连接了。</p>\n<p>这个是一个系统更新、系统重启、安装 RPM 包的剧本示例，后续可以继续安装 nginx，当然这里可以替换成任何你想要的角色和应用程序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - centos-update</span><br><span class=\"line\">    - nginx-simple</span><br></pre></td></tr></table></figure>\n<p>观看演示视频了解了解这个过程。</p>\n<p><a href=\"https://asciinema.org/a/166437/embed?\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>这只是关于如何更新系统、重启以及后续工作的示例。简单起见，我只添加了不带<a href=\"https://docs.ansible.com/ansible/latest/playbooks_variables.html\" target=\"_blank\" rel=\"noopener\">变量</a>的包，当你在操作大量主机的时候，你就需要修改其中的一些设置了：</p>\n<ul>\n<li><a href=\"https://docs.ansible.com/ansible/latest/playbooks_async.html\" target=\"_blank\" rel=\"noopener\">async &amp; poll</a></li>\n<li><a href=\"https://docs.ansible.com/ansible/latest/playbooks_delegation.html#rolling-update-batch-size\" target=\"_blank\" rel=\"noopener\">serial</a></li>\n<li><a href=\"https://docs.ansible.com/ansible/latest/intro_configuration.html#forks\" target=\"_blank\" rel=\"noopener\">forks</a></li>\n</ul>\n<p>这是由于在生产环境中如果你想逐一更新每一台主机的系统，你需要花相当一段时间去等待主机重启才能够继续下去。</p>\n<p>有关 Ansible 进行自动化工作的更多用法，请查阅<a href=\"https://opensource.com/tags/ansible\" target=\"_blank\" rel=\"noopener\">其它文章</a>。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/ansible-patch-systems\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/ansible-patch-systems</a></p>\n"},{"title":"pydbgen：一个数据库随机生成器","date":"2018-11-17T15:11:08.000Z","_content":"\n> 用这个简单的工具生成带有多表的大型数据库，让你更好地用 SQL 研究数据科学。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/features_solutions_command_data.png?itok=4_VQN3RK)\n\n在研究数据科学的过程中，最麻烦的往往不是算法或者技术，而是如何获取到一批原始数据。尽管网上有很多真实优质的数据集可以用于机器学习，然而在学习 SQL 时却不是如此。\n\n对于数据科学来说，熟悉 SQL 的重要性不亚于了解 Python 或 R 编程。如果想收集诸如姓名、年龄、信用卡信息、地址这些信息用于机器学习任务，在 Kaggle 上查找专门的数据集比使用足够大的真实数据库要容易得多。\n\n如果有一个简单的工具或库来帮助你生成一个大型数据库，表里还存放着大量你需要的数据，岂不美哉？\n\n不仅仅是数据科学的入门者，即使是经验丰富的软件测试人员也会需要这样一个简单的工具，只需编写几行代码，就可以通过随机（但是是假随机）生成任意数量但有意义的数据集。\n\n因此，我要推荐这个名为 [pydbgen][1] 的轻量级 Python 库。在后文中，我会简要说明这个库的相关内容，你也可以[阅读它的文档][2]详细了解更多信息。\n\n### pydbgen 是什么\n\n`pydbgen` 是一个轻量的纯 Python 库，它可以用于生成随机但有意义的数据记录（包括姓名、地址、信用卡号、日期、时间、公司名称、职位、车牌号等等），存放在 Pandas Dataframe 对象中，并保存到 SQLite 数据库或 Excel 文件。\n\n### 如何安装 pydbgen\n\n目前 1.0.5 版本的 pydbgen 托管在 PyPI（<ruby>Python 包索引存储库<rt>Python Package Index repository</rt></ruby>）上，并且对 [Faker][3] 有依赖关系。安装 pydbgen 只需要执行命令：\n\n```\npip install pydbgen\n```\n\n已经在 Python 3.6 环境下测试安装成功，但在 Python 2 环境下无法正常安装。\n\n### 如何使用 pydbgen\n\n在使用 `pydbgen` 之前，首先要初始化 `pydb` 对象。\n\n```\nimport pydbgen\nfrom pydbgen import pydbgen\nmyDB=pydbgen.pydb()\n```\n\n随后就可以调用 `pydb` 对象公开的各种内部函数了。可以按照下面的例子，输出随机的美国城市和车牌号码：\n\n```\nmyDB.city_real()\n>> 'Otterville'\nfor _ in range(10):\n    print(myDB.license_plate())\n>> 8NVX937\n   6YZH485\n   XBY-564\n   SCG-2185\n   XMR-158\n   6OZZ231\n   CJN-850\n   SBL-4272\n   TPY-658\n   SZL-0934\n```\n\n另外，如果你输入的是 `city()` 而不是 `city_real()`，返回的将会是虚构的城市名。\n\n```\nprint(myDB.gen_data_series(num=8,data_type='city'))\n>>\nNew Michelle\nRobinborough\nLeebury\nKaylatown\nHamiltonfort\nLake Christopher\nHannahstad\nWest Adamborough\n```\n\n### 生成随机的 Pandas Dataframe\n\n你可以指定生成数据的数量和种类，但需要注意的是，返回结果均为字符串或文本类型。\n\n```\ntestdf=myDB.gen_dataframe(5,['name','city','phone','date'])\ntestdf\n```\n\n最终产生的 Dataframe 类似下图所示。\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_pandas-dataframe.png)\n\n### 生成数据库表\n\n你也可以指定生成数据的数量和种类，而返回结果是数据库中的文本或者变长字符串类型。在生成过程中，你可以指定对应的数据库文件名和表名。\n\n```\nmyDB.gen_table(db_file='Testdb.DB',table_name='People',\n\nfields=['name','city','street_address','email'])\n```\n\n上面的例子种生成了一个能被 MySQL 和 SQLite 支持的 `.db` 文件。下图则显示了这个文件中的数据表在 SQLite 可视化客户端中打开的画面。\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_db-browser-for-sqlite.png)\n\n### 生成 Excel 文件\n\n和上面的其它示例类似，下面的代码可以生成一个具有随机数据的 Excel 文件。值得一提的是，通过将 `phone_simple` 参数设为 `False` ，可以生成较长较复杂的电话号码。如果你想要提高自己在数据提取方面的能力，不妨尝试一下这个功能。\n\n```\nmyDB.gen_excel(num=20,fields=['name','phone','time','country'],\nphone_simple=False,filename='TestExcel.xlsx')\n```\n\n最终的结果类似下图所示：\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_excel.png)\n\n### 生成随机电子邮箱地址\n\n`pydbgen` 内置了一个 `realistic_email` 方法，它基于种子来生成随机的电子邮箱地址。如果你不想在网络上使用真实的电子邮箱地址时，这个功能可以派上用场。\n\n```\nfor _ in range(10):\n    print(myDB.realistic_email('Tirtha Sarkar'))\n>>\nTirtha_Sarkar@gmail.com\nSarkar.Tirtha@outlook.com\nTirtha_S48@verizon.com\nTirtha_Sarkar62@yahoo.com\nTirtha.S46@yandex.com\nTirtha.S@att.com\nSarkar.Tirtha60@gmail.com\nTirthaSarkar@zoho.com\nSarkar.Tirtha@protonmail.com\nTirtha.S@comcast.net\n```\n\n### 未来的改进和用户贡献\n\n目前的版本中并不完美。如果你发现了 pydbgen 的 bug 导致它在运行期间发生崩溃，请向我反馈。如果你打算对这个项目贡献代码，[也随时欢迎你][1]。当然现在也还有很多改进的方向：\n\n  * pydbgen 作为随机数据生成器，可以集成一些机器学习或统计建模的功能吗？\n  * pydbgen 是否会添加可视化功能？\n\n一切皆有可能！\n\n如果你有任何问题或想法想要分享，都可以通过 [tirthajyoti@gmail.com][4] 与我联系。如果你像我一样对机器学习和数据科学感兴趣，也可以添加我的 [LinkedIn][5] 或在 [Twitter][6] 上关注我。另外，还可以在我的 [GitHub][7] 上找到更多 Python、R 或 MATLAB 的有趣代码和机器学习资源。\n\n本文以 [CC BY-SA 4.0][9] 许可在 [Towards Data Science][8] 首发。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/pydbgen-random-database-table-generator\n\n[a]: https://opensource.com/users/tirthajyoti\n[b]: https://github.com/lujun9972\n[1]: https://github.com/tirthajyoti/pydbgen\n[2]: http://pydbgen.readthedocs.io/en/latest/\n[3]: https://faker.readthedocs.io/en/latest/index.html\n[4]: mailto:tirthajyoti@gmail.com\n[5]: https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/\n[6]: https://twitter.com/tirthajyotiS\n[7]: https://github.com/tirthajyoti?tab=repositories\n[8]: https://towardsdatascience.com/introducing-pydbgen-a-random-dataframe-database-table-generator-b5c7bdc84be5\n[9]: https://creativecommons.org/licenses/by-sa/4.0/\n\n","source":"_posts/Introducing-pydbgen-A-random-dataframe-database-table-generator.md","raw":"---\ntitle: pydbgen：一个数据库随机生成器\ndate: 2018-11-17 23:11:08\ntags:\n  - Python\n  - 数据库\n  - 随机\n  - LCTT 翻译\n---\n\n> 用这个简单的工具生成带有多表的大型数据库，让你更好地用 SQL 研究数据科学。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/features_solutions_command_data.png?itok=4_VQN3RK)\n\n在研究数据科学的过程中，最麻烦的往往不是算法或者技术，而是如何获取到一批原始数据。尽管网上有很多真实优质的数据集可以用于机器学习，然而在学习 SQL 时却不是如此。\n\n对于数据科学来说，熟悉 SQL 的重要性不亚于了解 Python 或 R 编程。如果想收集诸如姓名、年龄、信用卡信息、地址这些信息用于机器学习任务，在 Kaggle 上查找专门的数据集比使用足够大的真实数据库要容易得多。\n\n如果有一个简单的工具或库来帮助你生成一个大型数据库，表里还存放着大量你需要的数据，岂不美哉？\n\n不仅仅是数据科学的入门者，即使是经验丰富的软件测试人员也会需要这样一个简单的工具，只需编写几行代码，就可以通过随机（但是是假随机）生成任意数量但有意义的数据集。\n\n因此，我要推荐这个名为 [pydbgen][1] 的轻量级 Python 库。在后文中，我会简要说明这个库的相关内容，你也可以[阅读它的文档][2]详细了解更多信息。\n\n### pydbgen 是什么\n\n`pydbgen` 是一个轻量的纯 Python 库，它可以用于生成随机但有意义的数据记录（包括姓名、地址、信用卡号、日期、时间、公司名称、职位、车牌号等等），存放在 Pandas Dataframe 对象中，并保存到 SQLite 数据库或 Excel 文件。\n\n### 如何安装 pydbgen\n\n目前 1.0.5 版本的 pydbgen 托管在 PyPI（<ruby>Python 包索引存储库<rt>Python Package Index repository</rt></ruby>）上，并且对 [Faker][3] 有依赖关系。安装 pydbgen 只需要执行命令：\n\n```\npip install pydbgen\n```\n\n已经在 Python 3.6 环境下测试安装成功，但在 Python 2 环境下无法正常安装。\n\n### 如何使用 pydbgen\n\n在使用 `pydbgen` 之前，首先要初始化 `pydb` 对象。\n\n```\nimport pydbgen\nfrom pydbgen import pydbgen\nmyDB=pydbgen.pydb()\n```\n\n随后就可以调用 `pydb` 对象公开的各种内部函数了。可以按照下面的例子，输出随机的美国城市和车牌号码：\n\n```\nmyDB.city_real()\n>> 'Otterville'\nfor _ in range(10):\n    print(myDB.license_plate())\n>> 8NVX937\n   6YZH485\n   XBY-564\n   SCG-2185\n   XMR-158\n   6OZZ231\n   CJN-850\n   SBL-4272\n   TPY-658\n   SZL-0934\n```\n\n另外，如果你输入的是 `city()` 而不是 `city_real()`，返回的将会是虚构的城市名。\n\n```\nprint(myDB.gen_data_series(num=8,data_type='city'))\n>>\nNew Michelle\nRobinborough\nLeebury\nKaylatown\nHamiltonfort\nLake Christopher\nHannahstad\nWest Adamborough\n```\n\n### 生成随机的 Pandas Dataframe\n\n你可以指定生成数据的数量和种类，但需要注意的是，返回结果均为字符串或文本类型。\n\n```\ntestdf=myDB.gen_dataframe(5,['name','city','phone','date'])\ntestdf\n```\n\n最终产生的 Dataframe 类似下图所示。\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_pandas-dataframe.png)\n\n### 生成数据库表\n\n你也可以指定生成数据的数量和种类，而返回结果是数据库中的文本或者变长字符串类型。在生成过程中，你可以指定对应的数据库文件名和表名。\n\n```\nmyDB.gen_table(db_file='Testdb.DB',table_name='People',\n\nfields=['name','city','street_address','email'])\n```\n\n上面的例子种生成了一个能被 MySQL 和 SQLite 支持的 `.db` 文件。下图则显示了这个文件中的数据表在 SQLite 可视化客户端中打开的画面。\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_db-browser-for-sqlite.png)\n\n### 生成 Excel 文件\n\n和上面的其它示例类似，下面的代码可以生成一个具有随机数据的 Excel 文件。值得一提的是，通过将 `phone_simple` 参数设为 `False` ，可以生成较长较复杂的电话号码。如果你想要提高自己在数据提取方面的能力，不妨尝试一下这个功能。\n\n```\nmyDB.gen_excel(num=20,fields=['name','phone','time','country'],\nphone_simple=False,filename='TestExcel.xlsx')\n```\n\n最终的结果类似下图所示：\n\n![](https://opensource.com/sites/default/files/uploads/pydbgen_excel.png)\n\n### 生成随机电子邮箱地址\n\n`pydbgen` 内置了一个 `realistic_email` 方法，它基于种子来生成随机的电子邮箱地址。如果你不想在网络上使用真实的电子邮箱地址时，这个功能可以派上用场。\n\n```\nfor _ in range(10):\n    print(myDB.realistic_email('Tirtha Sarkar'))\n>>\nTirtha_Sarkar@gmail.com\nSarkar.Tirtha@outlook.com\nTirtha_S48@verizon.com\nTirtha_Sarkar62@yahoo.com\nTirtha.S46@yandex.com\nTirtha.S@att.com\nSarkar.Tirtha60@gmail.com\nTirthaSarkar@zoho.com\nSarkar.Tirtha@protonmail.com\nTirtha.S@comcast.net\n```\n\n### 未来的改进和用户贡献\n\n目前的版本中并不完美。如果你发现了 pydbgen 的 bug 导致它在运行期间发生崩溃，请向我反馈。如果你打算对这个项目贡献代码，[也随时欢迎你][1]。当然现在也还有很多改进的方向：\n\n  * pydbgen 作为随机数据生成器，可以集成一些机器学习或统计建模的功能吗？\n  * pydbgen 是否会添加可视化功能？\n\n一切皆有可能！\n\n如果你有任何问题或想法想要分享，都可以通过 [tirthajyoti@gmail.com][4] 与我联系。如果你像我一样对机器学习和数据科学感兴趣，也可以添加我的 [LinkedIn][5] 或在 [Twitter][6] 上关注我。另外，还可以在我的 [GitHub][7] 上找到更多 Python、R 或 MATLAB 的有趣代码和机器学习资源。\n\n本文以 [CC BY-SA 4.0][9] 许可在 [Towards Data Science][8] 首发。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/pydbgen-random-database-table-generator\n\n[a]: https://opensource.com/users/tirthajyoti\n[b]: https://github.com/lujun9972\n[1]: https://github.com/tirthajyoti/pydbgen\n[2]: http://pydbgen.readthedocs.io/en/latest/\n[3]: https://faker.readthedocs.io/en/latest/index.html\n[4]: mailto:tirthajyoti@gmail.com\n[5]: https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/\n[6]: https://twitter.com/tirthajyotiS\n[7]: https://github.com/tirthajyoti?tab=repositories\n[8]: https://towardsdatascience.com/introducing-pydbgen-a-random-dataframe-database-table-generator-b5c7bdc84be5\n[9]: https://creativecommons.org/licenses/by-sa/4.0/\n\n","slug":"Introducing-pydbgen-A-random-dataframe-database-table-generator","published":1,"updated":"2019-03-28T12:47:48.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cy001blixumr9uieo4","content":"<blockquote>\n<p>用这个简单的工具生成带有多表的大型数据库，让你更好地用 SQL 研究数据科学。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/features_solutions_command_data.png?itok=4_VQN3RK\" alt=\"\"></p>\n<p>在研究数据科学的过程中，最麻烦的往往不是算法或者技术，而是如何获取到一批原始数据。尽管网上有很多真实优质的数据集可以用于机器学习，然而在学习 SQL 时却不是如此。</p>\n<p>对于数据科学来说，熟悉 SQL 的重要性不亚于了解 Python 或 R 编程。如果想收集诸如姓名、年龄、信用卡信息、地址这些信息用于机器学习任务，在 Kaggle 上查找专门的数据集比使用足够大的真实数据库要容易得多。</p>\n<p>如果有一个简单的工具或库来帮助你生成一个大型数据库，表里还存放着大量你需要的数据，岂不美哉？</p>\n<p>不仅仅是数据科学的入门者，即使是经验丰富的软件测试人员也会需要这样一个简单的工具，只需编写几行代码，就可以通过随机（但是是假随机）生成任意数量但有意义的数据集。</p>\n<p>因此，我要推荐这个名为 <a href=\"https://github.com/tirthajyoti/pydbgen\" target=\"_blank\" rel=\"noopener\">pydbgen</a> 的轻量级 Python 库。在后文中，我会简要说明这个库的相关内容，你也可以<a href=\"http://pydbgen.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">阅读它的文档</a>详细了解更多信息。</p>\n<h3 id=\"pydbgen-是什么\"><a href=\"#pydbgen-是什么\" class=\"headerlink\" title=\"pydbgen 是什么\"></a>pydbgen 是什么</h3><p><code>pydbgen</code> 是一个轻量的纯 Python 库，它可以用于生成随机但有意义的数据记录（包括姓名、地址、信用卡号、日期、时间、公司名称、职位、车牌号等等），存放在 Pandas Dataframe 对象中，并保存到 SQLite 数据库或 Excel 文件。</p>\n<h3 id=\"如何安装-pydbgen\"><a href=\"#如何安装-pydbgen\" class=\"headerlink\" title=\"如何安装 pydbgen\"></a>如何安装 pydbgen</h3><p>目前 1.0.5 版本的 pydbgen 托管在 PyPI（<ruby>Python 包索引存储库<rt>Python Package Index repository</rt></ruby>）上，并且对 <a href=\"https://faker.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">Faker</a> 有依赖关系。安装 pydbgen 只需要执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pydbgen</span><br></pre></td></tr></table></figure>\n<p>已经在 Python 3.6 环境下测试安装成功，但在 Python 2 环境下无法正常安装。</p>\n<h3 id=\"如何使用-pydbgen\"><a href=\"#如何使用-pydbgen\" class=\"headerlink\" title=\"如何使用 pydbgen\"></a>如何使用 pydbgen</h3><p>在使用 <code>pydbgen</code> 之前，首先要初始化 <code>pydb</code> 对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import pydbgen</span><br><span class=\"line\">from pydbgen import pydbgen</span><br><span class=\"line\">myDB=pydbgen.pydb()</span><br></pre></td></tr></table></figure>\n<p>随后就可以调用 <code>pydb</code> 对象公开的各种内部函数了。可以按照下面的例子，输出随机的美国城市和车牌号码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.city_real()</span><br><span class=\"line\">&gt;&gt; &apos;Otterville&apos;</span><br><span class=\"line\">for _ in range(10):</span><br><span class=\"line\">    print(myDB.license_plate())</span><br><span class=\"line\">&gt;&gt; 8NVX937</span><br><span class=\"line\">   6YZH485</span><br><span class=\"line\">   XBY-564</span><br><span class=\"line\">   SCG-2185</span><br><span class=\"line\">   XMR-158</span><br><span class=\"line\">   6OZZ231</span><br><span class=\"line\">   CJN-850</span><br><span class=\"line\">   SBL-4272</span><br><span class=\"line\">   TPY-658</span><br><span class=\"line\">   SZL-0934</span><br></pre></td></tr></table></figure>\n<p>另外，如果你输入的是 <code>city()</code> 而不是 <code>city_real()</code>，返回的将会是虚构的城市名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(myDB.gen_data_series(num=8,data_type=&apos;city&apos;))</span><br><span class=\"line\">&gt;&gt;</span><br><span class=\"line\">New Michelle</span><br><span class=\"line\">Robinborough</span><br><span class=\"line\">Leebury</span><br><span class=\"line\">Kaylatown</span><br><span class=\"line\">Hamiltonfort</span><br><span class=\"line\">Lake Christopher</span><br><span class=\"line\">Hannahstad</span><br><span class=\"line\">West Adamborough</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机的-Pandas-Dataframe\"><a href=\"#生成随机的-Pandas-Dataframe\" class=\"headerlink\" title=\"生成随机的 Pandas Dataframe\"></a>生成随机的 Pandas Dataframe</h3><p>你可以指定生成数据的数量和种类，但需要注意的是，返回结果均为字符串或文本类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdf=myDB.gen_dataframe(5,[&apos;name&apos;,&apos;city&apos;,&apos;phone&apos;,&apos;date&apos;])</span><br><span class=\"line\">testdf</span><br></pre></td></tr></table></figure>\n<p>最终产生的 Dataframe 类似下图所示。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_pandas-dataframe.png\" alt=\"\"></p>\n<h3 id=\"生成数据库表\"><a href=\"#生成数据库表\" class=\"headerlink\" title=\"生成数据库表\"></a>生成数据库表</h3><p>你也可以指定生成数据的数量和种类，而返回结果是数据库中的文本或者变长字符串类型。在生成过程中，你可以指定对应的数据库文件名和表名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.gen_table(db_file=&apos;Testdb.DB&apos;,table_name=&apos;People&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">fields=[&apos;name&apos;,&apos;city&apos;,&apos;street_address&apos;,&apos;email&apos;])</span><br></pre></td></tr></table></figure>\n<p>上面的例子种生成了一个能被 MySQL 和 SQLite 支持的 <code>.db</code> 文件。下图则显示了这个文件中的数据表在 SQLite 可视化客户端中打开的画面。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_db-browser-for-sqlite.png\" alt=\"\"></p>\n<h3 id=\"生成-Excel-文件\"><a href=\"#生成-Excel-文件\" class=\"headerlink\" title=\"生成 Excel 文件\"></a>生成 Excel 文件</h3><p>和上面的其它示例类似，下面的代码可以生成一个具有随机数据的 Excel 文件。值得一提的是，通过将 <code>phone_simple</code> 参数设为 <code>False</code> ，可以生成较长较复杂的电话号码。如果你想要提高自己在数据提取方面的能力，不妨尝试一下这个功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.gen_excel(num=20,fields=[&apos;name&apos;,&apos;phone&apos;,&apos;time&apos;,&apos;country&apos;],</span><br><span class=\"line\">phone_simple=False,filename=&apos;TestExcel.xlsx&apos;)</span><br></pre></td></tr></table></figure>\n<p>最终的结果类似下图所示：</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_excel.png\" alt=\"\"></p>\n<h3 id=\"生成随机电子邮箱地址\"><a href=\"#生成随机电子邮箱地址\" class=\"headerlink\" title=\"生成随机电子邮箱地址\"></a>生成随机电子邮箱地址</h3><p><code>pydbgen</code> 内置了一个 <code>realistic_email</code> 方法，它基于种子来生成随机的电子邮箱地址。如果你不想在网络上使用真实的电子邮箱地址时，这个功能可以派上用场。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in range(10):</span><br><span class=\"line\">    print(myDB.realistic_email(&apos;Tirtha Sarkar&apos;))</span><br><span class=\"line\">&gt;&gt;</span><br><span class=\"line\">Tirtha_Sarkar@gmail.com</span><br><span class=\"line\">Sarkar.Tirtha@outlook.com</span><br><span class=\"line\">Tirtha_S48@verizon.com</span><br><span class=\"line\">Tirtha_Sarkar62@yahoo.com</span><br><span class=\"line\">Tirtha.S46@yandex.com</span><br><span class=\"line\">Tirtha.S@att.com</span><br><span class=\"line\">Sarkar.Tirtha60@gmail.com</span><br><span class=\"line\">TirthaSarkar@zoho.com</span><br><span class=\"line\">Sarkar.Tirtha@protonmail.com</span><br><span class=\"line\">Tirtha.S@comcast.net</span><br></pre></td></tr></table></figure>\n<h3 id=\"未来的改进和用户贡献\"><a href=\"#未来的改进和用户贡献\" class=\"headerlink\" title=\"未来的改进和用户贡献\"></a>未来的改进和用户贡献</h3><p>目前的版本中并不完美。如果你发现了 pydbgen 的 bug 导致它在运行期间发生崩溃，请向我反馈。如果你打算对这个项目贡献代码，<a href=\"https://github.com/tirthajyoti/pydbgen\" target=\"_blank\" rel=\"noopener\">也随时欢迎你</a>。当然现在也还有很多改进的方向：</p>\n<ul>\n<li>pydbgen 作为随机数据生成器，可以集成一些机器学习或统计建模的功能吗？</li>\n<li>pydbgen 是否会添加可视化功能？</li>\n</ul>\n<p>一切皆有可能！</p>\n<p>如果你有任何问题或想法想要分享，都可以通过 <a href=\"mailto:tirthajyoti@gmail.com\" target=\"_blank\" rel=\"noopener\">tirthajyoti@gmail.com</a> 与我联系。如果你像我一样对机器学习和数据科学感兴趣，也可以添加我的 <a href=\"https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/\" target=\"_blank\" rel=\"noopener\">LinkedIn</a> 或在 <a href=\"https://twitter.com/tirthajyotiS\" target=\"_blank\" rel=\"noopener\">Twitter</a> 上关注我。另外，还可以在我的 <a href=\"https://github.com/tirthajyoti?tab=repositories\" target=\"_blank\" rel=\"noopener\">GitHub</a> 上找到更多 Python、R 或 MATLAB 的有趣代码和机器学习资源。</p>\n<p>本文以 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">CC BY-SA 4.0</a> 许可在 <a href=\"https://towardsdatascience.com/introducing-pydbgen-a-random-dataframe-database-table-generator-b5c7bdc84be5\" target=\"_blank\" rel=\"noopener\">Towards Data Science</a> 首发。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/pydbgen-random-database-table-generator\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/pydbgen-random-database-table-generator</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>用这个简单的工具生成带有多表的大型数据库，让你更好地用 SQL 研究数据科学。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/features_solutions_command_data.png?itok=4_VQN3RK\" alt=\"\"></p>\n<p>在研究数据科学的过程中，最麻烦的往往不是算法或者技术，而是如何获取到一批原始数据。尽管网上有很多真实优质的数据集可以用于机器学习，然而在学习 SQL 时却不是如此。</p>\n<p>对于数据科学来说，熟悉 SQL 的重要性不亚于了解 Python 或 R 编程。如果想收集诸如姓名、年龄、信用卡信息、地址这些信息用于机器学习任务，在 Kaggle 上查找专门的数据集比使用足够大的真实数据库要容易得多。</p>\n<p>如果有一个简单的工具或库来帮助你生成一个大型数据库，表里还存放着大量你需要的数据，岂不美哉？</p>\n<p>不仅仅是数据科学的入门者，即使是经验丰富的软件测试人员也会需要这样一个简单的工具，只需编写几行代码，就可以通过随机（但是是假随机）生成任意数量但有意义的数据集。</p>\n<p>因此，我要推荐这个名为 <a href=\"https://github.com/tirthajyoti/pydbgen\" target=\"_blank\" rel=\"noopener\">pydbgen</a> 的轻量级 Python 库。在后文中，我会简要说明这个库的相关内容，你也可以<a href=\"http://pydbgen.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">阅读它的文档</a>详细了解更多信息。</p>\n<h3 id=\"pydbgen-是什么\"><a href=\"#pydbgen-是什么\" class=\"headerlink\" title=\"pydbgen 是什么\"></a>pydbgen 是什么</h3><p><code>pydbgen</code> 是一个轻量的纯 Python 库，它可以用于生成随机但有意义的数据记录（包括姓名、地址、信用卡号、日期、时间、公司名称、职位、车牌号等等），存放在 Pandas Dataframe 对象中，并保存到 SQLite 数据库或 Excel 文件。</p>\n<h3 id=\"如何安装-pydbgen\"><a href=\"#如何安装-pydbgen\" class=\"headerlink\" title=\"如何安装 pydbgen\"></a>如何安装 pydbgen</h3><p>目前 1.0.5 版本的 pydbgen 托管在 PyPI（<ruby>Python 包索引存储库<rt>Python Package Index repository</rt></ruby>）上，并且对 <a href=\"https://faker.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">Faker</a> 有依赖关系。安装 pydbgen 只需要执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pydbgen</span><br></pre></td></tr></table></figure>\n<p>已经在 Python 3.6 环境下测试安装成功，但在 Python 2 环境下无法正常安装。</p>\n<h3 id=\"如何使用-pydbgen\"><a href=\"#如何使用-pydbgen\" class=\"headerlink\" title=\"如何使用 pydbgen\"></a>如何使用 pydbgen</h3><p>在使用 <code>pydbgen</code> 之前，首先要初始化 <code>pydb</code> 对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import pydbgen</span><br><span class=\"line\">from pydbgen import pydbgen</span><br><span class=\"line\">myDB=pydbgen.pydb()</span><br></pre></td></tr></table></figure>\n<p>随后就可以调用 <code>pydb</code> 对象公开的各种内部函数了。可以按照下面的例子，输出随机的美国城市和车牌号码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.city_real()</span><br><span class=\"line\">&gt;&gt; &apos;Otterville&apos;</span><br><span class=\"line\">for _ in range(10):</span><br><span class=\"line\">    print(myDB.license_plate())</span><br><span class=\"line\">&gt;&gt; 8NVX937</span><br><span class=\"line\">   6YZH485</span><br><span class=\"line\">   XBY-564</span><br><span class=\"line\">   SCG-2185</span><br><span class=\"line\">   XMR-158</span><br><span class=\"line\">   6OZZ231</span><br><span class=\"line\">   CJN-850</span><br><span class=\"line\">   SBL-4272</span><br><span class=\"line\">   TPY-658</span><br><span class=\"line\">   SZL-0934</span><br></pre></td></tr></table></figure>\n<p>另外，如果你输入的是 <code>city()</code> 而不是 <code>city_real()</code>，返回的将会是虚构的城市名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(myDB.gen_data_series(num=8,data_type=&apos;city&apos;))</span><br><span class=\"line\">&gt;&gt;</span><br><span class=\"line\">New Michelle</span><br><span class=\"line\">Robinborough</span><br><span class=\"line\">Leebury</span><br><span class=\"line\">Kaylatown</span><br><span class=\"line\">Hamiltonfort</span><br><span class=\"line\">Lake Christopher</span><br><span class=\"line\">Hannahstad</span><br><span class=\"line\">West Adamborough</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机的-Pandas-Dataframe\"><a href=\"#生成随机的-Pandas-Dataframe\" class=\"headerlink\" title=\"生成随机的 Pandas Dataframe\"></a>生成随机的 Pandas Dataframe</h3><p>你可以指定生成数据的数量和种类，但需要注意的是，返回结果均为字符串或文本类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdf=myDB.gen_dataframe(5,[&apos;name&apos;,&apos;city&apos;,&apos;phone&apos;,&apos;date&apos;])</span><br><span class=\"line\">testdf</span><br></pre></td></tr></table></figure>\n<p>最终产生的 Dataframe 类似下图所示。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_pandas-dataframe.png\" alt=\"\"></p>\n<h3 id=\"生成数据库表\"><a href=\"#生成数据库表\" class=\"headerlink\" title=\"生成数据库表\"></a>生成数据库表</h3><p>你也可以指定生成数据的数量和种类，而返回结果是数据库中的文本或者变长字符串类型。在生成过程中，你可以指定对应的数据库文件名和表名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.gen_table(db_file=&apos;Testdb.DB&apos;,table_name=&apos;People&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">fields=[&apos;name&apos;,&apos;city&apos;,&apos;street_address&apos;,&apos;email&apos;])</span><br></pre></td></tr></table></figure>\n<p>上面的例子种生成了一个能被 MySQL 和 SQLite 支持的 <code>.db</code> 文件。下图则显示了这个文件中的数据表在 SQLite 可视化客户端中打开的画面。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_db-browser-for-sqlite.png\" alt=\"\"></p>\n<h3 id=\"生成-Excel-文件\"><a href=\"#生成-Excel-文件\" class=\"headerlink\" title=\"生成 Excel 文件\"></a>生成 Excel 文件</h3><p>和上面的其它示例类似，下面的代码可以生成一个具有随机数据的 Excel 文件。值得一提的是，通过将 <code>phone_simple</code> 参数设为 <code>False</code> ，可以生成较长较复杂的电话号码。如果你想要提高自己在数据提取方面的能力，不妨尝试一下这个功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myDB.gen_excel(num=20,fields=[&apos;name&apos;,&apos;phone&apos;,&apos;time&apos;,&apos;country&apos;],</span><br><span class=\"line\">phone_simple=False,filename=&apos;TestExcel.xlsx&apos;)</span><br></pre></td></tr></table></figure>\n<p>最终的结果类似下图所示：</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pydbgen_excel.png\" alt=\"\"></p>\n<h3 id=\"生成随机电子邮箱地址\"><a href=\"#生成随机电子邮箱地址\" class=\"headerlink\" title=\"生成随机电子邮箱地址\"></a>生成随机电子邮箱地址</h3><p><code>pydbgen</code> 内置了一个 <code>realistic_email</code> 方法，它基于种子来生成随机的电子邮箱地址。如果你不想在网络上使用真实的电子邮箱地址时，这个功能可以派上用场。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in range(10):</span><br><span class=\"line\">    print(myDB.realistic_email(&apos;Tirtha Sarkar&apos;))</span><br><span class=\"line\">&gt;&gt;</span><br><span class=\"line\">Tirtha_Sarkar@gmail.com</span><br><span class=\"line\">Sarkar.Tirtha@outlook.com</span><br><span class=\"line\">Tirtha_S48@verizon.com</span><br><span class=\"line\">Tirtha_Sarkar62@yahoo.com</span><br><span class=\"line\">Tirtha.S46@yandex.com</span><br><span class=\"line\">Tirtha.S@att.com</span><br><span class=\"line\">Sarkar.Tirtha60@gmail.com</span><br><span class=\"line\">TirthaSarkar@zoho.com</span><br><span class=\"line\">Sarkar.Tirtha@protonmail.com</span><br><span class=\"line\">Tirtha.S@comcast.net</span><br></pre></td></tr></table></figure>\n<h3 id=\"未来的改进和用户贡献\"><a href=\"#未来的改进和用户贡献\" class=\"headerlink\" title=\"未来的改进和用户贡献\"></a>未来的改进和用户贡献</h3><p>目前的版本中并不完美。如果你发现了 pydbgen 的 bug 导致它在运行期间发生崩溃，请向我反馈。如果你打算对这个项目贡献代码，<a href=\"https://github.com/tirthajyoti/pydbgen\" target=\"_blank\" rel=\"noopener\">也随时欢迎你</a>。当然现在也还有很多改进的方向：</p>\n<ul>\n<li>pydbgen 作为随机数据生成器，可以集成一些机器学习或统计建模的功能吗？</li>\n<li>pydbgen 是否会添加可视化功能？</li>\n</ul>\n<p>一切皆有可能！</p>\n<p>如果你有任何问题或想法想要分享，都可以通过 <a href=\"mailto:tirthajyoti@gmail.com\" target=\"_blank\" rel=\"noopener\">tirthajyoti@gmail.com</a> 与我联系。如果你像我一样对机器学习和数据科学感兴趣，也可以添加我的 <a href=\"https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/\" target=\"_blank\" rel=\"noopener\">LinkedIn</a> 或在 <a href=\"https://twitter.com/tirthajyotiS\" target=\"_blank\" rel=\"noopener\">Twitter</a> 上关注我。另外，还可以在我的 <a href=\"https://github.com/tirthajyoti?tab=repositories\" target=\"_blank\" rel=\"noopener\">GitHub</a> 上找到更多 Python、R 或 MATLAB 的有趣代码和机器学习资源。</p>\n<p>本文以 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">CC BY-SA 4.0</a> 许可在 <a href=\"https://towardsdatascience.com/introducing-pydbgen-a-random-dataframe-database-table-generator-b5c7bdc84be5\" target=\"_blank\" rel=\"noopener\">Towards Data Science</a> 首发。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/pydbgen-random-database-table-generator\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/pydbgen-random-database-table-generator</a></p>\n"},{"title":"让你提高效率的 Linux 技巧","date":"2018-09-29T03:45:11.000Z","_content":"\n> 想要在 Linux 命令行工作中提高效率，你需要使用一些技巧。\n\n![](https://images.idgesg.net/images/article/2018/09/boy-jumping-off-swing-100772498-large.jpg)\n\n巧妙的 Linux 命令行技巧能让你节省时间、避免出错，还能让你记住和复用各种复杂的命令，专注在需要做的事情本身，而不是你要怎么做。以下介绍一些好用的命令行技巧。\n\n### 命令编辑\n\n如果要对一个已输入的命令进行修改，可以使用 `^a`（`ctrl + a`）或 `^e`（`ctrl + e`）将光标快速移动到命令的开头或命令的末尾。\n\n还可以使用 `^` 字符实现对上一个命令的文本替换并重新执行命令，例如 `^before^after^` 相当于把上一个命令中的 `before` 替换为 `after` 然后重新执行一次。\n\n```\n$ eho hello world  <== 错误的命令\n\nCommand 'eho' not found, did you mean:\n\n command 'echo' from deb coreutils\n command 'who' from deb coreutils\n\nTry: sudo apt install <deb name>\n\n$ ^e^ec^        <== 替换\necho hello world\nhello world\n\n```\n\n### 使用远程机器的名称登录到机器上\n\n如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。例如使用 `server_name ='ssh -v -l username IP-address'` 这样的别名命令：\n\n```\n$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”\n```\n\n也可以通过在 `/etc/hosts` 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。\n\n执行 `alias` 命令可以列出机器上已有的别名。\n\n```\n$ alias\nalias butterfly='ssh -v -l jdoe 192.168.0.11'\nalias c='clear'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l='ls -CF'\nalias la='ls -A'\nalias list_repos='grep ^[^#] /etc/apt/sources.list /etc/apt/sources.list.d/*'\nalias ll='ls -alF'\nalias ls='ls --color=auto'\nalias show_dimensions='xdpyinfo | grep '\\''dimensions:'\\'''\n```\n\n只要将新的别名添加到 `~/.bashrc` 或类似的文件中，就可以让别名在每次登录后都能立即生效。\n\n### 冻结、解冻终端界面\n\n`^s`（`ctrl + s`）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。如果误输入了这个命令，可以使用 `^q`（`ctrl + q`）让终端重新响应。所以只需要记住 `^q` 这个组合键就可以了，毕竟这种情况并不多见。\n\n### 复用命令\n\nLinux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 `!` 然后接最近使用过的命令的开头字母；当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 `history` 显示命令历史，然后输入 `!` 后面再接命令历史记录中需要复用的命令旁边的数字。\n\n```\n!! <== 复用上一条命令\n!ec <== 复用上一条以 “ec” 开头的命令\n!76 <== 复用命令历史中的 76 号命令\n```\n\n### 查看日志文件并动态显示更新内容\n\n使用形如 `tail -f /var/log/syslog` 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。\n\n```\n$ tail -f /var/log/auth.log\nSep 17 09:41:01 fly CRON[8071]: pam_unix(cron:session): session closed for user smmsp\nSep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session opened for user root\nSep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session closed for user root\nSep 17 09:47:00 fly sshd[8124]: Accepted password for shs from 192.168.0.22 port 47792\nSep 17 09:47:00 fly sshd[8124]: pam_unix(sshd:session): session opened for user shs by\nSep 17 09:47:00 fly systemd-logind[776]: New session 215 of user shs.\nSep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session opened for user root\nSep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session closed for user root\n        <== 等待显示追加的内容\n```\n\n### 寻求帮助\n\n对于大多数 Linux 命令，都可以通过在输入命令后加上选项 `--help` 来获得这个命令的作用、用法以及它的一些相关信息。除了 `man` 命令之外， `--help` 选项可以让你在不使用所有扩展选项的情况下获取到所需要的内容。\n\n```\n$ mkdir --help\nUsage: mkdir [OPTION]... DIRECTORY...\nCreate the DIRECTORY(ies), if they do not already exist.\n\nMandatory arguments to long options are mandatory for short options too.\n -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask\n -p, --parents no error if existing, make parent directories as needed\n -v, --verbose print a message for each created directory\n -Z set SELinux security context of each created directory\n to the default type\n --context[=CTX] like -Z, or if CTX is specified then set the SELinux\n or SMACK security context to CTX\n --help display this help and exit\n --version output version information and exit\n\nGNU coreutils online help: <http://www.gnu.org/software/coreutils/>\nFull documentation at: <http://www.gnu.org/software/coreutils/mkdir>\nor available locally via: info '(coreutils) mkdir invocation'\n```\n\n### 谨慎删除文件\n\n如果要谨慎使用 `rm` 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，对于这种情况，你可能需要看看下一个技巧。\n\n```\n$ rm -i    <== 请求确认\n```\n\n### 关闭别名\n\n你可以使用 `unalias` 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。\n\n```\n$ unalias rm\n```\n\n如果已经将 `rm -i` 默认设置为 `rm` 的别名，但你希望在删除文件之前不必进行确认，则可以将 `unalias` 命令放在一个启动文件（例如 `~/.bashrc`）中。\n\n### 使用 sudo\n\n如果你经常在只有 root 用户才能执行的命令前忘记使用 `sudo`，这里有两个方法可以解决。一是利用命令历史记录，可以使用 `sudo !!`（使用 `!!` 来运行最近的命令，并在前面添加 `sudo`）来重复执行，二是设置一些附加了所需 `sudo` 的命令别名。\n\n```\n$ alias update=’sudo apt update’\n```\n\n### 更复杂的技巧\n\n有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。但如果需要比别名更复杂功能，可以通过编写脚本、向 `.bashrc` 或其他启动文件添加函数来实现。例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 `source .bashrc`，就可以使用 `md temp` 这样的命令来创建目录立即进入这个目录下。\n\n```\nmd () { mkdir -p \"$@\" && cd \"$1\"; }\n```\n\n### 总结\n\n使用 Linux 命令行是在 Linux 系统上工作最有效也最有趣的方法，但配合命令行技巧和巧妙的别名可以让你获得更好的体验。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html\n\n[a]: https://www.networkworld.com/author/Sandra-Henry_Stocker/\n[1]: https://www.facebook.com/NetworkWorld/\n[2]: https://www.linkedin.com/company/network-world\n\n","source":"_posts/Linux-tricks-that-can-save-you-time-and-trouble.md","raw":"---\ntitle: 让你提高效率的 Linux 技巧\ndate: 2018-09-29 11:45:11\ntags:\n  - Linux\n  - LCTT 翻译\n---\n\n> 想要在 Linux 命令行工作中提高效率，你需要使用一些技巧。\n\n![](https://images.idgesg.net/images/article/2018/09/boy-jumping-off-swing-100772498-large.jpg)\n\n巧妙的 Linux 命令行技巧能让你节省时间、避免出错，还能让你记住和复用各种复杂的命令，专注在需要做的事情本身，而不是你要怎么做。以下介绍一些好用的命令行技巧。\n\n### 命令编辑\n\n如果要对一个已输入的命令进行修改，可以使用 `^a`（`ctrl + a`）或 `^e`（`ctrl + e`）将光标快速移动到命令的开头或命令的末尾。\n\n还可以使用 `^` 字符实现对上一个命令的文本替换并重新执行命令，例如 `^before^after^` 相当于把上一个命令中的 `before` 替换为 `after` 然后重新执行一次。\n\n```\n$ eho hello world  <== 错误的命令\n\nCommand 'eho' not found, did you mean:\n\n command 'echo' from deb coreutils\n command 'who' from deb coreutils\n\nTry: sudo apt install <deb name>\n\n$ ^e^ec^        <== 替换\necho hello world\nhello world\n\n```\n\n### 使用远程机器的名称登录到机器上\n\n如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。例如使用 `server_name ='ssh -v -l username IP-address'` 这样的别名命令：\n\n```\n$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”\n```\n\n也可以通过在 `/etc/hosts` 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。\n\n执行 `alias` 命令可以列出机器上已有的别名。\n\n```\n$ alias\nalias butterfly='ssh -v -l jdoe 192.168.0.11'\nalias c='clear'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l='ls -CF'\nalias la='ls -A'\nalias list_repos='grep ^[^#] /etc/apt/sources.list /etc/apt/sources.list.d/*'\nalias ll='ls -alF'\nalias ls='ls --color=auto'\nalias show_dimensions='xdpyinfo | grep '\\''dimensions:'\\'''\n```\n\n只要将新的别名添加到 `~/.bashrc` 或类似的文件中，就可以让别名在每次登录后都能立即生效。\n\n### 冻结、解冻终端界面\n\n`^s`（`ctrl + s`）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。如果误输入了这个命令，可以使用 `^q`（`ctrl + q`）让终端重新响应。所以只需要记住 `^q` 这个组合键就可以了，毕竟这种情况并不多见。\n\n### 复用命令\n\nLinux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 `!` 然后接最近使用过的命令的开头字母；当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 `history` 显示命令历史，然后输入 `!` 后面再接命令历史记录中需要复用的命令旁边的数字。\n\n```\n!! <== 复用上一条命令\n!ec <== 复用上一条以 “ec” 开头的命令\n!76 <== 复用命令历史中的 76 号命令\n```\n\n### 查看日志文件并动态显示更新内容\n\n使用形如 `tail -f /var/log/syslog` 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。\n\n```\n$ tail -f /var/log/auth.log\nSep 17 09:41:01 fly CRON[8071]: pam_unix(cron:session): session closed for user smmsp\nSep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session opened for user root\nSep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session closed for user root\nSep 17 09:47:00 fly sshd[8124]: Accepted password for shs from 192.168.0.22 port 47792\nSep 17 09:47:00 fly sshd[8124]: pam_unix(sshd:session): session opened for user shs by\nSep 17 09:47:00 fly systemd-logind[776]: New session 215 of user shs.\nSep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session opened for user root\nSep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session closed for user root\n        <== 等待显示追加的内容\n```\n\n### 寻求帮助\n\n对于大多数 Linux 命令，都可以通过在输入命令后加上选项 `--help` 来获得这个命令的作用、用法以及它的一些相关信息。除了 `man` 命令之外， `--help` 选项可以让你在不使用所有扩展选项的情况下获取到所需要的内容。\n\n```\n$ mkdir --help\nUsage: mkdir [OPTION]... DIRECTORY...\nCreate the DIRECTORY(ies), if they do not already exist.\n\nMandatory arguments to long options are mandatory for short options too.\n -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask\n -p, --parents no error if existing, make parent directories as needed\n -v, --verbose print a message for each created directory\n -Z set SELinux security context of each created directory\n to the default type\n --context[=CTX] like -Z, or if CTX is specified then set the SELinux\n or SMACK security context to CTX\n --help display this help and exit\n --version output version information and exit\n\nGNU coreutils online help: <http://www.gnu.org/software/coreutils/>\nFull documentation at: <http://www.gnu.org/software/coreutils/mkdir>\nor available locally via: info '(coreutils) mkdir invocation'\n```\n\n### 谨慎删除文件\n\n如果要谨慎使用 `rm` 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，对于这种情况，你可能需要看看下一个技巧。\n\n```\n$ rm -i    <== 请求确认\n```\n\n### 关闭别名\n\n你可以使用 `unalias` 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。\n\n```\n$ unalias rm\n```\n\n如果已经将 `rm -i` 默认设置为 `rm` 的别名，但你希望在删除文件之前不必进行确认，则可以将 `unalias` 命令放在一个启动文件（例如 `~/.bashrc`）中。\n\n### 使用 sudo\n\n如果你经常在只有 root 用户才能执行的命令前忘记使用 `sudo`，这里有两个方法可以解决。一是利用命令历史记录，可以使用 `sudo !!`（使用 `!!` 来运行最近的命令，并在前面添加 `sudo`）来重复执行，二是设置一些附加了所需 `sudo` 的命令别名。\n\n```\n$ alias update=’sudo apt update’\n```\n\n### 更复杂的技巧\n\n有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。但如果需要比别名更复杂功能，可以通过编写脚本、向 `.bashrc` 或其他启动文件添加函数来实现。例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 `source .bashrc`，就可以使用 `md temp` 这样的命令来创建目录立即进入这个目录下。\n\n```\nmd () { mkdir -p \"$@\" && cd \"$1\"; }\n```\n\n### 总结\n\n使用 Linux 命令行是在 Linux 系统上工作最有效也最有趣的方法，但配合命令行技巧和巧妙的别名可以让你获得更好的体验。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html\n\n[a]: https://www.networkworld.com/author/Sandra-Henry_Stocker/\n[1]: https://www.facebook.com/NetworkWorld/\n[2]: https://www.linkedin.com/company/network-world\n\n","slug":"Linux-tricks-that-can-save-you-time-and-trouble","published":1,"updated":"2019-03-28T05:57:33.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0cz001elixurg4circ6","content":"<blockquote>\n<p>想要在 Linux 命令行工作中提高效率，你需要使用一些技巧。</p>\n</blockquote>\n<p><img src=\"https://images.idgesg.net/images/article/2018/09/boy-jumping-off-swing-100772498-large.jpg\" alt=\"\"></p>\n<p>巧妙的 Linux 命令行技巧能让你节省时间、避免出错，还能让你记住和复用各种复杂的命令，专注在需要做的事情本身，而不是你要怎么做。以下介绍一些好用的命令行技巧。</p>\n<h3 id=\"命令编辑\"><a href=\"#命令编辑\" class=\"headerlink\" title=\"命令编辑\"></a>命令编辑</h3><p>如果要对一个已输入的命令进行修改，可以使用 <code>^a</code>（<code>ctrl + a</code>）或 <code>^e</code>（<code>ctrl + e</code>）将光标快速移动到命令的开头或命令的末尾。</p>\n<p>还可以使用 <code>^</code> 字符实现对上一个命令的文本替换并重新执行命令，例如 <code>^before^after^</code> 相当于把上一个命令中的 <code>before</code> 替换为 <code>after</code> 然后重新执行一次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ eho hello world  &lt;== 错误的命令</span><br><span class=\"line\"></span><br><span class=\"line\">Command &apos;eho&apos; not found, did you mean:</span><br><span class=\"line\"></span><br><span class=\"line\"> command &apos;echo&apos; from deb coreutils</span><br><span class=\"line\"> command &apos;who&apos; from deb coreutils</span><br><span class=\"line\"></span><br><span class=\"line\">Try: sudo apt install &lt;deb name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$ ^e^ec^        &lt;== 替换</span><br><span class=\"line\">echo hello world</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用远程机器的名称登录到机器上\"><a href=\"#使用远程机器的名称登录到机器上\" class=\"headerlink\" title=\"使用远程机器的名称登录到机器上\"></a>使用远程机器的名称登录到机器上</h3><p>如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。例如使用 <code>server_name =&#39;ssh -v -l username IP-address&#39;</code> 这样的别名命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”</span><br></pre></td></tr></table></figure>\n<p>也可以通过在 <code>/etc/hosts</code> 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。</p>\n<p>执行 <code>alias</code> 命令可以列出机器上已有的别名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias</span><br><span class=\"line\">alias butterfly=&apos;ssh -v -l jdoe 192.168.0.11&apos;</span><br><span class=\"line\">alias c=&apos;clear&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l=&apos;ls -CF&apos;</span><br><span class=\"line\">alias la=&apos;ls -A&apos;</span><br><span class=\"line\">alias list_repos=&apos;grep ^[^#] /etc/apt/sources.list /etc/apt/sources.list.d/*&apos;</span><br><span class=\"line\">alias ll=&apos;ls -alF&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias show_dimensions=&apos;xdpyinfo | grep &apos;\\&apos;&apos;dimensions:&apos;\\&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>\n<p>只要将新的别名添加到 <code>~/.bashrc</code> 或类似的文件中，就可以让别名在每次登录后都能立即生效。</p>\n<h3 id=\"冻结、解冻终端界面\"><a href=\"#冻结、解冻终端界面\" class=\"headerlink\" title=\"冻结、解冻终端界面\"></a>冻结、解冻终端界面</h3><p><code>^s</code>（<code>ctrl + s</code>）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。如果误输入了这个命令，可以使用 <code>^q</code>（<code>ctrl + q</code>）让终端重新响应。所以只需要记住 <code>^q</code> 这个组合键就可以了，毕竟这种情况并不多见。</p>\n<h3 id=\"复用命令\"><a href=\"#复用命令\" class=\"headerlink\" title=\"复用命令\"></a>复用命令</h3><p>Linux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 <code>!</code> 然后接最近使用过的命令的开头字母；当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 <code>history</code> 显示命令历史，然后输入 <code>!</code> 后面再接命令历史记录中需要复用的命令旁边的数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!! &lt;== 复用上一条命令</span><br><span class=\"line\">!ec &lt;== 复用上一条以 “ec” 开头的命令</span><br><span class=\"line\">!76 &lt;== 复用命令历史中的 76 号命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看日志文件并动态显示更新内容\"><a href=\"#查看日志文件并动态显示更新内容\" class=\"headerlink\" title=\"查看日志文件并动态显示更新内容\"></a>查看日志文件并动态显示更新内容</h3><p>使用形如 <code>tail -f /var/log/syslog</code> 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tail -f /var/log/auth.log</span><br><span class=\"line\">Sep 17 09:41:01 fly CRON[8071]: pam_unix(cron:session): session closed for user smmsp</span><br><span class=\"line\">Sep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session opened for user root</span><br><span class=\"line\">Sep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session closed for user root</span><br><span class=\"line\">Sep 17 09:47:00 fly sshd[8124]: Accepted password for shs from 192.168.0.22 port 47792</span><br><span class=\"line\">Sep 17 09:47:00 fly sshd[8124]: pam_unix(sshd:session): session opened for user shs by</span><br><span class=\"line\">Sep 17 09:47:00 fly systemd-logind[776]: New session 215 of user shs.</span><br><span class=\"line\">Sep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session opened for user root</span><br><span class=\"line\">Sep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session closed for user root</span><br><span class=\"line\">        &lt;== 等待显示追加的内容</span><br></pre></td></tr></table></figure>\n<h3 id=\"寻求帮助\"><a href=\"#寻求帮助\" class=\"headerlink\" title=\"寻求帮助\"></a>寻求帮助</h3><p>对于大多数 Linux 命令，都可以通过在输入命令后加上选项 <code>--help</code> 来获得这个命令的作用、用法以及它的一些相关信息。除了 <code>man</code> 命令之外， <code>--help</code> 选项可以让你在不使用所有扩展选项的情况下获取到所需要的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir --help</span><br><span class=\"line\">Usage: mkdir [OPTION]... DIRECTORY...</span><br><span class=\"line\">Create the DIRECTORY(ies), if they do not already exist.</span><br><span class=\"line\"></span><br><span class=\"line\">Mandatory arguments to long options are mandatory for short options too.</span><br><span class=\"line\"> -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask</span><br><span class=\"line\"> -p, --parents no error if existing, make parent directories as needed</span><br><span class=\"line\"> -v, --verbose print a message for each created directory</span><br><span class=\"line\"> -Z set SELinux security context of each created directory</span><br><span class=\"line\"> to the default type</span><br><span class=\"line\"> --context[=CTX] like -Z, or if CTX is specified then set the SELinux</span><br><span class=\"line\"> or SMACK security context to CTX</span><br><span class=\"line\"> --help display this help and exit</span><br><span class=\"line\"> --version output version information and exit</span><br><span class=\"line\"></span><br><span class=\"line\">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class=\"line\">Full documentation at: &lt;http://www.gnu.org/software/coreutils/mkdir&gt;</span><br><span class=\"line\">or available locally via: info &apos;(coreutils) mkdir invocation&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谨慎删除文件\"><a href=\"#谨慎删除文件\" class=\"headerlink\" title=\"谨慎删除文件\"></a>谨慎删除文件</h3><p>如果要谨慎使用 <code>rm</code> 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，对于这种情况，你可能需要看看下一个技巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -i    &lt;== 请求确认</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭别名\"><a href=\"#关闭别名\" class=\"headerlink\" title=\"关闭别名\"></a>关闭别名</h3><p>你可以使用 <code>unalias</code> 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unalias rm</span><br></pre></td></tr></table></figure>\n<p>如果已经将 <code>rm -i</code> 默认设置为 <code>rm</code> 的别名，但你希望在删除文件之前不必进行确认，则可以将 <code>unalias</code> 命令放在一个启动文件（例如 <code>~/.bashrc</code>）中。</p>\n<h3 id=\"使用-sudo\"><a href=\"#使用-sudo\" class=\"headerlink\" title=\"使用 sudo\"></a>使用 sudo</h3><p>如果你经常在只有 root 用户才能执行的命令前忘记使用 <code>sudo</code>，这里有两个方法可以解决。一是利用命令历史记录，可以使用 <code>sudo !!</code>（使用 <code>!!</code> 来运行最近的命令，并在前面添加 <code>sudo</code>）来重复执行，二是设置一些附加了所需 <code>sudo</code> 的命令别名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias update=’sudo apt update’</span><br></pre></td></tr></table></figure>\n<h3 id=\"更复杂的技巧\"><a href=\"#更复杂的技巧\" class=\"headerlink\" title=\"更复杂的技巧\"></a>更复杂的技巧</h3><p>有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。但如果需要比别名更复杂功能，可以通过编写脚本、向 <code>.bashrc</code> 或其他启动文件添加函数来实现。例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 <code>source .bashrc</code>，就可以使用 <code>md temp</code> 这样的命令来创建目录立即进入这个目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md () &#123; mkdir -p &quot;$@&quot; &amp;&amp; cd &quot;$1&quot;; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用 Linux 命令行是在 Linux 系统上工作最有效也最有趣的方法，但配合命令行技巧和巧妙的别名可以让你获得更好的体验。</p>\n<hr>\n<p>via: <a href=\"https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html\" target=\"_blank\" rel=\"noopener\">https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>想要在 Linux 命令行工作中提高效率，你需要使用一些技巧。</p>\n</blockquote>\n<p><img src=\"https://images.idgesg.net/images/article/2018/09/boy-jumping-off-swing-100772498-large.jpg\" alt=\"\"></p>\n<p>巧妙的 Linux 命令行技巧能让你节省时间、避免出错，还能让你记住和复用各种复杂的命令，专注在需要做的事情本身，而不是你要怎么做。以下介绍一些好用的命令行技巧。</p>\n<h3 id=\"命令编辑\"><a href=\"#命令编辑\" class=\"headerlink\" title=\"命令编辑\"></a>命令编辑</h3><p>如果要对一个已输入的命令进行修改，可以使用 <code>^a</code>（<code>ctrl + a</code>）或 <code>^e</code>（<code>ctrl + e</code>）将光标快速移动到命令的开头或命令的末尾。</p>\n<p>还可以使用 <code>^</code> 字符实现对上一个命令的文本替换并重新执行命令，例如 <code>^before^after^</code> 相当于把上一个命令中的 <code>before</code> 替换为 <code>after</code> 然后重新执行一次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ eho hello world  &lt;== 错误的命令</span><br><span class=\"line\"></span><br><span class=\"line\">Command &apos;eho&apos; not found, did you mean:</span><br><span class=\"line\"></span><br><span class=\"line\"> command &apos;echo&apos; from deb coreutils</span><br><span class=\"line\"> command &apos;who&apos; from deb coreutils</span><br><span class=\"line\"></span><br><span class=\"line\">Try: sudo apt install &lt;deb name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">$ ^e^ec^        &lt;== 替换</span><br><span class=\"line\">echo hello world</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用远程机器的名称登录到机器上\"><a href=\"#使用远程机器的名称登录到机器上\" class=\"headerlink\" title=\"使用远程机器的名称登录到机器上\"></a>使用远程机器的名称登录到机器上</h3><p>如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。例如使用 <code>server_name =&#39;ssh -v -l username IP-address&#39;</code> 这样的别名命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”</span><br></pre></td></tr></table></figure>\n<p>也可以通过在 <code>/etc/hosts</code> 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。</p>\n<p>执行 <code>alias</code> 命令可以列出机器上已有的别名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias</span><br><span class=\"line\">alias butterfly=&apos;ssh -v -l jdoe 192.168.0.11&apos;</span><br><span class=\"line\">alias c=&apos;clear&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l=&apos;ls -CF&apos;</span><br><span class=\"line\">alias la=&apos;ls -A&apos;</span><br><span class=\"line\">alias list_repos=&apos;grep ^[^#] /etc/apt/sources.list /etc/apt/sources.list.d/*&apos;</span><br><span class=\"line\">alias ll=&apos;ls -alF&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias show_dimensions=&apos;xdpyinfo | grep &apos;\\&apos;&apos;dimensions:&apos;\\&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>\n<p>只要将新的别名添加到 <code>~/.bashrc</code> 或类似的文件中，就可以让别名在每次登录后都能立即生效。</p>\n<h3 id=\"冻结、解冻终端界面\"><a href=\"#冻结、解冻终端界面\" class=\"headerlink\" title=\"冻结、解冻终端界面\"></a>冻结、解冻终端界面</h3><p><code>^s</code>（<code>ctrl + s</code>）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。如果误输入了这个命令，可以使用 <code>^q</code>（<code>ctrl + q</code>）让终端重新响应。所以只需要记住 <code>^q</code> 这个组合键就可以了，毕竟这种情况并不多见。</p>\n<h3 id=\"复用命令\"><a href=\"#复用命令\" class=\"headerlink\" title=\"复用命令\"></a>复用命令</h3><p>Linux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 <code>!</code> 然后接最近使用过的命令的开头字母；当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 <code>history</code> 显示命令历史，然后输入 <code>!</code> 后面再接命令历史记录中需要复用的命令旁边的数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!! &lt;== 复用上一条命令</span><br><span class=\"line\">!ec &lt;== 复用上一条以 “ec” 开头的命令</span><br><span class=\"line\">!76 &lt;== 复用命令历史中的 76 号命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看日志文件并动态显示更新内容\"><a href=\"#查看日志文件并动态显示更新内容\" class=\"headerlink\" title=\"查看日志文件并动态显示更新内容\"></a>查看日志文件并动态显示更新内容</h3><p>使用形如 <code>tail -f /var/log/syslog</code> 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tail -f /var/log/auth.log</span><br><span class=\"line\">Sep 17 09:41:01 fly CRON[8071]: pam_unix(cron:session): session closed for user smmsp</span><br><span class=\"line\">Sep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session opened for user root</span><br><span class=\"line\">Sep 17 09:45:01 fly CRON[8115]: pam_unix(cron:session): session closed for user root</span><br><span class=\"line\">Sep 17 09:47:00 fly sshd[8124]: Accepted password for shs from 192.168.0.22 port 47792</span><br><span class=\"line\">Sep 17 09:47:00 fly sshd[8124]: pam_unix(sshd:session): session opened for user shs by</span><br><span class=\"line\">Sep 17 09:47:00 fly systemd-logind[776]: New session 215 of user shs.</span><br><span class=\"line\">Sep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session opened for user root</span><br><span class=\"line\">Sep 17 09:55:01 fly CRON[8208]: pam_unix(cron:session): session closed for user root</span><br><span class=\"line\">        &lt;== 等待显示追加的内容</span><br></pre></td></tr></table></figure>\n<h3 id=\"寻求帮助\"><a href=\"#寻求帮助\" class=\"headerlink\" title=\"寻求帮助\"></a>寻求帮助</h3><p>对于大多数 Linux 命令，都可以通过在输入命令后加上选项 <code>--help</code> 来获得这个命令的作用、用法以及它的一些相关信息。除了 <code>man</code> 命令之外， <code>--help</code> 选项可以让你在不使用所有扩展选项的情况下获取到所需要的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir --help</span><br><span class=\"line\">Usage: mkdir [OPTION]... DIRECTORY...</span><br><span class=\"line\">Create the DIRECTORY(ies), if they do not already exist.</span><br><span class=\"line\"></span><br><span class=\"line\">Mandatory arguments to long options are mandatory for short options too.</span><br><span class=\"line\"> -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask</span><br><span class=\"line\"> -p, --parents no error if existing, make parent directories as needed</span><br><span class=\"line\"> -v, --verbose print a message for each created directory</span><br><span class=\"line\"> -Z set SELinux security context of each created directory</span><br><span class=\"line\"> to the default type</span><br><span class=\"line\"> --context[=CTX] like -Z, or if CTX is specified then set the SELinux</span><br><span class=\"line\"> or SMACK security context to CTX</span><br><span class=\"line\"> --help display this help and exit</span><br><span class=\"line\"> --version output version information and exit</span><br><span class=\"line\"></span><br><span class=\"line\">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class=\"line\">Full documentation at: &lt;http://www.gnu.org/software/coreutils/mkdir&gt;</span><br><span class=\"line\">or available locally via: info &apos;(coreutils) mkdir invocation&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谨慎删除文件\"><a href=\"#谨慎删除文件\" class=\"headerlink\" title=\"谨慎删除文件\"></a>谨慎删除文件</h3><p>如果要谨慎使用 <code>rm</code> 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，对于这种情况，你可能需要看看下一个技巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -i    &lt;== 请求确认</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭别名\"><a href=\"#关闭别名\" class=\"headerlink\" title=\"关闭别名\"></a>关闭别名</h3><p>你可以使用 <code>unalias</code> 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unalias rm</span><br></pre></td></tr></table></figure>\n<p>如果已经将 <code>rm -i</code> 默认设置为 <code>rm</code> 的别名，但你希望在删除文件之前不必进行确认，则可以将 <code>unalias</code> 命令放在一个启动文件（例如 <code>~/.bashrc</code>）中。</p>\n<h3 id=\"使用-sudo\"><a href=\"#使用-sudo\" class=\"headerlink\" title=\"使用 sudo\"></a>使用 sudo</h3><p>如果你经常在只有 root 用户才能执行的命令前忘记使用 <code>sudo</code>，这里有两个方法可以解决。一是利用命令历史记录，可以使用 <code>sudo !!</code>（使用 <code>!!</code> 来运行最近的命令，并在前面添加 <code>sudo</code>）来重复执行，二是设置一些附加了所需 <code>sudo</code> 的命令别名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias update=’sudo apt update’</span><br></pre></td></tr></table></figure>\n<h3 id=\"更复杂的技巧\"><a href=\"#更复杂的技巧\" class=\"headerlink\" title=\"更复杂的技巧\"></a>更复杂的技巧</h3><p>有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。但如果需要比别名更复杂功能，可以通过编写脚本、向 <code>.bashrc</code> 或其他启动文件添加函数来实现。例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 <code>source .bashrc</code>，就可以使用 <code>md temp</code> 这样的命令来创建目录立即进入这个目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md () &#123; mkdir -p &quot;$@&quot; &amp;&amp; cd &quot;$1&quot;; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用 Linux 命令行是在 Linux 系统上工作最有效也最有趣的方法，但配合命令行技巧和巧妙的别名可以让你获得更好的体验。</p>\n<hr>\n<p>via: <a href=\"https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html\" target=\"_blank\" rel=\"noopener\">https://www.networkworld.com/article/3305811/linux/linux-tricks-that-even-you-can-love.html</a></p>\n"},{"title":"Python 机器学习的必备技巧","date":"2018-11-08T01:57:16.000Z","_content":"\n> 尝试使用 Python 掌握机器学习、人工智能和深度学习。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming-code-keyboard-laptop.png?itok=pGfEfu2S)\n\n想要入门机器学习并不难。除了<ruby>大规模网络公开课<rt>Massive Open Online Courses</rt></ruby>（MOOC）之外，还有很多其它优秀的免费资源。下面我分享一些我觉得比较有用的方法。\n\n1. 从一些 YouTube 上的好视频开始，阅览一些关于这方面的文章或者书籍，例如 《[主算法：终极学习机器的探索将如何重塑我们的世界][29]》，而且我觉得你肯定会喜欢这些[关于机器学习的很酷的互动页面][30]。\n2. 对于“<ruby>机器学习<rt>machine learning</rt></ruby>”、“<ruby>人工智能<rt>artificial intelligence</rt></ruby>”、“<ruby>深度学习<rt>deep learning</rt></ruby>”、“<ruby>数据科学<rt>data science</rt></ruby>”、“<ruby>计算机视觉<rt>computer vision</rt></ruby>”和“<ruby>机器人技术<rt>robotics</rt></ruby>”这一堆新名词，你需要知道它们之间的区别。你可以阅览或聆听这些领域的专家们的演讲，例如这位有影响力的[数据科学家 Brandon Rohrer 的精彩视频][1]。或者这个讲述了数据科学相关的[各种角色之间的区别][2]的视频。\n3. 明确你自己的学习目标，并选择合适的 [Coursera 课程][3]，或者参加高校的网络公开课，例如[华盛顿大学的课程][4]就很不错。\n4. 关注优秀的博客：例如 [KDnuggets][32] 的博客、[Mark Meloon][33] 的博客、[Brandon Rohrer][34] 的博客、[Open AI][35] 的研究博客，这些都值得推荐。\n5. 如果你热衷于在线课程，后文中会有如何[正确选择 MOOC 课程][31]的指导。\n6. 最重要的是，培养自己对这些技术的兴趣。加入一些优秀的社交论坛，不要被那些耸人听闻的头条和新闻所吸引，专注于阅读和了解，将这些技术的背景知识和发展方向理解透彻，并积极思考在日常生活和工作中如何应用机器学习或数据科学的原理。例如建立一个简单的回归模型来预测下一次午餐的成本，又或者是从电力公司的网站上下载历史电费数据，在 Excel 中进行简单的时序分析以发现某种规律。在你对这些技术产生了浓厚兴趣之后，可以观看以下这个视频。\n\n<https://www.youtube.com/embed/IpGxLWOIZy4>\n\n### Python 是机器学习和人工智能方面的最佳语言吗？\n\n除非你是一名专业的研究一些复杂算法纯理论证明的研究人员，否则，对于一个机器学习的入门者来说，需要熟悉至少一种高级编程语言。因为大多数情况下都是需要考虑如何将现有的机器学习算法应用于解决实际问题，而这需要有一定的编程能力作为基础。\n\n哪一种语言是数据科学的最佳语言？这个讨论一直没有停息过。对于这方面，你可以提起精神来看一下 FreeCodeCamp 上这一篇关于[数据科学语言][6]的文章，又或者是 KDnuggets 关于 [Python 和 R 之争][7]的深入探讨。\n\n目前人们普遍认为 Python 在开发、部署、维护各方面的效率都是比较高的。与 Java、C 和 C++ 这些较为传统的语言相比，Python 的语法更为简单和高级。而且 Python 拥有活跃的社区群体、广泛的开源文化、数百个专用于机器学习的优质代码库，以及来自业界巨头（包括 Google、Dropbox、Airbnb 等）的强大技术支持。\n\n### 基础 Python 库\n\n如果你打算使用 Python 实施机器学习，你必须掌握一些 Python 包和库的使用方法。\n\n#### NumPy\n\nNumPy 的完整名称是 [Numerical Python][8]，它是 Python 生态里高性能科学计算和数据分析都需要用到的基础包，几乎所有高级工具（例如 [Pandas][9] 和 [scikit-learn][10]）都依赖于它。[TensorFlow][11] 使用了 NumPy 数组作为基础构建块以支持 Tensor 对象和深度学习的图形流。很多 NumPy 操作的速度都非常快，因为它们都是通过 C 实现的。高性能对于数据科学和现代机器学习来说是一个非常宝贵的优势。\n\n![](https://opensource.com/sites/default/files/uploads/machine-learning-python_numpy-cheat-sheet.jpeg)\n\n#### Pandas\n\nPandas 是 Python 生态中用于进行通用数据分析的最受欢迎的库。Pandas 基于 NumPy 数组构建，在保证了可观的执行速度的同时，还提供了许多数据工程方面的功能，包括：\n\n  * 对多种不同数据格式的读写操作\n  * 选择数据子集\n  * 跨行列计算\n  * 查找并补充缺失的数据\n  * 将操作应用于数据中的独立分组\n  * 按照多种格式转换数据\n  * 组合多个数据集\n  * 高级时间序列功能\n  * 通过 Matplotlib 和 Seaborn 进行可视化\n\n![](https://opensource.com/sites/default/files/uploads/pandas_cheat_sheet_github.png)\n\n#### Matplotlib 和 Seaborn\n\n数据可视化和数据分析是数据科学家的必备技能，毕竟仅凭一堆枯燥的数据是无法有效地将背后蕴含的信息向受众传达的。这两项技能对于机器学习来说同样重要，因为首先要对数据集进行一个探索性分析，才能更准确地选择合适的机器学习算法。\n\n[Matplotlib][12] 是应用最广泛的 2D Python 可视化库。它包含海量的命令和接口，可以让你根据数据生成高质量的图表。要学习使用 Matplotlib，可以参考这篇详尽的[文章][13]。\n\n![](https://opensource.com/sites/default/files/uploads/matplotlib_gallery_-1.png)\n\n[Seaborn][14] 也是一个强大的用于统计和绘图的可视化库。它在 Matplotlib 的基础上提供样式灵活的 API、用于统计和绘图的常见高级函数，还可以和 Pandas 提供的功能相结合。要学习使用 Seaborn，可以参考这篇优秀的[教程][15]。\n\n![](https://opensource.com/sites/default/files/uploads/machine-learning-python_seaborn.png)\n\n#### Scikit-learn\n\nScikit-learn 是机器学习方面通用的重要 Python 包。它实现了多种[分类][16]、[回归][17]和[聚类][18]算法，包括[支持向量机][19]、[随机森林][20]、[梯度增强][21]、[k-means 算法][22]和 [DBSCAN 算法][23]，可以与 Python 的数值库 NumPy 和科学计算库 [SciPy][24] 结合使用。它通过兼容的接口提供了有监督和无监督的学习算法。Scikit-learn 的强壮性让它可以稳定运行在生产环境中，同时它在易用性、代码质量、团队协作、文档和性能等各个方面都有良好的表现。可以参考[这篇基于 Scikit-learn 的机器学习入门][25]，或者[这篇基于 Scikit-learn 的简单机器学习用例演示][26]。\n\n本文使用 [CC BY-SA 4.0][28] 许可，在 [Heartbeat][27] 上首发。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks\n\n[a]: https://opensource.com/users/tirthajyoti\n[b]: https://github.com/lujun9972\n[1]: https://www.youtube.com/watch?v=tKa0zDDDaQk\n[2]: https://www.youtube.com/watch?v=Ura_ioOcpQI\n[3]: https://www.coursera.org/learn/machine-learning\n[4]: https://www.coursera.org/specializations/machine-learning\n[5]: https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\n[6]: https://medium.freecodecamp.org/which-languages-should-you-learn-for-data-science-e806ba55a81f\n[7]: https://www.kdnuggets.com/2017/09/python-vs-r-data-science-machine-learning.html\n[8]: http://numpy.org/\n[9]: https://pandas.pydata.org/\n[10]: http://scikit-learn.org/\n[11]: https://www.tensorflow.org/\n[12]: https://matplotlib.org/\n[13]: https://realpython.com/python-matplotlib-guide/\n[14]: https://seaborn.pydata.org/\n[15]: https://www.datacamp.com/community/tutorials/seaborn-python-tutorial\n[16]: https://en.wikipedia.org/wiki/Statistical_classification\n[17]: https://en.wikipedia.org/wiki/Regression_analysis\n[18]: https://en.wikipedia.org/wiki/Cluster_analysis\n[19]: https://en.wikipedia.org/wiki/Support_vector_machine\n[20]: https://en.wikipedia.org/wiki/Random_forests\n[21]: https://en.wikipedia.org/wiki/Gradient_boosting\n[22]: https://en.wikipedia.org/wiki/K-means_clustering\n[23]: https://en.wikipedia.org/wiki/DBSCAN\n[24]: https://en.wikipedia.org/wiki/SciPy\n[25]: http://scikit-learn.org/stable/tutorial/basic/tutorial.html\n[26]: https://towardsdatascience.com/machine-learning-with-python-easy-and-robust-method-to-fit-nonlinear-data-19e8a1ddbd49\n[27]: https://heartbeat.fritz.ai/some-essential-hacks-and-tricks-for-machine-learning-with-python-5478bc6593f2\n[28]: https://creativecommons.org/licenses/by-sa/4.0/\n[29]: https://www.goodreads.com/book/show/24612233-the-master-algorithm\n[30]: http://www.r2d3.us/visual-intro-to-machine-learning-part-1/\n[31]: https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\n[32]: https://www.kdnuggets.com/\n[33]: http://www.markmeloon.com/\n[34]: https://brohrer.github.io/blog.html\n[35]: https://blog.openai.com/\n\n","source":"_posts/Machine-learning-with-Python-Essential-hacks-and-tricks.md","raw":"---\ntitle: Python 机器学习的必备技巧\ndate: 2018-11-08 09:57:16\ntags:\n  - Python\n  - 机器学习\n  - LCTT 翻译\n---\n\n> 尝试使用 Python 掌握机器学习、人工智能和深度学习。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming-code-keyboard-laptop.png?itok=pGfEfu2S)\n\n想要入门机器学习并不难。除了<ruby>大规模网络公开课<rt>Massive Open Online Courses</rt></ruby>（MOOC）之外，还有很多其它优秀的免费资源。下面我分享一些我觉得比较有用的方法。\n\n1. 从一些 YouTube 上的好视频开始，阅览一些关于这方面的文章或者书籍，例如 《[主算法：终极学习机器的探索将如何重塑我们的世界][29]》，而且我觉得你肯定会喜欢这些[关于机器学习的很酷的互动页面][30]。\n2. 对于“<ruby>机器学习<rt>machine learning</rt></ruby>”、“<ruby>人工智能<rt>artificial intelligence</rt></ruby>”、“<ruby>深度学习<rt>deep learning</rt></ruby>”、“<ruby>数据科学<rt>data science</rt></ruby>”、“<ruby>计算机视觉<rt>computer vision</rt></ruby>”和“<ruby>机器人技术<rt>robotics</rt></ruby>”这一堆新名词，你需要知道它们之间的区别。你可以阅览或聆听这些领域的专家们的演讲，例如这位有影响力的[数据科学家 Brandon Rohrer 的精彩视频][1]。或者这个讲述了数据科学相关的[各种角色之间的区别][2]的视频。\n3. 明确你自己的学习目标，并选择合适的 [Coursera 课程][3]，或者参加高校的网络公开课，例如[华盛顿大学的课程][4]就很不错。\n4. 关注优秀的博客：例如 [KDnuggets][32] 的博客、[Mark Meloon][33] 的博客、[Brandon Rohrer][34] 的博客、[Open AI][35] 的研究博客，这些都值得推荐。\n5. 如果你热衷于在线课程，后文中会有如何[正确选择 MOOC 课程][31]的指导。\n6. 最重要的是，培养自己对这些技术的兴趣。加入一些优秀的社交论坛，不要被那些耸人听闻的头条和新闻所吸引，专注于阅读和了解，将这些技术的背景知识和发展方向理解透彻，并积极思考在日常生活和工作中如何应用机器学习或数据科学的原理。例如建立一个简单的回归模型来预测下一次午餐的成本，又或者是从电力公司的网站上下载历史电费数据，在 Excel 中进行简单的时序分析以发现某种规律。在你对这些技术产生了浓厚兴趣之后，可以观看以下这个视频。\n\n<https://www.youtube.com/embed/IpGxLWOIZy4>\n\n### Python 是机器学习和人工智能方面的最佳语言吗？\n\n除非你是一名专业的研究一些复杂算法纯理论证明的研究人员，否则，对于一个机器学习的入门者来说，需要熟悉至少一种高级编程语言。因为大多数情况下都是需要考虑如何将现有的机器学习算法应用于解决实际问题，而这需要有一定的编程能力作为基础。\n\n哪一种语言是数据科学的最佳语言？这个讨论一直没有停息过。对于这方面，你可以提起精神来看一下 FreeCodeCamp 上这一篇关于[数据科学语言][6]的文章，又或者是 KDnuggets 关于 [Python 和 R 之争][7]的深入探讨。\n\n目前人们普遍认为 Python 在开发、部署、维护各方面的效率都是比较高的。与 Java、C 和 C++ 这些较为传统的语言相比，Python 的语法更为简单和高级。而且 Python 拥有活跃的社区群体、广泛的开源文化、数百个专用于机器学习的优质代码库，以及来自业界巨头（包括 Google、Dropbox、Airbnb 等）的强大技术支持。\n\n### 基础 Python 库\n\n如果你打算使用 Python 实施机器学习，你必须掌握一些 Python 包和库的使用方法。\n\n#### NumPy\n\nNumPy 的完整名称是 [Numerical Python][8]，它是 Python 生态里高性能科学计算和数据分析都需要用到的基础包，几乎所有高级工具（例如 [Pandas][9] 和 [scikit-learn][10]）都依赖于它。[TensorFlow][11] 使用了 NumPy 数组作为基础构建块以支持 Tensor 对象和深度学习的图形流。很多 NumPy 操作的速度都非常快，因为它们都是通过 C 实现的。高性能对于数据科学和现代机器学习来说是一个非常宝贵的优势。\n\n![](https://opensource.com/sites/default/files/uploads/machine-learning-python_numpy-cheat-sheet.jpeg)\n\n#### Pandas\n\nPandas 是 Python 生态中用于进行通用数据分析的最受欢迎的库。Pandas 基于 NumPy 数组构建，在保证了可观的执行速度的同时，还提供了许多数据工程方面的功能，包括：\n\n  * 对多种不同数据格式的读写操作\n  * 选择数据子集\n  * 跨行列计算\n  * 查找并补充缺失的数据\n  * 将操作应用于数据中的独立分组\n  * 按照多种格式转换数据\n  * 组合多个数据集\n  * 高级时间序列功能\n  * 通过 Matplotlib 和 Seaborn 进行可视化\n\n![](https://opensource.com/sites/default/files/uploads/pandas_cheat_sheet_github.png)\n\n#### Matplotlib 和 Seaborn\n\n数据可视化和数据分析是数据科学家的必备技能，毕竟仅凭一堆枯燥的数据是无法有效地将背后蕴含的信息向受众传达的。这两项技能对于机器学习来说同样重要，因为首先要对数据集进行一个探索性分析，才能更准确地选择合适的机器学习算法。\n\n[Matplotlib][12] 是应用最广泛的 2D Python 可视化库。它包含海量的命令和接口，可以让你根据数据生成高质量的图表。要学习使用 Matplotlib，可以参考这篇详尽的[文章][13]。\n\n![](https://opensource.com/sites/default/files/uploads/matplotlib_gallery_-1.png)\n\n[Seaborn][14] 也是一个强大的用于统计和绘图的可视化库。它在 Matplotlib 的基础上提供样式灵活的 API、用于统计和绘图的常见高级函数，还可以和 Pandas 提供的功能相结合。要学习使用 Seaborn，可以参考这篇优秀的[教程][15]。\n\n![](https://opensource.com/sites/default/files/uploads/machine-learning-python_seaborn.png)\n\n#### Scikit-learn\n\nScikit-learn 是机器学习方面通用的重要 Python 包。它实现了多种[分类][16]、[回归][17]和[聚类][18]算法，包括[支持向量机][19]、[随机森林][20]、[梯度增强][21]、[k-means 算法][22]和 [DBSCAN 算法][23]，可以与 Python 的数值库 NumPy 和科学计算库 [SciPy][24] 结合使用。它通过兼容的接口提供了有监督和无监督的学习算法。Scikit-learn 的强壮性让它可以稳定运行在生产环境中，同时它在易用性、代码质量、团队协作、文档和性能等各个方面都有良好的表现。可以参考[这篇基于 Scikit-learn 的机器学习入门][25]，或者[这篇基于 Scikit-learn 的简单机器学习用例演示][26]。\n\n本文使用 [CC BY-SA 4.0][28] 许可，在 [Heartbeat][27] 上首发。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks\n\n[a]: https://opensource.com/users/tirthajyoti\n[b]: https://github.com/lujun9972\n[1]: https://www.youtube.com/watch?v=tKa0zDDDaQk\n[2]: https://www.youtube.com/watch?v=Ura_ioOcpQI\n[3]: https://www.coursera.org/learn/machine-learning\n[4]: https://www.coursera.org/specializations/machine-learning\n[5]: https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\n[6]: https://medium.freecodecamp.org/which-languages-should-you-learn-for-data-science-e806ba55a81f\n[7]: https://www.kdnuggets.com/2017/09/python-vs-r-data-science-machine-learning.html\n[8]: http://numpy.org/\n[9]: https://pandas.pydata.org/\n[10]: http://scikit-learn.org/\n[11]: https://www.tensorflow.org/\n[12]: https://matplotlib.org/\n[13]: https://realpython.com/python-matplotlib-guide/\n[14]: https://seaborn.pydata.org/\n[15]: https://www.datacamp.com/community/tutorials/seaborn-python-tutorial\n[16]: https://en.wikipedia.org/wiki/Statistical_classification\n[17]: https://en.wikipedia.org/wiki/Regression_analysis\n[18]: https://en.wikipedia.org/wiki/Cluster_analysis\n[19]: https://en.wikipedia.org/wiki/Support_vector_machine\n[20]: https://en.wikipedia.org/wiki/Random_forests\n[21]: https://en.wikipedia.org/wiki/Gradient_boosting\n[22]: https://en.wikipedia.org/wiki/K-means_clustering\n[23]: https://en.wikipedia.org/wiki/DBSCAN\n[24]: https://en.wikipedia.org/wiki/SciPy\n[25]: http://scikit-learn.org/stable/tutorial/basic/tutorial.html\n[26]: https://towardsdatascience.com/machine-learning-with-python-easy-and-robust-method-to-fit-nonlinear-data-19e8a1ddbd49\n[27]: https://heartbeat.fritz.ai/some-essential-hacks-and-tricks-for-machine-learning-with-python-5478bc6593f2\n[28]: https://creativecommons.org/licenses/by-sa/4.0/\n[29]: https://www.goodreads.com/book/show/24612233-the-master-algorithm\n[30]: http://www.r2d3.us/visual-intro-to-machine-learning-part-1/\n[31]: https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\n[32]: https://www.kdnuggets.com/\n[33]: http://www.markmeloon.com/\n[34]: https://brohrer.github.io/blog.html\n[35]: https://blog.openai.com/\n\n","slug":"Machine-learning-with-Python-Essential-hacks-and-tricks","published":1,"updated":"2019-03-28T12:31:55.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0d0001flixugqnd53qe","content":"<blockquote>\n<p>尝试使用 Python 掌握机器学习、人工智能和深度学习。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming-code-keyboard-laptop.png?itok=pGfEfu2S\" alt=\"\"></p>\n<p>想要入门机器学习并不难。除了<ruby>大规模网络公开课<rt>Massive Open Online Courses</rt></ruby>（MOOC）之外，还有很多其它优秀的免费资源。下面我分享一些我觉得比较有用的方法。</p>\n<ol>\n<li>从一些 YouTube 上的好视频开始，阅览一些关于这方面的文章或者书籍，例如 《<a href=\"https://www.goodreads.com/book/show/24612233-the-master-algorithm\" target=\"_blank\" rel=\"noopener\">主算法：终极学习机器的探索将如何重塑我们的世界</a>》，而且我觉得你肯定会喜欢这些<a href=\"http://www.r2d3.us/visual-intro-to-machine-learning-part-1/\" target=\"_blank\" rel=\"noopener\">关于机器学习的很酷的互动页面</a>。</li>\n<li>对于“<ruby>机器学习<rt>machine learning</rt></ruby>”、“<ruby>人工智能<rt>artificial intelligence</rt></ruby>”、“<ruby>深度学习<rt>deep learning</rt></ruby>”、“<ruby>数据科学<rt>data science</rt></ruby>”、“<ruby>计算机视觉<rt>computer vision</rt></ruby>”和“<ruby>机器人技术<rt>robotics</rt></ruby>”这一堆新名词，你需要知道它们之间的区别。你可以阅览或聆听这些领域的专家们的演讲，例如这位有影响力的<a href=\"https://www.youtube.com/watch?v=tKa0zDDDaQk\" target=\"_blank\" rel=\"noopener\">数据科学家 Brandon Rohrer 的精彩视频</a>。或者这个讲述了数据科学相关的<a href=\"https://www.youtube.com/watch?v=Ura_ioOcpQI\" target=\"_blank\" rel=\"noopener\">各种角色之间的区别</a>的视频。</li>\n<li>明确你自己的学习目标，并选择合适的 <a href=\"https://www.coursera.org/learn/machine-learning\" target=\"_blank\" rel=\"noopener\">Coursera 课程</a>，或者参加高校的网络公开课，例如<a href=\"https://www.coursera.org/specializations/machine-learning\" target=\"_blank\" rel=\"noopener\">华盛顿大学的课程</a>就很不错。</li>\n<li>关注优秀的博客：例如 <a href=\"https://www.kdnuggets.com/\" target=\"_blank\" rel=\"noopener\">KDnuggets</a> 的博客、<a href=\"http://www.markmeloon.com/\" target=\"_blank\" rel=\"noopener\">Mark Meloon</a> 的博客、<a href=\"https://brohrer.github.io/blog.html\" target=\"_blank\" rel=\"noopener\">Brandon Rohrer</a> 的博客、<a href=\"https://blog.openai.com/\" target=\"_blank\" rel=\"noopener\">Open AI</a> 的研究博客，这些都值得推荐。</li>\n<li>如果你热衷于在线课程，后文中会有如何<a href=\"https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\" target=\"_blank\" rel=\"noopener\">正确选择 MOOC 课程</a>的指导。</li>\n<li>最重要的是，培养自己对这些技术的兴趣。加入一些优秀的社交论坛，不要被那些耸人听闻的头条和新闻所吸引，专注于阅读和了解，将这些技术的背景知识和发展方向理解透彻，并积极思考在日常生活和工作中如何应用机器学习或数据科学的原理。例如建立一个简单的回归模型来预测下一次午餐的成本，又或者是从电力公司的网站上下载历史电费数据，在 Excel 中进行简单的时序分析以发现某种规律。在你对这些技术产生了浓厚兴趣之后，可以观看以下这个视频。</li>\n</ol>\n<p><a href=\"https://www.youtube.com/embed/IpGxLWOIZy4\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/embed/IpGxLWOIZy4</a></p>\n<h3 id=\"Python-是机器学习和人工智能方面的最佳语言吗？\"><a href=\"#Python-是机器学习和人工智能方面的最佳语言吗？\" class=\"headerlink\" title=\"Python 是机器学习和人工智能方面的最佳语言吗？\"></a>Python 是机器学习和人工智能方面的最佳语言吗？</h3><p>除非你是一名专业的研究一些复杂算法纯理论证明的研究人员，否则，对于一个机器学习的入门者来说，需要熟悉至少一种高级编程语言。因为大多数情况下都是需要考虑如何将现有的机器学习算法应用于解决实际问题，而这需要有一定的编程能力作为基础。</p>\n<p>哪一种语言是数据科学的最佳语言？这个讨论一直没有停息过。对于这方面，你可以提起精神来看一下 FreeCodeCamp 上这一篇关于<a href=\"https://medium.freecodecamp.org/which-languages-should-you-learn-for-data-science-e806ba55a81f\" target=\"_blank\" rel=\"noopener\">数据科学语言</a>的文章，又或者是 KDnuggets 关于 <a href=\"https://www.kdnuggets.com/2017/09/python-vs-r-data-science-machine-learning.html\" target=\"_blank\" rel=\"noopener\">Python 和 R 之争</a>的深入探讨。</p>\n<p>目前人们普遍认为 Python 在开发、部署、维护各方面的效率都是比较高的。与 Java、C 和 C++ 这些较为传统的语言相比，Python 的语法更为简单和高级。而且 Python 拥有活跃的社区群体、广泛的开源文化、数百个专用于机器学习的优质代码库，以及来自业界巨头（包括 Google、Dropbox、Airbnb 等）的强大技术支持。</p>\n<h3 id=\"基础-Python-库\"><a href=\"#基础-Python-库\" class=\"headerlink\" title=\"基础 Python 库\"></a>基础 Python 库</h3><p>如果你打算使用 Python 实施机器学习，你必须掌握一些 Python 包和库的使用方法。</p>\n<h4 id=\"NumPy\"><a href=\"#NumPy\" class=\"headerlink\" title=\"NumPy\"></a>NumPy</h4><p>NumPy 的完整名称是 <a href=\"http://numpy.org/\" target=\"_blank\" rel=\"noopener\">Numerical Python</a>，它是 Python 生态里高性能科学计算和数据分析都需要用到的基础包，几乎所有高级工具（例如 <a href=\"https://pandas.pydata.org/\" target=\"_blank\" rel=\"noopener\">Pandas</a> 和 <a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">scikit-learn</a>）都依赖于它。<a href=\"https://www.tensorflow.org/\" target=\"_blank\" rel=\"noopener\">TensorFlow</a> 使用了 NumPy 数组作为基础构建块以支持 Tensor 对象和深度学习的图形流。很多 NumPy 操作的速度都非常快，因为它们都是通过 C 实现的。高性能对于数据科学和现代机器学习来说是一个非常宝贵的优势。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/machine-learning-python_numpy-cheat-sheet.jpeg\" alt=\"\"></p>\n<h4 id=\"Pandas\"><a href=\"#Pandas\" class=\"headerlink\" title=\"Pandas\"></a>Pandas</h4><p>Pandas 是 Python 生态中用于进行通用数据分析的最受欢迎的库。Pandas 基于 NumPy 数组构建，在保证了可观的执行速度的同时，还提供了许多数据工程方面的功能，包括：</p>\n<ul>\n<li>对多种不同数据格式的读写操作</li>\n<li>选择数据子集</li>\n<li>跨行列计算</li>\n<li>查找并补充缺失的数据</li>\n<li>将操作应用于数据中的独立分组</li>\n<li>按照多种格式转换数据</li>\n<li>组合多个数据集</li>\n<li>高级时间序列功能</li>\n<li>通过 Matplotlib 和 Seaborn 进行可视化</li>\n</ul>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pandas_cheat_sheet_github.png\" alt=\"\"></p>\n<h4 id=\"Matplotlib-和-Seaborn\"><a href=\"#Matplotlib-和-Seaborn\" class=\"headerlink\" title=\"Matplotlib 和 Seaborn\"></a>Matplotlib 和 Seaborn</h4><p>数据可视化和数据分析是数据科学家的必备技能，毕竟仅凭一堆枯燥的数据是无法有效地将背后蕴含的信息向受众传达的。这两项技能对于机器学习来说同样重要，因为首先要对数据集进行一个探索性分析，才能更准确地选择合适的机器学习算法。</p>\n<p><a href=\"https://matplotlib.org/\" target=\"_blank\" rel=\"noopener\">Matplotlib</a> 是应用最广泛的 2D Python 可视化库。它包含海量的命令和接口，可以让你根据数据生成高质量的图表。要学习使用 Matplotlib，可以参考这篇详尽的<a href=\"https://realpython.com/python-matplotlib-guide/\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/matplotlib_gallery_-1.png\" alt=\"\"></p>\n<p><a href=\"https://seaborn.pydata.org/\" target=\"_blank\" rel=\"noopener\">Seaborn</a> 也是一个强大的用于统计和绘图的可视化库。它在 Matplotlib 的基础上提供样式灵活的 API、用于统计和绘图的常见高级函数，还可以和 Pandas 提供的功能相结合。要学习使用 Seaborn，可以参考这篇优秀的<a href=\"https://www.datacamp.com/community/tutorials/seaborn-python-tutorial\" target=\"_blank\" rel=\"noopener\">教程</a>。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/machine-learning-python_seaborn.png\" alt=\"\"></p>\n<h4 id=\"Scikit-learn\"><a href=\"#Scikit-learn\" class=\"headerlink\" title=\"Scikit-learn\"></a>Scikit-learn</h4><p>Scikit-learn 是机器学习方面通用的重要 Python 包。它实现了多种<a href=\"https://en.wikipedia.org/wiki/Statistical_classification\" target=\"_blank\" rel=\"noopener\">分类</a>、<a href=\"https://en.wikipedia.org/wiki/Regression_analysis\" target=\"_blank\" rel=\"noopener\">回归</a>和<a href=\"https://en.wikipedia.org/wiki/Cluster_analysis\" target=\"_blank\" rel=\"noopener\">聚类</a>算法，包括<a href=\"https://en.wikipedia.org/wiki/Support_vector_machine\" target=\"_blank\" rel=\"noopener\">支持向量机</a>、<a href=\"https://en.wikipedia.org/wiki/Random_forests\" target=\"_blank\" rel=\"noopener\">随机森林</a>、<a href=\"https://en.wikipedia.org/wiki/Gradient_boosting\" target=\"_blank\" rel=\"noopener\">梯度增强</a>、<a href=\"https://en.wikipedia.org/wiki/K-means_clustering\" target=\"_blank\" rel=\"noopener\">k-means 算法</a>和 <a href=\"https://en.wikipedia.org/wiki/DBSCAN\" target=\"_blank\" rel=\"noopener\">DBSCAN 算法</a>，可以与 Python 的数值库 NumPy 和科学计算库 <a href=\"https://en.wikipedia.org/wiki/SciPy\" target=\"_blank\" rel=\"noopener\">SciPy</a> 结合使用。它通过兼容的接口提供了有监督和无监督的学习算法。Scikit-learn 的强壮性让它可以稳定运行在生产环境中，同时它在易用性、代码质量、团队协作、文档和性能等各个方面都有良好的表现。可以参考<a href=\"http://scikit-learn.org/stable/tutorial/basic/tutorial.html\" target=\"_blank\" rel=\"noopener\">这篇基于 Scikit-learn 的机器学习入门</a>，或者<a href=\"https://towardsdatascience.com/machine-learning-with-python-easy-and-robust-method-to-fit-nonlinear-data-19e8a1ddbd49\" target=\"_blank\" rel=\"noopener\">这篇基于 Scikit-learn 的简单机器学习用例演示</a>。</p>\n<p>本文使用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">CC BY-SA 4.0</a> 许可，在 <a href=\"https://heartbeat.fritz.ai/some-essential-hacks-and-tricks-for-machine-learning-with-python-5478bc6593f2\" target=\"_blank\" rel=\"noopener\">Heartbeat</a> 上首发。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>尝试使用 Python 掌握机器学习、人工智能和深度学习。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/programming-code-keyboard-laptop.png?itok=pGfEfu2S\" alt=\"\"></p>\n<p>想要入门机器学习并不难。除了<ruby>大规模网络公开课<rt>Massive Open Online Courses</rt></ruby>（MOOC）之外，还有很多其它优秀的免费资源。下面我分享一些我觉得比较有用的方法。</p>\n<ol>\n<li>从一些 YouTube 上的好视频开始，阅览一些关于这方面的文章或者书籍，例如 《<a href=\"https://www.goodreads.com/book/show/24612233-the-master-algorithm\" target=\"_blank\" rel=\"noopener\">主算法：终极学习机器的探索将如何重塑我们的世界</a>》，而且我觉得你肯定会喜欢这些<a href=\"http://www.r2d3.us/visual-intro-to-machine-learning-part-1/\" target=\"_blank\" rel=\"noopener\">关于机器学习的很酷的互动页面</a>。</li>\n<li>对于“<ruby>机器学习<rt>machine learning</rt></ruby>”、“<ruby>人工智能<rt>artificial intelligence</rt></ruby>”、“<ruby>深度学习<rt>deep learning</rt></ruby>”、“<ruby>数据科学<rt>data science</rt></ruby>”、“<ruby>计算机视觉<rt>computer vision</rt></ruby>”和“<ruby>机器人技术<rt>robotics</rt></ruby>”这一堆新名词，你需要知道它们之间的区别。你可以阅览或聆听这些领域的专家们的演讲，例如这位有影响力的<a href=\"https://www.youtube.com/watch?v=tKa0zDDDaQk\" target=\"_blank\" rel=\"noopener\">数据科学家 Brandon Rohrer 的精彩视频</a>。或者这个讲述了数据科学相关的<a href=\"https://www.youtube.com/watch?v=Ura_ioOcpQI\" target=\"_blank\" rel=\"noopener\">各种角色之间的区别</a>的视频。</li>\n<li>明确你自己的学习目标，并选择合适的 <a href=\"https://www.coursera.org/learn/machine-learning\" target=\"_blank\" rel=\"noopener\">Coursera 课程</a>，或者参加高校的网络公开课，例如<a href=\"https://www.coursera.org/specializations/machine-learning\" target=\"_blank\" rel=\"noopener\">华盛顿大学的课程</a>就很不错。</li>\n<li>关注优秀的博客：例如 <a href=\"https://www.kdnuggets.com/\" target=\"_blank\" rel=\"noopener\">KDnuggets</a> 的博客、<a href=\"http://www.markmeloon.com/\" target=\"_blank\" rel=\"noopener\">Mark Meloon</a> 的博客、<a href=\"https://brohrer.github.io/blog.html\" target=\"_blank\" rel=\"noopener\">Brandon Rohrer</a> 的博客、<a href=\"https://blog.openai.com/\" target=\"_blank\" rel=\"noopener\">Open AI</a> 的研究博客，这些都值得推荐。</li>\n<li>如果你热衷于在线课程，后文中会有如何<a href=\"https://towardsdatascience.com/how-to-choose-effective-moocs-for-machine-learning-and-data-science-8681700ed83f\" target=\"_blank\" rel=\"noopener\">正确选择 MOOC 课程</a>的指导。</li>\n<li>最重要的是，培养自己对这些技术的兴趣。加入一些优秀的社交论坛，不要被那些耸人听闻的头条和新闻所吸引，专注于阅读和了解，将这些技术的背景知识和发展方向理解透彻，并积极思考在日常生活和工作中如何应用机器学习或数据科学的原理。例如建立一个简单的回归模型来预测下一次午餐的成本，又或者是从电力公司的网站上下载历史电费数据，在 Excel 中进行简单的时序分析以发现某种规律。在你对这些技术产生了浓厚兴趣之后，可以观看以下这个视频。</li>\n</ol>\n<p><a href=\"https://www.youtube.com/embed/IpGxLWOIZy4\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/embed/IpGxLWOIZy4</a></p>\n<h3 id=\"Python-是机器学习和人工智能方面的最佳语言吗？\"><a href=\"#Python-是机器学习和人工智能方面的最佳语言吗？\" class=\"headerlink\" title=\"Python 是机器学习和人工智能方面的最佳语言吗？\"></a>Python 是机器学习和人工智能方面的最佳语言吗？</h3><p>除非你是一名专业的研究一些复杂算法纯理论证明的研究人员，否则，对于一个机器学习的入门者来说，需要熟悉至少一种高级编程语言。因为大多数情况下都是需要考虑如何将现有的机器学习算法应用于解决实际问题，而这需要有一定的编程能力作为基础。</p>\n<p>哪一种语言是数据科学的最佳语言？这个讨论一直没有停息过。对于这方面，你可以提起精神来看一下 FreeCodeCamp 上这一篇关于<a href=\"https://medium.freecodecamp.org/which-languages-should-you-learn-for-data-science-e806ba55a81f\" target=\"_blank\" rel=\"noopener\">数据科学语言</a>的文章，又或者是 KDnuggets 关于 <a href=\"https://www.kdnuggets.com/2017/09/python-vs-r-data-science-machine-learning.html\" target=\"_blank\" rel=\"noopener\">Python 和 R 之争</a>的深入探讨。</p>\n<p>目前人们普遍认为 Python 在开发、部署、维护各方面的效率都是比较高的。与 Java、C 和 C++ 这些较为传统的语言相比，Python 的语法更为简单和高级。而且 Python 拥有活跃的社区群体、广泛的开源文化、数百个专用于机器学习的优质代码库，以及来自业界巨头（包括 Google、Dropbox、Airbnb 等）的强大技术支持。</p>\n<h3 id=\"基础-Python-库\"><a href=\"#基础-Python-库\" class=\"headerlink\" title=\"基础 Python 库\"></a>基础 Python 库</h3><p>如果你打算使用 Python 实施机器学习，你必须掌握一些 Python 包和库的使用方法。</p>\n<h4 id=\"NumPy\"><a href=\"#NumPy\" class=\"headerlink\" title=\"NumPy\"></a>NumPy</h4><p>NumPy 的完整名称是 <a href=\"http://numpy.org/\" target=\"_blank\" rel=\"noopener\">Numerical Python</a>，它是 Python 生态里高性能科学计算和数据分析都需要用到的基础包，几乎所有高级工具（例如 <a href=\"https://pandas.pydata.org/\" target=\"_blank\" rel=\"noopener\">Pandas</a> 和 <a href=\"http://scikit-learn.org/\" target=\"_blank\" rel=\"noopener\">scikit-learn</a>）都依赖于它。<a href=\"https://www.tensorflow.org/\" target=\"_blank\" rel=\"noopener\">TensorFlow</a> 使用了 NumPy 数组作为基础构建块以支持 Tensor 对象和深度学习的图形流。很多 NumPy 操作的速度都非常快，因为它们都是通过 C 实现的。高性能对于数据科学和现代机器学习来说是一个非常宝贵的优势。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/machine-learning-python_numpy-cheat-sheet.jpeg\" alt=\"\"></p>\n<h4 id=\"Pandas\"><a href=\"#Pandas\" class=\"headerlink\" title=\"Pandas\"></a>Pandas</h4><p>Pandas 是 Python 生态中用于进行通用数据分析的最受欢迎的库。Pandas 基于 NumPy 数组构建，在保证了可观的执行速度的同时，还提供了许多数据工程方面的功能，包括：</p>\n<ul>\n<li>对多种不同数据格式的读写操作</li>\n<li>选择数据子集</li>\n<li>跨行列计算</li>\n<li>查找并补充缺失的数据</li>\n<li>将操作应用于数据中的独立分组</li>\n<li>按照多种格式转换数据</li>\n<li>组合多个数据集</li>\n<li>高级时间序列功能</li>\n<li>通过 Matplotlib 和 Seaborn 进行可视化</li>\n</ul>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/pandas_cheat_sheet_github.png\" alt=\"\"></p>\n<h4 id=\"Matplotlib-和-Seaborn\"><a href=\"#Matplotlib-和-Seaborn\" class=\"headerlink\" title=\"Matplotlib 和 Seaborn\"></a>Matplotlib 和 Seaborn</h4><p>数据可视化和数据分析是数据科学家的必备技能，毕竟仅凭一堆枯燥的数据是无法有效地将背后蕴含的信息向受众传达的。这两项技能对于机器学习来说同样重要，因为首先要对数据集进行一个探索性分析，才能更准确地选择合适的机器学习算法。</p>\n<p><a href=\"https://matplotlib.org/\" target=\"_blank\" rel=\"noopener\">Matplotlib</a> 是应用最广泛的 2D Python 可视化库。它包含海量的命令和接口，可以让你根据数据生成高质量的图表。要学习使用 Matplotlib，可以参考这篇详尽的<a href=\"https://realpython.com/python-matplotlib-guide/\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/matplotlib_gallery_-1.png\" alt=\"\"></p>\n<p><a href=\"https://seaborn.pydata.org/\" target=\"_blank\" rel=\"noopener\">Seaborn</a> 也是一个强大的用于统计和绘图的可视化库。它在 Matplotlib 的基础上提供样式灵活的 API、用于统计和绘图的常见高级函数，还可以和 Pandas 提供的功能相结合。要学习使用 Seaborn，可以参考这篇优秀的<a href=\"https://www.datacamp.com/community/tutorials/seaborn-python-tutorial\" target=\"_blank\" rel=\"noopener\">教程</a>。</p>\n<p><img src=\"https://opensource.com/sites/default/files/uploads/machine-learning-python_seaborn.png\" alt=\"\"></p>\n<h4 id=\"Scikit-learn\"><a href=\"#Scikit-learn\" class=\"headerlink\" title=\"Scikit-learn\"></a>Scikit-learn</h4><p>Scikit-learn 是机器学习方面通用的重要 Python 包。它实现了多种<a href=\"https://en.wikipedia.org/wiki/Statistical_classification\" target=\"_blank\" rel=\"noopener\">分类</a>、<a href=\"https://en.wikipedia.org/wiki/Regression_analysis\" target=\"_blank\" rel=\"noopener\">回归</a>和<a href=\"https://en.wikipedia.org/wiki/Cluster_analysis\" target=\"_blank\" rel=\"noopener\">聚类</a>算法，包括<a href=\"https://en.wikipedia.org/wiki/Support_vector_machine\" target=\"_blank\" rel=\"noopener\">支持向量机</a>、<a href=\"https://en.wikipedia.org/wiki/Random_forests\" target=\"_blank\" rel=\"noopener\">随机森林</a>、<a href=\"https://en.wikipedia.org/wiki/Gradient_boosting\" target=\"_blank\" rel=\"noopener\">梯度增强</a>、<a href=\"https://en.wikipedia.org/wiki/K-means_clustering\" target=\"_blank\" rel=\"noopener\">k-means 算法</a>和 <a href=\"https://en.wikipedia.org/wiki/DBSCAN\" target=\"_blank\" rel=\"noopener\">DBSCAN 算法</a>，可以与 Python 的数值库 NumPy 和科学计算库 <a href=\"https://en.wikipedia.org/wiki/SciPy\" target=\"_blank\" rel=\"noopener\">SciPy</a> 结合使用。它通过兼容的接口提供了有监督和无监督的学习算法。Scikit-learn 的强壮性让它可以稳定运行在生产环境中，同时它在易用性、代码质量、团队协作、文档和性能等各个方面都有良好的表现。可以参考<a href=\"http://scikit-learn.org/stable/tutorial/basic/tutorial.html\" target=\"_blank\" rel=\"noopener\">这篇基于 Scikit-learn 的机器学习入门</a>，或者<a href=\"https://towardsdatascience.com/machine-learning-with-python-easy-and-robust-method-to-fit-nonlinear-data-19e8a1ddbd49\" target=\"_blank\" rel=\"noopener\">这篇基于 Scikit-learn 的简单机器学习用例演示</a>。</p>\n<p>本文使用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">CC BY-SA 4.0</a> 许可，在 <a href=\"https://heartbeat.fritz.ai/some-essential-hacks-and-tricks-for-machine-learning-with-python-5478bc6593f2\" target=\"_blank\" rel=\"noopener\">Heartbeat</a> 上首发。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/machine-learning-python-essential-hacks-and-tricks</a></p>\n"},{"title":"如何让 Ping 的输出更简单易读","date":"2018-09-30T05:16:31.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-720x340.png)\n\n众所周知，`ping` 命令可以用来检查目标主机是否可达。使用 `ping` 命令的时候，会发送一个 ICMP Echo 请求，通过目标主机的响应与否来确定目标主机的状态。如果你经常使用 `ping` 命令，你可以尝试一下 `prettyping`。Prettyping 只是将一个标准的 ping 工具增加了一层封装，在运行标准 `ping` 命令的同时添加了颜色和 unicode 字符解析输出，所以它的输出更漂亮紧凑、清晰易读。它是用 `bash` 和 `awk` 编写的自由开源工具，支持大部分类 Unix 操作系统，包括 GNU/Linux、FreeBSD 和 Mac OS X。Prettyping 除了美化 `ping` 命令的输出，还有很多值得注意的功能。\n\n  * 检测丢失的数据包并在输出中标记出来。\n  * 显示实时数据。每次收到响应后，都会更新统计数据，而对于普通 `ping` 命令，只会在执行结束后统计。\n  * 可以灵活处理“未知信息”（例如错误信息），而不搞乱输出结果。\n  * 能够避免输出重复的信息。\n  * 兼容常用的 `ping` 工具命令参数。\n  * 能够由普通用户执行。\n  * 可以将输出重定向到文件中。\n  * 不需要安装，只需要下载二进制文件，赋予可执行权限即可执行。\n  * 快速且轻巧。\n  * 输出结果清晰直观。\n\n### 安装 Prettyping\n\n如上所述，Prettyping 是一个绿色软件，不需要任何安装，只要使用以下命令下载 Prettyping 二进制文件：\n\n```\n$ curl -O https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping\n```\n\n将二进制文件放置到 `$PATH`（例如 `/usr/local/bin`）中：\n\n```\n$ sudo mv prettyping /usr/local/bin\n```\n\n然后对其赋予可执行权限：\n\n```\n$ sudo chmod +x /usr/local/bin/prettyping\n```\n\n就可以使用了。\n\n### 让 ping 的输出清晰易读\n\n安装完成后，通过 `prettyping` 来 ping 任何主机或 IP 地址，就可以以图形方式查看输出。\n\n```\n$ prettyping ostechnix.com\n```\n\n输出效果大概会是这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-in-action.gif)\n\n如果你不带任何参数执行 `prettyping`，它就会一直运行直到被 `ctrl + c` 中断。\n\n由于 Prettyping 只是一个对普通 `ping` 命令的封装，所以常用的 ping 参数也是有效的。例如使用 `-c 5` 来指定 ping 一台主机的 5 次：\n\n```\n$ prettyping -c 5 ostechnix.com\n```\n\nPrettyping 默认会使用彩色输出，如果你不喜欢彩色的输出，可以加上 `--nocolor` 参数：\n\n```\n$ prettyping --nocolor ostechnix.com\n```\n\n同样的，也可以用 `--nomulticolor` 参数禁用多颜色支持：\n\n```\n$ prettyping --nomulticolor ostechnix.com\n```\n\n使用 `--nounicode` 参数禁用 unicode 字符：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-without-unicode-support.png)\n\n如果你的终端不支持 UTF-8，或者无法修复系统中的 unicode 字体，只需要加上 `--nounicode` 参数就能轻松解决。\n\nPrettyping 支持将输出的内容重定向到文件中，例如执行以下这个命令会将 `prettyping ostechnix.com` 的输出重定向到 `ostechnix.txt` 中：\n\n```\n$ prettyping ostechnix.com | tee ostechnix.txt\n```\n\nPrettyping 还有很多选项帮助你完成各种任务，例如：\n\n  * 启用/禁用延时图例（默认启用）\n  * 强制按照终端的格式输出（默认自动）\n  * 在统计数据中统计最后的 n 次 ping（默认 60 次）\n  * 覆盖对终端尺寸的自动检测\n  * 指定 awk 解释器路径（默认：`awk`）\n  * 指定 ping 工具路径（默认：`ping`）\n\n\n查看帮助文档可以了解更多：\n\n```\n$ prettyping --help\n```\n\n尽管 Prettyping 没有添加任何额外功能，但我个人喜欢它的这些优点：\n\n  * 实时统计 —— 可以随时查看所有实时统计信息，标准 `ping` 命令只会在命令执行结束后才显示统计信息。\n  * 紧凑的显示 —— 可以在终端看到更长的时间跨度。\n  * 检测丢失的数据包并显示出来。\n\n如果你一直在寻找可视化显示 `ping` 命令输出的工具，那么 Prettyping 肯定会有所帮助。尝试一下，你不会失望的。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/\n\n[a]: https://www.ostechnix.com/author/sk/\n\n","source":"_posts/Make-The-Output-Of-Ping-Command-Prettier-And-Easier-To-Read.md","raw":"---\ntitle: 如何让 Ping 的输出更简单易读\ndate: 2018-09-30 13:16:31\ntags:\n  - ping\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-720x340.png)\n\n众所周知，`ping` 命令可以用来检查目标主机是否可达。使用 `ping` 命令的时候，会发送一个 ICMP Echo 请求，通过目标主机的响应与否来确定目标主机的状态。如果你经常使用 `ping` 命令，你可以尝试一下 `prettyping`。Prettyping 只是将一个标准的 ping 工具增加了一层封装，在运行标准 `ping` 命令的同时添加了颜色和 unicode 字符解析输出，所以它的输出更漂亮紧凑、清晰易读。它是用 `bash` 和 `awk` 编写的自由开源工具，支持大部分类 Unix 操作系统，包括 GNU/Linux、FreeBSD 和 Mac OS X。Prettyping 除了美化 `ping` 命令的输出，还有很多值得注意的功能。\n\n  * 检测丢失的数据包并在输出中标记出来。\n  * 显示实时数据。每次收到响应后，都会更新统计数据，而对于普通 `ping` 命令，只会在执行结束后统计。\n  * 可以灵活处理“未知信息”（例如错误信息），而不搞乱输出结果。\n  * 能够避免输出重复的信息。\n  * 兼容常用的 `ping` 工具命令参数。\n  * 能够由普通用户执行。\n  * 可以将输出重定向到文件中。\n  * 不需要安装，只需要下载二进制文件，赋予可执行权限即可执行。\n  * 快速且轻巧。\n  * 输出结果清晰直观。\n\n### 安装 Prettyping\n\n如上所述，Prettyping 是一个绿色软件，不需要任何安装，只要使用以下命令下载 Prettyping 二进制文件：\n\n```\n$ curl -O https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping\n```\n\n将二进制文件放置到 `$PATH`（例如 `/usr/local/bin`）中：\n\n```\n$ sudo mv prettyping /usr/local/bin\n```\n\n然后对其赋予可执行权限：\n\n```\n$ sudo chmod +x /usr/local/bin/prettyping\n```\n\n就可以使用了。\n\n### 让 ping 的输出清晰易读\n\n安装完成后，通过 `prettyping` 来 ping 任何主机或 IP 地址，就可以以图形方式查看输出。\n\n```\n$ prettyping ostechnix.com\n```\n\n输出效果大概会是这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-in-action.gif)\n\n如果你不带任何参数执行 `prettyping`，它就会一直运行直到被 `ctrl + c` 中断。\n\n由于 Prettyping 只是一个对普通 `ping` 命令的封装，所以常用的 ping 参数也是有效的。例如使用 `-c 5` 来指定 ping 一台主机的 5 次：\n\n```\n$ prettyping -c 5 ostechnix.com\n```\n\nPrettyping 默认会使用彩色输出，如果你不喜欢彩色的输出，可以加上 `--nocolor` 参数：\n\n```\n$ prettyping --nocolor ostechnix.com\n```\n\n同样的，也可以用 `--nomulticolor` 参数禁用多颜色支持：\n\n```\n$ prettyping --nomulticolor ostechnix.com\n```\n\n使用 `--nounicode` 参数禁用 unicode 字符：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-without-unicode-support.png)\n\n如果你的终端不支持 UTF-8，或者无法修复系统中的 unicode 字体，只需要加上 `--nounicode` 参数就能轻松解决。\n\nPrettyping 支持将输出的内容重定向到文件中，例如执行以下这个命令会将 `prettyping ostechnix.com` 的输出重定向到 `ostechnix.txt` 中：\n\n```\n$ prettyping ostechnix.com | tee ostechnix.txt\n```\n\nPrettyping 还有很多选项帮助你完成各种任务，例如：\n\n  * 启用/禁用延时图例（默认启用）\n  * 强制按照终端的格式输出（默认自动）\n  * 在统计数据中统计最后的 n 次 ping（默认 60 次）\n  * 覆盖对终端尺寸的自动检测\n  * 指定 awk 解释器路径（默认：`awk`）\n  * 指定 ping 工具路径（默认：`ping`）\n\n\n查看帮助文档可以了解更多：\n\n```\n$ prettyping --help\n```\n\n尽管 Prettyping 没有添加任何额外功能，但我个人喜欢它的这些优点：\n\n  * 实时统计 —— 可以随时查看所有实时统计信息，标准 `ping` 命令只会在命令执行结束后才显示统计信息。\n  * 紧凑的显示 —— 可以在终端看到更长的时间跨度。\n  * 检测丢失的数据包并显示出来。\n\n如果你一直在寻找可视化显示 `ping` 命令输出的工具，那么 Prettyping 肯定会有所帮助。尝试一下，你不会失望的。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/\n\n[a]: https://www.ostechnix.com/author/sk/\n\n","slug":"Make-The-Output-Of-Ping-Command-Prettier-And-Easier-To-Read","published":1,"updated":"2019-03-28T05:59:42.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0d1001ilixuv61icszg","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-720x340.png\" alt=\"\"></p>\n<p>众所周知，<code>ping</code> 命令可以用来检查目标主机是否可达。使用 <code>ping</code> 命令的时候，会发送一个 ICMP Echo 请求，通过目标主机的响应与否来确定目标主机的状态。如果你经常使用 <code>ping</code> 命令，你可以尝试一下 <code>prettyping</code>。Prettyping 只是将一个标准的 ping 工具增加了一层封装，在运行标准 <code>ping</code> 命令的同时添加了颜色和 unicode 字符解析输出，所以它的输出更漂亮紧凑、清晰易读。它是用 <code>bash</code> 和 <code>awk</code> 编写的自由开源工具，支持大部分类 Unix 操作系统，包括 GNU/Linux、FreeBSD 和 Mac OS X。Prettyping 除了美化 <code>ping</code> 命令的输出，还有很多值得注意的功能。</p>\n<ul>\n<li>检测丢失的数据包并在输出中标记出来。</li>\n<li>显示实时数据。每次收到响应后，都会更新统计数据，而对于普通 <code>ping</code> 命令，只会在执行结束后统计。</li>\n<li>可以灵活处理“未知信息”（例如错误信息），而不搞乱输出结果。</li>\n<li>能够避免输出重复的信息。</li>\n<li>兼容常用的 <code>ping</code> 工具命令参数。</li>\n<li>能够由普通用户执行。</li>\n<li>可以将输出重定向到文件中。</li>\n<li>不需要安装，只需要下载二进制文件，赋予可执行权限即可执行。</li>\n<li>快速且轻巧。</li>\n<li>输出结果清晰直观。</li>\n</ul>\n<h3 id=\"安装-Prettyping\"><a href=\"#安装-Prettyping\" class=\"headerlink\" title=\"安装 Prettyping\"></a>安装 Prettyping</h3><p>如上所述，Prettyping 是一个绿色软件，不需要任何安装，只要使用以下命令下载 Prettyping 二进制文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -O https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping</span><br></pre></td></tr></table></figure>\n<p>将二进制文件放置到 <code>$PATH</code>（例如 <code>/usr/local/bin</code>）中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv prettyping /usr/local/bin</span><br></pre></td></tr></table></figure>\n<p>然后对其赋予可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chmod +x /usr/local/bin/prettyping</span><br></pre></td></tr></table></figure>\n<p>就可以使用了。</p>\n<h3 id=\"让-ping-的输出清晰易读\"><a href=\"#让-ping-的输出清晰易读\" class=\"headerlink\" title=\"让 ping 的输出清晰易读\"></a>让 ping 的输出清晰易读</h3><p>安装完成后，通过 <code>prettyping</code> 来 ping 任何主机或 IP 地址，就可以以图形方式查看输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>输出效果大概会是这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-in-action.gif\" alt=\"\"></p>\n<p>如果你不带任何参数执行 <code>prettyping</code>，它就会一直运行直到被 <code>ctrl + c</code> 中断。</p>\n<p>由于 Prettyping 只是一个对普通 <code>ping</code> 命令的封装，所以常用的 ping 参数也是有效的。例如使用 <code>-c 5</code> 来指定 ping 一台主机的 5 次：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping -c 5 ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>Prettyping 默认会使用彩色输出，如果你不喜欢彩色的输出，可以加上 <code>--nocolor</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --nocolor ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>同样的，也可以用 <code>--nomulticolor</code> 参数禁用多颜色支持：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --nomulticolor ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>使用 <code>--nounicode</code> 参数禁用 unicode 字符：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-without-unicode-support.png\" alt=\"\"></p>\n<p>如果你的终端不支持 UTF-8，或者无法修复系统中的 unicode 字体，只需要加上 <code>--nounicode</code> 参数就能轻松解决。</p>\n<p>Prettyping 支持将输出的内容重定向到文件中，例如执行以下这个命令会将 <code>prettyping ostechnix.com</code> 的输出重定向到 <code>ostechnix.txt</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping ostechnix.com | tee ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>Prettyping 还有很多选项帮助你完成各种任务，例如：</p>\n<ul>\n<li>启用/禁用延时图例（默认启用）</li>\n<li>强制按照终端的格式输出（默认自动）</li>\n<li>在统计数据中统计最后的 n 次 ping（默认 60 次）</li>\n<li>覆盖对终端尺寸的自动检测</li>\n<li>指定 awk 解释器路径（默认：<code>awk</code>）</li>\n<li>指定 ping 工具路径（默认：<code>ping</code>）</li>\n</ul>\n<p>查看帮助文档可以了解更多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --help</span><br></pre></td></tr></table></figure>\n<p>尽管 Prettyping 没有添加任何额外功能，但我个人喜欢它的这些优点：</p>\n<ul>\n<li>实时统计 —— 可以随时查看所有实时统计信息，标准 <code>ping</code> 命令只会在命令执行结束后才显示统计信息。</li>\n<li>紧凑的显示 —— 可以在终端看到更长的时间跨度。</li>\n<li>检测丢失的数据包并显示出来。</li>\n</ul>\n<p>如果你一直在寻找可视化显示 <code>ping</code> 命令输出的工具，那么 Prettyping 肯定会有所帮助。尝试一下，你不会失望的。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-720x340.png\" alt=\"\"></p>\n<p>众所周知，<code>ping</code> 命令可以用来检查目标主机是否可达。使用 <code>ping</code> 命令的时候，会发送一个 ICMP Echo 请求，通过目标主机的响应与否来确定目标主机的状态。如果你经常使用 <code>ping</code> 命令，你可以尝试一下 <code>prettyping</code>。Prettyping 只是将一个标准的 ping 工具增加了一层封装，在运行标准 <code>ping</code> 命令的同时添加了颜色和 unicode 字符解析输出，所以它的输出更漂亮紧凑、清晰易读。它是用 <code>bash</code> 和 <code>awk</code> 编写的自由开源工具，支持大部分类 Unix 操作系统，包括 GNU/Linux、FreeBSD 和 Mac OS X。Prettyping 除了美化 <code>ping</code> 命令的输出，还有很多值得注意的功能。</p>\n<ul>\n<li>检测丢失的数据包并在输出中标记出来。</li>\n<li>显示实时数据。每次收到响应后，都会更新统计数据，而对于普通 <code>ping</code> 命令，只会在执行结束后统计。</li>\n<li>可以灵活处理“未知信息”（例如错误信息），而不搞乱输出结果。</li>\n<li>能够避免输出重复的信息。</li>\n<li>兼容常用的 <code>ping</code> 工具命令参数。</li>\n<li>能够由普通用户执行。</li>\n<li>可以将输出重定向到文件中。</li>\n<li>不需要安装，只需要下载二进制文件，赋予可执行权限即可执行。</li>\n<li>快速且轻巧。</li>\n<li>输出结果清晰直观。</li>\n</ul>\n<h3 id=\"安装-Prettyping\"><a href=\"#安装-Prettyping\" class=\"headerlink\" title=\"安装 Prettyping\"></a>安装 Prettyping</h3><p>如上所述，Prettyping 是一个绿色软件，不需要任何安装，只要使用以下命令下载 Prettyping 二进制文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -O https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping</span><br></pre></td></tr></table></figure>\n<p>将二进制文件放置到 <code>$PATH</code>（例如 <code>/usr/local/bin</code>）中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv prettyping /usr/local/bin</span><br></pre></td></tr></table></figure>\n<p>然后对其赋予可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chmod +x /usr/local/bin/prettyping</span><br></pre></td></tr></table></figure>\n<p>就可以使用了。</p>\n<h3 id=\"让-ping-的输出清晰易读\"><a href=\"#让-ping-的输出清晰易读\" class=\"headerlink\" title=\"让 ping 的输出清晰易读\"></a>让 ping 的输出清晰易读</h3><p>安装完成后，通过 <code>prettyping</code> 来 ping 任何主机或 IP 地址，就可以以图形方式查看输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>输出效果大概会是这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-in-action.gif\" alt=\"\"></p>\n<p>如果你不带任何参数执行 <code>prettyping</code>，它就会一直运行直到被 <code>ctrl + c</code> 中断。</p>\n<p>由于 Prettyping 只是一个对普通 <code>ping</code> 命令的封装，所以常用的 ping 参数也是有效的。例如使用 <code>-c 5</code> 来指定 ping 一台主机的 5 次：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping -c 5 ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>Prettyping 默认会使用彩色输出，如果你不喜欢彩色的输出，可以加上 <code>--nocolor</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --nocolor ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>同样的，也可以用 <code>--nomulticolor</code> 参数禁用多颜色支持：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --nomulticolor ostechnix.com</span><br></pre></td></tr></table></figure>\n<p>使用 <code>--nounicode</code> 参数禁用 unicode 字符：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/09/prettyping-without-unicode-support.png\" alt=\"\"></p>\n<p>如果你的终端不支持 UTF-8，或者无法修复系统中的 unicode 字体，只需要加上 <code>--nounicode</code> 参数就能轻松解决。</p>\n<p>Prettyping 支持将输出的内容重定向到文件中，例如执行以下这个命令会将 <code>prettyping ostechnix.com</code> 的输出重定向到 <code>ostechnix.txt</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping ostechnix.com | tee ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>Prettyping 还有很多选项帮助你完成各种任务，例如：</p>\n<ul>\n<li>启用/禁用延时图例（默认启用）</li>\n<li>强制按照终端的格式输出（默认自动）</li>\n<li>在统计数据中统计最后的 n 次 ping（默认 60 次）</li>\n<li>覆盖对终端尺寸的自动检测</li>\n<li>指定 awk 解释器路径（默认：<code>awk</code>）</li>\n<li>指定 ping 工具路径（默认：<code>ping</code>）</li>\n</ul>\n<p>查看帮助文档可以了解更多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ prettyping --help</span><br></pre></td></tr></table></figure>\n<p>尽管 Prettyping 没有添加任何额外功能，但我个人喜欢它的这些优点：</p>\n<ul>\n<li>实时统计 —— 可以随时查看所有实时统计信息，标准 <code>ping</code> 命令只会在命令执行结束后才显示统计信息。</li>\n<li>紧凑的显示 —— 可以在终端看到更长的时间跨度。</li>\n<li>检测丢失的数据包并显示出来。</li>\n</ul>\n<p>如果你一直在寻找可视化显示 <code>ping</code> 命令输出的工具，那么 Prettyping 肯定会有所帮助。尝试一下，你不会失望的。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/prettyping-make-the-output-of-ping-command-prettier-and-easier-to-read/</a></p>\n"},{"title":"ProtectedText：一个免费的在线加密笔记","date":"2018-11-25T02:41:56.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/protected-text-720x340.png)\n\n记录笔记是我们每个人必备的重要技能，它可以帮助我们把自己听到、读到、学到的内容长期地保留下来，也有很多的应用和工具都能让我们更好地记录笔记。下面我要介绍一个叫做 **ProtectedText** 的应用，这是一个可以将你的笔记在线上保存起来的免费的加密笔记。它是一个免费的 web 服务，在上面记录文本以后，它将会对文本进行加密，只需要一台支持连接到互联网并且拥有 web 浏览器的设备，就可以访问到记录的内容。\n\nProtectedText 不会向你询问任何个人信息，也不会保存任何密码，没有广告，没有 Cookies，更没有用户跟踪和注册流程。除了拥有密码能够解密文本的人，任何人都无法查看到笔记的内容。而且，使用前不需要在网站上注册账号，写完笔记之后，直接关闭浏览器，你的笔记也就保存好了。\n\n### 在加密笔记本上记录笔记\n\n访问 <https://www.protectedtext.com/> 这个链接，就可以打开 ProtectedText 页面了（LCTT 译注：如果访问不了，你知道的）。这个时候你将进入网站主页，接下来需要在页面上的输入框输入一个你想用的名称，或者在地址栏后面直接加上想用的名称。这个名称是一个自定义的名称（例如 <https://www.protectedtext.com/mysite>），是你查看自己保存的笔记的专有入口。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-1.png)\n\n如果你选用的名称还没有被占用，你就会看到下图中的提示信息。点击 “Create” 键就可以创建你的个人笔记页了。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-2.png)\n\n至此你已经创建好了你自己的笔记页面，可以开始记录笔记了。目前每个笔记页的最大容量是每页 750000+ 个字符。\n\nProtectedText 使用 AES 算法对你的笔记内容进行加密和解密，而计算散列则使用了 SHA512 算法。\n\n笔记记录完毕以后，点击顶部的 “Save” 键保存。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-3.png)\n\n按下保存键之后，ProtectedText 会提示你输入密码以加密你的笔记内容。按照它的要求输入两次密码，然后点击 “Save” 键。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png)\n\n尽管 ProtectedText 对你使用的密码没有太多要求，但毕竟密码总是一寸长一寸强，所以还是最好使用长且复杂的密码（用到数字和特殊字符）以避免暴力破解。由于 ProtectedText 不会保存你的密码，一旦密码丢失，密码和笔记内容就都找不回来了。因此，请牢记你的密码，或者使用诸如 [Buttercup][3]、[KeeWeb][4] 这样的密码管理器来存储你的密码。\n\n在使用其它设备时，可以通过访问之前创建的 URL 就可以访问你的笔记了。届时会出现如下的提示信息，只需要输入正确的密码，就可以查看和编辑你的笔记。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png)\n\n一般情况下，只有知道密码的人才能正常访问笔记的内容。如果你希望将自己的笔记公开，只需要以 <https://www.protectedtext.com/yourSite?yourPassword> 的形式访问就可以了，ProtectedText 将会自动使用 `yourPassword` 字符串解密你的笔记。\n\nProtectedText 还有配套的 [Android 应用][6] 可以让你在移动设备上进行同步笔记、离线工作、备份笔记、锁定/解锁笔记等等操作。\n\n**优点**\n\n  * 简单、易用、快速、免费\n  * ProtectedText.com 的客户端代码可以在[这里][7]免费获取，如果你想了解它的底层实现，可以自行学习它的源代码\n  * 存储的内容没有到期时间，只要你愿意，笔记内容可以一直保存在服务器上\n  * 可以让你的数据限制为私有或公开开放\n\n**缺点**\n\n  * 尽管客户端代码是公开的，但服务端代码并没有公开，因此你无法自行搭建一个类似的服务。如果你不信任这个网站，请不要使用。\n  * 由于网站不存储你的任何个人信息，包括你的密码，因此如果你丢失了密码，数据将永远无法恢复。网站方还声称他们并不清楚谁拥有了哪些数据，所以一定要牢记密码。\n\n\n如果你想通过一种简单的方式将笔记保存到线上，并且需要在不需要安装任何工具的情况下访问，那么 ProtectedText 会是一个好的选择。如果你还知道其它类似的应用程序，欢迎在评论区留言！\n\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[2]: http://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png\n[3]: https://www.ostechnix.com/buttercup-a-free-secure-and-cross-platform-password-manager/\n[4]: https://www.ostechnix.com/keeweb-an-open-source-cross-platform-password-manager/\n[5]: http://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png\n[6]: https://play.google.com/store/apps/details?id=com.protectedtext.android\n[7]: https://www.protectedtext.com/js/main.js\n\n","source":"_posts/ProtectedText-A-Free-Encrypted-Notepad-To-Save-Your-Notes-Online.md","raw":"---\ntitle: ProtectedText：一个免费的在线加密笔记\ndate: 2018-11-25 10:41:56\ntags:\n  - 加密\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/protected-text-720x340.png)\n\n记录笔记是我们每个人必备的重要技能，它可以帮助我们把自己听到、读到、学到的内容长期地保留下来，也有很多的应用和工具都能让我们更好地记录笔记。下面我要介绍一个叫做 **ProtectedText** 的应用，这是一个可以将你的笔记在线上保存起来的免费的加密笔记。它是一个免费的 web 服务，在上面记录文本以后，它将会对文本进行加密，只需要一台支持连接到互联网并且拥有 web 浏览器的设备，就可以访问到记录的内容。\n\nProtectedText 不会向你询问任何个人信息，也不会保存任何密码，没有广告，没有 Cookies，更没有用户跟踪和注册流程。除了拥有密码能够解密文本的人，任何人都无法查看到笔记的内容。而且，使用前不需要在网站上注册账号，写完笔记之后，直接关闭浏览器，你的笔记也就保存好了。\n\n### 在加密笔记本上记录笔记\n\n访问 <https://www.protectedtext.com/> 这个链接，就可以打开 ProtectedText 页面了（LCTT 译注：如果访问不了，你知道的）。这个时候你将进入网站主页，接下来需要在页面上的输入框输入一个你想用的名称，或者在地址栏后面直接加上想用的名称。这个名称是一个自定义的名称（例如 <https://www.protectedtext.com/mysite>），是你查看自己保存的笔记的专有入口。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-1.png)\n\n如果你选用的名称还没有被占用，你就会看到下图中的提示信息。点击 “Create” 键就可以创建你的个人笔记页了。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-2.png)\n\n至此你已经创建好了你自己的笔记页面，可以开始记录笔记了。目前每个笔记页的最大容量是每页 750000+ 个字符。\n\nProtectedText 使用 AES 算法对你的笔记内容进行加密和解密，而计算散列则使用了 SHA512 算法。\n\n笔记记录完毕以后，点击顶部的 “Save” 键保存。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-3.png)\n\n按下保存键之后，ProtectedText 会提示你输入密码以加密你的笔记内容。按照它的要求输入两次密码，然后点击 “Save” 键。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png)\n\n尽管 ProtectedText 对你使用的密码没有太多要求，但毕竟密码总是一寸长一寸强，所以还是最好使用长且复杂的密码（用到数字和特殊字符）以避免暴力破解。由于 ProtectedText 不会保存你的密码，一旦密码丢失，密码和笔记内容就都找不回来了。因此，请牢记你的密码，或者使用诸如 [Buttercup][3]、[KeeWeb][4] 这样的密码管理器来存储你的密码。\n\n在使用其它设备时，可以通过访问之前创建的 URL 就可以访问你的笔记了。届时会出现如下的提示信息，只需要输入正确的密码，就可以查看和编辑你的笔记。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png)\n\n一般情况下，只有知道密码的人才能正常访问笔记的内容。如果你希望将自己的笔记公开，只需要以 <https://www.protectedtext.com/yourSite?yourPassword> 的形式访问就可以了，ProtectedText 将会自动使用 `yourPassword` 字符串解密你的笔记。\n\nProtectedText 还有配套的 [Android 应用][6] 可以让你在移动设备上进行同步笔记、离线工作、备份笔记、锁定/解锁笔记等等操作。\n\n**优点**\n\n  * 简单、易用、快速、免费\n  * ProtectedText.com 的客户端代码可以在[这里][7]免费获取，如果你想了解它的底层实现，可以自行学习它的源代码\n  * 存储的内容没有到期时间，只要你愿意，笔记内容可以一直保存在服务器上\n  * 可以让你的数据限制为私有或公开开放\n\n**缺点**\n\n  * 尽管客户端代码是公开的，但服务端代码并没有公开，因此你无法自行搭建一个类似的服务。如果你不信任这个网站，请不要使用。\n  * 由于网站不存储你的任何个人信息，包括你的密码，因此如果你丢失了密码，数据将永远无法恢复。网站方还声称他们并不清楚谁拥有了哪些数据，所以一定要牢记密码。\n\n\n如果你想通过一种简单的方式将笔记保存到线上，并且需要在不需要安装任何工具的情况下访问，那么 ProtectedText 会是一个好的选择。如果你还知道其它类似的应用程序，欢迎在评论区留言！\n\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[2]: http://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png\n[3]: https://www.ostechnix.com/buttercup-a-free-secure-and-cross-platform-password-manager/\n[4]: https://www.ostechnix.com/keeweb-an-open-source-cross-platform-password-manager/\n[5]: http://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png\n[6]: https://play.google.com/store/apps/details?id=com.protectedtext.android\n[7]: https://www.protectedtext.com/js/main.js\n\n","slug":"ProtectedText-A-Free-Encrypted-Notepad-To-Save-Your-Notes-Online","published":1,"updated":"2019-03-28T12:59:07.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0d3001klixu86a1wkeb","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/protected-text-720x340.png\" alt=\"\"></p>\n<p>记录笔记是我们每个人必备的重要技能，它可以帮助我们把自己听到、读到、学到的内容长期地保留下来，也有很多的应用和工具都能让我们更好地记录笔记。下面我要介绍一个叫做 <strong>ProtectedText</strong> 的应用，这是一个可以将你的笔记在线上保存起来的免费的加密笔记。它是一个免费的 web 服务，在上面记录文本以后，它将会对文本进行加密，只需要一台支持连接到互联网并且拥有 web 浏览器的设备，就可以访问到记录的内容。</p>\n<p>ProtectedText 不会向你询问任何个人信息，也不会保存任何密码，没有广告，没有 Cookies，更没有用户跟踪和注册流程。除了拥有密码能够解密文本的人，任何人都无法查看到笔记的内容。而且，使用前不需要在网站上注册账号，写完笔记之后，直接关闭浏览器，你的笔记也就保存好了。</p>\n<h3 id=\"在加密笔记本上记录笔记\"><a href=\"#在加密笔记本上记录笔记\" class=\"headerlink\" title=\"在加密笔记本上记录笔记\"></a>在加密笔记本上记录笔记</h3><p>访问 <a href=\"https://www.protectedtext.com/\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/</a> 这个链接，就可以打开 ProtectedText 页面了（LCTT 译注：如果访问不了，你知道的）。这个时候你将进入网站主页，接下来需要在页面上的输入框输入一个你想用的名称，或者在地址栏后面直接加上想用的名称。这个名称是一个自定义的名称（例如 <a href=\"https://www.protectedtext.com/mysite\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/mysite</a>），是你查看自己保存的笔记的专有入口。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-1.png\" alt=\"\"></p>\n<p>如果你选用的名称还没有被占用，你就会看到下图中的提示信息。点击 “Create” 键就可以创建你的个人笔记页了。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-2.png\" alt=\"\"></p>\n<p>至此你已经创建好了你自己的笔记页面，可以开始记录笔记了。目前每个笔记页的最大容量是每页 750000+ 个字符。</p>\n<p>ProtectedText 使用 AES 算法对你的笔记内容进行加密和解密，而计算散列则使用了 SHA512 算法。</p>\n<p>笔记记录完毕以后，点击顶部的 “Save” 键保存。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-3.png\" alt=\"\"></p>\n<p>按下保存键之后，ProtectedText 会提示你输入密码以加密你的笔记内容。按照它的要求输入两次密码，然后点击 “Save” 键。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png\" alt=\"\"></p>\n<p>尽管 ProtectedText 对你使用的密码没有太多要求，但毕竟密码总是一寸长一寸强，所以还是最好使用长且复杂的密码（用到数字和特殊字符）以避免暴力破解。由于 ProtectedText 不会保存你的密码，一旦密码丢失，密码和笔记内容就都找不回来了。因此，请牢记你的密码，或者使用诸如 <a href=\"https://www.ostechnix.com/buttercup-a-free-secure-and-cross-platform-password-manager/\" target=\"_blank\" rel=\"noopener\">Buttercup</a>、<a href=\"https://www.ostechnix.com/keeweb-an-open-source-cross-platform-password-manager/\" target=\"_blank\" rel=\"noopener\">KeeWeb</a> 这样的密码管理器来存储你的密码。</p>\n<p>在使用其它设备时，可以通过访问之前创建的 URL 就可以访问你的笔记了。届时会出现如下的提示信息，只需要输入正确的密码，就可以查看和编辑你的笔记。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png\" alt=\"\"></p>\n<p>一般情况下，只有知道密码的人才能正常访问笔记的内容。如果你希望将自己的笔记公开，只需要以 <a href=\"https://www.protectedtext.com/yourSite?yourPassword\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/yourSite?yourPassword</a> 的形式访问就可以了，ProtectedText 将会自动使用 <code>yourPassword</code> 字符串解密你的笔记。</p>\n<p>ProtectedText 还有配套的 <a href=\"https://play.google.com/store/apps/details?id=com.protectedtext.android\" target=\"_blank\" rel=\"noopener\">Android 应用</a> 可以让你在移动设备上进行同步笔记、离线工作、备份笔记、锁定/解锁笔记等等操作。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>简单、易用、快速、免费</li>\n<li>ProtectedText.com 的客户端代码可以在<a href=\"https://www.protectedtext.com/js/main.js\" target=\"_blank\" rel=\"noopener\">这里</a>免费获取，如果你想了解它的底层实现，可以自行学习它的源代码</li>\n<li>存储的内容没有到期时间，只要你愿意，笔记内容可以一直保存在服务器上</li>\n<li>可以让你的数据限制为私有或公开开放</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>尽管客户端代码是公开的，但服务端代码并没有公开，因此你无法自行搭建一个类似的服务。如果你不信任这个网站，请不要使用。</li>\n<li>由于网站不存储你的任何个人信息，包括你的密码，因此如果你丢失了密码，数据将永远无法恢复。网站方还声称他们并不清楚谁拥有了哪些数据，所以一定要牢记密码。</li>\n</ul>\n<p>如果你想通过一种简单的方式将笔记保存到线上，并且需要在不需要安装任何工具的情况下访问，那么 ProtectedText 会是一个好的选择。如果你还知道其它类似的应用程序，欢迎在评论区留言！</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/protected-text-720x340.png\" alt=\"\"></p>\n<p>记录笔记是我们每个人必备的重要技能，它可以帮助我们把自己听到、读到、学到的内容长期地保留下来，也有很多的应用和工具都能让我们更好地记录笔记。下面我要介绍一个叫做 <strong>ProtectedText</strong> 的应用，这是一个可以将你的笔记在线上保存起来的免费的加密笔记。它是一个免费的 web 服务，在上面记录文本以后，它将会对文本进行加密，只需要一台支持连接到互联网并且拥有 web 浏览器的设备，就可以访问到记录的内容。</p>\n<p>ProtectedText 不会向你询问任何个人信息，也不会保存任何密码，没有广告，没有 Cookies，更没有用户跟踪和注册流程。除了拥有密码能够解密文本的人，任何人都无法查看到笔记的内容。而且，使用前不需要在网站上注册账号，写完笔记之后，直接关闭浏览器，你的笔记也就保存好了。</p>\n<h3 id=\"在加密笔记本上记录笔记\"><a href=\"#在加密笔记本上记录笔记\" class=\"headerlink\" title=\"在加密笔记本上记录笔记\"></a>在加密笔记本上记录笔记</h3><p>访问 <a href=\"https://www.protectedtext.com/\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/</a> 这个链接，就可以打开 ProtectedText 页面了（LCTT 译注：如果访问不了，你知道的）。这个时候你将进入网站主页，接下来需要在页面上的输入框输入一个你想用的名称，或者在地址栏后面直接加上想用的名称。这个名称是一个自定义的名称（例如 <a href=\"https://www.protectedtext.com/mysite\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/mysite</a>），是你查看自己保存的笔记的专有入口。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-1.png\" alt=\"\"></p>\n<p>如果你选用的名称还没有被占用，你就会看到下图中的提示信息。点击 “Create” 键就可以创建你的个人笔记页了。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-2.png\" alt=\"\"></p>\n<p>至此你已经创建好了你自己的笔记页面，可以开始记录笔记了。目前每个笔记页的最大容量是每页 750000+ 个字符。</p>\n<p>ProtectedText 使用 AES 算法对你的笔记内容进行加密和解密，而计算散列则使用了 SHA512 算法。</p>\n<p>笔记记录完毕以后，点击顶部的 “Save” 键保存。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-3.png\" alt=\"\"></p>\n<p>按下保存键之后，ProtectedText 会提示你输入密码以加密你的笔记内容。按照它的要求输入两次密码，然后点击 “Save” 键。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-4.png\" alt=\"\"></p>\n<p>尽管 ProtectedText 对你使用的密码没有太多要求，但毕竟密码总是一寸长一寸强，所以还是最好使用长且复杂的密码（用到数字和特殊字符）以避免暴力破解。由于 ProtectedText 不会保存你的密码，一旦密码丢失，密码和笔记内容就都找不回来了。因此，请牢记你的密码，或者使用诸如 <a href=\"https://www.ostechnix.com/buttercup-a-free-secure-and-cross-platform-password-manager/\" target=\"_blank\" rel=\"noopener\">Buttercup</a>、<a href=\"https://www.ostechnix.com/keeweb-an-open-source-cross-platform-password-manager/\" target=\"_blank\" rel=\"noopener\">KeeWeb</a> 这样的密码管理器来存储你的密码。</p>\n<p>在使用其它设备时，可以通过访问之前创建的 URL 就可以访问你的笔记了。届时会出现如下的提示信息，只需要输入正确的密码，就可以查看和编辑你的笔记。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Protected-Text-5.png\" alt=\"\"></p>\n<p>一般情况下，只有知道密码的人才能正常访问笔记的内容。如果你希望将自己的笔记公开，只需要以 <a href=\"https://www.protectedtext.com/yourSite?yourPassword\" target=\"_blank\" rel=\"noopener\">https://www.protectedtext.com/yourSite?yourPassword</a> 的形式访问就可以了，ProtectedText 将会自动使用 <code>yourPassword</code> 字符串解密你的笔记。</p>\n<p>ProtectedText 还有配套的 <a href=\"https://play.google.com/store/apps/details?id=com.protectedtext.android\" target=\"_blank\" rel=\"noopener\">Android 应用</a> 可以让你在移动设备上进行同步笔记、离线工作、备份笔记、锁定/解锁笔记等等操作。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>简单、易用、快速、免费</li>\n<li>ProtectedText.com 的客户端代码可以在<a href=\"https://www.protectedtext.com/js/main.js\" target=\"_blank\" rel=\"noopener\">这里</a>免费获取，如果你想了解它的底层实现，可以自行学习它的源代码</li>\n<li>存储的内容没有到期时间，只要你愿意，笔记内容可以一直保存在服务器上</li>\n<li>可以让你的数据限制为私有或公开开放</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>尽管客户端代码是公开的，但服务端代码并没有公开，因此你无法自行搭建一个类似的服务。如果你不信任这个网站，请不要使用。</li>\n<li>由于网站不存储你的任何个人信息，包括你的密码，因此如果你丢失了密码，数据将永远无法恢复。网站方还声称他们并不清楚谁拥有了哪些数据，所以一定要牢记密码。</li>\n</ul>\n<p>如果你想通过一种简单的方式将笔记保存到线上，并且需要在不需要安装任何工具的情况下访问，那么 ProtectedText 会是一个好的选择。如果你还知道其它类似的应用程序，欢迎在评论区留言！</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/protectedtext-a-free-encrypted-notepad-to-save-your-notes-online/</a></p>\n"},{"title":"使用 Python 为你的油箱加油","date":"2018-10-17T16:37:29.000Z","_content":"\n> 我来介绍一下我是如何使用 Python 来节省成本的。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bulb-light-energy-power-idea.png?itok=zTEEmTZB)\n\n我最近在开一辆烧 93 号汽油的车子。根据汽车制造商的说法，它只需要加 91 号汽油就可以了。然而，在美国只能买到 87 号、89 号、93 号汽油。而我家附近的汽油的物价水平是每增加一号，每加仑就要多付 30 美分，因此如果加 93 号汽油，每加仑就要多花 60 美分。为什么不能节省一些钱呢？\n\n一开始很简单，只需要先加满 93 号汽油，然后在油量表显示油箱半满的时候，用 89 号汽油加满，就得到一整箱 91 号汽油了。但接下来就麻烦了，剩下半箱 91 号汽油加上半箱 93 号汽油，只会变成一箱 92 号汽油，再接下来呢？如果继续算下去，只会越来越混乱。这个时候 Python 就派上用场了。\n\n我的方案是，可以根据汽油的实时状态，不断向油箱中加入 93 号汽油或者 89 号汽油，而最终目标是使油箱内汽油的号数不低于 91。我需要做的是只是通过一些算法来判断新旧汽油混合之后的号数。使用多项式方程或许也可以解决这个问题，但如果使用 Python，好像只需要进行循环就可以了。\n\n```\n#!/usr/bin/env python\n# octane.py\n\no = 93.0\nnewgas = 93.0   # 这个变量记录上一次加入的汽油号数\ni = 1\nwhile i < 21:                   # 20 次迭代 (加油次数)\n    if newgas == 89.0:          # 如果上一次加的是 89 号汽油，改加 93 号汽油\n        newgas = 93.0\n        o = newgas/2 + o/2      # 当油箱半满的时候就加油\n    else:                       # 如果上一次加的是 93 号汽油，则改加 89 号汽油\n        newgas = 89.0\n        o = newgas/2 + o/2      # 当油箱半满的时候就加油\n    print str(i) + ': '+ str(o)\n    i += 1\n```\n\n在代码中，我首先将变量 `o`（油箱中的当前混合汽油号数）和变量 `newgas`（上一次加入的汽油号数）的初始值都设为 93，然后循环 20 次，也就是分别加入 89 号汽油和 93 号汽油一共 20 次，以保持混合汽油号数稳定。\n\n```\n1: 91.0\n2: 92.0\n3: 90.5\n4: 91.75\n5: 90.375\n6: 91.6875\n7: 90.34375\n8: 91.671875\n9: 90.3359375\n10: 91.66796875\n11: 90.333984375\n12: 91.6669921875\n13: 90.3334960938\n14: 91.6667480469\n15: 90.3333740234\n16: 91.6666870117\n17: 90.3333435059\n18: 91.6666717529\n19: 90.3333358765\n20: 91.6666679382\n```\n\n从以上数据来看，只需要 10 到 15 次循环，汽油号数就比较稳定了，也相当接近 91 号汽油的目标。这种交替混合直到稳定的现象看起来很有趣，每次交替加入同等量的不同号数汽油，都会趋于稳定。实际上，即使加入的 89 号汽油和 93 号汽油的量不同，也会趋于稳定。\n\n因此，我尝试了不同的比例，我认为加入的 93 号汽油需要比 89 号汽油更多一点。在尽量少补充新汽油的情况下，我最终计算到的结果是 89 号汽油要在油箱大约 7/12 满的时候加进去，而 93 号汽油则要在油箱 1/4 满的时候才加进去。\n\n我的循环将会更改成这样：\n\n```\n    if newgas == 89.0:            \n                                 \n        newgas = 93.0\n        o = 3*newgas/4 + o/4      \n    else:                        \n        newgas = 89.0\n        o = 5*newgas/12 + 7*o/12\n```\n\n以下是从第十次加油开始的混合汽油号数：\n\n```\n10: 92.5122272978\n11: 91.0487992571\n12: 92.5121998143\n13: 91.048783225\n14: 92.5121958062\n15: 91.048780887\n```\n\n如你所见，这个调整会令混合汽油号数始终略高于 91。当然，我的油量表并没有 1/12 的刻度，但是 7/12 略小于 5/8，我可以近似地计算。\n\n一个更简单地方案是每次都首先加满 93 号汽油，然后在油箱半满时加入 89 号汽油直到耗尽，这可能会是我的常规方案。就我个人而言，这种方法并不太好，有时甚至会产生一些麻烦。但对于长途旅行来说，这种方案会相对简便一些。有时我也会因为油价突然下跌而购买一些汽油，所以，这个方案是我可以考虑的一系列选项之一。\n\n当然最重要的是：开车不写码，写码不开车！\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/python-gas-pump\n\n[a]: https://opensource.com/users/greg-p\n\n","source":"_posts/Python-at-the-pump-A-script-for-filling-your-gas-tank.md","raw":"---\ntitle: 使用 Python 为你的油箱加油\ndate: 2018-10-18 00:37:29\ntags:\n  - Python\n  - LCTT 翻译\n---\n\n> 我来介绍一下我是如何使用 Python 来节省成本的。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bulb-light-energy-power-idea.png?itok=zTEEmTZB)\n\n我最近在开一辆烧 93 号汽油的车子。根据汽车制造商的说法，它只需要加 91 号汽油就可以了。然而，在美国只能买到 87 号、89 号、93 号汽油。而我家附近的汽油的物价水平是每增加一号，每加仑就要多付 30 美分，因此如果加 93 号汽油，每加仑就要多花 60 美分。为什么不能节省一些钱呢？\n\n一开始很简单，只需要先加满 93 号汽油，然后在油量表显示油箱半满的时候，用 89 号汽油加满，就得到一整箱 91 号汽油了。但接下来就麻烦了，剩下半箱 91 号汽油加上半箱 93 号汽油，只会变成一箱 92 号汽油，再接下来呢？如果继续算下去，只会越来越混乱。这个时候 Python 就派上用场了。\n\n我的方案是，可以根据汽油的实时状态，不断向油箱中加入 93 号汽油或者 89 号汽油，而最终目标是使油箱内汽油的号数不低于 91。我需要做的是只是通过一些算法来判断新旧汽油混合之后的号数。使用多项式方程或许也可以解决这个问题，但如果使用 Python，好像只需要进行循环就可以了。\n\n```\n#!/usr/bin/env python\n# octane.py\n\no = 93.0\nnewgas = 93.0   # 这个变量记录上一次加入的汽油号数\ni = 1\nwhile i < 21:                   # 20 次迭代 (加油次数)\n    if newgas == 89.0:          # 如果上一次加的是 89 号汽油，改加 93 号汽油\n        newgas = 93.0\n        o = newgas/2 + o/2      # 当油箱半满的时候就加油\n    else:                       # 如果上一次加的是 93 号汽油，则改加 89 号汽油\n        newgas = 89.0\n        o = newgas/2 + o/2      # 当油箱半满的时候就加油\n    print str(i) + ': '+ str(o)\n    i += 1\n```\n\n在代码中，我首先将变量 `o`（油箱中的当前混合汽油号数）和变量 `newgas`（上一次加入的汽油号数）的初始值都设为 93，然后循环 20 次，也就是分别加入 89 号汽油和 93 号汽油一共 20 次，以保持混合汽油号数稳定。\n\n```\n1: 91.0\n2: 92.0\n3: 90.5\n4: 91.75\n5: 90.375\n6: 91.6875\n7: 90.34375\n8: 91.671875\n9: 90.3359375\n10: 91.66796875\n11: 90.333984375\n12: 91.6669921875\n13: 90.3334960938\n14: 91.6667480469\n15: 90.3333740234\n16: 91.6666870117\n17: 90.3333435059\n18: 91.6666717529\n19: 90.3333358765\n20: 91.6666679382\n```\n\n从以上数据来看，只需要 10 到 15 次循环，汽油号数就比较稳定了，也相当接近 91 号汽油的目标。这种交替混合直到稳定的现象看起来很有趣，每次交替加入同等量的不同号数汽油，都会趋于稳定。实际上，即使加入的 89 号汽油和 93 号汽油的量不同，也会趋于稳定。\n\n因此，我尝试了不同的比例，我认为加入的 93 号汽油需要比 89 号汽油更多一点。在尽量少补充新汽油的情况下，我最终计算到的结果是 89 号汽油要在油箱大约 7/12 满的时候加进去，而 93 号汽油则要在油箱 1/4 满的时候才加进去。\n\n我的循环将会更改成这样：\n\n```\n    if newgas == 89.0:            \n                                 \n        newgas = 93.0\n        o = 3*newgas/4 + o/4      \n    else:                        \n        newgas = 89.0\n        o = 5*newgas/12 + 7*o/12\n```\n\n以下是从第十次加油开始的混合汽油号数：\n\n```\n10: 92.5122272978\n11: 91.0487992571\n12: 92.5121998143\n13: 91.048783225\n14: 92.5121958062\n15: 91.048780887\n```\n\n如你所见，这个调整会令混合汽油号数始终略高于 91。当然，我的油量表并没有 1/12 的刻度，但是 7/12 略小于 5/8，我可以近似地计算。\n\n一个更简单地方案是每次都首先加满 93 号汽油，然后在油箱半满时加入 89 号汽油直到耗尽，这可能会是我的常规方案。就我个人而言，这种方法并不太好，有时甚至会产生一些麻烦。但对于长途旅行来说，这种方案会相对简便一些。有时我也会因为油价突然下跌而购买一些汽油，所以，这个方案是我可以考虑的一系列选项之一。\n\n当然最重要的是：开车不写码，写码不开车！\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/10/python-gas-pump\n\n[a]: https://opensource.com/users/greg-p\n\n","slug":"Python-at-the-pump-A-script-for-filling-your-gas-tank","published":1,"updated":"2019-03-28T11:58:46.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0d7001mlixuf3t72kco","content":"<blockquote>\n<p>我来介绍一下我是如何使用 Python 来节省成本的。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bulb-light-energy-power-idea.png?itok=zTEEmTZB\" alt=\"\"></p>\n<p>我最近在开一辆烧 93 号汽油的车子。根据汽车制造商的说法，它只需要加 91 号汽油就可以了。然而，在美国只能买到 87 号、89 号、93 号汽油。而我家附近的汽油的物价水平是每增加一号，每加仑就要多付 30 美分，因此如果加 93 号汽油，每加仑就要多花 60 美分。为什么不能节省一些钱呢？</p>\n<p>一开始很简单，只需要先加满 93 号汽油，然后在油量表显示油箱半满的时候，用 89 号汽油加满，就得到一整箱 91 号汽油了。但接下来就麻烦了，剩下半箱 91 号汽油加上半箱 93 号汽油，只会变成一箱 92 号汽油，再接下来呢？如果继续算下去，只会越来越混乱。这个时候 Python 就派上用场了。</p>\n<p>我的方案是，可以根据汽油的实时状态，不断向油箱中加入 93 号汽油或者 89 号汽油，而最终目标是使油箱内汽油的号数不低于 91。我需要做的是只是通过一些算法来判断新旧汽油混合之后的号数。使用多项式方程或许也可以解决这个问题，但如果使用 Python，好像只需要进行循环就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># octane.py</span><br><span class=\"line\"></span><br><span class=\"line\">o = 93.0</span><br><span class=\"line\">newgas = 93.0   # 这个变量记录上一次加入的汽油号数</span><br><span class=\"line\">i = 1</span><br><span class=\"line\">while i &lt; 21:                   # 20 次迭代 (加油次数)</span><br><span class=\"line\">    if newgas == 89.0:          # 如果上一次加的是 89 号汽油，改加 93 号汽油</span><br><span class=\"line\">        newgas = 93.0</span><br><span class=\"line\">        o = newgas/2 + o/2      # 当油箱半满的时候就加油</span><br><span class=\"line\">    else:                       # 如果上一次加的是 93 号汽油，则改加 89 号汽油</span><br><span class=\"line\">        newgas = 89.0</span><br><span class=\"line\">        o = newgas/2 + o/2      # 当油箱半满的时候就加油</span><br><span class=\"line\">    print str(i) + &apos;: &apos;+ str(o)</span><br><span class=\"line\">    i += 1</span><br></pre></td></tr></table></figure>\n<p>在代码中，我首先将变量 <code>o</code>（油箱中的当前混合汽油号数）和变量 <code>newgas</code>（上一次加入的汽油号数）的初始值都设为 93，然后循环 20 次，也就是分别加入 89 号汽油和 93 号汽油一共 20 次，以保持混合汽油号数稳定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: 91.0</span><br><span class=\"line\">2: 92.0</span><br><span class=\"line\">3: 90.5</span><br><span class=\"line\">4: 91.75</span><br><span class=\"line\">5: 90.375</span><br><span class=\"line\">6: 91.6875</span><br><span class=\"line\">7: 90.34375</span><br><span class=\"line\">8: 91.671875</span><br><span class=\"line\">9: 90.3359375</span><br><span class=\"line\">10: 91.66796875</span><br><span class=\"line\">11: 90.333984375</span><br><span class=\"line\">12: 91.6669921875</span><br><span class=\"line\">13: 90.3334960938</span><br><span class=\"line\">14: 91.6667480469</span><br><span class=\"line\">15: 90.3333740234</span><br><span class=\"line\">16: 91.6666870117</span><br><span class=\"line\">17: 90.3333435059</span><br><span class=\"line\">18: 91.6666717529</span><br><span class=\"line\">19: 90.3333358765</span><br><span class=\"line\">20: 91.6666679382</span><br></pre></td></tr></table></figure>\n<p>从以上数据来看，只需要 10 到 15 次循环，汽油号数就比较稳定了，也相当接近 91 号汽油的目标。这种交替混合直到稳定的现象看起来很有趣，每次交替加入同等量的不同号数汽油，都会趋于稳定。实际上，即使加入的 89 号汽油和 93 号汽油的量不同，也会趋于稳定。</p>\n<p>因此，我尝试了不同的比例，我认为加入的 93 号汽油需要比 89 号汽油更多一点。在尽量少补充新汽油的情况下，我最终计算到的结果是 89 号汽油要在油箱大约 7/12 满的时候加进去，而 93 号汽油则要在油箱 1/4 满的时候才加进去。</p>\n<p>我的循环将会更改成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if newgas == 89.0:            </span><br><span class=\"line\">                             </span><br><span class=\"line\">    newgas = 93.0</span><br><span class=\"line\">    o = 3*newgas/4 + o/4      </span><br><span class=\"line\">else:                        </span><br><span class=\"line\">    newgas = 89.0</span><br><span class=\"line\">    o = 5*newgas/12 + 7*o/12</span><br></pre></td></tr></table></figure>\n<p>以下是从第十次加油开始的混合汽油号数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10: 92.5122272978</span><br><span class=\"line\">11: 91.0487992571</span><br><span class=\"line\">12: 92.5121998143</span><br><span class=\"line\">13: 91.048783225</span><br><span class=\"line\">14: 92.5121958062</span><br><span class=\"line\">15: 91.048780887</span><br></pre></td></tr></table></figure>\n<p>如你所见，这个调整会令混合汽油号数始终略高于 91。当然，我的油量表并没有 1/12 的刻度，但是 7/12 略小于 5/8，我可以近似地计算。</p>\n<p>一个更简单地方案是每次都首先加满 93 号汽油，然后在油箱半满时加入 89 号汽油直到耗尽，这可能会是我的常规方案。就我个人而言，这种方法并不太好，有时甚至会产生一些麻烦。但对于长途旅行来说，这种方案会相对简便一些。有时我也会因为油价突然下跌而购买一些汽油，所以，这个方案是我可以考虑的一系列选项之一。</p>\n<p>当然最重要的是：开车不写码，写码不开车！</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/python-gas-pump\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/python-gas-pump</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我来介绍一下我是如何使用 Python 来节省成本的。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/bulb-light-energy-power-idea.png?itok=zTEEmTZB\" alt=\"\"></p>\n<p>我最近在开一辆烧 93 号汽油的车子。根据汽车制造商的说法，它只需要加 91 号汽油就可以了。然而，在美国只能买到 87 号、89 号、93 号汽油。而我家附近的汽油的物价水平是每增加一号，每加仑就要多付 30 美分，因此如果加 93 号汽油，每加仑就要多花 60 美分。为什么不能节省一些钱呢？</p>\n<p>一开始很简单，只需要先加满 93 号汽油，然后在油量表显示油箱半满的时候，用 89 号汽油加满，就得到一整箱 91 号汽油了。但接下来就麻烦了，剩下半箱 91 号汽油加上半箱 93 号汽油，只会变成一箱 92 号汽油，再接下来呢？如果继续算下去，只会越来越混乱。这个时候 Python 就派上用场了。</p>\n<p>我的方案是，可以根据汽油的实时状态，不断向油箱中加入 93 号汽油或者 89 号汽油，而最终目标是使油箱内汽油的号数不低于 91。我需要做的是只是通过一些算法来判断新旧汽油混合之后的号数。使用多项式方程或许也可以解决这个问题，但如果使用 Python，好像只需要进行循环就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># octane.py</span><br><span class=\"line\"></span><br><span class=\"line\">o = 93.0</span><br><span class=\"line\">newgas = 93.0   # 这个变量记录上一次加入的汽油号数</span><br><span class=\"line\">i = 1</span><br><span class=\"line\">while i &lt; 21:                   # 20 次迭代 (加油次数)</span><br><span class=\"line\">    if newgas == 89.0:          # 如果上一次加的是 89 号汽油，改加 93 号汽油</span><br><span class=\"line\">        newgas = 93.0</span><br><span class=\"line\">        o = newgas/2 + o/2      # 当油箱半满的时候就加油</span><br><span class=\"line\">    else:                       # 如果上一次加的是 93 号汽油，则改加 89 号汽油</span><br><span class=\"line\">        newgas = 89.0</span><br><span class=\"line\">        o = newgas/2 + o/2      # 当油箱半满的时候就加油</span><br><span class=\"line\">    print str(i) + &apos;: &apos;+ str(o)</span><br><span class=\"line\">    i += 1</span><br></pre></td></tr></table></figure>\n<p>在代码中，我首先将变量 <code>o</code>（油箱中的当前混合汽油号数）和变量 <code>newgas</code>（上一次加入的汽油号数）的初始值都设为 93，然后循环 20 次，也就是分别加入 89 号汽油和 93 号汽油一共 20 次，以保持混合汽油号数稳定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: 91.0</span><br><span class=\"line\">2: 92.0</span><br><span class=\"line\">3: 90.5</span><br><span class=\"line\">4: 91.75</span><br><span class=\"line\">5: 90.375</span><br><span class=\"line\">6: 91.6875</span><br><span class=\"line\">7: 90.34375</span><br><span class=\"line\">8: 91.671875</span><br><span class=\"line\">9: 90.3359375</span><br><span class=\"line\">10: 91.66796875</span><br><span class=\"line\">11: 90.333984375</span><br><span class=\"line\">12: 91.6669921875</span><br><span class=\"line\">13: 90.3334960938</span><br><span class=\"line\">14: 91.6667480469</span><br><span class=\"line\">15: 90.3333740234</span><br><span class=\"line\">16: 91.6666870117</span><br><span class=\"line\">17: 90.3333435059</span><br><span class=\"line\">18: 91.6666717529</span><br><span class=\"line\">19: 90.3333358765</span><br><span class=\"line\">20: 91.6666679382</span><br></pre></td></tr></table></figure>\n<p>从以上数据来看，只需要 10 到 15 次循环，汽油号数就比较稳定了，也相当接近 91 号汽油的目标。这种交替混合直到稳定的现象看起来很有趣，每次交替加入同等量的不同号数汽油，都会趋于稳定。实际上，即使加入的 89 号汽油和 93 号汽油的量不同，也会趋于稳定。</p>\n<p>因此，我尝试了不同的比例，我认为加入的 93 号汽油需要比 89 号汽油更多一点。在尽量少补充新汽油的情况下，我最终计算到的结果是 89 号汽油要在油箱大约 7/12 满的时候加进去，而 93 号汽油则要在油箱 1/4 满的时候才加进去。</p>\n<p>我的循环将会更改成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if newgas == 89.0:            </span><br><span class=\"line\">                             </span><br><span class=\"line\">    newgas = 93.0</span><br><span class=\"line\">    o = 3*newgas/4 + o/4      </span><br><span class=\"line\">else:                        </span><br><span class=\"line\">    newgas = 89.0</span><br><span class=\"line\">    o = 5*newgas/12 + 7*o/12</span><br></pre></td></tr></table></figure>\n<p>以下是从第十次加油开始的混合汽油号数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10: 92.5122272978</span><br><span class=\"line\">11: 91.0487992571</span><br><span class=\"line\">12: 92.5121998143</span><br><span class=\"line\">13: 91.048783225</span><br><span class=\"line\">14: 92.5121958062</span><br><span class=\"line\">15: 91.048780887</span><br></pre></td></tr></table></figure>\n<p>如你所见，这个调整会令混合汽油号数始终略高于 91。当然，我的油量表并没有 1/12 的刻度，但是 7/12 略小于 5/8，我可以近似地计算。</p>\n<p>一个更简单地方案是每次都首先加满 93 号汽油，然后在油箱半满时加入 89 号汽油直到耗尽，这可能会是我的常规方案。就我个人而言，这种方法并不太好，有时甚至会产生一些麻烦。但对于长途旅行来说，这种方案会相对简便一些。有时我也会因为油价突然下跌而购买一些汽油，所以，这个方案是我可以考虑的一系列选项之一。</p>\n<p>当然最重要的是：开车不写码，写码不开车！</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/10/python-gas-pump\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/10/python-gas-pump</a></p>\n"},{"title":"使用 NetworkManager 随机化你的 MAC 地址","date":"2018-09-19T00:11:25.000Z","_content":"\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/randomizemacaddress-816x345.png)\n\n今时今日，无论在家里的沙发上，还是在外面的咖啡厅，只要打开笔记本电脑，连上 Wi-Fi，就能通过网络与外界保持联系。但现在的 Wi-Fi 热点们大都能够通过[每张网卡对应的唯一 MAC 地址][1]来追踪你的设备。下面就来看一下如何避免被追踪。\n\n现在很多人已经开始注重个人隐私这个问题。个人隐私问题并不仅仅指防止他人能够访问到你电脑上的私有内容（这又是另一个问题了），而更多的是指<ruby>可追踪性<rt>legibility</rt></ruby>，也就是是否能够被轻易地统计和追踪到。大家都应该[对此更加重视][2]。同时，这方面的底线是，服务提供者在得到了用户的授权后才能对用户进行追踪，例如机场的计时 Wi-Fi 只有在用户授权后才能够使用。\n\n因为固定的 MAC 地址能被轻易地追踪到，所以应该定时进行更换，随机的 MAC 地址是一个好的选择。由于 MAC 地址一般只在局域网内使用，因此随机的 MAC 地址也不大会产生[冲突][3]。\n\n### 配置 NetworkManager\n\n要将随机的 MAC 地址默认地用于所有的 Wi-Fi 连接，需要创建 `/etc/NetworkManager/conf.d/00-macrandomize.conf` 这个文件：\n\n```\n[device]\nwifi.scan-rand-mac-address=yes\n\n[connection]\nwifi.cloned-mac-address=stable\nethernet.cloned-mac-address=stable\nconnection.stable-id=${CONNECTION}/${BOOT}\n```\n\n然后重启 NetworkManager ：\n\n```\nsystemctl restart NetworkManager\n```\n\n以上配置文件中，将 `cloned-mac-address` 的值设置为 `stable` 就可以在每次 NetworkManager 激活连接的时候都生成相同的 MAC 地址，但连接时使用不同的 MAC 地址。如果要在每次激活连接时也获得随机的 MAC 地址，需要将 `cloned-mac-address` 的值设置为 `random`。\n\n设置为 `stable` 可以从 DHCP 获取相同的 IP 地址，也可以让 Wi-Fi 的<ruby>[强制主页](https://en.wikipedia.org/wiki/Captive_portal)<rt>captive portal</rt></ruby>根据 MAC 地址记住你的登录状态。如果设置为 `random` ，在每次连接的时候都需要重新认证（或者点击“我同意”），在使用机场 Wi-Fi 的时候会需要到这种 `random` 模式。可以在这篇 NetworkManager 的[博客文章][4]中参阅到有关使用 `nmcli` 从终端配置特定连接的详细说明。\n\n使用 `ip link` 命令可以查看当前的 MAC 地址，MAC 地址将会显示在 `ether` 一词的后面。\n\n```\n$ ip link\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: enp2s0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000\n    link/ether 52:54:00:5f:d5:4e brd ff:ff:ff:ff:ff:ff\n3: wlp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000\n    link/ether 52:54:00:03:23:59 brd ff:ff:ff:ff:ff:ff\n```\n\n### 什么时候不能随机化 MAC 地址\n\n当然，在某些情况下确实需要能被追踪到。例如在家用网络中，可能需要将路由器配置为对电脑分配一致的 IP 地址以进行端口转发；再例如公司的雇主可能需要根据 MAC 地址来提供 Wi-Fi 服务，这时候就需要进行追踪。要更改特定的 Wi-Fi 连接，请使用 `nmcli` 查看 NetworkManager 连接并显示当前设置：\n\n```\n$ nmcli c | grep wifi\nAmtrak_WiFi    5f4b9f75-9e41-47f8-8bac-25dae779cd87 wifi -- \nStaplesHotspot de57940c-32c2-468b-8f96-0a3b9a9b0a5e wifi -- \nMyHome         e8c79829-1848-4563-8e44-466e14a3223d wifi wlp1s0 \n...\n$ nmcli c show 5f4b9f75-9e41-47f8-8bac-25dae779cd87 | grep cloned\n802-11-wireless.cloned-mac-address:     --\n$ nmcli c show e8c79829-1848-4563-8e44-466e14a3223d | grep cloned\n802-11-wireless.cloned-mac-address:     stable\n```\n\n这个例子在 Amtrak 使用完全随机 MAC 地址（使用默认配置）和 MyHome 的永久 MAC 地址（使用 `stable` 配置）。永久 MAC 地址是在硬件生产的时候分配到网络接口上的，网络管理员能够根据永久 MAC 地址来查看[设备的制造商 ID][5]。\n\n更改配置并重新连接活动的接口：\n\n```\n$ nmcli c modify 5f4b9f75-9e41-47f8-8bac-25dae779cd87 802-11-wireless.cloned-mac-address random\n$ nmcli c modify e8c79829-1848-4563-8e44-466e14a3223d 802-11-wireless.cloned-mac-address permanent\n$ nmcli c down e8c79829-1848-4563-8e44-466e14a3223d\n$ nmcli c up e8c79829-1848-4563-8e44-466e14a3223d\n$ ip link\n...\n```\n\n你还可以安装 NetworkManager-tui ，就可以通过可视化界面菜单来编辑连接。\n\n### 总结\n\n当你走在路上时，你要[留意周围的环境][6]，并[警惕可能的危险][7]。同样，在使用公共互联网资源时也要注意你自己的可追踪性。\n\n--------------------------------------------------------------------------------\n\nvia: https://fedoramagazine.org/randomize-mac-address-nm/\n\n[a]: https://fedoramagazine.org/author/sheogorath/\n[b]: https://fedoramagazine.org/author/sdgathman/\n[1]: https://en.wikipedia.org/wiki/MAC_address\n[2]: https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/\n[3]: https://serverfault.com/questions/462178/duplicate-mac-address-on-the-same-lan-possible\n[4]: https://blogs.gnome.org/thaller/2016/08/26/mac-address-spoofing-in-networkmanager-1-4-0/\n[5]: https://www.wireshark.org/tools/oui-lookup.html\n[6]: https://www.isba.org/committees/governmentlawyers/newsletter/2013/06/becomingmoreawareafewtipsonkeepingy\n[7]: http://www.selectinternational.com/safety-blog/aware-of-surroundings-can-reduce-safety-incidents\n\n","source":"_posts/Randomize-your-MAC-address-using-NetworkManager.md","raw":"---\ntitle: 使用 NetworkManager 随机化你的 MAC 地址\ndate: 2018-09-19 08:11:25\ntags:\n  - Mac\n  - Wi-Fi\n  - LCTT 翻译\n---\n\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/randomizemacaddress-816x345.png)\n\n今时今日，无论在家里的沙发上，还是在外面的咖啡厅，只要打开笔记本电脑，连上 Wi-Fi，就能通过网络与外界保持联系。但现在的 Wi-Fi 热点们大都能够通过[每张网卡对应的唯一 MAC 地址][1]来追踪你的设备。下面就来看一下如何避免被追踪。\n\n现在很多人已经开始注重个人隐私这个问题。个人隐私问题并不仅仅指防止他人能够访问到你电脑上的私有内容（这又是另一个问题了），而更多的是指<ruby>可追踪性<rt>legibility</rt></ruby>，也就是是否能够被轻易地统计和追踪到。大家都应该[对此更加重视][2]。同时，这方面的底线是，服务提供者在得到了用户的授权后才能对用户进行追踪，例如机场的计时 Wi-Fi 只有在用户授权后才能够使用。\n\n因为固定的 MAC 地址能被轻易地追踪到，所以应该定时进行更换，随机的 MAC 地址是一个好的选择。由于 MAC 地址一般只在局域网内使用，因此随机的 MAC 地址也不大会产生[冲突][3]。\n\n### 配置 NetworkManager\n\n要将随机的 MAC 地址默认地用于所有的 Wi-Fi 连接，需要创建 `/etc/NetworkManager/conf.d/00-macrandomize.conf` 这个文件：\n\n```\n[device]\nwifi.scan-rand-mac-address=yes\n\n[connection]\nwifi.cloned-mac-address=stable\nethernet.cloned-mac-address=stable\nconnection.stable-id=${CONNECTION}/${BOOT}\n```\n\n然后重启 NetworkManager ：\n\n```\nsystemctl restart NetworkManager\n```\n\n以上配置文件中，将 `cloned-mac-address` 的值设置为 `stable` 就可以在每次 NetworkManager 激活连接的时候都生成相同的 MAC 地址，但连接时使用不同的 MAC 地址。如果要在每次激活连接时也获得随机的 MAC 地址，需要将 `cloned-mac-address` 的值设置为 `random`。\n\n设置为 `stable` 可以从 DHCP 获取相同的 IP 地址，也可以让 Wi-Fi 的<ruby>[强制主页](https://en.wikipedia.org/wiki/Captive_portal)<rt>captive portal</rt></ruby>根据 MAC 地址记住你的登录状态。如果设置为 `random` ，在每次连接的时候都需要重新认证（或者点击“我同意”），在使用机场 Wi-Fi 的时候会需要到这种 `random` 模式。可以在这篇 NetworkManager 的[博客文章][4]中参阅到有关使用 `nmcli` 从终端配置特定连接的详细说明。\n\n使用 `ip link` 命令可以查看当前的 MAC 地址，MAC 地址将会显示在 `ether` 一词的后面。\n\n```\n$ ip link\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: enp2s0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000\n    link/ether 52:54:00:5f:d5:4e brd ff:ff:ff:ff:ff:ff\n3: wlp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000\n    link/ether 52:54:00:03:23:59 brd ff:ff:ff:ff:ff:ff\n```\n\n### 什么时候不能随机化 MAC 地址\n\n当然，在某些情况下确实需要能被追踪到。例如在家用网络中，可能需要将路由器配置为对电脑分配一致的 IP 地址以进行端口转发；再例如公司的雇主可能需要根据 MAC 地址来提供 Wi-Fi 服务，这时候就需要进行追踪。要更改特定的 Wi-Fi 连接，请使用 `nmcli` 查看 NetworkManager 连接并显示当前设置：\n\n```\n$ nmcli c | grep wifi\nAmtrak_WiFi    5f4b9f75-9e41-47f8-8bac-25dae779cd87 wifi -- \nStaplesHotspot de57940c-32c2-468b-8f96-0a3b9a9b0a5e wifi -- \nMyHome         e8c79829-1848-4563-8e44-466e14a3223d wifi wlp1s0 \n...\n$ nmcli c show 5f4b9f75-9e41-47f8-8bac-25dae779cd87 | grep cloned\n802-11-wireless.cloned-mac-address:     --\n$ nmcli c show e8c79829-1848-4563-8e44-466e14a3223d | grep cloned\n802-11-wireless.cloned-mac-address:     stable\n```\n\n这个例子在 Amtrak 使用完全随机 MAC 地址（使用默认配置）和 MyHome 的永久 MAC 地址（使用 `stable` 配置）。永久 MAC 地址是在硬件生产的时候分配到网络接口上的，网络管理员能够根据永久 MAC 地址来查看[设备的制造商 ID][5]。\n\n更改配置并重新连接活动的接口：\n\n```\n$ nmcli c modify 5f4b9f75-9e41-47f8-8bac-25dae779cd87 802-11-wireless.cloned-mac-address random\n$ nmcli c modify e8c79829-1848-4563-8e44-466e14a3223d 802-11-wireless.cloned-mac-address permanent\n$ nmcli c down e8c79829-1848-4563-8e44-466e14a3223d\n$ nmcli c up e8c79829-1848-4563-8e44-466e14a3223d\n$ ip link\n...\n```\n\n你还可以安装 NetworkManager-tui ，就可以通过可视化界面菜单来编辑连接。\n\n### 总结\n\n当你走在路上时，你要[留意周围的环境][6]，并[警惕可能的危险][7]。同样，在使用公共互联网资源时也要注意你自己的可追踪性。\n\n--------------------------------------------------------------------------------\n\nvia: https://fedoramagazine.org/randomize-mac-address-nm/\n\n[a]: https://fedoramagazine.org/author/sheogorath/\n[b]: https://fedoramagazine.org/author/sdgathman/\n[1]: https://en.wikipedia.org/wiki/MAC_address\n[2]: https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/\n[3]: https://serverfault.com/questions/462178/duplicate-mac-address-on-the-same-lan-possible\n[4]: https://blogs.gnome.org/thaller/2016/08/26/mac-address-spoofing-in-networkmanager-1-4-0/\n[5]: https://www.wireshark.org/tools/oui-lookup.html\n[6]: https://www.isba.org/committees/governmentlawyers/newsletter/2013/06/becomingmoreawareafewtipsonkeepingy\n[7]: http://www.selectinternational.com/safety-blog/aware-of-surroundings-can-reduce-safety-incidents\n\n","slug":"Randomize-your-MAC-address-using-NetworkManager","published":1,"updated":"2019-03-28T05:52:00.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0d8001olixuk6nnqmpo","content":"<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/randomizemacaddress-816x345.png\" alt=\"\"></p>\n<p>今时今日，无论在家里的沙发上，还是在外面的咖啡厅，只要打开笔记本电脑，连上 Wi-Fi，就能通过网络与外界保持联系。但现在的 Wi-Fi 热点们大都能够通过<a href=\"https://en.wikipedia.org/wiki/MAC_address\" target=\"_blank\" rel=\"noopener\">每张网卡对应的唯一 MAC 地址</a>来追踪你的设备。下面就来看一下如何避免被追踪。</p>\n<p>现在很多人已经开始注重个人隐私这个问题。个人隐私问题并不仅仅指防止他人能够访问到你电脑上的私有内容（这又是另一个问题了），而更多的是指<ruby>可追踪性<rt>legibility</rt></ruby>，也就是是否能够被轻易地统计和追踪到。大家都应该<a href=\"https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/\" target=\"_blank\" rel=\"noopener\">对此更加重视</a>。同时，这方面的底线是，服务提供者在得到了用户的授权后才能对用户进行追踪，例如机场的计时 Wi-Fi 只有在用户授权后才能够使用。</p>\n<p>因为固定的 MAC 地址能被轻易地追踪到，所以应该定时进行更换，随机的 MAC 地址是一个好的选择。由于 MAC 地址一般只在局域网内使用，因此随机的 MAC 地址也不大会产生<a href=\"https://serverfault.com/questions/462178/duplicate-mac-address-on-the-same-lan-possible\" target=\"_blank\" rel=\"noopener\">冲突</a>。</p>\n<h3 id=\"配置-NetworkManager\"><a href=\"#配置-NetworkManager\" class=\"headerlink\" title=\"配置 NetworkManager\"></a>配置 NetworkManager</h3><p>要将随机的 MAC 地址默认地用于所有的 Wi-Fi 连接，需要创建 <code>/etc/NetworkManager/conf.d/00-macrandomize.conf</code> 这个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[device]</span><br><span class=\"line\">wifi.scan-rand-mac-address=yes</span><br><span class=\"line\"></span><br><span class=\"line\">[connection]</span><br><span class=\"line\">wifi.cloned-mac-address=stable</span><br><span class=\"line\">ethernet.cloned-mac-address=stable</span><br><span class=\"line\">connection.stable-id=$&#123;CONNECTION&#125;/$&#123;BOOT&#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启 NetworkManager ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>\n<p>以上配置文件中，将 <code>cloned-mac-address</code> 的值设置为 <code>stable</code> 就可以在每次 NetworkManager 激活连接的时候都生成相同的 MAC 地址，但连接时使用不同的 MAC 地址。如果要在每次激活连接时也获得随机的 MAC 地址，需要将 <code>cloned-mac-address</code> 的值设置为 <code>random</code>。</p>\n<p>设置为 <code>stable</code> 可以从 DHCP 获取相同的 IP 地址，也可以让 Wi-Fi 的<ruby><a href=\"https://en.wikipedia.org/wiki/Captive_portal\" target=\"_blank\" rel=\"noopener\">强制主页</a><rt>captive portal</rt></ruby>根据 MAC 地址记住你的登录状态。如果设置为 <code>random</code> ，在每次连接的时候都需要重新认证（或者点击“我同意”），在使用机场 Wi-Fi 的时候会需要到这种 <code>random</code> 模式。可以在这篇 NetworkManager 的<a href=\"https://blogs.gnome.org/thaller/2016/08/26/mac-address-spoofing-in-networkmanager-1-4-0/\" target=\"_blank\" rel=\"noopener\">博客文章</a>中参阅到有关使用 <code>nmcli</code> 从终端配置特定连接的详细说明。</p>\n<p>使用 <code>ip link</code> 命令可以查看当前的 MAC 地址，MAC 地址将会显示在 <code>ether</code> 一词的后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ip link</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">2: enp2s0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/ether 52:54:00:5f:d5:4e brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">3: wlp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class=\"line\">    link/ether 52:54:00:03:23:59 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么时候不能随机化-MAC-地址\"><a href=\"#什么时候不能随机化-MAC-地址\" class=\"headerlink\" title=\"什么时候不能随机化 MAC 地址\"></a>什么时候不能随机化 MAC 地址</h3><p>当然，在某些情况下确实需要能被追踪到。例如在家用网络中，可能需要将路由器配置为对电脑分配一致的 IP 地址以进行端口转发；再例如公司的雇主可能需要根据 MAC 地址来提供 Wi-Fi 服务，这时候就需要进行追踪。要更改特定的 Wi-Fi 连接，请使用 <code>nmcli</code> 查看 NetworkManager 连接并显示当前设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nmcli c | grep wifi</span><br><span class=\"line\">Amtrak_WiFi    5f4b9f75-9e41-47f8-8bac-25dae779cd87 wifi -- </span><br><span class=\"line\">StaplesHotspot de57940c-32c2-468b-8f96-0a3b9a9b0a5e wifi -- </span><br><span class=\"line\">MyHome         e8c79829-1848-4563-8e44-466e14a3223d wifi wlp1s0 </span><br><span class=\"line\">...</span><br><span class=\"line\">$ nmcli c show 5f4b9f75-9e41-47f8-8bac-25dae779cd87 | grep cloned</span><br><span class=\"line\">802-11-wireless.cloned-mac-address:     --</span><br><span class=\"line\">$ nmcli c show e8c79829-1848-4563-8e44-466e14a3223d | grep cloned</span><br><span class=\"line\">802-11-wireless.cloned-mac-address:     stable</span><br></pre></td></tr></table></figure>\n<p>这个例子在 Amtrak 使用完全随机 MAC 地址（使用默认配置）和 MyHome 的永久 MAC 地址（使用 <code>stable</code> 配置）。永久 MAC 地址是在硬件生产的时候分配到网络接口上的，网络管理员能够根据永久 MAC 地址来查看<a href=\"https://www.wireshark.org/tools/oui-lookup.html\" target=\"_blank\" rel=\"noopener\">设备的制造商 ID</a>。</p>\n<p>更改配置并重新连接活动的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nmcli c modify 5f4b9f75-9e41-47f8-8bac-25dae779cd87 802-11-wireless.cloned-mac-address random</span><br><span class=\"line\">$ nmcli c modify e8c79829-1848-4563-8e44-466e14a3223d 802-11-wireless.cloned-mac-address permanent</span><br><span class=\"line\">$ nmcli c down e8c79829-1848-4563-8e44-466e14a3223d</span><br><span class=\"line\">$ nmcli c up e8c79829-1848-4563-8e44-466e14a3223d</span><br><span class=\"line\">$ ip link</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>你还可以安装 NetworkManager-tui ，就可以通过可视化界面菜单来编辑连接。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你走在路上时，你要<a href=\"https://www.isba.org/committees/governmentlawyers/newsletter/2013/06/becomingmoreawareafewtipsonkeepingy\" target=\"_blank\" rel=\"noopener\">留意周围的环境</a>，并<a href=\"http://www.selectinternational.com/safety-blog/aware-of-surroundings-can-reduce-safety-incidents\" target=\"_blank\" rel=\"noopener\">警惕可能的危险</a>。同样，在使用公共互联网资源时也要注意你自己的可追踪性。</p>\n<hr>\n<p>via: <a href=\"https://fedoramagazine.org/randomize-mac-address-nm/\" target=\"_blank\" rel=\"noopener\">https://fedoramagazine.org/randomize-mac-address-nm/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/randomizemacaddress-816x345.png\" alt=\"\"></p>\n<p>今时今日，无论在家里的沙发上，还是在外面的咖啡厅，只要打开笔记本电脑，连上 Wi-Fi，就能通过网络与外界保持联系。但现在的 Wi-Fi 热点们大都能够通过<a href=\"https://en.wikipedia.org/wiki/MAC_address\" target=\"_blank\" rel=\"noopener\">每张网卡对应的唯一 MAC 地址</a>来追踪你的设备。下面就来看一下如何避免被追踪。</p>\n<p>现在很多人已经开始注重个人隐私这个问题。个人隐私问题并不仅仅指防止他人能够访问到你电脑上的私有内容（这又是另一个问题了），而更多的是指<ruby>可追踪性<rt>legibility</rt></ruby>，也就是是否能够被轻易地统计和追踪到。大家都应该<a href=\"https://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/\" target=\"_blank\" rel=\"noopener\">对此更加重视</a>。同时，这方面的底线是，服务提供者在得到了用户的授权后才能对用户进行追踪，例如机场的计时 Wi-Fi 只有在用户授权后才能够使用。</p>\n<p>因为固定的 MAC 地址能被轻易地追踪到，所以应该定时进行更换，随机的 MAC 地址是一个好的选择。由于 MAC 地址一般只在局域网内使用，因此随机的 MAC 地址也不大会产生<a href=\"https://serverfault.com/questions/462178/duplicate-mac-address-on-the-same-lan-possible\" target=\"_blank\" rel=\"noopener\">冲突</a>。</p>\n<h3 id=\"配置-NetworkManager\"><a href=\"#配置-NetworkManager\" class=\"headerlink\" title=\"配置 NetworkManager\"></a>配置 NetworkManager</h3><p>要将随机的 MAC 地址默认地用于所有的 Wi-Fi 连接，需要创建 <code>/etc/NetworkManager/conf.d/00-macrandomize.conf</code> 这个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[device]</span><br><span class=\"line\">wifi.scan-rand-mac-address=yes</span><br><span class=\"line\"></span><br><span class=\"line\">[connection]</span><br><span class=\"line\">wifi.cloned-mac-address=stable</span><br><span class=\"line\">ethernet.cloned-mac-address=stable</span><br><span class=\"line\">connection.stable-id=$&#123;CONNECTION&#125;/$&#123;BOOT&#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启 NetworkManager ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>\n<p>以上配置文件中，将 <code>cloned-mac-address</code> 的值设置为 <code>stable</code> 就可以在每次 NetworkManager 激活连接的时候都生成相同的 MAC 地址，但连接时使用不同的 MAC 地址。如果要在每次激活连接时也获得随机的 MAC 地址，需要将 <code>cloned-mac-address</code> 的值设置为 <code>random</code>。</p>\n<p>设置为 <code>stable</code> 可以从 DHCP 获取相同的 IP 地址，也可以让 Wi-Fi 的<ruby><a href=\"https://en.wikipedia.org/wiki/Captive_portal\" target=\"_blank\" rel=\"noopener\">强制主页</a><rt>captive portal</rt></ruby>根据 MAC 地址记住你的登录状态。如果设置为 <code>random</code> ，在每次连接的时候都需要重新认证（或者点击“我同意”），在使用机场 Wi-Fi 的时候会需要到这种 <code>random</code> 模式。可以在这篇 NetworkManager 的<a href=\"https://blogs.gnome.org/thaller/2016/08/26/mac-address-spoofing-in-networkmanager-1-4-0/\" target=\"_blank\" rel=\"noopener\">博客文章</a>中参阅到有关使用 <code>nmcli</code> 从终端配置特定连接的详细说明。</p>\n<p>使用 <code>ip link</code> 命令可以查看当前的 MAC 地址，MAC 地址将会显示在 <code>ether</code> 一词的后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ip link</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">2: enp2s0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/ether 52:54:00:5f:d5:4e brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">3: wlp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class=\"line\">    link/ether 52:54:00:03:23:59 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么时候不能随机化-MAC-地址\"><a href=\"#什么时候不能随机化-MAC-地址\" class=\"headerlink\" title=\"什么时候不能随机化 MAC 地址\"></a>什么时候不能随机化 MAC 地址</h3><p>当然，在某些情况下确实需要能被追踪到。例如在家用网络中，可能需要将路由器配置为对电脑分配一致的 IP 地址以进行端口转发；再例如公司的雇主可能需要根据 MAC 地址来提供 Wi-Fi 服务，这时候就需要进行追踪。要更改特定的 Wi-Fi 连接，请使用 <code>nmcli</code> 查看 NetworkManager 连接并显示当前设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nmcli c | grep wifi</span><br><span class=\"line\">Amtrak_WiFi    5f4b9f75-9e41-47f8-8bac-25dae779cd87 wifi -- </span><br><span class=\"line\">StaplesHotspot de57940c-32c2-468b-8f96-0a3b9a9b0a5e wifi -- </span><br><span class=\"line\">MyHome         e8c79829-1848-4563-8e44-466e14a3223d wifi wlp1s0 </span><br><span class=\"line\">...</span><br><span class=\"line\">$ nmcli c show 5f4b9f75-9e41-47f8-8bac-25dae779cd87 | grep cloned</span><br><span class=\"line\">802-11-wireless.cloned-mac-address:     --</span><br><span class=\"line\">$ nmcli c show e8c79829-1848-4563-8e44-466e14a3223d | grep cloned</span><br><span class=\"line\">802-11-wireless.cloned-mac-address:     stable</span><br></pre></td></tr></table></figure>\n<p>这个例子在 Amtrak 使用完全随机 MAC 地址（使用默认配置）和 MyHome 的永久 MAC 地址（使用 <code>stable</code> 配置）。永久 MAC 地址是在硬件生产的时候分配到网络接口上的，网络管理员能够根据永久 MAC 地址来查看<a href=\"https://www.wireshark.org/tools/oui-lookup.html\" target=\"_blank\" rel=\"noopener\">设备的制造商 ID</a>。</p>\n<p>更改配置并重新连接活动的接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nmcli c modify 5f4b9f75-9e41-47f8-8bac-25dae779cd87 802-11-wireless.cloned-mac-address random</span><br><span class=\"line\">$ nmcli c modify e8c79829-1848-4563-8e44-466e14a3223d 802-11-wireless.cloned-mac-address permanent</span><br><span class=\"line\">$ nmcli c down e8c79829-1848-4563-8e44-466e14a3223d</span><br><span class=\"line\">$ nmcli c up e8c79829-1848-4563-8e44-466e14a3223d</span><br><span class=\"line\">$ ip link</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>你还可以安装 NetworkManager-tui ，就可以通过可视化界面菜单来编辑连接。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你走在路上时，你要<a href=\"https://www.isba.org/committees/governmentlawyers/newsletter/2013/06/becomingmoreawareafewtipsonkeepingy\" target=\"_blank\" rel=\"noopener\">留意周围的环境</a>，并<a href=\"http://www.selectinternational.com/safety-blog/aware-of-surroundings-can-reduce-safety-incidents\" target=\"_blank\" rel=\"noopener\">警惕可能的危险</a>。同样，在使用公共互联网资源时也要注意你自己的可追踪性。</p>\n<hr>\n<p>via: <a href=\"https://fedoramagazine.org/randomize-mac-address-nm/\" target=\"_blank\" rel=\"noopener\">https://fedoramagazine.org/randomize-mac-address-nm/</a></p>\n"},{"title":"在树莓派上运行 DOS 系统","date":"2018-04-14T14:28:24.000Z","_content":"\n\n> 不同的 CPU 架构意味着在树莓派上运行 DOS 并非唾手可得，但其实也没多麻烦。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/wings_freedos_game.jpg?itok=7j8x-A-w)\n\n[FreeDOS][1] 对大家来说也许并不陌生。它是一个完整、免费并且对 DOS 兼容良好的操作系统，它可以运行一些比较老旧的 DOS 游戏或者商用软件，也可以开发嵌入式的应用。只要在 MS-DOS 上能够运行的程序，在 FreeDOS 上都可以运行。\n\n作为 FreeDOS 的发起者和项目协调人员，很多用户会把我作为内行人士进行发问。而我最常被问到的问题是：“FreeDOS 可以在树莓派上运行吗？”\n\n这个问题并不令人意外。毕竟 Linux 在树莓派上能够很好地运行，而 FreeDOS 和 Linux 相比是一个更古老、占用资源更少的操作系统，那 FreeDOS 为啥不能树莓派上运行呢？\n\n简单来说。由于 CPU 架构的原因，FreeDOS 并不能在树莓派中独立运行。和其它 DOS 类的系统一样，FreeDOS 需要英特尔 x86 架构 CPU 以及 BIOS 来提供基础的运行时服务。而树莓派运行在 ARM 架构的 CPU 上，与英特尔 CPU 二进制不兼容，也没有 BIOS。因此树莓派在硬件层面就不支持 FreeDOS。\n\n不过通过 PC 模拟器还是能在树莓派上运行 FreeDOS 的，虽然这样也许稍有不足，但也不失为一个能在树莓派上运行 FreeDOS 的方法。\n\n### DOSBox 怎么样?\n\n有人可能会问：“为什么不用 DOSBox 呢？” DOSBox 是一个开源的跨平台 x86 模拟器，在 Linux 上也能使用，它能够为应用软件尤其是游戏软件提供了一个类 DOS 的运行环境，所以如果你只是想玩 DOS 游戏的话，DOSBox 是一个不错的选择。但在大众眼中，DOSBox 是专为 DOS 游戏而设的，而在运行一些别的 DOS 应用软件方面，DOSBox 只是表现平平。\n\n对多数人来说，这只是个人偏好的问题，我喜欢用 FreeDOS 来运行 DOS 游戏和其它程序，完整的 DOS 系统和 DOSBox 相比能让我体验到更好的灵活性和操控性。我只用 DOSBox 来玩游戏，在其它方面还是选择完整的 FreeDOS。\n\n### 在树莓派上安装 FreeDOS\n\n[QEMU][3]（Quick EMUlator）是一款能在 Linux 系统上运行 DOS 系统的开源的虚拟机软件。很多流行的 Linux 系统都自带 QEMU。QEMU 在我的树莓派上的 Raspbian 系统中也同样能够运行，下文就有一些我在树莓派 [Raspbian GNU/Linux 9 (Stretch)][4] 系统中使用 QEMU 的截图。\n\n去年我在写了一篇关于[如何在 Linux 系统中运行 DOS 程序][5]的文章的时候就用到了 QEMU，在树莓派上使用 QEMU 来安装运行 FreeDOS 的步骤基本上和在别的基于 GNOME 的系统上没有什么太大的区别。\n\n在 QEMU 中你需要通过添加各种组件来搭建虚拟机。先指定一个用来安装运行 DOS 的虚拟磁盘镜像，通过 `qemu-img` 命令来创建一个虚拟磁盘镜像，对于 FreeDOS 来说不需要太大的空间，所以我只创建了一个 200MB 的虚拟磁盘：\n\n```\nqemu-img create freedos.img 200M\n```\n\n和 VMware 或者 VirtualBox 这些 PC 模拟器不同，使用 QEMU 需要通过添加各种组件来搭建虚拟机，尽管有点麻烦，但是并不困难。我使用了以下这些参数来在树莓派上使用 QEMU 安装 FreeDOS 系统：\n\n```\nqemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=d\n```\n\n你可以在我其它的[文章][5]中找到这些命令的完整介绍。简单来说，上面这条命令指定了一个英特尔 i386 兼容虚拟机，并且分配了 16MB 内存、一个英文输入键盘、一个基于系统时间的实时时钟、一个声卡、一个音乐卡以及一个 VGA 卡。文件 `freedos.img` 指定为第一个硬盘（`C:`），`FD12CD.iso` 镜像作为 CD-ROM （`D:`）驱动。QEMU 设定为从 `D:` 的 CD-ROM 启动。\n\n你只需要按照提示就可以轻松安装好 FreeDOS 1.2 了。但是由于 microSD 卡在面对大量的 I/O 时速度比较慢，所以安装操作系统需要花费很长时间。\n\n### 在树莓派上运行 FreeDOS\n\n你的运行情况取决于使用哪一种 microSD 卡。我用的是 SanDisk Ultra 64GB microSDXC UHS-I U1A1 ，其中 U1 这种型号专用于支持 1080p 的视频录制（例如 GoPro），它的最低串行写速度能够达到 10MB/s。相比之下，V60 型号专用于 4K 视频录制，最低连续写入速度能达到 60MB/s。如果你的树莓派使用的是 V60 的 microSD 卡甚至是 V30（也能达到 30MB/s），你就能明显看到它的 I/O 性能会比我的好。\n\nFreeDOS 安装好之后，你可以直接从 `C:` 进行启动。只需要按照下面的命令用 `-boot order=c` 来指定 QEMU 的启动顺序即可：\n\n```\n​qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=c​\n```\n\n只要树莓派的 QEMU 上安装了 FreeDOS，就不会出现明显的性能问题。例如游戏通常在每一关开始的时候会加载地图、怪物、声音等一系列的数据，尽管这些内容需要加载一段时间，但在正常玩的时候并没有出现性能不足的现象。\n\nFreeDOS 1.2 自带了很多游戏以及其它应用软件，可以使用 `FDIMPLES` 包管理程序来安装它们。FreeDOS 1.2 里面我最喜欢的是一款叫 WING 的太空射击游戏，让人想起经典的街机游戏 Galaga（WING 就是 Wing Is Not Galaga 的递归缩写词）。\n\nAs-Easy-As 是我最喜欢的一个 DOS 应用程序，作为 20 世纪八九十年代流行的电子表格程序，它和当时的 Lotus 1-2-3 以及现在的 Microsoft Excel、LibreOffice Calc 一样具有强大的威力。As-Easy-As 和 Lotus 1-2-3 都将数据保存为 WKS 文件，现在新版本的 Microsoft Excel 已经无法读取这种文件了，而 LibreOffice Calc 视兼容性而定有可能支持。鉴于 As-Easy-As 的初始版本是一个共享软件，TRIUS 仍然为 As-Easy-As 5.7 免费提供[激活码][6]。\n\n我也非常喜欢 GNU Emacs 编辑器，FreeDOS 也自带了一个叫 Freemacs 的类 Emacs 的文本编辑器。它比 FreeDOS 默认的 FreeDOS Edit 编辑器更强大，也能带来 GNU Emacs 的体验。如果你也需要，可以在 FreeDOS 1.2 中通过`FDIMPLES`包管理程序来安装。\n\n### 是的，你或许真的可以在树莓派上运行 DOS\n\n即使树莓派在硬件上不支持 DOS，但是在模拟器的帮助下，DOS 还是能够在树莓派上运行。得益于 QEMU PC 模拟器，一些经典的 DOS 游戏和 DOS 应用程序能够运行在树莓派上。在执行磁盘 I/O ，尤其是大量密集操作（例如写入大量数据）的时候，性能可能会受到轻微的影响。当你使用 QEMU 并且在虚拟机里安装好 FreeDOS 之后，你就可以尽情享受经典的 DOS 程序了。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi\n\n\n[a]:https://opensource.com/users/jim-hall\n[1]:http://www.freedos.org/\n[2]:https://opensource.com/article/18/3/raspberry-pi-week-giveaway\n[3]:https://www.qemu.org/\n[4]:https://www.raspberrypi.org/downloads/\n[5]:https://linux.cn/article-9014-1.html\n[6]:http://www.triusinc.com/forums/viewtopic.php?t=10\n","source":"_posts/Running-DOS-on-the-Raspberry-Pi.md","raw":"---\ntitle: 在树莓派上运行 DOS 系统\ndate: 2018-04-14 22:28:24\ntags:\n  - 树莓派\n  - DoS\n  - LCTT 翻译\n---\n\n\n> 不同的 CPU 架构意味着在树莓派上运行 DOS 并非唾手可得，但其实也没多麻烦。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/wings_freedos_game.jpg?itok=7j8x-A-w)\n\n[FreeDOS][1] 对大家来说也许并不陌生。它是一个完整、免费并且对 DOS 兼容良好的操作系统，它可以运行一些比较老旧的 DOS 游戏或者商用软件，也可以开发嵌入式的应用。只要在 MS-DOS 上能够运行的程序，在 FreeDOS 上都可以运行。\n\n作为 FreeDOS 的发起者和项目协调人员，很多用户会把我作为内行人士进行发问。而我最常被问到的问题是：“FreeDOS 可以在树莓派上运行吗？”\n\n这个问题并不令人意外。毕竟 Linux 在树莓派上能够很好地运行，而 FreeDOS 和 Linux 相比是一个更古老、占用资源更少的操作系统，那 FreeDOS 为啥不能树莓派上运行呢？\n\n简单来说。由于 CPU 架构的原因，FreeDOS 并不能在树莓派中独立运行。和其它 DOS 类的系统一样，FreeDOS 需要英特尔 x86 架构 CPU 以及 BIOS 来提供基础的运行时服务。而树莓派运行在 ARM 架构的 CPU 上，与英特尔 CPU 二进制不兼容，也没有 BIOS。因此树莓派在硬件层面就不支持 FreeDOS。\n\n不过通过 PC 模拟器还是能在树莓派上运行 FreeDOS 的，虽然这样也许稍有不足，但也不失为一个能在树莓派上运行 FreeDOS 的方法。\n\n### DOSBox 怎么样?\n\n有人可能会问：“为什么不用 DOSBox 呢？” DOSBox 是一个开源的跨平台 x86 模拟器，在 Linux 上也能使用，它能够为应用软件尤其是游戏软件提供了一个类 DOS 的运行环境，所以如果你只是想玩 DOS 游戏的话，DOSBox 是一个不错的选择。但在大众眼中，DOSBox 是专为 DOS 游戏而设的，而在运行一些别的 DOS 应用软件方面，DOSBox 只是表现平平。\n\n对多数人来说，这只是个人偏好的问题，我喜欢用 FreeDOS 来运行 DOS 游戏和其它程序，完整的 DOS 系统和 DOSBox 相比能让我体验到更好的灵活性和操控性。我只用 DOSBox 来玩游戏，在其它方面还是选择完整的 FreeDOS。\n\n### 在树莓派上安装 FreeDOS\n\n[QEMU][3]（Quick EMUlator）是一款能在 Linux 系统上运行 DOS 系统的开源的虚拟机软件。很多流行的 Linux 系统都自带 QEMU。QEMU 在我的树莓派上的 Raspbian 系统中也同样能够运行，下文就有一些我在树莓派 [Raspbian GNU/Linux 9 (Stretch)][4] 系统中使用 QEMU 的截图。\n\n去年我在写了一篇关于[如何在 Linux 系统中运行 DOS 程序][5]的文章的时候就用到了 QEMU，在树莓派上使用 QEMU 来安装运行 FreeDOS 的步骤基本上和在别的基于 GNOME 的系统上没有什么太大的区别。\n\n在 QEMU 中你需要通过添加各种组件来搭建虚拟机。先指定一个用来安装运行 DOS 的虚拟磁盘镜像，通过 `qemu-img` 命令来创建一个虚拟磁盘镜像，对于 FreeDOS 来说不需要太大的空间，所以我只创建了一个 200MB 的虚拟磁盘：\n\n```\nqemu-img create freedos.img 200M\n```\n\n和 VMware 或者 VirtualBox 这些 PC 模拟器不同，使用 QEMU 需要通过添加各种组件来搭建虚拟机，尽管有点麻烦，但是并不困难。我使用了以下这些参数来在树莓派上使用 QEMU 安装 FreeDOS 系统：\n\n```\nqemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=d\n```\n\n你可以在我其它的[文章][5]中找到这些命令的完整介绍。简单来说，上面这条命令指定了一个英特尔 i386 兼容虚拟机，并且分配了 16MB 内存、一个英文输入键盘、一个基于系统时间的实时时钟、一个声卡、一个音乐卡以及一个 VGA 卡。文件 `freedos.img` 指定为第一个硬盘（`C:`），`FD12CD.iso` 镜像作为 CD-ROM （`D:`）驱动。QEMU 设定为从 `D:` 的 CD-ROM 启动。\n\n你只需要按照提示就可以轻松安装好 FreeDOS 1.2 了。但是由于 microSD 卡在面对大量的 I/O 时速度比较慢，所以安装操作系统需要花费很长时间。\n\n### 在树莓派上运行 FreeDOS\n\n你的运行情况取决于使用哪一种 microSD 卡。我用的是 SanDisk Ultra 64GB microSDXC UHS-I U1A1 ，其中 U1 这种型号专用于支持 1080p 的视频录制（例如 GoPro），它的最低串行写速度能够达到 10MB/s。相比之下，V60 型号专用于 4K 视频录制，最低连续写入速度能达到 60MB/s。如果你的树莓派使用的是 V60 的 microSD 卡甚至是 V30（也能达到 30MB/s），你就能明显看到它的 I/O 性能会比我的好。\n\nFreeDOS 安装好之后，你可以直接从 `C:` 进行启动。只需要按照下面的命令用 `-boot order=c` 来指定 QEMU 的启动顺序即可：\n\n```\n​qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=c​\n```\n\n只要树莓派的 QEMU 上安装了 FreeDOS，就不会出现明显的性能问题。例如游戏通常在每一关开始的时候会加载地图、怪物、声音等一系列的数据，尽管这些内容需要加载一段时间，但在正常玩的时候并没有出现性能不足的现象。\n\nFreeDOS 1.2 自带了很多游戏以及其它应用软件，可以使用 `FDIMPLES` 包管理程序来安装它们。FreeDOS 1.2 里面我最喜欢的是一款叫 WING 的太空射击游戏，让人想起经典的街机游戏 Galaga（WING 就是 Wing Is Not Galaga 的递归缩写词）。\n\nAs-Easy-As 是我最喜欢的一个 DOS 应用程序，作为 20 世纪八九十年代流行的电子表格程序，它和当时的 Lotus 1-2-3 以及现在的 Microsoft Excel、LibreOffice Calc 一样具有强大的威力。As-Easy-As 和 Lotus 1-2-3 都将数据保存为 WKS 文件，现在新版本的 Microsoft Excel 已经无法读取这种文件了，而 LibreOffice Calc 视兼容性而定有可能支持。鉴于 As-Easy-As 的初始版本是一个共享软件，TRIUS 仍然为 As-Easy-As 5.7 免费提供[激活码][6]。\n\n我也非常喜欢 GNU Emacs 编辑器，FreeDOS 也自带了一个叫 Freemacs 的类 Emacs 的文本编辑器。它比 FreeDOS 默认的 FreeDOS Edit 编辑器更强大，也能带来 GNU Emacs 的体验。如果你也需要，可以在 FreeDOS 1.2 中通过`FDIMPLES`包管理程序来安装。\n\n### 是的，你或许真的可以在树莓派上运行 DOS\n\n即使树莓派在硬件上不支持 DOS，但是在模拟器的帮助下，DOS 还是能够在树莓派上运行。得益于 QEMU PC 模拟器，一些经典的 DOS 游戏和 DOS 应用程序能够运行在树莓派上。在执行磁盘 I/O ，尤其是大量密集操作（例如写入大量数据）的时候，性能可能会受到轻微的影响。当你使用 QEMU 并且在虚拟机里安装好 FreeDOS 之后，你就可以尽情享受经典的 DOS 程序了。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi\n\n\n[a]:https://opensource.com/users/jim-hall\n[1]:http://www.freedos.org/\n[2]:https://opensource.com/article/18/3/raspberry-pi-week-giveaway\n[3]:https://www.qemu.org/\n[4]:https://www.raspberrypi.org/downloads/\n[5]:https://linux.cn/article-9014-1.html\n[6]:http://www.triusinc.com/forums/viewtopic.php?t=10\n","slug":"Running-DOS-on-the-Raspberry-Pi","published":1,"updated":"2019-03-28T05:35:49.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0da001rlixuie6v8sz4","content":"<blockquote>\n<p>不同的 CPU 架构意味着在树莓派上运行 DOS 并非唾手可得，但其实也没多麻烦。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/wings_freedos_game.jpg?itok=7j8x-A-w\" alt=\"\"></p>\n<p><a href=\"http://www.freedos.org/\" target=\"_blank\" rel=\"noopener\">FreeDOS</a> 对大家来说也许并不陌生。它是一个完整、免费并且对 DOS 兼容良好的操作系统，它可以运行一些比较老旧的 DOS 游戏或者商用软件，也可以开发嵌入式的应用。只要在 MS-DOS 上能够运行的程序，在 FreeDOS 上都可以运行。</p>\n<p>作为 FreeDOS 的发起者和项目协调人员，很多用户会把我作为内行人士进行发问。而我最常被问到的问题是：“FreeDOS 可以在树莓派上运行吗？”</p>\n<p>这个问题并不令人意外。毕竟 Linux 在树莓派上能够很好地运行，而 FreeDOS 和 Linux 相比是一个更古老、占用资源更少的操作系统，那 FreeDOS 为啥不能树莓派上运行呢？</p>\n<p>简单来说。由于 CPU 架构的原因，FreeDOS 并不能在树莓派中独立运行。和其它 DOS 类的系统一样，FreeDOS 需要英特尔 x86 架构 CPU 以及 BIOS 来提供基础的运行时服务。而树莓派运行在 ARM 架构的 CPU 上，与英特尔 CPU 二进制不兼容，也没有 BIOS。因此树莓派在硬件层面就不支持 FreeDOS。</p>\n<p>不过通过 PC 模拟器还是能在树莓派上运行 FreeDOS 的，虽然这样也许稍有不足，但也不失为一个能在树莓派上运行 FreeDOS 的方法。</p>\n<h3 id=\"DOSBox-怎么样\"><a href=\"#DOSBox-怎么样\" class=\"headerlink\" title=\"DOSBox 怎么样?\"></a>DOSBox 怎么样?</h3><p>有人可能会问：“为什么不用 DOSBox 呢？” DOSBox 是一个开源的跨平台 x86 模拟器，在 Linux 上也能使用，它能够为应用软件尤其是游戏软件提供了一个类 DOS 的运行环境，所以如果你只是想玩 DOS 游戏的话，DOSBox 是一个不错的选择。但在大众眼中，DOSBox 是专为 DOS 游戏而设的，而在运行一些别的 DOS 应用软件方面，DOSBox 只是表现平平。</p>\n<p>对多数人来说，这只是个人偏好的问题，我喜欢用 FreeDOS 来运行 DOS 游戏和其它程序，完整的 DOS 系统和 DOSBox 相比能让我体验到更好的灵活性和操控性。我只用 DOSBox 来玩游戏，在其它方面还是选择完整的 FreeDOS。</p>\n<h3 id=\"在树莓派上安装-FreeDOS\"><a href=\"#在树莓派上安装-FreeDOS\" class=\"headerlink\" title=\"在树莓派上安装 FreeDOS\"></a>在树莓派上安装 FreeDOS</h3><p><a href=\"https://www.qemu.org/\" target=\"_blank\" rel=\"noopener\">QEMU</a>（Quick EMUlator）是一款能在 Linux 系统上运行 DOS 系统的开源的虚拟机软件。很多流行的 Linux 系统都自带 QEMU。QEMU 在我的树莓派上的 Raspbian 系统中也同样能够运行，下文就有一些我在树莓派 <a href=\"https://www.raspberrypi.org/downloads/\" target=\"_blank\" rel=\"noopener\">Raspbian GNU/Linux 9 (Stretch)</a> 系统中使用 QEMU 的截图。</p>\n<p>去年我在写了一篇关于<a href=\"https://linux.cn/article-9014-1.html\" target=\"_blank\" rel=\"noopener\">如何在 Linux 系统中运行 DOS 程序</a>的文章的时候就用到了 QEMU，在树莓派上使用 QEMU 来安装运行 FreeDOS 的步骤基本上和在别的基于 GNOME 的系统上没有什么太大的区别。</p>\n<p>在 QEMU 中你需要通过添加各种组件来搭建虚拟机。先指定一个用来安装运行 DOS 的虚拟磁盘镜像，通过 <code>qemu-img</code> 命令来创建一个虚拟磁盘镜像，对于 FreeDOS 来说不需要太大的空间，所以我只创建了一个 200MB 的虚拟磁盘：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-img create freedos.img 200M</span><br></pre></td></tr></table></figure>\n<p>和 VMware 或者 VirtualBox 这些 PC 模拟器不同，使用 QEMU 需要通过添加各种组件来搭建虚拟机，尽管有点麻烦，但是并不困难。我使用了以下这些参数来在树莓派上使用 QEMU 安装 FreeDOS 系统：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=d</span><br></pre></td></tr></table></figure>\n<p>你可以在我其它的<a href=\"https://linux.cn/article-9014-1.html\" target=\"_blank\" rel=\"noopener\">文章</a>中找到这些命令的完整介绍。简单来说，上面这条命令指定了一个英特尔 i386 兼容虚拟机，并且分配了 16MB 内存、一个英文输入键盘、一个基于系统时间的实时时钟、一个声卡、一个音乐卡以及一个 VGA 卡。文件 <code>freedos.img</code> 指定为第一个硬盘（<code>C:</code>），<code>FD12CD.iso</code> 镜像作为 CD-ROM （<code>D:</code>）驱动。QEMU 设定为从 <code>D:</code> 的 CD-ROM 启动。</p>\n<p>你只需要按照提示就可以轻松安装好 FreeDOS 1.2 了。但是由于 microSD 卡在面对大量的 I/O 时速度比较慢，所以安装操作系统需要花费很长时间。</p>\n<h3 id=\"在树莓派上运行-FreeDOS\"><a href=\"#在树莓派上运行-FreeDOS\" class=\"headerlink\" title=\"在树莓派上运行 FreeDOS\"></a>在树莓派上运行 FreeDOS</h3><p>你的运行情况取决于使用哪一种 microSD 卡。我用的是 SanDisk Ultra 64GB microSDXC UHS-I U1A1 ，其中 U1 这种型号专用于支持 1080p 的视频录制（例如 GoPro），它的最低串行写速度能够达到 10MB/s。相比之下，V60 型号专用于 4K 视频录制，最低连续写入速度能达到 60MB/s。如果你的树莓派使用的是 V60 的 microSD 卡甚至是 V30（也能达到 30MB/s），你就能明显看到它的 I/O 性能会比我的好。</p>\n<p>FreeDOS 安装好之后，你可以直接从 <code>C:</code> 进行启动。只需要按照下面的命令用 <code>-boot order=c</code> 来指定 QEMU 的启动顺序即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">​qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=c​</span><br></pre></td></tr></table></figure>\n<p>只要树莓派的 QEMU 上安装了 FreeDOS，就不会出现明显的性能问题。例如游戏通常在每一关开始的时候会加载地图、怪物、声音等一系列的数据，尽管这些内容需要加载一段时间，但在正常玩的时候并没有出现性能不足的现象。</p>\n<p>FreeDOS 1.2 自带了很多游戏以及其它应用软件，可以使用 <code>FDIMPLES</code> 包管理程序来安装它们。FreeDOS 1.2 里面我最喜欢的是一款叫 WING 的太空射击游戏，让人想起经典的街机游戏 Galaga（WING 就是 Wing Is Not Galaga 的递归缩写词）。</p>\n<p>As-Easy-As 是我最喜欢的一个 DOS 应用程序，作为 20 世纪八九十年代流行的电子表格程序，它和当时的 Lotus 1-2-3 以及现在的 Microsoft Excel、LibreOffice Calc 一样具有强大的威力。As-Easy-As 和 Lotus 1-2-3 都将数据保存为 WKS 文件，现在新版本的 Microsoft Excel 已经无法读取这种文件了，而 LibreOffice Calc 视兼容性而定有可能支持。鉴于 As-Easy-As 的初始版本是一个共享软件，TRIUS 仍然为 As-Easy-As 5.7 免费提供<a href=\"http://www.triusinc.com/forums/viewtopic.php?t=10\" target=\"_blank\" rel=\"noopener\">激活码</a>。</p>\n<p>我也非常喜欢 GNU Emacs 编辑器，FreeDOS 也自带了一个叫 Freemacs 的类 Emacs 的文本编辑器。它比 FreeDOS 默认的 FreeDOS Edit 编辑器更强大，也能带来 GNU Emacs 的体验。如果你也需要，可以在 FreeDOS 1.2 中通过<code>FDIMPLES</code>包管理程序来安装。</p>\n<h3 id=\"是的，你或许真的可以在树莓派上运行-DOS\"><a href=\"#是的，你或许真的可以在树莓派上运行-DOS\" class=\"headerlink\" title=\"是的，你或许真的可以在树莓派上运行 DOS\"></a>是的，你或许真的可以在树莓派上运行 DOS</h3><p>即使树莓派在硬件上不支持 DOS，但是在模拟器的帮助下，DOS 还是能够在树莓派上运行。得益于 QEMU PC 模拟器，一些经典的 DOS 游戏和 DOS 应用程序能够运行在树莓派上。在执行磁盘 I/O ，尤其是大量密集操作（例如写入大量数据）的时候，性能可能会受到轻微的影响。当你使用 QEMU 并且在虚拟机里安装好 FreeDOS 之后，你就可以尽情享受经典的 DOS 程序了。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不同的 CPU 架构意味着在树莓派上运行 DOS 并非唾手可得，但其实也没多麻烦。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/wings_freedos_game.jpg?itok=7j8x-A-w\" alt=\"\"></p>\n<p><a href=\"http://www.freedos.org/\" target=\"_blank\" rel=\"noopener\">FreeDOS</a> 对大家来说也许并不陌生。它是一个完整、免费并且对 DOS 兼容良好的操作系统，它可以运行一些比较老旧的 DOS 游戏或者商用软件，也可以开发嵌入式的应用。只要在 MS-DOS 上能够运行的程序，在 FreeDOS 上都可以运行。</p>\n<p>作为 FreeDOS 的发起者和项目协调人员，很多用户会把我作为内行人士进行发问。而我最常被问到的问题是：“FreeDOS 可以在树莓派上运行吗？”</p>\n<p>这个问题并不令人意外。毕竟 Linux 在树莓派上能够很好地运行，而 FreeDOS 和 Linux 相比是一个更古老、占用资源更少的操作系统，那 FreeDOS 为啥不能树莓派上运行呢？</p>\n<p>简单来说。由于 CPU 架构的原因，FreeDOS 并不能在树莓派中独立运行。和其它 DOS 类的系统一样，FreeDOS 需要英特尔 x86 架构 CPU 以及 BIOS 来提供基础的运行时服务。而树莓派运行在 ARM 架构的 CPU 上，与英特尔 CPU 二进制不兼容，也没有 BIOS。因此树莓派在硬件层面就不支持 FreeDOS。</p>\n<p>不过通过 PC 模拟器还是能在树莓派上运行 FreeDOS 的，虽然这样也许稍有不足，但也不失为一个能在树莓派上运行 FreeDOS 的方法。</p>\n<h3 id=\"DOSBox-怎么样\"><a href=\"#DOSBox-怎么样\" class=\"headerlink\" title=\"DOSBox 怎么样?\"></a>DOSBox 怎么样?</h3><p>有人可能会问：“为什么不用 DOSBox 呢？” DOSBox 是一个开源的跨平台 x86 模拟器，在 Linux 上也能使用，它能够为应用软件尤其是游戏软件提供了一个类 DOS 的运行环境，所以如果你只是想玩 DOS 游戏的话，DOSBox 是一个不错的选择。但在大众眼中，DOSBox 是专为 DOS 游戏而设的，而在运行一些别的 DOS 应用软件方面，DOSBox 只是表现平平。</p>\n<p>对多数人来说，这只是个人偏好的问题，我喜欢用 FreeDOS 来运行 DOS 游戏和其它程序，完整的 DOS 系统和 DOSBox 相比能让我体验到更好的灵活性和操控性。我只用 DOSBox 来玩游戏，在其它方面还是选择完整的 FreeDOS。</p>\n<h3 id=\"在树莓派上安装-FreeDOS\"><a href=\"#在树莓派上安装-FreeDOS\" class=\"headerlink\" title=\"在树莓派上安装 FreeDOS\"></a>在树莓派上安装 FreeDOS</h3><p><a href=\"https://www.qemu.org/\" target=\"_blank\" rel=\"noopener\">QEMU</a>（Quick EMUlator）是一款能在 Linux 系统上运行 DOS 系统的开源的虚拟机软件。很多流行的 Linux 系统都自带 QEMU。QEMU 在我的树莓派上的 Raspbian 系统中也同样能够运行，下文就有一些我在树莓派 <a href=\"https://www.raspberrypi.org/downloads/\" target=\"_blank\" rel=\"noopener\">Raspbian GNU/Linux 9 (Stretch)</a> 系统中使用 QEMU 的截图。</p>\n<p>去年我在写了一篇关于<a href=\"https://linux.cn/article-9014-1.html\" target=\"_blank\" rel=\"noopener\">如何在 Linux 系统中运行 DOS 程序</a>的文章的时候就用到了 QEMU，在树莓派上使用 QEMU 来安装运行 FreeDOS 的步骤基本上和在别的基于 GNOME 的系统上没有什么太大的区别。</p>\n<p>在 QEMU 中你需要通过添加各种组件来搭建虚拟机。先指定一个用来安装运行 DOS 的虚拟磁盘镜像，通过 <code>qemu-img</code> 命令来创建一个虚拟磁盘镜像，对于 FreeDOS 来说不需要太大的空间，所以我只创建了一个 200MB 的虚拟磁盘：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-img create freedos.img 200M</span><br></pre></td></tr></table></figure>\n<p>和 VMware 或者 VirtualBox 这些 PC 模拟器不同，使用 QEMU 需要通过添加各种组件来搭建虚拟机，尽管有点麻烦，但是并不困难。我使用了以下这些参数来在树莓派上使用 QEMU 安装 FreeDOS 系统：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=d</span><br></pre></td></tr></table></figure>\n<p>你可以在我其它的<a href=\"https://linux.cn/article-9014-1.html\" target=\"_blank\" rel=\"noopener\">文章</a>中找到这些命令的完整介绍。简单来说，上面这条命令指定了一个英特尔 i386 兼容虚拟机，并且分配了 16MB 内存、一个英文输入键盘、一个基于系统时间的实时时钟、一个声卡、一个音乐卡以及一个 VGA 卡。文件 <code>freedos.img</code> 指定为第一个硬盘（<code>C:</code>），<code>FD12CD.iso</code> 镜像作为 CD-ROM （<code>D:</code>）驱动。QEMU 设定为从 <code>D:</code> 的 CD-ROM 启动。</p>\n<p>你只需要按照提示就可以轻松安装好 FreeDOS 1.2 了。但是由于 microSD 卡在面对大量的 I/O 时速度比较慢，所以安装操作系统需要花费很长时间。</p>\n<h3 id=\"在树莓派上运行-FreeDOS\"><a href=\"#在树莓派上运行-FreeDOS\" class=\"headerlink\" title=\"在树莓派上运行 FreeDOS\"></a>在树莓派上运行 FreeDOS</h3><p>你的运行情况取决于使用哪一种 microSD 卡。我用的是 SanDisk Ultra 64GB microSDXC UHS-I U1A1 ，其中 U1 这种型号专用于支持 1080p 的视频录制（例如 GoPro），它的最低串行写速度能够达到 10MB/s。相比之下，V60 型号专用于 4K 视频录制，最低连续写入速度能达到 60MB/s。如果你的树莓派使用的是 V60 的 microSD 卡甚至是 V30（也能达到 30MB/s），你就能明显看到它的 I/O 性能会比我的好。</p>\n<p>FreeDOS 安装好之后，你可以直接从 <code>C:</code> 进行启动。只需要按照下面的命令用 <code>-boot order=c</code> 来指定 QEMU 的启动顺序即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">​qemu-system-i386 -m 16 -k en-us -rtc base=localtime -soundhw sb16,adlib -device cirrus-vga -hda freedos.img -cdrom FD12CD.iso -boot order=c​</span><br></pre></td></tr></table></figure>\n<p>只要树莓派的 QEMU 上安装了 FreeDOS，就不会出现明显的性能问题。例如游戏通常在每一关开始的时候会加载地图、怪物、声音等一系列的数据，尽管这些内容需要加载一段时间，但在正常玩的时候并没有出现性能不足的现象。</p>\n<p>FreeDOS 1.2 自带了很多游戏以及其它应用软件，可以使用 <code>FDIMPLES</code> 包管理程序来安装它们。FreeDOS 1.2 里面我最喜欢的是一款叫 WING 的太空射击游戏，让人想起经典的街机游戏 Galaga（WING 就是 Wing Is Not Galaga 的递归缩写词）。</p>\n<p>As-Easy-As 是我最喜欢的一个 DOS 应用程序，作为 20 世纪八九十年代流行的电子表格程序，它和当时的 Lotus 1-2-3 以及现在的 Microsoft Excel、LibreOffice Calc 一样具有强大的威力。As-Easy-As 和 Lotus 1-2-3 都将数据保存为 WKS 文件，现在新版本的 Microsoft Excel 已经无法读取这种文件了，而 LibreOffice Calc 视兼容性而定有可能支持。鉴于 As-Easy-As 的初始版本是一个共享软件，TRIUS 仍然为 As-Easy-As 5.7 免费提供<a href=\"http://www.triusinc.com/forums/viewtopic.php?t=10\" target=\"_blank\" rel=\"noopener\">激活码</a>。</p>\n<p>我也非常喜欢 GNU Emacs 编辑器，FreeDOS 也自带了一个叫 Freemacs 的类 Emacs 的文本编辑器。它比 FreeDOS 默认的 FreeDOS Edit 编辑器更强大，也能带来 GNU Emacs 的体验。如果你也需要，可以在 FreeDOS 1.2 中通过<code>FDIMPLES</code>包管理程序来安装。</p>\n<h3 id=\"是的，你或许真的可以在树莓派上运行-DOS\"><a href=\"#是的，你或许真的可以在树莓派上运行-DOS\" class=\"headerlink\" title=\"是的，你或许真的可以在树莓派上运行 DOS\"></a>是的，你或许真的可以在树莓派上运行 DOS</h3><p>即使树莓派在硬件上不支持 DOS，但是在模拟器的帮助下，DOS 还是能够在树莓派上运行。得益于 QEMU PC 模拟器，一些经典的 DOS 游戏和 DOS 应用程序能够运行在树莓派上。在执行磁盘 I/O ，尤其是大量密集操作（例如写入大量数据）的时候，性能可能会受到轻微的影响。当你使用 QEMU 并且在虚拟机里安装好 FreeDOS 之后，你就可以尽情享受经典的 DOS 程序了。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/3/can-you-run-dos-raspberry-pi</a></p>\n"},{"title":"关于 top 工具的 6 个替代方案","date":"2018-12-08T05:45:26.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Alternatives-To-Top-Command-720x340.png)\n\n在 GitHub 和 GitLab 上，不断有来自世界各地的开源应用程序和工具涌现。其中有全新的应用程序，也有针对现有各种被广泛使用的 Linux 程序的替代方案。在本文档中，我会介绍一些针对 [top][1] 工具（也就是命令行任务管理器程序）的替代方案。\n\n### top 工具的替代方案\n\n在本文中，将会介绍以下 6 种 `top` 工具的替代方案：\n\n  1. Htop\n  2. Vtop\n  3. Gtop\n  4. Gotop\n  5. Ptop\n  6. Hegemon\n\n如果后续有更多类似的工具，原作者会在原文进行更新。如果你对此有兴趣，可以持续关注。\n\n####  Htop\n\n`htop` 是一个流行的开源跨平台交互式进程管理器，也是我最喜欢的系统活动监控工具。`htop` 是对原版 `top` 工具的扩展。它最初只是用于 Linux 系统，后来开发者们不断为其添加对其它类 Unix 操作系统的支持，包括 FreeBSD 和 Mac OS。`htop` 还是一个自由开源软件，它基于 ncurses 并按照 GPLv2 发布。\n\n和原版的 `top` 工具相比，`htop` 工具有这些优势：\n\n  * `htop` 比 `top` 启动更快\n  * `htop` 支持横向滚动和纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行\n  * 在 `top` 工具中进行杀死进程、更改进程优先级这些操作时，需要输入进程 ID，而在 `htop` 工具中则不需要输入\n  * 在 `htop` 中可以同时杀死多个进程\n  * 在 `top` 中每次输入一个未预设的键都要等待一段时间，尤其是在多个键组成转义字符串的时候就更麻烦了\n\n在很多 Linux 发行版的默认软件仓库中，都带有了 `htop`。\n\n在基于 Arch 的操作系统中则可以执行以下命令来安装 `htop`：\n\n```\n$ sudo pacman -S htop\n```\n\n在基于 Debian 的操作系统使用以下命令：\n\n```\n$ sudo apt install htop\n```\n\n在使用 RPM 软件管理的操作系统使用以下命令：\n\n```\n$ sudo dnf install htop\n```\n\n或者\n\n```\n$ sudo yum install htop\n```\n\n在 openSUSE 系统中：\n\n```\n$ sudo zypper in htop\n```\n\n**用法**\n\n不带任何参数执行 `htop` 时，会显示如下画面：\n\n```\n$ htop\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/htop-command-1.png)\n\n从图上可以看出，`htop` 会在界面顶部显示内存、交换空间、任务总数、系统平均负载、系统正常运行时间这些常用指标，在下方则和 `top` 一样显示进程列表，并且将进程的 ID、用户、进程优先级、进程 nice 值、虚拟内存使用情况、CPU 使用情况、内存使用情况等信息以多列显示出来。如果你想详细了解这些数据的含义，可以在[这里][1]阅读参考。\n\n和 `top` 不同的是，`htop` 支持对不同的操作使用专有的按键。以下列出一些用于与 `htop` 交互的快捷键：\n\n  * `F1`、`h`、`?`：进入帮助界面。\n  * `F2`、`Shift+s`：进入设置界面。在设置界面中可以配置仪表板界面顶部显示哪些数据，以及设置颜色方案、显示列、显示顺序等等多种参数。\n  * `F3`、`/`：在进程列表中进行搜索。\n  * `F4`、`\\`：进入筛选模式。输入一个字符串，筛选出包含这个字符串的进程。进入筛选模式后再按一次 `F4` 或者 `ESC` 可以退出筛选模式。\n  * `F5`、`t`：切换默认显示模式和树型显示模式，在树型显示模式下按 `+` 可以查看子树。\n  * `F6`、`<`、`>`：依次按照进程 ID、用户、进程优先级、进程 nice 值、CPU 使用率、内存使用率排序显示。\n  * `F7`、`]`：提高所选进程的优先级。\n  * `F8`、`[`：降低所选进程的优先级。\n  * `F9`、`k`：杀死所选进程。可以用 `↑` / `↓` 键选择不同的进程并按 `F9` 杀死进程。\n  * `F10`、`q`： 退出 `htop`\n\n以上这些快捷键都在 `htop` 界面底部显示。\n\n需要注意的是，这其中有一些快捷键可能会与已有的快捷键发生冲突。例如按 `F2` 之后可能没有进入 `htop` 的设置界面，而是开始了对终端窗口的重命名。在这种情况下，你可能要更改一下快捷键的设置。\n\n除了以上列出的快捷键以外，还有一些带有其它功能的快捷键，例如：\n\n  * `u` 可以选择显示某个用户的进程。\n  * `Shift+m` 可以按照内存使用量对进程列表排序。\n  * `Shift+p` 可以按照 CPU 使用量对进程列表排序。\n  * `Shit+t` 可以按照进程启动时间对进程列表排序。\n  * `CTRL+l` 刷新界面。\n\n`htop` 的所有功能都可以在启动后通过快捷键来调用，而不需要在启动的时候带上某个参数。当然，`htop` 也支持带参数启动。\n\n例如按照以下方式启动 `htop` 就可以只显示某个用户的进程：\n\n```\n$ htop -u <username>\n```\n\n更改界面自动刷新的时间间隔：\n\n```\n$ htop -d 10\n```\n\n看，`htop` 确实比 `top` 好用多了。\n\n想了解 `htop` 的更多细节，可以查阅它的手册页面：\n\n```\n$ man htop\n```\n\n也可以查看它的[项目主页](http://hisham.hm/htop/) 和 [GitHub 仓库](https://github.com/hishamhm/htop)。\n\n#### Vtop\n\n`vtop` 是 `top` 工具的另一个替代方案。它是一个使用 NodeJS 编写的、自由开源的命令行界面系统活动监视器，并使用 MIT 许可证发布。`vtop` 通过使用 unicode 中的盲文字符来绘制 CPU 和内存使用情况的可视化图表。\n\n在安装 `vtop` 之前，需要先安装 NodeJS。如果还没有安装 NodeJS，可以按照[这个教程](https://www.ostechnix.com/install-node-js-linux/)进行安装。\n\nNodeJS 安装完毕之后，执行以下命令安装 `vtop`：\n\n```\n$ npm install -g vtop\n```\n\n安装好 `vtop` 就可以执行以下命令开始监控了。\n\n```\n$ vtop\n```\n\n显示界面如下：\n\n![][3]\n\n如上图所示，`vtop` 界面和 `top`、`htop` 都有所不同，它将不同的内容分别以多个框的布局显示。另外在界面底部也展示了用于与 `vtop` 交互的所有快捷键。\n\n`vtop` 有这些快捷键：\n\n  * `dd` ：杀死一个进程。\n  * `↑`、`k`：向上移动。\n  * `↓`、`j`：向下移动。\n  * `←`、`h` ：放大图表。\n  * `→`、`l`：缩小图表。\n  * `g` ：跳转到进程列表顶部。\n  * `Shift+g` ：跳转到进程列表底部。\n  * `c` ：以 CPU 使用量对进程排序。\n  * `m` ：以内存使用量对进程排序。\n\n想要了解更多关于 `vtop` 的细节，可以查阅它的[项目主页](http://parall.ax/vtop)或者 [GitHub 仓库](https://github.com/MrRio/vtop)。\n\n#### Gtop\n\n`gtop` 和 `vtop` 一样，都是一个使用 NodeJS 编写、在 MIT 许可下发布的系统活动监视器。\n\n执行以下命令安装 `gtop`：\n\n```\n$ npm install gtop -g\n```\n\n然后执行以下命令启动：\n\n```\n$ gtop\n```\n\n显示界面如下：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/gtop.png)\n\n`gtop` 有一个优点，就是它会以不同的颜色来显示不同的模块，这种表现形式非常清晰明了。\n\n主要的快捷键包括：\n\n  * `p`：按照进程 ID 对进程排序。\n  * `c`：按照 CPU 使用量对进程排序。\n  * `m`：按照内存使用量对进程排序。\n  * `q`、`Ctrl+c`：退出。\n\n想要了解更多关于 `gtop` 的细节，可以查阅它的 [GitHub 仓库](https://github.com/aksakalli/gtop)。\n\n#### Gotop\n\n`gotop` 也是一个完全自由和开源的图表式系统活动监视器。顾名思义，它是在受到 `gtop` 和 `vtop` 的启发之后用 Go 语言编写的，因此也不再对其展开过多的赘述了。如果你有兴趣了解这个项目，可以阅读《[gotop：又一个图表式系统活动监视器](https://www.ostechnix.com/manage-python-packages-using-pip/)》这篇文章。\n\n#### Ptop\n\n有些人对 NodeJS 和 Go 语言的项目可能不太感冒。如果你也是其中之一，你可以试一下使用 Python 编写的 `ptop`。它同样是一个自由开源的、在 MIT 许可下发布的系统活动监视器。\n\n`ptop` 同时兼容 Python2.x 和 Python3.x，因此可以使用 Python 的软件包管理器 `pip` 轻松安装。如果你没有安装 `pip`，也可以参考[这个教程](https://www.ostechnix.com/manage-python-packages-using-pip/)进行安装。\n\n安装 `pip` 之后，执行以下命令就可以安装 `ptop`：\n\n```\n$ pip install ptop\n```\n\n又或者按照以下方式通过源代码安装：\n\n```\n$ git clone https://github.com/darxtrix/ptop\n$ cd ptop/\n$ pip install -r requirements.txt # install requirements\n$ sudo python setup.py install\n```\n\n如果需要对 `ptop` 进行更新，可以这样操作：\n\n```\n$ pip install --upgrade ptop\n```\n\n即使你不执行更新，`ptop` 也会在第一次启动的时候提示你是否需要更新到最新的版本。\n\n现在可以看一下启动 `ptop` 后的界面。\n\n```\n$ ptop\n```\n\n就像下面这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/ptop-1.png)\n\n`ptop` 的快捷键包括以下这些：\n\n  * `Ctrl+k`：杀死一个进程。\n  * `Ctrl+n`：按照内存使用量对进程排序。\n  * `Ctrl+t`：按照进程启动时间对进程排序。\n  * `Ctrl+r`：重置所有数据。\n  * `Ctrl+f`：对进程进行筛选，输入进程的名称就能够筛选出符合条件的进程。\n  * `Ctrl+l`：查看所选进程的详细信息。\n  * `g`：跳转到进程列表顶部。\n  * `Ctrl+q`：退出。\n\n`ptop` 还支持更改显示主题。如果你想让 `ptop` 更好看，可以选择你喜欢的主题。可用的主题包括以下这些：\n\n  * colorful\n  * elegant\n  * simple\n  * dark\n  * light\n\n如果需要更换主题（例如更换到 colorful 主题），可以执行以下命令：\n\n```\n$ ptop -t colorful\n```\n\n使用 `-h` 参数可以查看帮助页面：\n\n```\n$ ptop -h\n```\n\n想要了解更多关于 `ptop` 的细节，可以查阅它的 [GitHub 仓库](https://github.com/darxtrix/ptop)。\n\n#### Hegemon\n\n`hegemon` 是一个使用 Rust 编写的系统活动监视器，如果你对 Rust 感兴趣，也可以了解一下。我们最近有一篇关于 `hegemon` 的[文章](https://www.ostechnix.com/hegemon-a-modular-system-monitor-application-written-in-rust/)，想要详细了解的读者不妨阅读。\n\n### 总结\n\n以上就是关于 `top` 工具的 6 个替代方案。我并不会说它们比 `top` 更好或者可以完全替代 `top`，但多了解一些类似的工具总是好的。你有使用过这些工具吗？哪个是你最喜欢的？欢迎在评论区留言。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\n[2]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[3]: http://www.ostechnix.com/wp-content/uploads/2018/11/vtop.png\n\n","source":"_posts/Some-Alternatives-To-top-Command-line-Utility-You-Might-Want-To-Know.md","raw":"---\ntitle: 关于 top 工具的 6 个替代方案\ndate: 2018-12-08 13:45:26\ntags:\n  - top\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/Alternatives-To-Top-Command-720x340.png)\n\n在 GitHub 和 GitLab 上，不断有来自世界各地的开源应用程序和工具涌现。其中有全新的应用程序，也有针对现有各种被广泛使用的 Linux 程序的替代方案。在本文档中，我会介绍一些针对 [top][1] 工具（也就是命令行任务管理器程序）的替代方案。\n\n### top 工具的替代方案\n\n在本文中，将会介绍以下 6 种 `top` 工具的替代方案：\n\n  1. Htop\n  2. Vtop\n  3. Gtop\n  4. Gotop\n  5. Ptop\n  6. Hegemon\n\n如果后续有更多类似的工具，原作者会在原文进行更新。如果你对此有兴趣，可以持续关注。\n\n####  Htop\n\n`htop` 是一个流行的开源跨平台交互式进程管理器，也是我最喜欢的系统活动监控工具。`htop` 是对原版 `top` 工具的扩展。它最初只是用于 Linux 系统，后来开发者们不断为其添加对其它类 Unix 操作系统的支持，包括 FreeBSD 和 Mac OS。`htop` 还是一个自由开源软件，它基于 ncurses 并按照 GPLv2 发布。\n\n和原版的 `top` 工具相比，`htop` 工具有这些优势：\n\n  * `htop` 比 `top` 启动更快\n  * `htop` 支持横向滚动和纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行\n  * 在 `top` 工具中进行杀死进程、更改进程优先级这些操作时，需要输入进程 ID，而在 `htop` 工具中则不需要输入\n  * 在 `htop` 中可以同时杀死多个进程\n  * 在 `top` 中每次输入一个未预设的键都要等待一段时间，尤其是在多个键组成转义字符串的时候就更麻烦了\n\n在很多 Linux 发行版的默认软件仓库中，都带有了 `htop`。\n\n在基于 Arch 的操作系统中则可以执行以下命令来安装 `htop`：\n\n```\n$ sudo pacman -S htop\n```\n\n在基于 Debian 的操作系统使用以下命令：\n\n```\n$ sudo apt install htop\n```\n\n在使用 RPM 软件管理的操作系统使用以下命令：\n\n```\n$ sudo dnf install htop\n```\n\n或者\n\n```\n$ sudo yum install htop\n```\n\n在 openSUSE 系统中：\n\n```\n$ sudo zypper in htop\n```\n\n**用法**\n\n不带任何参数执行 `htop` 时，会显示如下画面：\n\n```\n$ htop\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/htop-command-1.png)\n\n从图上可以看出，`htop` 会在界面顶部显示内存、交换空间、任务总数、系统平均负载、系统正常运行时间这些常用指标，在下方则和 `top` 一样显示进程列表，并且将进程的 ID、用户、进程优先级、进程 nice 值、虚拟内存使用情况、CPU 使用情况、内存使用情况等信息以多列显示出来。如果你想详细了解这些数据的含义，可以在[这里][1]阅读参考。\n\n和 `top` 不同的是，`htop` 支持对不同的操作使用专有的按键。以下列出一些用于与 `htop` 交互的快捷键：\n\n  * `F1`、`h`、`?`：进入帮助界面。\n  * `F2`、`Shift+s`：进入设置界面。在设置界面中可以配置仪表板界面顶部显示哪些数据，以及设置颜色方案、显示列、显示顺序等等多种参数。\n  * `F3`、`/`：在进程列表中进行搜索。\n  * `F4`、`\\`：进入筛选模式。输入一个字符串，筛选出包含这个字符串的进程。进入筛选模式后再按一次 `F4` 或者 `ESC` 可以退出筛选模式。\n  * `F5`、`t`：切换默认显示模式和树型显示模式，在树型显示模式下按 `+` 可以查看子树。\n  * `F6`、`<`、`>`：依次按照进程 ID、用户、进程优先级、进程 nice 值、CPU 使用率、内存使用率排序显示。\n  * `F7`、`]`：提高所选进程的优先级。\n  * `F8`、`[`：降低所选进程的优先级。\n  * `F9`、`k`：杀死所选进程。可以用 `↑` / `↓` 键选择不同的进程并按 `F9` 杀死进程。\n  * `F10`、`q`： 退出 `htop`\n\n以上这些快捷键都在 `htop` 界面底部显示。\n\n需要注意的是，这其中有一些快捷键可能会与已有的快捷键发生冲突。例如按 `F2` 之后可能没有进入 `htop` 的设置界面，而是开始了对终端窗口的重命名。在这种情况下，你可能要更改一下快捷键的设置。\n\n除了以上列出的快捷键以外，还有一些带有其它功能的快捷键，例如：\n\n  * `u` 可以选择显示某个用户的进程。\n  * `Shift+m` 可以按照内存使用量对进程列表排序。\n  * `Shift+p` 可以按照 CPU 使用量对进程列表排序。\n  * `Shit+t` 可以按照进程启动时间对进程列表排序。\n  * `CTRL+l` 刷新界面。\n\n`htop` 的所有功能都可以在启动后通过快捷键来调用，而不需要在启动的时候带上某个参数。当然，`htop` 也支持带参数启动。\n\n例如按照以下方式启动 `htop` 就可以只显示某个用户的进程：\n\n```\n$ htop -u <username>\n```\n\n更改界面自动刷新的时间间隔：\n\n```\n$ htop -d 10\n```\n\n看，`htop` 确实比 `top` 好用多了。\n\n想了解 `htop` 的更多细节，可以查阅它的手册页面：\n\n```\n$ man htop\n```\n\n也可以查看它的[项目主页](http://hisham.hm/htop/) 和 [GitHub 仓库](https://github.com/hishamhm/htop)。\n\n#### Vtop\n\n`vtop` 是 `top` 工具的另一个替代方案。它是一个使用 NodeJS 编写的、自由开源的命令行界面系统活动监视器，并使用 MIT 许可证发布。`vtop` 通过使用 unicode 中的盲文字符来绘制 CPU 和内存使用情况的可视化图表。\n\n在安装 `vtop` 之前，需要先安装 NodeJS。如果还没有安装 NodeJS，可以按照[这个教程](https://www.ostechnix.com/install-node-js-linux/)进行安装。\n\nNodeJS 安装完毕之后，执行以下命令安装 `vtop`：\n\n```\n$ npm install -g vtop\n```\n\n安装好 `vtop` 就可以执行以下命令开始监控了。\n\n```\n$ vtop\n```\n\n显示界面如下：\n\n![][3]\n\n如上图所示，`vtop` 界面和 `top`、`htop` 都有所不同，它将不同的内容分别以多个框的布局显示。另外在界面底部也展示了用于与 `vtop` 交互的所有快捷键。\n\n`vtop` 有这些快捷键：\n\n  * `dd` ：杀死一个进程。\n  * `↑`、`k`：向上移动。\n  * `↓`、`j`：向下移动。\n  * `←`、`h` ：放大图表。\n  * `→`、`l`：缩小图表。\n  * `g` ：跳转到进程列表顶部。\n  * `Shift+g` ：跳转到进程列表底部。\n  * `c` ：以 CPU 使用量对进程排序。\n  * `m` ：以内存使用量对进程排序。\n\n想要了解更多关于 `vtop` 的细节，可以查阅它的[项目主页](http://parall.ax/vtop)或者 [GitHub 仓库](https://github.com/MrRio/vtop)。\n\n#### Gtop\n\n`gtop` 和 `vtop` 一样，都是一个使用 NodeJS 编写、在 MIT 许可下发布的系统活动监视器。\n\n执行以下命令安装 `gtop`：\n\n```\n$ npm install gtop -g\n```\n\n然后执行以下命令启动：\n\n```\n$ gtop\n```\n\n显示界面如下：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/gtop.png)\n\n`gtop` 有一个优点，就是它会以不同的颜色来显示不同的模块，这种表现形式非常清晰明了。\n\n主要的快捷键包括：\n\n  * `p`：按照进程 ID 对进程排序。\n  * `c`：按照 CPU 使用量对进程排序。\n  * `m`：按照内存使用量对进程排序。\n  * `q`、`Ctrl+c`：退出。\n\n想要了解更多关于 `gtop` 的细节，可以查阅它的 [GitHub 仓库](https://github.com/aksakalli/gtop)。\n\n#### Gotop\n\n`gotop` 也是一个完全自由和开源的图表式系统活动监视器。顾名思义，它是在受到 `gtop` 和 `vtop` 的启发之后用 Go 语言编写的，因此也不再对其展开过多的赘述了。如果你有兴趣了解这个项目，可以阅读《[gotop：又一个图表式系统活动监视器](https://www.ostechnix.com/manage-python-packages-using-pip/)》这篇文章。\n\n#### Ptop\n\n有些人对 NodeJS 和 Go 语言的项目可能不太感冒。如果你也是其中之一，你可以试一下使用 Python 编写的 `ptop`。它同样是一个自由开源的、在 MIT 许可下发布的系统活动监视器。\n\n`ptop` 同时兼容 Python2.x 和 Python3.x，因此可以使用 Python 的软件包管理器 `pip` 轻松安装。如果你没有安装 `pip`，也可以参考[这个教程](https://www.ostechnix.com/manage-python-packages-using-pip/)进行安装。\n\n安装 `pip` 之后，执行以下命令就可以安装 `ptop`：\n\n```\n$ pip install ptop\n```\n\n又或者按照以下方式通过源代码安装：\n\n```\n$ git clone https://github.com/darxtrix/ptop\n$ cd ptop/\n$ pip install -r requirements.txt # install requirements\n$ sudo python setup.py install\n```\n\n如果需要对 `ptop` 进行更新，可以这样操作：\n\n```\n$ pip install --upgrade ptop\n```\n\n即使你不执行更新，`ptop` 也会在第一次启动的时候提示你是否需要更新到最新的版本。\n\n现在可以看一下启动 `ptop` 后的界面。\n\n```\n$ ptop\n```\n\n就像下面这样：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/ptop-1.png)\n\n`ptop` 的快捷键包括以下这些：\n\n  * `Ctrl+k`：杀死一个进程。\n  * `Ctrl+n`：按照内存使用量对进程排序。\n  * `Ctrl+t`：按照进程启动时间对进程排序。\n  * `Ctrl+r`：重置所有数据。\n  * `Ctrl+f`：对进程进行筛选，输入进程的名称就能够筛选出符合条件的进程。\n  * `Ctrl+l`：查看所选进程的详细信息。\n  * `g`：跳转到进程列表顶部。\n  * `Ctrl+q`：退出。\n\n`ptop` 还支持更改显示主题。如果你想让 `ptop` 更好看，可以选择你喜欢的主题。可用的主题包括以下这些：\n\n  * colorful\n  * elegant\n  * simple\n  * dark\n  * light\n\n如果需要更换主题（例如更换到 colorful 主题），可以执行以下命令：\n\n```\n$ ptop -t colorful\n```\n\n使用 `-h` 参数可以查看帮助页面：\n\n```\n$ ptop -h\n```\n\n想要了解更多关于 `ptop` 的细节，可以查阅它的 [GitHub 仓库](https://github.com/darxtrix/ptop)。\n\n#### Hegemon\n\n`hegemon` 是一个使用 Rust 编写的系统活动监视器，如果你对 Rust 感兴趣，也可以了解一下。我们最近有一篇关于 `hegemon` 的[文章](https://www.ostechnix.com/hegemon-a-modular-system-monitor-application-written-in-rust/)，想要详细了解的读者不妨阅读。\n\n### 总结\n\n以上就是关于 `top` 工具的 6 个替代方案。我并不会说它们比 `top` 更好或者可以完全替代 `top`，但多了解一些类似的工具总是好的。你有使用过这些工具吗？哪个是你最喜欢的？欢迎在评论区留言。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\n[2]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[3]: http://www.ostechnix.com/wp-content/uploads/2018/11/vtop.png\n\n","slug":"Some-Alternatives-To-top-Command-line-Utility-You-Might-Want-To-Know","published":1,"updated":"2019-03-28T13:09:25.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0db001tlixusctoq59b","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Alternatives-To-Top-Command-720x340.png\" alt=\"\"></p>\n<p>在 GitHub 和 GitLab 上，不断有来自世界各地的开源应用程序和工具涌现。其中有全新的应用程序，也有针对现有各种被广泛使用的 Linux 程序的替代方案。在本文档中，我会介绍一些针对 <a href=\"https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\" target=\"_blank\" rel=\"noopener\">top</a> 工具（也就是命令行任务管理器程序）的替代方案。</p>\n<h3 id=\"top-工具的替代方案\"><a href=\"#top-工具的替代方案\" class=\"headerlink\" title=\"top 工具的替代方案\"></a>top 工具的替代方案</h3><p>在本文中，将会介绍以下 6 种 <code>top</code> 工具的替代方案：</p>\n<ol>\n<li>Htop</li>\n<li>Vtop</li>\n<li>Gtop</li>\n<li>Gotop</li>\n<li>Ptop</li>\n<li>Hegemon</li>\n</ol>\n<p>如果后续有更多类似的工具，原作者会在原文进行更新。如果你对此有兴趣，可以持续关注。</p>\n<h4 id=\"Htop\"><a href=\"#Htop\" class=\"headerlink\" title=\"Htop\"></a>Htop</h4><p><code>htop</code> 是一个流行的开源跨平台交互式进程管理器，也是我最喜欢的系统活动监控工具。<code>htop</code> 是对原版 <code>top</code> 工具的扩展。它最初只是用于 Linux 系统，后来开发者们不断为其添加对其它类 Unix 操作系统的支持，包括 FreeBSD 和 Mac OS。<code>htop</code> 还是一个自由开源软件，它基于 ncurses 并按照 GPLv2 发布。</p>\n<p>和原版的 <code>top</code> 工具相比，<code>htop</code> 工具有这些优势：</p>\n<ul>\n<li><code>htop</code> 比 <code>top</code> 启动更快</li>\n<li><code>htop</code> 支持横向滚动和纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行</li>\n<li>在 <code>top</code> 工具中进行杀死进程、更改进程优先级这些操作时，需要输入进程 ID，而在 <code>htop</code> 工具中则不需要输入</li>\n<li>在 <code>htop</code> 中可以同时杀死多个进程</li>\n<li>在 <code>top</code> 中每次输入一个未预设的键都要等待一段时间，尤其是在多个键组成转义字符串的时候就更麻烦了</li>\n</ul>\n<p>在很多 Linux 发行版的默认软件仓库中，都带有了 <code>htop</code>。</p>\n<p>在基于 Arch 的操作系统中则可以执行以下命令来安装 <code>htop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo pacman -S htop</span><br></pre></td></tr></table></figure>\n<p>在基于 Debian 的操作系统使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install htop</span><br></pre></td></tr></table></figure>\n<p>在使用 RPM 软件管理的操作系统使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo dnf install htop</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install htop</span><br></pre></td></tr></table></figure>\n<p>在 openSUSE 系统中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo zypper in htop</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>不带任何参数执行 <code>htop</code> 时，会显示如下画面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/htop-command-1.png\" alt=\"\"></p>\n<p>从图上可以看出，<code>htop</code> 会在界面顶部显示内存、交换空间、任务总数、系统平均负载、系统正常运行时间这些常用指标，在下方则和 <code>top</code> 一样显示进程列表，并且将进程的 ID、用户、进程优先级、进程 nice 值、虚拟内存使用情况、CPU 使用情况、内存使用情况等信息以多列显示出来。如果你想详细了解这些数据的含义，可以在<a href=\"https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\" target=\"_blank\" rel=\"noopener\">这里</a>阅读参考。</p>\n<p>和 <code>top</code> 不同的是，<code>htop</code> 支持对不同的操作使用专有的按键。以下列出一些用于与 <code>htop</code> 交互的快捷键：</p>\n<ul>\n<li><code>F1</code>、<code>h</code>、<code>?</code>：进入帮助界面。</li>\n<li><code>F2</code>、<code>Shift+s</code>：进入设置界面。在设置界面中可以配置仪表板界面顶部显示哪些数据，以及设置颜色方案、显示列、显示顺序等等多种参数。</li>\n<li><code>F3</code>、<code>/</code>：在进程列表中进行搜索。</li>\n<li><code>F4</code>、<code>\\</code>：进入筛选模式。输入一个字符串，筛选出包含这个字符串的进程。进入筛选模式后再按一次 <code>F4</code> 或者 <code>ESC</code> 可以退出筛选模式。</li>\n<li><code>F5</code>、<code>t</code>：切换默认显示模式和树型显示模式，在树型显示模式下按 <code>+</code> 可以查看子树。</li>\n<li><code>F6</code>、<code>&lt;</code>、<code>&gt;</code>：依次按照进程 ID、用户、进程优先级、进程 nice 值、CPU 使用率、内存使用率排序显示。</li>\n<li><code>F7</code>、<code>]</code>：提高所选进程的优先级。</li>\n<li><code>F8</code>、<code>[</code>：降低所选进程的优先级。</li>\n<li><code>F9</code>、<code>k</code>：杀死所选进程。可以用 <code>↑</code> / <code>↓</code> 键选择不同的进程并按 <code>F9</code> 杀死进程。</li>\n<li><code>F10</code>、<code>q</code>： 退出 <code>htop</code></li>\n</ul>\n<p>以上这些快捷键都在 <code>htop</code> 界面底部显示。</p>\n<p>需要注意的是，这其中有一些快捷键可能会与已有的快捷键发生冲突。例如按 <code>F2</code> 之后可能没有进入 <code>htop</code> 的设置界面，而是开始了对终端窗口的重命名。在这种情况下，你可能要更改一下快捷键的设置。</p>\n<p>除了以上列出的快捷键以外，还有一些带有其它功能的快捷键，例如：</p>\n<ul>\n<li><code>u</code> 可以选择显示某个用户的进程。</li>\n<li><code>Shift+m</code> 可以按照内存使用量对进程列表排序。</li>\n<li><code>Shift+p</code> 可以按照 CPU 使用量对进程列表排序。</li>\n<li><code>Shit+t</code> 可以按照进程启动时间对进程列表排序。</li>\n<li><code>CTRL+l</code> 刷新界面。</li>\n</ul>\n<p><code>htop</code> 的所有功能都可以在启动后通过快捷键来调用，而不需要在启动的时候带上某个参数。当然，<code>htop</code> 也支持带参数启动。</p>\n<p>例如按照以下方式启动 <code>htop</code> 就可以只显示某个用户的进程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop -u &lt;username&gt;</span><br></pre></td></tr></table></figure>\n<p>更改界面自动刷新的时间间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop -d 10</span><br></pre></td></tr></table></figure>\n<p>看，<code>htop</code> 确实比 <code>top</code> 好用多了。</p>\n<p>想了解 <code>htop</code> 的更多细节，可以查阅它的手册页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man htop</span><br></pre></td></tr></table></figure>\n<p>也可以查看它的<a href=\"http://hisham.hm/htop/\" target=\"_blank\" rel=\"noopener\">项目主页</a> 和 <a href=\"https://github.com/hishamhm/htop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Vtop\"><a href=\"#Vtop\" class=\"headerlink\" title=\"Vtop\"></a>Vtop</h4><p><code>vtop</code> 是 <code>top</code> 工具的另一个替代方案。它是一个使用 NodeJS 编写的、自由开源的命令行界面系统活动监视器，并使用 MIT 许可证发布。<code>vtop</code> 通过使用 unicode 中的盲文字符来绘制 CPU 和内存使用情况的可视化图表。</p>\n<p>在安装 <code>vtop</code> 之前，需要先安装 NodeJS。如果还没有安装 NodeJS，可以按照<a href=\"https://www.ostechnix.com/install-node-js-linux/\" target=\"_blank\" rel=\"noopener\">这个教程</a>进行安装。</p>\n<p>NodeJS 安装完毕之后，执行以下命令安装 <code>vtop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g vtop</span><br></pre></td></tr></table></figure>\n<p>安装好 <code>vtop</code> 就可以执行以下命令开始监控了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vtop</span><br></pre></td></tr></table></figure>\n<p>显示界面如下：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/vtop.png\" alt=\"\"></p>\n<p>如上图所示，<code>vtop</code> 界面和 <code>top</code>、<code>htop</code> 都有所不同，它将不同的内容分别以多个框的布局显示。另外在界面底部也展示了用于与 <code>vtop</code> 交互的所有快捷键。</p>\n<p><code>vtop</code> 有这些快捷键：</p>\n<ul>\n<li><code>dd</code> ：杀死一个进程。</li>\n<li><code>↑</code>、<code>k</code>：向上移动。</li>\n<li><code>↓</code>、<code>j</code>：向下移动。</li>\n<li><code>←</code>、<code>h</code> ：放大图表。</li>\n<li><code>→</code>、<code>l</code>：缩小图表。</li>\n<li><code>g</code> ：跳转到进程列表顶部。</li>\n<li><code>Shift+g</code> ：跳转到进程列表底部。</li>\n<li><code>c</code> ：以 CPU 使用量对进程排序。</li>\n<li><code>m</code> ：以内存使用量对进程排序。</li>\n</ul>\n<p>想要了解更多关于 <code>vtop</code> 的细节，可以查阅它的<a href=\"http://parall.ax/vtop\" target=\"_blank\" rel=\"noopener\">项目主页</a>或者 <a href=\"https://github.com/MrRio/vtop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Gtop\"><a href=\"#Gtop\" class=\"headerlink\" title=\"Gtop\"></a>Gtop</h4><p><code>gtop</code> 和 <code>vtop</code> 一样，都是一个使用 NodeJS 编写、在 MIT 许可下发布的系统活动监视器。</p>\n<p>执行以下命令安装 <code>gtop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gtop -g</span><br></pre></td></tr></table></figure>\n<p>然后执行以下命令启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gtop</span><br></pre></td></tr></table></figure>\n<p>显示界面如下：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/gtop.png\" alt=\"\"></p>\n<p><code>gtop</code> 有一个优点，就是它会以不同的颜色来显示不同的模块，这种表现形式非常清晰明了。</p>\n<p>主要的快捷键包括：</p>\n<ul>\n<li><code>p</code>：按照进程 ID 对进程排序。</li>\n<li><code>c</code>：按照 CPU 使用量对进程排序。</li>\n<li><code>m</code>：按照内存使用量对进程排序。</li>\n<li><code>q</code>、<code>Ctrl+c</code>：退出。</li>\n</ul>\n<p>想要了解更多关于 <code>gtop</code> 的细节，可以查阅它的 <a href=\"https://github.com/aksakalli/gtop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Gotop\"><a href=\"#Gotop\" class=\"headerlink\" title=\"Gotop\"></a>Gotop</h4><p><code>gotop</code> 也是一个完全自由和开源的图表式系统活动监视器。顾名思义，它是在受到 <code>gtop</code> 和 <code>vtop</code> 的启发之后用 Go 语言编写的，因此也不再对其展开过多的赘述了。如果你有兴趣了解这个项目，可以阅读《<a href=\"https://www.ostechnix.com/manage-python-packages-using-pip/\" target=\"_blank\" rel=\"noopener\">gotop：又一个图表式系统活动监视器</a>》这篇文章。</p>\n<h4 id=\"Ptop\"><a href=\"#Ptop\" class=\"headerlink\" title=\"Ptop\"></a>Ptop</h4><p>有些人对 NodeJS 和 Go 语言的项目可能不太感冒。如果你也是其中之一，你可以试一下使用 Python 编写的 <code>ptop</code>。它同样是一个自由开源的、在 MIT 许可下发布的系统活动监视器。</p>\n<p><code>ptop</code> 同时兼容 Python2.x 和 Python3.x，因此可以使用 Python 的软件包管理器 <code>pip</code> 轻松安装。如果你没有安装 <code>pip</code>，也可以参考<a href=\"https://www.ostechnix.com/manage-python-packages-using-pip/\" target=\"_blank\" rel=\"noopener\">这个教程</a>进行安装。</p>\n<p>安装 <code>pip</code> 之后，执行以下命令就可以安装 <code>ptop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install ptop</span><br></pre></td></tr></table></figure>\n<p>又或者按照以下方式通过源代码安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/darxtrix/ptop</span><br><span class=\"line\">$ cd ptop/</span><br><span class=\"line\">$ pip install -r requirements.txt # install requirements</span><br><span class=\"line\">$ sudo python setup.py install</span><br></pre></td></tr></table></figure>\n<p>如果需要对 <code>ptop</code> 进行更新，可以这样操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install --upgrade ptop</span><br></pre></td></tr></table></figure>\n<p>即使你不执行更新，<code>ptop</code> 也会在第一次启动的时候提示你是否需要更新到最新的版本。</p>\n<p>现在可以看一下启动 <code>ptop</code> 后的界面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop</span><br></pre></td></tr></table></figure>\n<p>就像下面这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/ptop-1.png\" alt=\"\"></p>\n<p><code>ptop</code> 的快捷键包括以下这些：</p>\n<ul>\n<li><code>Ctrl+k</code>：杀死一个进程。</li>\n<li><code>Ctrl+n</code>：按照内存使用量对进程排序。</li>\n<li><code>Ctrl+t</code>：按照进程启动时间对进程排序。</li>\n<li><code>Ctrl+r</code>：重置所有数据。</li>\n<li><code>Ctrl+f</code>：对进程进行筛选，输入进程的名称就能够筛选出符合条件的进程。</li>\n<li><code>Ctrl+l</code>：查看所选进程的详细信息。</li>\n<li><code>g</code>：跳转到进程列表顶部。</li>\n<li><code>Ctrl+q</code>：退出。</li>\n</ul>\n<p><code>ptop</code> 还支持更改显示主题。如果你想让 <code>ptop</code> 更好看，可以选择你喜欢的主题。可用的主题包括以下这些：</p>\n<ul>\n<li>colorful</li>\n<li>elegant</li>\n<li>simple</li>\n<li>dark</li>\n<li>light</li>\n</ul>\n<p>如果需要更换主题（例如更换到 colorful 主题），可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop -t colorful</span><br></pre></td></tr></table></figure>\n<p>使用 <code>-h</code> 参数可以查看帮助页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop -h</span><br></pre></td></tr></table></figure>\n<p>想要了解更多关于 <code>ptop</code> 的细节，可以查阅它的 <a href=\"https://github.com/darxtrix/ptop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Hegemon\"><a href=\"#Hegemon\" class=\"headerlink\" title=\"Hegemon\"></a>Hegemon</h4><p><code>hegemon</code> 是一个使用 Rust 编写的系统活动监视器，如果你对 Rust 感兴趣，也可以了解一下。我们最近有一篇关于 <code>hegemon</code> 的<a href=\"https://www.ostechnix.com/hegemon-a-modular-system-monitor-application-written-in-rust/\" target=\"_blank\" rel=\"noopener\">文章</a>，想要详细了解的读者不妨阅读。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是关于 <code>top</code> 工具的 6 个替代方案。我并不会说它们比 <code>top</code> 更好或者可以完全替代 <code>top</code>，但多了解一些类似的工具总是好的。你有使用过这些工具吗？哪个是你最喜欢的？欢迎在评论区留言。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/Alternatives-To-Top-Command-720x340.png\" alt=\"\"></p>\n<p>在 GitHub 和 GitLab 上，不断有来自世界各地的开源应用程序和工具涌现。其中有全新的应用程序，也有针对现有各种被广泛使用的 Linux 程序的替代方案。在本文档中，我会介绍一些针对 <a href=\"https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\" target=\"_blank\" rel=\"noopener\">top</a> 工具（也就是命令行任务管理器程序）的替代方案。</p>\n<h3 id=\"top-工具的替代方案\"><a href=\"#top-工具的替代方案\" class=\"headerlink\" title=\"top 工具的替代方案\"></a>top 工具的替代方案</h3><p>在本文中，将会介绍以下 6 种 <code>top</code> 工具的替代方案：</p>\n<ol>\n<li>Htop</li>\n<li>Vtop</li>\n<li>Gtop</li>\n<li>Gotop</li>\n<li>Ptop</li>\n<li>Hegemon</li>\n</ol>\n<p>如果后续有更多类似的工具，原作者会在原文进行更新。如果你对此有兴趣，可以持续关注。</p>\n<h4 id=\"Htop\"><a href=\"#Htop\" class=\"headerlink\" title=\"Htop\"></a>Htop</h4><p><code>htop</code> 是一个流行的开源跨平台交互式进程管理器，也是我最喜欢的系统活动监控工具。<code>htop</code> 是对原版 <code>top</code> 工具的扩展。它最初只是用于 Linux 系统，后来开发者们不断为其添加对其它类 Unix 操作系统的支持，包括 FreeBSD 和 Mac OS。<code>htop</code> 还是一个自由开源软件，它基于 ncurses 并按照 GPLv2 发布。</p>\n<p>和原版的 <code>top</code> 工具相比，<code>htop</code> 工具有这些优势：</p>\n<ul>\n<li><code>htop</code> 比 <code>top</code> 启动更快</li>\n<li><code>htop</code> 支持横向滚动和纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行</li>\n<li>在 <code>top</code> 工具中进行杀死进程、更改进程优先级这些操作时，需要输入进程 ID，而在 <code>htop</code> 工具中则不需要输入</li>\n<li>在 <code>htop</code> 中可以同时杀死多个进程</li>\n<li>在 <code>top</code> 中每次输入一个未预设的键都要等待一段时间，尤其是在多个键组成转义字符串的时候就更麻烦了</li>\n</ul>\n<p>在很多 Linux 发行版的默认软件仓库中，都带有了 <code>htop</code>。</p>\n<p>在基于 Arch 的操作系统中则可以执行以下命令来安装 <code>htop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo pacman -S htop</span><br></pre></td></tr></table></figure>\n<p>在基于 Debian 的操作系统使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt install htop</span><br></pre></td></tr></table></figure>\n<p>在使用 RPM 软件管理的操作系统使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo dnf install htop</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install htop</span><br></pre></td></tr></table></figure>\n<p>在 openSUSE 系统中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo zypper in htop</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>不带任何参数执行 <code>htop</code> 时，会显示如下画面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/htop-command-1.png\" alt=\"\"></p>\n<p>从图上可以看出，<code>htop</code> 会在界面顶部显示内存、交换空间、任务总数、系统平均负载、系统正常运行时间这些常用指标，在下方则和 <code>top</code> 一样显示进程列表，并且将进程的 ID、用户、进程优先级、进程 nice 值、虚拟内存使用情况、CPU 使用情况、内存使用情况等信息以多列显示出来。如果你想详细了解这些数据的含义，可以在<a href=\"https://www.ostechnix.com/the-top-command-tutorial-with-examples-for-beginners/\" target=\"_blank\" rel=\"noopener\">这里</a>阅读参考。</p>\n<p>和 <code>top</code> 不同的是，<code>htop</code> 支持对不同的操作使用专有的按键。以下列出一些用于与 <code>htop</code> 交互的快捷键：</p>\n<ul>\n<li><code>F1</code>、<code>h</code>、<code>?</code>：进入帮助界面。</li>\n<li><code>F2</code>、<code>Shift+s</code>：进入设置界面。在设置界面中可以配置仪表板界面顶部显示哪些数据，以及设置颜色方案、显示列、显示顺序等等多种参数。</li>\n<li><code>F3</code>、<code>/</code>：在进程列表中进行搜索。</li>\n<li><code>F4</code>、<code>\\</code>：进入筛选模式。输入一个字符串，筛选出包含这个字符串的进程。进入筛选模式后再按一次 <code>F4</code> 或者 <code>ESC</code> 可以退出筛选模式。</li>\n<li><code>F5</code>、<code>t</code>：切换默认显示模式和树型显示模式，在树型显示模式下按 <code>+</code> 可以查看子树。</li>\n<li><code>F6</code>、<code>&lt;</code>、<code>&gt;</code>：依次按照进程 ID、用户、进程优先级、进程 nice 值、CPU 使用率、内存使用率排序显示。</li>\n<li><code>F7</code>、<code>]</code>：提高所选进程的优先级。</li>\n<li><code>F8</code>、<code>[</code>：降低所选进程的优先级。</li>\n<li><code>F9</code>、<code>k</code>：杀死所选进程。可以用 <code>↑</code> / <code>↓</code> 键选择不同的进程并按 <code>F9</code> 杀死进程。</li>\n<li><code>F10</code>、<code>q</code>： 退出 <code>htop</code></li>\n</ul>\n<p>以上这些快捷键都在 <code>htop</code> 界面底部显示。</p>\n<p>需要注意的是，这其中有一些快捷键可能会与已有的快捷键发生冲突。例如按 <code>F2</code> 之后可能没有进入 <code>htop</code> 的设置界面，而是开始了对终端窗口的重命名。在这种情况下，你可能要更改一下快捷键的设置。</p>\n<p>除了以上列出的快捷键以外，还有一些带有其它功能的快捷键，例如：</p>\n<ul>\n<li><code>u</code> 可以选择显示某个用户的进程。</li>\n<li><code>Shift+m</code> 可以按照内存使用量对进程列表排序。</li>\n<li><code>Shift+p</code> 可以按照 CPU 使用量对进程列表排序。</li>\n<li><code>Shit+t</code> 可以按照进程启动时间对进程列表排序。</li>\n<li><code>CTRL+l</code> 刷新界面。</li>\n</ul>\n<p><code>htop</code> 的所有功能都可以在启动后通过快捷键来调用，而不需要在启动的时候带上某个参数。当然，<code>htop</code> 也支持带参数启动。</p>\n<p>例如按照以下方式启动 <code>htop</code> 就可以只显示某个用户的进程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop -u &lt;username&gt;</span><br></pre></td></tr></table></figure>\n<p>更改界面自动刷新的时间间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ htop -d 10</span><br></pre></td></tr></table></figure>\n<p>看，<code>htop</code> 确实比 <code>top</code> 好用多了。</p>\n<p>想了解 <code>htop</code> 的更多细节，可以查阅它的手册页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man htop</span><br></pre></td></tr></table></figure>\n<p>也可以查看它的<a href=\"http://hisham.hm/htop/\" target=\"_blank\" rel=\"noopener\">项目主页</a> 和 <a href=\"https://github.com/hishamhm/htop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Vtop\"><a href=\"#Vtop\" class=\"headerlink\" title=\"Vtop\"></a>Vtop</h4><p><code>vtop</code> 是 <code>top</code> 工具的另一个替代方案。它是一个使用 NodeJS 编写的、自由开源的命令行界面系统活动监视器，并使用 MIT 许可证发布。<code>vtop</code> 通过使用 unicode 中的盲文字符来绘制 CPU 和内存使用情况的可视化图表。</p>\n<p>在安装 <code>vtop</code> 之前，需要先安装 NodeJS。如果还没有安装 NodeJS，可以按照<a href=\"https://www.ostechnix.com/install-node-js-linux/\" target=\"_blank\" rel=\"noopener\">这个教程</a>进行安装。</p>\n<p>NodeJS 安装完毕之后，执行以下命令安装 <code>vtop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g vtop</span><br></pre></td></tr></table></figure>\n<p>安装好 <code>vtop</code> 就可以执行以下命令开始监控了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vtop</span><br></pre></td></tr></table></figure>\n<p>显示界面如下：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/vtop.png\" alt=\"\"></p>\n<p>如上图所示，<code>vtop</code> 界面和 <code>top</code>、<code>htop</code> 都有所不同，它将不同的内容分别以多个框的布局显示。另外在界面底部也展示了用于与 <code>vtop</code> 交互的所有快捷键。</p>\n<p><code>vtop</code> 有这些快捷键：</p>\n<ul>\n<li><code>dd</code> ：杀死一个进程。</li>\n<li><code>↑</code>、<code>k</code>：向上移动。</li>\n<li><code>↓</code>、<code>j</code>：向下移动。</li>\n<li><code>←</code>、<code>h</code> ：放大图表。</li>\n<li><code>→</code>、<code>l</code>：缩小图表。</li>\n<li><code>g</code> ：跳转到进程列表顶部。</li>\n<li><code>Shift+g</code> ：跳转到进程列表底部。</li>\n<li><code>c</code> ：以 CPU 使用量对进程排序。</li>\n<li><code>m</code> ：以内存使用量对进程排序。</li>\n</ul>\n<p>想要了解更多关于 <code>vtop</code> 的细节，可以查阅它的<a href=\"http://parall.ax/vtop\" target=\"_blank\" rel=\"noopener\">项目主页</a>或者 <a href=\"https://github.com/MrRio/vtop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Gtop\"><a href=\"#Gtop\" class=\"headerlink\" title=\"Gtop\"></a>Gtop</h4><p><code>gtop</code> 和 <code>vtop</code> 一样，都是一个使用 NodeJS 编写、在 MIT 许可下发布的系统活动监视器。</p>\n<p>执行以下命令安装 <code>gtop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gtop -g</span><br></pre></td></tr></table></figure>\n<p>然后执行以下命令启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gtop</span><br></pre></td></tr></table></figure>\n<p>显示界面如下：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/gtop.png\" alt=\"\"></p>\n<p><code>gtop</code> 有一个优点，就是它会以不同的颜色来显示不同的模块，这种表现形式非常清晰明了。</p>\n<p>主要的快捷键包括：</p>\n<ul>\n<li><code>p</code>：按照进程 ID 对进程排序。</li>\n<li><code>c</code>：按照 CPU 使用量对进程排序。</li>\n<li><code>m</code>：按照内存使用量对进程排序。</li>\n<li><code>q</code>、<code>Ctrl+c</code>：退出。</li>\n</ul>\n<p>想要了解更多关于 <code>gtop</code> 的细节，可以查阅它的 <a href=\"https://github.com/aksakalli/gtop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Gotop\"><a href=\"#Gotop\" class=\"headerlink\" title=\"Gotop\"></a>Gotop</h4><p><code>gotop</code> 也是一个完全自由和开源的图表式系统活动监视器。顾名思义，它是在受到 <code>gtop</code> 和 <code>vtop</code> 的启发之后用 Go 语言编写的，因此也不再对其展开过多的赘述了。如果你有兴趣了解这个项目，可以阅读《<a href=\"https://www.ostechnix.com/manage-python-packages-using-pip/\" target=\"_blank\" rel=\"noopener\">gotop：又一个图表式系统活动监视器</a>》这篇文章。</p>\n<h4 id=\"Ptop\"><a href=\"#Ptop\" class=\"headerlink\" title=\"Ptop\"></a>Ptop</h4><p>有些人对 NodeJS 和 Go 语言的项目可能不太感冒。如果你也是其中之一，你可以试一下使用 Python 编写的 <code>ptop</code>。它同样是一个自由开源的、在 MIT 许可下发布的系统活动监视器。</p>\n<p><code>ptop</code> 同时兼容 Python2.x 和 Python3.x，因此可以使用 Python 的软件包管理器 <code>pip</code> 轻松安装。如果你没有安装 <code>pip</code>，也可以参考<a href=\"https://www.ostechnix.com/manage-python-packages-using-pip/\" target=\"_blank\" rel=\"noopener\">这个教程</a>进行安装。</p>\n<p>安装 <code>pip</code> 之后，执行以下命令就可以安装 <code>ptop</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install ptop</span><br></pre></td></tr></table></figure>\n<p>又或者按照以下方式通过源代码安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/darxtrix/ptop</span><br><span class=\"line\">$ cd ptop/</span><br><span class=\"line\">$ pip install -r requirements.txt # install requirements</span><br><span class=\"line\">$ sudo python setup.py install</span><br></pre></td></tr></table></figure>\n<p>如果需要对 <code>ptop</code> 进行更新，可以这样操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install --upgrade ptop</span><br></pre></td></tr></table></figure>\n<p>即使你不执行更新，<code>ptop</code> 也会在第一次启动的时候提示你是否需要更新到最新的版本。</p>\n<p>现在可以看一下启动 <code>ptop</code> 后的界面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop</span><br></pre></td></tr></table></figure>\n<p>就像下面这样：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/ptop-1.png\" alt=\"\"></p>\n<p><code>ptop</code> 的快捷键包括以下这些：</p>\n<ul>\n<li><code>Ctrl+k</code>：杀死一个进程。</li>\n<li><code>Ctrl+n</code>：按照内存使用量对进程排序。</li>\n<li><code>Ctrl+t</code>：按照进程启动时间对进程排序。</li>\n<li><code>Ctrl+r</code>：重置所有数据。</li>\n<li><code>Ctrl+f</code>：对进程进行筛选，输入进程的名称就能够筛选出符合条件的进程。</li>\n<li><code>Ctrl+l</code>：查看所选进程的详细信息。</li>\n<li><code>g</code>：跳转到进程列表顶部。</li>\n<li><code>Ctrl+q</code>：退出。</li>\n</ul>\n<p><code>ptop</code> 还支持更改显示主题。如果你想让 <code>ptop</code> 更好看，可以选择你喜欢的主题。可用的主题包括以下这些：</p>\n<ul>\n<li>colorful</li>\n<li>elegant</li>\n<li>simple</li>\n<li>dark</li>\n<li>light</li>\n</ul>\n<p>如果需要更换主题（例如更换到 colorful 主题），可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop -t colorful</span><br></pre></td></tr></table></figure>\n<p>使用 <code>-h</code> 参数可以查看帮助页面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ptop -h</span><br></pre></td></tr></table></figure>\n<p>想要了解更多关于 <code>ptop</code> 的细节，可以查阅它的 <a href=\"https://github.com/darxtrix/ptop\" target=\"_blank\" rel=\"noopener\">GitHub 仓库</a>。</p>\n<h4 id=\"Hegemon\"><a href=\"#Hegemon\" class=\"headerlink\" title=\"Hegemon\"></a>Hegemon</h4><p><code>hegemon</code> 是一个使用 Rust 编写的系统活动监视器，如果你对 Rust 感兴趣，也可以了解一下。我们最近有一篇关于 <code>hegemon</code> 的<a href=\"https://www.ostechnix.com/hegemon-a-modular-system-monitor-application-written-in-rust/\" target=\"_blank\" rel=\"noopener\">文章</a>，想要详细了解的读者不妨阅读。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上就是关于 <code>top</code> 工具的 6 个替代方案。我并不会说它们比 <code>top</code> 更好或者可以完全替代 <code>top</code>，但多了解一些类似的工具总是好的。你有使用过这些工具吗？哪个是你最喜欢的？欢迎在评论区留言。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/some-alternatives-to-top-command-line-utility-you-might-want-to-know/</a></p>\n"},{"title":"几个用于替代 du 命令的更好选择","date":"2018-11-16T15:08:09.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/du-command-720x340.jpg)\n\n大家对 `du` 命令应该都不陌生，它可以在类 Unix 系统中对文件和目录的空间使用情况进行计算和汇总。如果你也经常需要使用 `du` 命令，你会对以下内容感兴趣的。我发现了五个可以替代原有的 `du` 命令的更好的工具。当然，如果后续有更多更好的选择，我会继续列出来。如果你有其它推荐，也欢迎在评论中留言。\n\n### ncdu\n\n`ncdu` 作为普通 `du` 的替代品，这在 Linux 社区中已经很流行了。`ncdu` 正是基于开发者们对 `du` 的性能不满意而被开发出来的。`ncdu` 是一个使用 C 语言和 ncurses 接口开发的简易快速的磁盘用量分析器，可以用来查看目录或文件在本地或远程系统上占用磁盘空间的情况。如果你有兴趣查看关于 `ncdu` 的详细介绍，可以浏览《[如何在 Linux 上使用 ncdu 查看磁盘占用量][9]》这一篇文章。\n\n### tin-summer\n\ntin-summer 是使用 Rust 语言编写的自由开源工具，它可以用于查找占用磁盘空间的文件，它也是 `du` 命令的另一个替代品。由于使用了多线程，因此 tin-summer 在计算大目录的大小时会比 `du` 命令快得多。tin-summer 与 `du` 命令之间的区别是前者读取文件的大小，而后者则读取磁盘使用情况。\n\ntin-summer 的开发者认为它可以替代 `du`，因为它具有以下优势：\n\n  * 在大目录的操作速度上比 `du` 更快；\n  * 在显示结果上默认采用易读格式；\n  * 可以使用正则表达式排除文件或目录；\n  * 可以对输出进行排序和着色处理；\n  * 可扩展，等等。\n\n**安装 tin-summer**\n\n要安装 tin-summer，只需要在终端中执行以下命令：\n\n```\n$ curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git vmchale/tin-summer\n```\n\n你也可以使用 `cargo` 软件包管理器安装 tin-summer，但你需要在系统上先安装 Rust。在 Rust 已经安装好的情况下，执行以下命令：\n\n```\n$ cargo install tin-summer\n```\n\n如果上面提到的这两种方法都不能成功安装 tin-summer，还可以从它的[软件发布页][1]下载最新版本的二进制文件编译，进行手动安装。\n\n**用法**\n\n（LCTT 译注：tin-summer 的命令名为 `sn`）\n\n如果需要查看当前工作目录的文件大小，可以执行以下命令：\n\n```\n$ sn f\n749 MB   ./.rustup/toolchains\n749 MB   ./.rustup\n147 MB   ./.cargo/bin\n147 MB   ./.cargo\n900 MB   .\n```\n\n不需要进行额外声明，它也是默认以易读的格式向用户展示数据。在使用 `du` 命令的时候，则必须加上额外的 `-h` 参数才能得到同样的效果。\n\n只需要按以下的形式执行命令，就可以查看某个特定目录的文件大小。\n\n```\n$ sn f <path-to-the-directory>\n```\n\n还可以对输出结果进行排序，例如下面的命令可以输出指定目录中最大的 5 个文件或目录：\n\n```\n$ sn sort /home/sk/ -n5\n749 MB /home/sk/.rustup\n749 MB /home/sk/.rustup/toolchains\n147 MB /home/sk/.cargo\n147 MB /home/sk/.cargo/bin\n2.6 MB /home/sk/mcelog\n900 MB /home/sk/\n```\n\n顺便一提，上面结果中的最后一行是指定目录 `/home/sk` 的总大小。所以不要惊讶为什么输入的是 5 而实际输出了 6 行结果。\n\n在当前目录下查找带有构建工程的目录，可以使用以下命令：\n\n```\n$ sn ar\n```\n\ntin-summer 同样支持查找指定大小的带有构建工程的目录。例如执行以下命令可以查找到大小在 100 MB 以上的带有构建工程的目录：\n\n```\n$ sn ar -t100M\n```\n\n如上文所说，tin-summer 在操作大目录的时候速度比较快，因此在操作小目录的时候，速度会相对比较慢一些。不过它的开发者已经表示，将会在以后的版本中优化这个缺陷。\n\n要获取相关的帮助，可以执行以下命令：\n\n```\n$ sn --help\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][10]。\n\n### dust\n\n`dust` （含义是 `du` + `rust` = `dust`）使用 Rust 编写，是一个免费、开源的更直观的 `du` 工具。它可以在不需要 `head` 或`sort` 命令的情况下即时显示目录占用的磁盘空间。与 tin-summer 一样，它会默认情况以易读的格式显示每个目录的大小。 \n\n**安装 dust**\n\n由于 `dust` 也是使用 Rust 编写，因此它也可以通过 `cargo` 软件包管理器进行安装：\n\n```\n$ cargo install du-dust\n```\n\n也可以从它的[软件发布页][2]下载最新版本的二进制文件，并按照以下步骤安装。在写这篇文章的时候，最新的版本是 0.3.1。\n\n```\n$ wget https://github.com/bootandy/dust/releases/download/v0.3.1/dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz\n```\n\n抽取文件：\n\n```\n$ tar -xvf dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz\n```\n\n最后将可执行文件复制到你的 `$PATH`（例如 `/usr/local/bin`）下：\n\n```\n$ sudo mv dust /usr/local/bin/\n```\n\n**用法**\n\n需要查看当前目录及所有子目录下的文件大小，可以执行以下命令：\n\n```\n$ dust\n```\n\n输出示例：\n\n![](http://www.ostechnix.com/wp-content/uploads/2018/11/dust-1.png)\n\n带上 `-p` 参数可以按照从当前目录起始的完整目录显示。\n\n```\n$ dust -p\n```\n\n![dust 2][4]\n\n如果需要查看多个目录的大小，只需要同时列出这些目录，并用空格分隔开即可：\n\n```\n$ dust <dir1> <dir2>\n```\n\n下面再多举几个例子，例如：\n\n显示文件的长度:\n\n```\n$ dust -s\n```\n\n只显示 10 个目录：\n\n```\n$ dust -n 10\n```\n\n查看当前目录下最多 3 层子目录：\n\n```\n$ dust -d 3\n```\n\n查看帮助：\n\n```\n$ dust -h\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][11]。\n\n### diskus\n\n`diskus` 也是使用 Rust 编写的一个小型、快速的开源工具，它可以用于替代 `du -sh` 命令。`diskus` 将会计算当前目录下所有文件的总大小，它的效果相当于 `du -sh` 或 `du -sh --bytes`，但其开发者表示 `diskus` 的运行速度是 `du -sh` 的 9 倍。\n\n**安装 diskus**\n\n`diskus` 已经存放于 <ruby>Arch Linux 社区用户软件仓库<rt>Arch Linux User-community Repository</rt></ruby>（[AUR][5]）当中，可以通过任何一种 AUR 帮助工具（例如 [`yay`][6]）把它安装在基于 Arch 的系统上：\n\n```\n$ yay -S diskus\n```\n\n对于 Ubuntu 及其衍生发行版，可以在 `diskus` 的[软件发布页][7]上下载最新版的软件包并安装：\n\n```\n$ wget \"https://github.com/sharkdp/diskus/releases/download/v0.3.1/diskus_0.3.1_amd64.deb\"\n\n$ sudo dpkg -i diskus_0.3.1_amd64.deb\n```\n\n还可以使用 `cargo` 软件包管理器安装 `diskus`，但必须在系统上先安装 Rust 1.29+。\n\n安装好 Rust 之后，就可以使用以下命令安装 `diskus`：\n\n```\n$ cargo install diskus\n```\n\n**用法**\n\n在通常情况下，如果需要查看某个目录的大小，我会使用形如 `du -sh` 的命令。\n\n```\n$ du -sh dir\n```\n\n这里的 `-s` 参数表示显示总大小。\n\n如果使用 `diskus`，直接就可以显示当前目录的总大小。\n\n```\n$ diskus\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/diskus-in-action.png)\n\n我使用 `diskus` 查看 Arch Linux 系统上各个目录的总大小，这个工具的速度确实比 `du -sh` 快得多。但是它目前只能显示当前目录的大小。\n\n要获取相关的帮助，可以执行以下命令：\n\n```\n$ diskus -h\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][12]。\n\n### duu\n\n`duu` 是 Directory Usage Utility 的缩写。它是使用 Python 编写的查看指定目录大小的工具。它具有跨平台的特性，因此在 Windows、Mac OS 和 Linux 系统上都能够使用。\n\n**安装 duu**\n\n安装这个工具之前需要先安装 Python 3。不过目前很多 Linux 发行版的默认软件仓库中都带有 Python 3，所以这个依赖并不难解决。\n\nPython 3 安装完成后，从 `duu` 的[软件发布页][8]下载其最新版本。\n\n```\n$ wget https://github.com/jftuga/duu/releases/download/2.20/duu.py\n```\n\n**用法**\n\n要查看当前目录的大小，只需要执行以下命令：\n\n```\n$ python3 duu.py\n```\n\n输出示例：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/duu.png)\n\n从上图可以看出，`duu` 会显示当前目录下文件的数量情况，按照 Byte、KB、MB 单位显示这些文件的总大小，以及每个文件的大小。\n\n如果需要查看某个目录的大小，只需要声明目录的绝对路径即可：\n\n```\n$ python3 duu.py /home/sk/Downloads/\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][13]。\n\n以上就是 `du` 命令的五种替代方案，希望这篇文章能够帮助到你。就我自己而言，我并不会在这五种工具之间交替使用，我更喜欢使用 `ncdu`。欢迎在下面的评论区发表你对这些工具的评论。\n\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/some-good-alternatives-to-du-command/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://github.com/vmchale/tin-summer/releases\n[2]: https://github.com/bootandy/dust/releases\n[3]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[4]: http://www.ostechnix.com/wp-content/uploads/2018/11/dust-2.png\n[5]: https://aur.archlinux.org/packages/diskus-bin/\n[6]: https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\n[7]: https://github.com/sharkdp/diskus/releases\n[8]: https://github.com/jftuga/duu/releases\n[9]: https://www.ostechnix.com/check-disk-space-usage-linux-using-ncdu/\n[10]: https://github.com/vmchale/tin-summer\n[11]: https://github.com/bootandy/dust\n[12]: https://github.com/sharkdp/diskus\n[13]: https://github.com/jftuga/duu\n\n","source":"_posts/Some-Good-Alternatives-To-du-Command.md","raw":"---\ntitle: 几个用于替代 du 命令的更好选择\ndate: 2018-11-16 23:08:09\ntags:\n  - 命令\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/du-command-720x340.jpg)\n\n大家对 `du` 命令应该都不陌生，它可以在类 Unix 系统中对文件和目录的空间使用情况进行计算和汇总。如果你也经常需要使用 `du` 命令，你会对以下内容感兴趣的。我发现了五个可以替代原有的 `du` 命令的更好的工具。当然，如果后续有更多更好的选择，我会继续列出来。如果你有其它推荐，也欢迎在评论中留言。\n\n### ncdu\n\n`ncdu` 作为普通 `du` 的替代品，这在 Linux 社区中已经很流行了。`ncdu` 正是基于开发者们对 `du` 的性能不满意而被开发出来的。`ncdu` 是一个使用 C 语言和 ncurses 接口开发的简易快速的磁盘用量分析器，可以用来查看目录或文件在本地或远程系统上占用磁盘空间的情况。如果你有兴趣查看关于 `ncdu` 的详细介绍，可以浏览《[如何在 Linux 上使用 ncdu 查看磁盘占用量][9]》这一篇文章。\n\n### tin-summer\n\ntin-summer 是使用 Rust 语言编写的自由开源工具，它可以用于查找占用磁盘空间的文件，它也是 `du` 命令的另一个替代品。由于使用了多线程，因此 tin-summer 在计算大目录的大小时会比 `du` 命令快得多。tin-summer 与 `du` 命令之间的区别是前者读取文件的大小，而后者则读取磁盘使用情况。\n\ntin-summer 的开发者认为它可以替代 `du`，因为它具有以下优势：\n\n  * 在大目录的操作速度上比 `du` 更快；\n  * 在显示结果上默认采用易读格式；\n  * 可以使用正则表达式排除文件或目录；\n  * 可以对输出进行排序和着色处理；\n  * 可扩展，等等。\n\n**安装 tin-summer**\n\n要安装 tin-summer，只需要在终端中执行以下命令：\n\n```\n$ curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git vmchale/tin-summer\n```\n\n你也可以使用 `cargo` 软件包管理器安装 tin-summer，但你需要在系统上先安装 Rust。在 Rust 已经安装好的情况下，执行以下命令：\n\n```\n$ cargo install tin-summer\n```\n\n如果上面提到的这两种方法都不能成功安装 tin-summer，还可以从它的[软件发布页][1]下载最新版本的二进制文件编译，进行手动安装。\n\n**用法**\n\n（LCTT 译注：tin-summer 的命令名为 `sn`）\n\n如果需要查看当前工作目录的文件大小，可以执行以下命令：\n\n```\n$ sn f\n749 MB   ./.rustup/toolchains\n749 MB   ./.rustup\n147 MB   ./.cargo/bin\n147 MB   ./.cargo\n900 MB   .\n```\n\n不需要进行额外声明，它也是默认以易读的格式向用户展示数据。在使用 `du` 命令的时候，则必须加上额外的 `-h` 参数才能得到同样的效果。\n\n只需要按以下的形式执行命令，就可以查看某个特定目录的文件大小。\n\n```\n$ sn f <path-to-the-directory>\n```\n\n还可以对输出结果进行排序，例如下面的命令可以输出指定目录中最大的 5 个文件或目录：\n\n```\n$ sn sort /home/sk/ -n5\n749 MB /home/sk/.rustup\n749 MB /home/sk/.rustup/toolchains\n147 MB /home/sk/.cargo\n147 MB /home/sk/.cargo/bin\n2.6 MB /home/sk/mcelog\n900 MB /home/sk/\n```\n\n顺便一提，上面结果中的最后一行是指定目录 `/home/sk` 的总大小。所以不要惊讶为什么输入的是 5 而实际输出了 6 行结果。\n\n在当前目录下查找带有构建工程的目录，可以使用以下命令：\n\n```\n$ sn ar\n```\n\ntin-summer 同样支持查找指定大小的带有构建工程的目录。例如执行以下命令可以查找到大小在 100 MB 以上的带有构建工程的目录：\n\n```\n$ sn ar -t100M\n```\n\n如上文所说，tin-summer 在操作大目录的时候速度比较快，因此在操作小目录的时候，速度会相对比较慢一些。不过它的开发者已经表示，将会在以后的版本中优化这个缺陷。\n\n要获取相关的帮助，可以执行以下命令：\n\n```\n$ sn --help\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][10]。\n\n### dust\n\n`dust` （含义是 `du` + `rust` = `dust`）使用 Rust 编写，是一个免费、开源的更直观的 `du` 工具。它可以在不需要 `head` 或`sort` 命令的情况下即时显示目录占用的磁盘空间。与 tin-summer 一样，它会默认情况以易读的格式显示每个目录的大小。 \n\n**安装 dust**\n\n由于 `dust` 也是使用 Rust 编写，因此它也可以通过 `cargo` 软件包管理器进行安装：\n\n```\n$ cargo install du-dust\n```\n\n也可以从它的[软件发布页][2]下载最新版本的二进制文件，并按照以下步骤安装。在写这篇文章的时候，最新的版本是 0.3.1。\n\n```\n$ wget https://github.com/bootandy/dust/releases/download/v0.3.1/dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz\n```\n\n抽取文件：\n\n```\n$ tar -xvf dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz\n```\n\n最后将可执行文件复制到你的 `$PATH`（例如 `/usr/local/bin`）下：\n\n```\n$ sudo mv dust /usr/local/bin/\n```\n\n**用法**\n\n需要查看当前目录及所有子目录下的文件大小，可以执行以下命令：\n\n```\n$ dust\n```\n\n输出示例：\n\n![](http://www.ostechnix.com/wp-content/uploads/2018/11/dust-1.png)\n\n带上 `-p` 参数可以按照从当前目录起始的完整目录显示。\n\n```\n$ dust -p\n```\n\n![dust 2][4]\n\n如果需要查看多个目录的大小，只需要同时列出这些目录，并用空格分隔开即可：\n\n```\n$ dust <dir1> <dir2>\n```\n\n下面再多举几个例子，例如：\n\n显示文件的长度:\n\n```\n$ dust -s\n```\n\n只显示 10 个目录：\n\n```\n$ dust -n 10\n```\n\n查看当前目录下最多 3 层子目录：\n\n```\n$ dust -d 3\n```\n\n查看帮助：\n\n```\n$ dust -h\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][11]。\n\n### diskus\n\n`diskus` 也是使用 Rust 编写的一个小型、快速的开源工具，它可以用于替代 `du -sh` 命令。`diskus` 将会计算当前目录下所有文件的总大小，它的效果相当于 `du -sh` 或 `du -sh --bytes`，但其开发者表示 `diskus` 的运行速度是 `du -sh` 的 9 倍。\n\n**安装 diskus**\n\n`diskus` 已经存放于 <ruby>Arch Linux 社区用户软件仓库<rt>Arch Linux User-community Repository</rt></ruby>（[AUR][5]）当中，可以通过任何一种 AUR 帮助工具（例如 [`yay`][6]）把它安装在基于 Arch 的系统上：\n\n```\n$ yay -S diskus\n```\n\n对于 Ubuntu 及其衍生发行版，可以在 `diskus` 的[软件发布页][7]上下载最新版的软件包并安装：\n\n```\n$ wget \"https://github.com/sharkdp/diskus/releases/download/v0.3.1/diskus_0.3.1_amd64.deb\"\n\n$ sudo dpkg -i diskus_0.3.1_amd64.deb\n```\n\n还可以使用 `cargo` 软件包管理器安装 `diskus`，但必须在系统上先安装 Rust 1.29+。\n\n安装好 Rust 之后，就可以使用以下命令安装 `diskus`：\n\n```\n$ cargo install diskus\n```\n\n**用法**\n\n在通常情况下，如果需要查看某个目录的大小，我会使用形如 `du -sh` 的命令。\n\n```\n$ du -sh dir\n```\n\n这里的 `-s` 参数表示显示总大小。\n\n如果使用 `diskus`，直接就可以显示当前目录的总大小。\n\n```\n$ diskus\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/diskus-in-action.png)\n\n我使用 `diskus` 查看 Arch Linux 系统上各个目录的总大小，这个工具的速度确实比 `du -sh` 快得多。但是它目前只能显示当前目录的大小。\n\n要获取相关的帮助，可以执行以下命令：\n\n```\n$ diskus -h\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][12]。\n\n### duu\n\n`duu` 是 Directory Usage Utility 的缩写。它是使用 Python 编写的查看指定目录大小的工具。它具有跨平台的特性，因此在 Windows、Mac OS 和 Linux 系统上都能够使用。\n\n**安装 duu**\n\n安装这个工具之前需要先安装 Python 3。不过目前很多 Linux 发行版的默认软件仓库中都带有 Python 3，所以这个依赖并不难解决。\n\nPython 3 安装完成后，从 `duu` 的[软件发布页][8]下载其最新版本。\n\n```\n$ wget https://github.com/jftuga/duu/releases/download/2.20/duu.py\n```\n\n**用法**\n\n要查看当前目录的大小，只需要执行以下命令：\n\n```\n$ python3 duu.py\n```\n\n输出示例：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/duu.png)\n\n从上图可以看出，`duu` 会显示当前目录下文件的数量情况，按照 Byte、KB、MB 单位显示这些文件的总大小，以及每个文件的大小。\n\n如果需要查看某个目录的大小，只需要声明目录的绝对路径即可：\n\n```\n$ python3 duu.py /home/sk/Downloads/\n```\n\n如果想要更详尽的介绍，可以查看[这个项目的 GitHub 页面][13]。\n\n以上就是 `du` 命令的五种替代方案，希望这篇文章能够帮助到你。就我自己而言，我并不会在这五种工具之间交替使用，我更喜欢使用 `ncdu`。欢迎在下面的评论区发表你对这些工具的评论。\n\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/some-good-alternatives-to-du-command/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://github.com/vmchale/tin-summer/releases\n[2]: https://github.com/bootandy/dust/releases\n[3]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[4]: http://www.ostechnix.com/wp-content/uploads/2018/11/dust-2.png\n[5]: https://aur.archlinux.org/packages/diskus-bin/\n[6]: https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\n[7]: https://github.com/sharkdp/diskus/releases\n[8]: https://github.com/jftuga/duu/releases\n[9]: https://www.ostechnix.com/check-disk-space-usage-linux-using-ncdu/\n[10]: https://github.com/vmchale/tin-summer\n[11]: https://github.com/bootandy/dust\n[12]: https://github.com/sharkdp/diskus\n[13]: https://github.com/jftuga/duu\n\n","slug":"Some-Good-Alternatives-To-du-Command","published":1,"updated":"2019-03-28T12:42:28.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dc001ulixujl14ixfi","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/du-command-720x340.jpg\" alt=\"\"></p>\n<p>大家对 <code>du</code> 命令应该都不陌生，它可以在类 Unix 系统中对文件和目录的空间使用情况进行计算和汇总。如果你也经常需要使用 <code>du</code> 命令，你会对以下内容感兴趣的。我发现了五个可以替代原有的 <code>du</code> 命令的更好的工具。当然，如果后续有更多更好的选择，我会继续列出来。如果你有其它推荐，也欢迎在评论中留言。</p>\n<h3 id=\"ncdu\"><a href=\"#ncdu\" class=\"headerlink\" title=\"ncdu\"></a>ncdu</h3><p><code>ncdu</code> 作为普通 <code>du</code> 的替代品，这在 Linux 社区中已经很流行了。<code>ncdu</code> 正是基于开发者们对 <code>du</code> 的性能不满意而被开发出来的。<code>ncdu</code> 是一个使用 C 语言和 ncurses 接口开发的简易快速的磁盘用量分析器，可以用来查看目录或文件在本地或远程系统上占用磁盘空间的情况。如果你有兴趣查看关于 <code>ncdu</code> 的详细介绍，可以浏览《<a href=\"https://www.ostechnix.com/check-disk-space-usage-linux-using-ncdu/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上使用 ncdu 查看磁盘占用量</a>》这一篇文章。</p>\n<h3 id=\"tin-summer\"><a href=\"#tin-summer\" class=\"headerlink\" title=\"tin-summer\"></a>tin-summer</h3><p>tin-summer 是使用 Rust 语言编写的自由开源工具，它可以用于查找占用磁盘空间的文件，它也是 <code>du</code> 命令的另一个替代品。由于使用了多线程，因此 tin-summer 在计算大目录的大小时会比 <code>du</code> 命令快得多。tin-summer 与 <code>du</code> 命令之间的区别是前者读取文件的大小，而后者则读取磁盘使用情况。</p>\n<p>tin-summer 的开发者认为它可以替代 <code>du</code>，因为它具有以下优势：</p>\n<ul>\n<li>在大目录的操作速度上比 <code>du</code> 更快；</li>\n<li>在显示结果上默认采用易读格式；</li>\n<li>可以使用正则表达式排除文件或目录；</li>\n<li>可以对输出进行排序和着色处理；</li>\n<li>可扩展，等等。</li>\n</ul>\n<p><strong>安装 tin-summer</strong></p>\n<p>要安装 tin-summer，只需要在终端中执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git vmchale/tin-summer</span><br></pre></td></tr></table></figure>\n<p>你也可以使用 <code>cargo</code> 软件包管理器安装 tin-summer，但你需要在系统上先安装 Rust。在 Rust 已经安装好的情况下，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install tin-summer</span><br></pre></td></tr></table></figure>\n<p>如果上面提到的这两种方法都不能成功安装 tin-summer，还可以从它的<a href=\"https://github.com/vmchale/tin-summer/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载最新版本的二进制文件编译，进行手动安装。</p>\n<p><strong>用法</strong></p>\n<p>（LCTT 译注：tin-summer 的命令名为 <code>sn</code>）</p>\n<p>如果需要查看当前工作目录的文件大小，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn f</span><br><span class=\"line\">749 MB   ./.rustup/toolchains</span><br><span class=\"line\">749 MB   ./.rustup</span><br><span class=\"line\">147 MB   ./.cargo/bin</span><br><span class=\"line\">147 MB   ./.cargo</span><br><span class=\"line\">900 MB   .</span><br></pre></td></tr></table></figure>\n<p>不需要进行额外声明，它也是默认以易读的格式向用户展示数据。在使用 <code>du</code> 命令的时候，则必须加上额外的 <code>-h</code> 参数才能得到同样的效果。</p>\n<p>只需要按以下的形式执行命令，就可以查看某个特定目录的文件大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn f &lt;path-to-the-directory&gt;</span><br></pre></td></tr></table></figure>\n<p>还可以对输出结果进行排序，例如下面的命令可以输出指定目录中最大的 5 个文件或目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn sort /home/sk/ -n5</span><br><span class=\"line\">749 MB /home/sk/.rustup</span><br><span class=\"line\">749 MB /home/sk/.rustup/toolchains</span><br><span class=\"line\">147 MB /home/sk/.cargo</span><br><span class=\"line\">147 MB /home/sk/.cargo/bin</span><br><span class=\"line\">2.6 MB /home/sk/mcelog</span><br><span class=\"line\">900 MB /home/sk/</span><br></pre></td></tr></table></figure>\n<p>顺便一提，上面结果中的最后一行是指定目录 <code>/home/sk</code> 的总大小。所以不要惊讶为什么输入的是 5 而实际输出了 6 行结果。</p>\n<p>在当前目录下查找带有构建工程的目录，可以使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn ar</span><br></pre></td></tr></table></figure>\n<p>tin-summer 同样支持查找指定大小的带有构建工程的目录。例如执行以下命令可以查找到大小在 100 MB 以上的带有构建工程的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn ar -t100M</span><br></pre></td></tr></table></figure>\n<p>如上文所说，tin-summer 在操作大目录的时候速度比较快，因此在操作小目录的时候，速度会相对比较慢一些。不过它的开发者已经表示，将会在以后的版本中优化这个缺陷。</p>\n<p>要获取相关的帮助，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn --help</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/vmchale/tin-summer\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"dust\"><a href=\"#dust\" class=\"headerlink\" title=\"dust\"></a>dust</h3><p><code>dust</code> （含义是 <code>du</code> + <code>rust</code> = <code>dust</code>）使用 Rust 编写，是一个免费、开源的更直观的 <code>du</code> 工具。它可以在不需要 <code>head</code> 或<code>sort</code> 命令的情况下即时显示目录占用的磁盘空间。与 tin-summer 一样，它会默认情况以易读的格式显示每个目录的大小。 </p>\n<p><strong>安装 dust</strong></p>\n<p>由于 <code>dust</code> 也是使用 Rust 编写，因此它也可以通过 <code>cargo</code> 软件包管理器进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install du-dust</span><br></pre></td></tr></table></figure>\n<p>也可以从它的<a href=\"https://github.com/bootandy/dust/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载最新版本的二进制文件，并按照以下步骤安装。在写这篇文章的时候，最新的版本是 0.3.1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/bootandy/dust/releases/download/v0.3.1/dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>\n<p>抽取文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -xvf dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>\n<p>最后将可执行文件复制到你的 <code>$PATH</code>（例如 <code>/usr/local/bin</code>）下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv dust /usr/local/bin/</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>需要查看当前目录及所有子目录下的文件大小，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust</span><br></pre></td></tr></table></figure>\n<p>输出示例：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/dust-1.png\" alt=\"\"></p>\n<p>带上 <code>-p</code> 参数可以按照从当前目录起始的完整目录显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -p</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/dust-2.png\" alt=\"dust 2\"></p>\n<p>如果需要查看多个目录的大小，只需要同时列出这些目录，并用空格分隔开即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust &lt;dir1&gt; &lt;dir2&gt;</span><br></pre></td></tr></table></figure>\n<p>下面再多举几个例子，例如：</p>\n<p>显示文件的长度:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -s</span><br></pre></td></tr></table></figure>\n<p>只显示 10 个目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -n 10</span><br></pre></td></tr></table></figure>\n<p>查看当前目录下最多 3 层子目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -d 3</span><br></pre></td></tr></table></figure>\n<p>查看帮助：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -h</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/bootandy/dust\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"diskus\"><a href=\"#diskus\" class=\"headerlink\" title=\"diskus\"></a>diskus</h3><p><code>diskus</code> 也是使用 Rust 编写的一个小型、快速的开源工具，它可以用于替代 <code>du -sh</code> 命令。<code>diskus</code> 将会计算当前目录下所有文件的总大小，它的效果相当于 <code>du -sh</code> 或 <code>du -sh --bytes</code>，但其开发者表示 <code>diskus</code> 的运行速度是 <code>du -sh</code> 的 9 倍。</p>\n<p><strong>安装 diskus</strong></p>\n<p><code>diskus</code> 已经存放于 <ruby>Arch Linux 社区用户软件仓库<rt>Arch Linux User-community Repository</rt></ruby>（<a href=\"https://aur.archlinux.org/packages/diskus-bin/\" target=\"_blank\" rel=\"noopener\">AUR</a>）当中，可以通过任何一种 AUR 帮助工具（例如 <a href=\"https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\" target=\"_blank\" rel=\"noopener\"><code>yay</code></a>）把它安装在基于 Arch 的系统上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yay -S diskus</span><br></pre></td></tr></table></figure>\n<p>对于 Ubuntu 及其衍生发行版，可以在 <code>diskus</code> 的<a href=\"https://github.com/sharkdp/diskus/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>上下载最新版的软件包并安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget &quot;https://github.com/sharkdp/diskus/releases/download/v0.3.1/diskus_0.3.1_amd64.deb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo dpkg -i diskus_0.3.1_amd64.deb</span><br></pre></td></tr></table></figure>\n<p>还可以使用 <code>cargo</code> 软件包管理器安装 <code>diskus</code>，但必须在系统上先安装 Rust 1.29+。</p>\n<p>安装好 Rust 之后，就可以使用以下命令安装 <code>diskus</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install diskus</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>在通常情况下，如果需要查看某个目录的大小，我会使用形如 <code>du -sh</code> 的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ du -sh dir</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>-s</code> 参数表示显示总大小。</p>\n<p>如果使用 <code>diskus</code>，直接就可以显示当前目录的总大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ diskus</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/diskus-in-action.png\" alt=\"\"></p>\n<p>我使用 <code>diskus</code> 查看 Arch Linux 系统上各个目录的总大小，这个工具的速度确实比 <code>du -sh</code> 快得多。但是它目前只能显示当前目录的大小。</p>\n<p>要获取相关的帮助，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ diskus -h</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/sharkdp/diskus\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"duu\"><a href=\"#duu\" class=\"headerlink\" title=\"duu\"></a>duu</h3><p><code>duu</code> 是 Directory Usage Utility 的缩写。它是使用 Python 编写的查看指定目录大小的工具。它具有跨平台的特性，因此在 Windows、Mac OS 和 Linux 系统上都能够使用。</p>\n<p><strong>安装 duu</strong></p>\n<p>安装这个工具之前需要先安装 Python 3。不过目前很多 Linux 发行版的默认软件仓库中都带有 Python 3，所以这个依赖并不难解决。</p>\n<p>Python 3 安装完成后，从 <code>duu</code> 的<a href=\"https://github.com/jftuga/duu/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载其最新版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/jftuga/duu/releases/download/2.20/duu.py</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>要查看当前目录的大小，只需要执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 duu.py</span><br></pre></td></tr></table></figure>\n<p>输出示例：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/duu.png\" alt=\"\"></p>\n<p>从上图可以看出，<code>duu</code> 会显示当前目录下文件的数量情况，按照 Byte、KB、MB 单位显示这些文件的总大小，以及每个文件的大小。</p>\n<p>如果需要查看某个目录的大小，只需要声明目录的绝对路径即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 duu.py /home/sk/Downloads/</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/jftuga/duu\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<p>以上就是 <code>du</code> 命令的五种替代方案，希望这篇文章能够帮助到你。就我自己而言，我并不会在这五种工具之间交替使用，我更喜欢使用 <code>ncdu</code>。欢迎在下面的评论区发表你对这些工具的评论。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/some-good-alternatives-to-du-command/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/some-good-alternatives-to-du-command/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/du-command-720x340.jpg\" alt=\"\"></p>\n<p>大家对 <code>du</code> 命令应该都不陌生，它可以在类 Unix 系统中对文件和目录的空间使用情况进行计算和汇总。如果你也经常需要使用 <code>du</code> 命令，你会对以下内容感兴趣的。我发现了五个可以替代原有的 <code>du</code> 命令的更好的工具。当然，如果后续有更多更好的选择，我会继续列出来。如果你有其它推荐，也欢迎在评论中留言。</p>\n<h3 id=\"ncdu\"><a href=\"#ncdu\" class=\"headerlink\" title=\"ncdu\"></a>ncdu</h3><p><code>ncdu</code> 作为普通 <code>du</code> 的替代品，这在 Linux 社区中已经很流行了。<code>ncdu</code> 正是基于开发者们对 <code>du</code> 的性能不满意而被开发出来的。<code>ncdu</code> 是一个使用 C 语言和 ncurses 接口开发的简易快速的磁盘用量分析器，可以用来查看目录或文件在本地或远程系统上占用磁盘空间的情况。如果你有兴趣查看关于 <code>ncdu</code> 的详细介绍，可以浏览《<a href=\"https://www.ostechnix.com/check-disk-space-usage-linux-using-ncdu/\" target=\"_blank\" rel=\"noopener\">如何在 Linux 上使用 ncdu 查看磁盘占用量</a>》这一篇文章。</p>\n<h3 id=\"tin-summer\"><a href=\"#tin-summer\" class=\"headerlink\" title=\"tin-summer\"></a>tin-summer</h3><p>tin-summer 是使用 Rust 语言编写的自由开源工具，它可以用于查找占用磁盘空间的文件，它也是 <code>du</code> 命令的另一个替代品。由于使用了多线程，因此 tin-summer 在计算大目录的大小时会比 <code>du</code> 命令快得多。tin-summer 与 <code>du</code> 命令之间的区别是前者读取文件的大小，而后者则读取磁盘使用情况。</p>\n<p>tin-summer 的开发者认为它可以替代 <code>du</code>，因为它具有以下优势：</p>\n<ul>\n<li>在大目录的操作速度上比 <code>du</code> 更快；</li>\n<li>在显示结果上默认采用易读格式；</li>\n<li>可以使用正则表达式排除文件或目录；</li>\n<li>可以对输出进行排序和着色处理；</li>\n<li>可扩展，等等。</li>\n</ul>\n<p><strong>安装 tin-summer</strong></p>\n<p>要安装 tin-summer，只需要在终端中执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git vmchale/tin-summer</span><br></pre></td></tr></table></figure>\n<p>你也可以使用 <code>cargo</code> 软件包管理器安装 tin-summer，但你需要在系统上先安装 Rust。在 Rust 已经安装好的情况下，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install tin-summer</span><br></pre></td></tr></table></figure>\n<p>如果上面提到的这两种方法都不能成功安装 tin-summer，还可以从它的<a href=\"https://github.com/vmchale/tin-summer/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载最新版本的二进制文件编译，进行手动安装。</p>\n<p><strong>用法</strong></p>\n<p>（LCTT 译注：tin-summer 的命令名为 <code>sn</code>）</p>\n<p>如果需要查看当前工作目录的文件大小，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn f</span><br><span class=\"line\">749 MB   ./.rustup/toolchains</span><br><span class=\"line\">749 MB   ./.rustup</span><br><span class=\"line\">147 MB   ./.cargo/bin</span><br><span class=\"line\">147 MB   ./.cargo</span><br><span class=\"line\">900 MB   .</span><br></pre></td></tr></table></figure>\n<p>不需要进行额外声明，它也是默认以易读的格式向用户展示数据。在使用 <code>du</code> 命令的时候，则必须加上额外的 <code>-h</code> 参数才能得到同样的效果。</p>\n<p>只需要按以下的形式执行命令，就可以查看某个特定目录的文件大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn f &lt;path-to-the-directory&gt;</span><br></pre></td></tr></table></figure>\n<p>还可以对输出结果进行排序，例如下面的命令可以输出指定目录中最大的 5 个文件或目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn sort /home/sk/ -n5</span><br><span class=\"line\">749 MB /home/sk/.rustup</span><br><span class=\"line\">749 MB /home/sk/.rustup/toolchains</span><br><span class=\"line\">147 MB /home/sk/.cargo</span><br><span class=\"line\">147 MB /home/sk/.cargo/bin</span><br><span class=\"line\">2.6 MB /home/sk/mcelog</span><br><span class=\"line\">900 MB /home/sk/</span><br></pre></td></tr></table></figure>\n<p>顺便一提，上面结果中的最后一行是指定目录 <code>/home/sk</code> 的总大小。所以不要惊讶为什么输入的是 5 而实际输出了 6 行结果。</p>\n<p>在当前目录下查找带有构建工程的目录，可以使用以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn ar</span><br></pre></td></tr></table></figure>\n<p>tin-summer 同样支持查找指定大小的带有构建工程的目录。例如执行以下命令可以查找到大小在 100 MB 以上的带有构建工程的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn ar -t100M</span><br></pre></td></tr></table></figure>\n<p>如上文所说，tin-summer 在操作大目录的时候速度比较快，因此在操作小目录的时候，速度会相对比较慢一些。不过它的开发者已经表示，将会在以后的版本中优化这个缺陷。</p>\n<p>要获取相关的帮助，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sn --help</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/vmchale/tin-summer\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"dust\"><a href=\"#dust\" class=\"headerlink\" title=\"dust\"></a>dust</h3><p><code>dust</code> （含义是 <code>du</code> + <code>rust</code> = <code>dust</code>）使用 Rust 编写，是一个免费、开源的更直观的 <code>du</code> 工具。它可以在不需要 <code>head</code> 或<code>sort</code> 命令的情况下即时显示目录占用的磁盘空间。与 tin-summer 一样，它会默认情况以易读的格式显示每个目录的大小。 </p>\n<p><strong>安装 dust</strong></p>\n<p>由于 <code>dust</code> 也是使用 Rust 编写，因此它也可以通过 <code>cargo</code> 软件包管理器进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install du-dust</span><br></pre></td></tr></table></figure>\n<p>也可以从它的<a href=\"https://github.com/bootandy/dust/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载最新版本的二进制文件，并按照以下步骤安装。在写这篇文章的时候，最新的版本是 0.3.1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/bootandy/dust/releases/download/v0.3.1/dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>\n<p>抽取文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -xvf dust-v0.3.1-x86_64-unknown-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure>\n<p>最后将可执行文件复制到你的 <code>$PATH</code>（例如 <code>/usr/local/bin</code>）下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv dust /usr/local/bin/</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>需要查看当前目录及所有子目录下的文件大小，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust</span><br></pre></td></tr></table></figure>\n<p>输出示例：</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/dust-1.png\" alt=\"\"></p>\n<p>带上 <code>-p</code> 参数可以按照从当前目录起始的完整目录显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -p</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/dust-2.png\" alt=\"dust 2\"></p>\n<p>如果需要查看多个目录的大小，只需要同时列出这些目录，并用空格分隔开即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust &lt;dir1&gt; &lt;dir2&gt;</span><br></pre></td></tr></table></figure>\n<p>下面再多举几个例子，例如：</p>\n<p>显示文件的长度:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -s</span><br></pre></td></tr></table></figure>\n<p>只显示 10 个目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -n 10</span><br></pre></td></tr></table></figure>\n<p>查看当前目录下最多 3 层子目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -d 3</span><br></pre></td></tr></table></figure>\n<p>查看帮助：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ dust -h</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/bootandy/dust\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"diskus\"><a href=\"#diskus\" class=\"headerlink\" title=\"diskus\"></a>diskus</h3><p><code>diskus</code> 也是使用 Rust 编写的一个小型、快速的开源工具，它可以用于替代 <code>du -sh</code> 命令。<code>diskus</code> 将会计算当前目录下所有文件的总大小，它的效果相当于 <code>du -sh</code> 或 <code>du -sh --bytes</code>，但其开发者表示 <code>diskus</code> 的运行速度是 <code>du -sh</code> 的 9 倍。</p>\n<p><strong>安装 diskus</strong></p>\n<p><code>diskus</code> 已经存放于 <ruby>Arch Linux 社区用户软件仓库<rt>Arch Linux User-community Repository</rt></ruby>（<a href=\"https://aur.archlinux.org/packages/diskus-bin/\" target=\"_blank\" rel=\"noopener\">AUR</a>）当中，可以通过任何一种 AUR 帮助工具（例如 <a href=\"https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/\" target=\"_blank\" rel=\"noopener\"><code>yay</code></a>）把它安装在基于 Arch 的系统上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yay -S diskus</span><br></pre></td></tr></table></figure>\n<p>对于 Ubuntu 及其衍生发行版，可以在 <code>diskus</code> 的<a href=\"https://github.com/sharkdp/diskus/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>上下载最新版的软件包并安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget &quot;https://github.com/sharkdp/diskus/releases/download/v0.3.1/diskus_0.3.1_amd64.deb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo dpkg -i diskus_0.3.1_amd64.deb</span><br></pre></td></tr></table></figure>\n<p>还可以使用 <code>cargo</code> 软件包管理器安装 <code>diskus</code>，但必须在系统上先安装 Rust 1.29+。</p>\n<p>安装好 Rust 之后，就可以使用以下命令安装 <code>diskus</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cargo install diskus</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>在通常情况下，如果需要查看某个目录的大小，我会使用形如 <code>du -sh</code> 的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ du -sh dir</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>-s</code> 参数表示显示总大小。</p>\n<p>如果使用 <code>diskus</code>，直接就可以显示当前目录的总大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ diskus</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/diskus-in-action.png\" alt=\"\"></p>\n<p>我使用 <code>diskus</code> 查看 Arch Linux 系统上各个目录的总大小，这个工具的速度确实比 <code>du -sh</code> 快得多。但是它目前只能显示当前目录的大小。</p>\n<p>要获取相关的帮助，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ diskus -h</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/sharkdp/diskus\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<h3 id=\"duu\"><a href=\"#duu\" class=\"headerlink\" title=\"duu\"></a>duu</h3><p><code>duu</code> 是 Directory Usage Utility 的缩写。它是使用 Python 编写的查看指定目录大小的工具。它具有跨平台的特性，因此在 Windows、Mac OS 和 Linux 系统上都能够使用。</p>\n<p><strong>安装 duu</strong></p>\n<p>安装这个工具之前需要先安装 Python 3。不过目前很多 Linux 发行版的默认软件仓库中都带有 Python 3，所以这个依赖并不难解决。</p>\n<p>Python 3 安装完成后，从 <code>duu</code> 的<a href=\"https://github.com/jftuga/duu/releases\" target=\"_blank\" rel=\"noopener\">软件发布页</a>下载其最新版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/jftuga/duu/releases/download/2.20/duu.py</span><br></pre></td></tr></table></figure>\n<p><strong>用法</strong></p>\n<p>要查看当前目录的大小，只需要执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 duu.py</span><br></pre></td></tr></table></figure>\n<p>输出示例：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/duu.png\" alt=\"\"></p>\n<p>从上图可以看出，<code>duu</code> 会显示当前目录下文件的数量情况，按照 Byte、KB、MB 单位显示这些文件的总大小，以及每个文件的大小。</p>\n<p>如果需要查看某个目录的大小，只需要声明目录的绝对路径即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 duu.py /home/sk/Downloads/</span><br></pre></td></tr></table></figure>\n<p>如果想要更详尽的介绍，可以查看<a href=\"https://github.com/jftuga/duu\" target=\"_blank\" rel=\"noopener\">这个项目的 GitHub 页面</a>。</p>\n<p>以上就是 <code>du</code> 命令的五种替代方案，希望这篇文章能够帮助到你。就我自己而言，我并不会在这五种工具之间交替使用，我更喜欢使用 <code>ncdu</code>。欢迎在下面的评论区发表你对这些工具的评论。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/some-good-alternatives-to-du-command/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/some-good-alternatives-to-du-command/</a></p>\n"},{"title":"more、less 和 most 的区别","date":"2018-11-19T15:21:12.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/more-less-and-most-commands-720x340.png)\n\n如果你是一个 Linux 方面的新手，你可能会在 `more`、`less`、`most` 这三个命令行工具之间产生疑惑。在本文当中，我会对这三个命令行工具进行对比，以及展示它们各自在 Linux 中的一些使用例子。总的来说，这几个命令行工具之间都有相通和差异，而且它们在大部分 Linux 发行版上都有自带。\n\n我们首先来看看 `more` 命令。\n\n### more 命令\n\n`more` 是一个老式的、基础的终端分页阅读器，它可以用于打开指定的文件并进行交互式阅读。如果文件的内容太长，在一屏以内无法完整显示，就会逐页显示文件内容。使用回车键或者空格键可以滚动浏览文件的内容，但有一个限制，就是只能够单向滚动。也就是说只能按顺序往下翻页，而不能进行回看。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/more-command-demo.gif)\n\n**更正**\n\n有的 Linux 用户向我指出，在 `more` 当中是可以向上翻页的。不过，最原始版本的 `more` 确实只允许向下翻页，在后续出现的较新的版本中也允许了有限次数的向上翻页，只需要在浏览过程中按 `b` 键即可向上翻页。唯一的限制是 `more` 不能搭配管道使用（如 `ls | more`）。（LCTT 译注：此处原作者疑似有误，译者使用 `more` 是可以搭配管道使用的，或许与不同 `more` 版本有关）\n\n按 `q` 即可退出 `more`。\n\n**更多示例**\n\n打开 `ostechnix.txt` 文件进行交互式阅读，可以执行以下命令：\n\n```\n$ more ostechnix.txt\n```\n\n在阅读过程中，如果需要查找某个字符串，只需要像下面这样输入斜杠（`/`）之后接着输入需要查找的内容：\n\n```\n/linux\n```\n\n按 `n` 键可以跳转到下一个匹配的字符串。\n\n如果需要在文件的第 `10` 行开始阅读，只需要执行：\n\n```\n$ more +10 file\n```\n\n就可以从文件的第 `10` 行开始显示文件的内容了。\n\n如果你需要让 `more` 提示你按空格键来翻页，可以加上 `-d` 参数：\n\n```\n$ more -d ostechnix.txt\n```\n\n![][2]\n\n如上图所示，`more` 会提示你可以按空格键翻页。\n\n如果需要查看所有选项以及对应的按键，可以按 `h` 键。\n\n要查看 `more` 的更多详细信息，可以参考手册：\n\n```\n$ man more\n```\n\n### less 命令\n\n`less` 命令也是用于打开指定的文件并进行交互式阅读，它也支持翻页和搜索。如果文件的内容太长，也会对输出进行分页，因此也可以翻页阅读。比 `more` 命令更好的一点是，`less` 支持向上翻页和向下翻页，也就是可以在整个文件中任意阅读。\n\n![][4]\n\n在使用功能方面，`less` 比 `more` 命令具有更多优点，以下列出其中几个：\n\n  * 支持向上翻页和向下翻页\n  * 支持向上搜索和向下搜索\n  * 可以跳转到文件的末尾并立即从文件的开头开始阅读\n  * 在编辑器中打开指定的文件\n\n**更多示例**\n\n打开文件：\n\n```\n$ less ostechnix.txt\n```\n\n按空格键或回车键可以向下翻页，按 `b` 键可以向上翻页。\n\n如果需要向下搜索，在输入斜杠（`/`）之后接着输入需要搜索的内容：\n\n```\n/linux\n```\n\n按 `n` 键可以跳转到下一个匹配的字符串，如果需要跳转到上一个匹配的字符串，可以按 `N` 键。\n\n如果需要向上搜索，在输入问号（`?`）之后接着输入需要搜索的内容：\n\n```\n?linux\n```\n\n同样是按 `n` 键或 `N` 键跳转到下一个或上一个匹配的字符串。\n\n只需要按 `v` 键，就会将正在阅读的文件在默认编辑器中打开，然后就可以对文件进行各种编辑操作了。\n\n按 `h` 键可以查看 `less` 工具的选项和对应的按键。\n\n按 `q` 键可以退出阅读。\n\n要查看 `less` 的更多详细信息，可以参考手册：\n\n```\n$ man less\n```\n\n### most 命令\n\n`most` 同样是一个终端阅读工具，而且比 `more` 和 `less` 的功能更为丰富。`most` 支持同时打开多个文件。你可以在打开的文件之间切换、编辑当前打开的文件、迅速跳转到文件中的某一行、分屏阅读、同时锁定或滚动多个屏幕等等功能。在默认情况下，对于较长的行，`most` 不会将其截断成多行显示，而是提供了左右滚动功能以在同一行内显示。\n\n**更多示例**\n\n打开文件：\n\n```\n$ most ostechnix1.txt\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/most-command.png)\n\n按 `e` 键可以编辑当前文件。\n\n如果需要向下搜索，在斜杠（`/`）或 `S` 或 `f` 之后输入需要搜索的内容，按 `n` 键就可以跳转到下一个匹配的字符串。\n\n![][3]\n\n如果需要向上搜索，在问号（`?`）之后输入需要搜索的内容，也是通过按 `n` 键跳转到下一个匹配的字符串。\n\n同时打开多个文件：\n\n```\n$ most ostechnix1.txt ostechnix2.txt ostechnix3.txt\n```\n\n在打开了多个文件的状态下，可以输入 `:n` 切换到下一个文件，使用 `↑` 或 `↓` 键选择需要切换到的文件，按回车键就可以查看对应的文件。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/most-2.gif)\n\n要打开文件并跳转到某个字符串首次出现的位置（例如 linux），可以执行以下命令：\n\n```\n$ most file +/linux\n```\n\n按 `h` 键可以查看帮助。\n\n**按键操作列表**\n\n移动：\n\n  * 空格键或 `D` 键 – 向下滚动一屏\n  * `DELETE` 键或 `U` 键 – 向上滚动一屏\n  * `↓` 键 – 向下移动一行\n  * `↑` 键 – 向上移动一行\n  * `T` 键 – 移动到文件开头\n  * `B` 键 – 移动到文件末尾\n  * `>` 键或 `TAB` 键 – 向右滚动屏幕\n  * `<` 键 – 向左滚动屏幕\n  * `→` 键 – 向右移动一列\n  * `←` 键 – 向左移动一列\n  * `J` 键或 `G` 键 – 移动到某一行，例如 `10j` 可以移动到第 10 行\n  * `%` 键 – 移动到文件长度某个百分比的位置\n\n窗口命令：\n\n  * `Ctrl-X 2`、`Ctrl-W 2` – 分屏\n  * `Ctrl-X 1`、`Ctrl-W 1` – 只显示一个窗口\n  * `O` 键、`Ctrl-X O` – 切换到另一个窗口\n  * `Ctrl-X 0` – 删除窗口\n\n文件内搜索：\n\n  * `S` 键或 `f` 键或 `/` 键 – 向下搜索\n  * `?` 键 – 向上搜索\n  * `n` 键 – 跳转到下一个匹配的字符串\n\n退出：\n\n  * `q` 键 – 退出 `most` ，且所有打开的文件都会被关闭\n  * `:N`、`:n` – 退出当前文件并查看下一个文件（使用 `↑` 键、`↓` 键选择下一个文件）\n\n要查看 `most` 的更多详细信息，可以参考手册：\n\n```\n$ man most\n```\n\n### 总结\n\n`more` – 传统且基础的分页阅读工具，仅支持向下翻页和有限次数的向上翻页。\n\n`less` – 比 `more` 功能丰富，支持向下翻页和向上翻页，也支持文本搜索。在打开大文件的时候，比 `vi` 这类文本编辑器启动得更快。\n\n`most` – 在上述两个工具功能的基础上，还加入了同时打开多个文件、同时锁定或滚动多个屏幕、分屏等等大量功能。\n\n以上就是我的介绍，希望能让你通过我的文章对这三个工具有一定的认识。如果想了解这篇文章以外的关于这几个工具的详细功能，请参阅它们的 `man` 手册。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[2]: http://www.ostechnix.com/wp-content/uploads/2018/11/more-1.png\n[3]: http://www.ostechnix.com/wp-content/uploads/2018/11/most-1-1.gif\n[4]: https://www.ostechnix.com/wp-content/uploads/2018/11/less-command-demo.gif\n","source":"_posts/The-Difference-Between-more-less-And-most-Commands.md","raw":"---\ntitle: more、less 和 most 的区别\ndate: 2018-11-19 23:21:12\ntags:\n  - Linux\n  - 命令\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/more-less-and-most-commands-720x340.png)\n\n如果你是一个 Linux 方面的新手，你可能会在 `more`、`less`、`most` 这三个命令行工具之间产生疑惑。在本文当中，我会对这三个命令行工具进行对比，以及展示它们各自在 Linux 中的一些使用例子。总的来说，这几个命令行工具之间都有相通和差异，而且它们在大部分 Linux 发行版上都有自带。\n\n我们首先来看看 `more` 命令。\n\n### more 命令\n\n`more` 是一个老式的、基础的终端分页阅读器，它可以用于打开指定的文件并进行交互式阅读。如果文件的内容太长，在一屏以内无法完整显示，就会逐页显示文件内容。使用回车键或者空格键可以滚动浏览文件的内容，但有一个限制，就是只能够单向滚动。也就是说只能按顺序往下翻页，而不能进行回看。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/more-command-demo.gif)\n\n**更正**\n\n有的 Linux 用户向我指出，在 `more` 当中是可以向上翻页的。不过，最原始版本的 `more` 确实只允许向下翻页，在后续出现的较新的版本中也允许了有限次数的向上翻页，只需要在浏览过程中按 `b` 键即可向上翻页。唯一的限制是 `more` 不能搭配管道使用（如 `ls | more`）。（LCTT 译注：此处原作者疑似有误，译者使用 `more` 是可以搭配管道使用的，或许与不同 `more` 版本有关）\n\n按 `q` 即可退出 `more`。\n\n**更多示例**\n\n打开 `ostechnix.txt` 文件进行交互式阅读，可以执行以下命令：\n\n```\n$ more ostechnix.txt\n```\n\n在阅读过程中，如果需要查找某个字符串，只需要像下面这样输入斜杠（`/`）之后接着输入需要查找的内容：\n\n```\n/linux\n```\n\n按 `n` 键可以跳转到下一个匹配的字符串。\n\n如果需要在文件的第 `10` 行开始阅读，只需要执行：\n\n```\n$ more +10 file\n```\n\n就可以从文件的第 `10` 行开始显示文件的内容了。\n\n如果你需要让 `more` 提示你按空格键来翻页，可以加上 `-d` 参数：\n\n```\n$ more -d ostechnix.txt\n```\n\n![][2]\n\n如上图所示，`more` 会提示你可以按空格键翻页。\n\n如果需要查看所有选项以及对应的按键，可以按 `h` 键。\n\n要查看 `more` 的更多详细信息，可以参考手册：\n\n```\n$ man more\n```\n\n### less 命令\n\n`less` 命令也是用于打开指定的文件并进行交互式阅读，它也支持翻页和搜索。如果文件的内容太长，也会对输出进行分页，因此也可以翻页阅读。比 `more` 命令更好的一点是，`less` 支持向上翻页和向下翻页，也就是可以在整个文件中任意阅读。\n\n![][4]\n\n在使用功能方面，`less` 比 `more` 命令具有更多优点，以下列出其中几个：\n\n  * 支持向上翻页和向下翻页\n  * 支持向上搜索和向下搜索\n  * 可以跳转到文件的末尾并立即从文件的开头开始阅读\n  * 在编辑器中打开指定的文件\n\n**更多示例**\n\n打开文件：\n\n```\n$ less ostechnix.txt\n```\n\n按空格键或回车键可以向下翻页，按 `b` 键可以向上翻页。\n\n如果需要向下搜索，在输入斜杠（`/`）之后接着输入需要搜索的内容：\n\n```\n/linux\n```\n\n按 `n` 键可以跳转到下一个匹配的字符串，如果需要跳转到上一个匹配的字符串，可以按 `N` 键。\n\n如果需要向上搜索，在输入问号（`?`）之后接着输入需要搜索的内容：\n\n```\n?linux\n```\n\n同样是按 `n` 键或 `N` 键跳转到下一个或上一个匹配的字符串。\n\n只需要按 `v` 键，就会将正在阅读的文件在默认编辑器中打开，然后就可以对文件进行各种编辑操作了。\n\n按 `h` 键可以查看 `less` 工具的选项和对应的按键。\n\n按 `q` 键可以退出阅读。\n\n要查看 `less` 的更多详细信息，可以参考手册：\n\n```\n$ man less\n```\n\n### most 命令\n\n`most` 同样是一个终端阅读工具，而且比 `more` 和 `less` 的功能更为丰富。`most` 支持同时打开多个文件。你可以在打开的文件之间切换、编辑当前打开的文件、迅速跳转到文件中的某一行、分屏阅读、同时锁定或滚动多个屏幕等等功能。在默认情况下，对于较长的行，`most` 不会将其截断成多行显示，而是提供了左右滚动功能以在同一行内显示。\n\n**更多示例**\n\n打开文件：\n\n```\n$ most ostechnix1.txt\n```\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/most-command.png)\n\n按 `e` 键可以编辑当前文件。\n\n如果需要向下搜索，在斜杠（`/`）或 `S` 或 `f` 之后输入需要搜索的内容，按 `n` 键就可以跳转到下一个匹配的字符串。\n\n![][3]\n\n如果需要向上搜索，在问号（`?`）之后输入需要搜索的内容，也是通过按 `n` 键跳转到下一个匹配的字符串。\n\n同时打开多个文件：\n\n```\n$ most ostechnix1.txt ostechnix2.txt ostechnix3.txt\n```\n\n在打开了多个文件的状态下，可以输入 `:n` 切换到下一个文件，使用 `↑` 或 `↓` 键选择需要切换到的文件，按回车键就可以查看对应的文件。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/11/most-2.gif)\n\n要打开文件并跳转到某个字符串首次出现的位置（例如 linux），可以执行以下命令：\n\n```\n$ most file +/linux\n```\n\n按 `h` 键可以查看帮助。\n\n**按键操作列表**\n\n移动：\n\n  * 空格键或 `D` 键 – 向下滚动一屏\n  * `DELETE` 键或 `U` 键 – 向上滚动一屏\n  * `↓` 键 – 向下移动一行\n  * `↑` 键 – 向上移动一行\n  * `T` 键 – 移动到文件开头\n  * `B` 键 – 移动到文件末尾\n  * `>` 键或 `TAB` 键 – 向右滚动屏幕\n  * `<` 键 – 向左滚动屏幕\n  * `→` 键 – 向右移动一列\n  * `←` 键 – 向左移动一列\n  * `J` 键或 `G` 键 – 移动到某一行，例如 `10j` 可以移动到第 10 行\n  * `%` 键 – 移动到文件长度某个百分比的位置\n\n窗口命令：\n\n  * `Ctrl-X 2`、`Ctrl-W 2` – 分屏\n  * `Ctrl-X 1`、`Ctrl-W 1` – 只显示一个窗口\n  * `O` 键、`Ctrl-X O` – 切换到另一个窗口\n  * `Ctrl-X 0` – 删除窗口\n\n文件内搜索：\n\n  * `S` 键或 `f` 键或 `/` 键 – 向下搜索\n  * `?` 键 – 向上搜索\n  * `n` 键 – 跳转到下一个匹配的字符串\n\n退出：\n\n  * `q` 键 – 退出 `most` ，且所有打开的文件都会被关闭\n  * `:N`、`:n` – 退出当前文件并查看下一个文件（使用 `↑` 键、`↓` 键选择下一个文件）\n\n要查看 `most` 的更多详细信息，可以参考手册：\n\n```\n$ man most\n```\n\n### 总结\n\n`more` – 传统且基础的分页阅读工具，仅支持向下翻页和有限次数的向上翻页。\n\n`less` – 比 `more` 功能丰富，支持向下翻页和向上翻页，也支持文本搜索。在打开大文件的时候，比 `vi` 这类文本编辑器启动得更快。\n\n`most` – 在上述两个工具功能的基础上，还加入了同时打开多个文件、同时锁定或滚动多个屏幕、分屏等等大量功能。\n\n以上就是我的介绍，希望能让你通过我的文章对这三个工具有一定的认识。如果想了解这篇文章以外的关于这几个工具的详细功能，请参阅它们的 `man` 手册。\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\n[2]: http://www.ostechnix.com/wp-content/uploads/2018/11/more-1.png\n[3]: http://www.ostechnix.com/wp-content/uploads/2018/11/most-1-1.gif\n[4]: https://www.ostechnix.com/wp-content/uploads/2018/11/less-command-demo.gif\n","slug":"The-Difference-Between-more-less-And-most-Commands","published":1,"updated":"2019-03-28T12:57:33.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0de001xlixug1x4osod","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/more-less-and-most-commands-720x340.png\" alt=\"\"></p>\n<p>如果你是一个 Linux 方面的新手，你可能会在 <code>more</code>、<code>less</code>、<code>most</code> 这三个命令行工具之间产生疑惑。在本文当中，我会对这三个命令行工具进行对比，以及展示它们各自在 Linux 中的一些使用例子。总的来说，这几个命令行工具之间都有相通和差异，而且它们在大部分 Linux 发行版上都有自带。</p>\n<p>我们首先来看看 <code>more</code> 命令。</p>\n<h3 id=\"more-命令\"><a href=\"#more-命令\" class=\"headerlink\" title=\"more 命令\"></a>more 命令</h3><p><code>more</code> 是一个老式的、基础的终端分页阅读器，它可以用于打开指定的文件并进行交互式阅读。如果文件的内容太长，在一屏以内无法完整显示，就会逐页显示文件内容。使用回车键或者空格键可以滚动浏览文件的内容，但有一个限制，就是只能够单向滚动。也就是说只能按顺序往下翻页，而不能进行回看。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/more-command-demo.gif\" alt=\"\"></p>\n<p><strong>更正</strong></p>\n<p>有的 Linux 用户向我指出，在 <code>more</code> 当中是可以向上翻页的。不过，最原始版本的 <code>more</code> 确实只允许向下翻页，在后续出现的较新的版本中也允许了有限次数的向上翻页，只需要在浏览过程中按 <code>b</code> 键即可向上翻页。唯一的限制是 <code>more</code> 不能搭配管道使用（如 <code>ls | more</code>）。（LCTT 译注：此处原作者疑似有误，译者使用 <code>more</code> 是可以搭配管道使用的，或许与不同 <code>more</code> 版本有关）</p>\n<p>按 <code>q</code> 即可退出 <code>more</code>。</p>\n<p><strong>更多示例</strong></p>\n<p>打开 <code>ostechnix.txt</code> 文件进行交互式阅读，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>在阅读过程中，如果需要查找某个字符串，只需要像下面这样输入斜杠（<code>/</code>）之后接着输入需要查找的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>n</code> 键可以跳转到下一个匹配的字符串。</p>\n<p>如果需要在文件的第 <code>10</code> 行开始阅读，只需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more +10 file</span><br></pre></td></tr></table></figure>\n<p>就可以从文件的第 <code>10</code> 行开始显示文件的内容了。</p>\n<p>如果你需要让 <code>more</code> 提示你按空格键来翻页，可以加上 <code>-d</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more -d ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/more-1.png\" alt=\"\"></p>\n<p>如上图所示，<code>more</code> 会提示你可以按空格键翻页。</p>\n<p>如果需要查看所有选项以及对应的按键，可以按 <code>h</code> 键。</p>\n<p>要查看 <code>more</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man more</span><br></pre></td></tr></table></figure>\n<h3 id=\"less-命令\"><a href=\"#less-命令\" class=\"headerlink\" title=\"less 命令\"></a>less 命令</h3><p><code>less</code> 命令也是用于打开指定的文件并进行交互式阅读，它也支持翻页和搜索。如果文件的内容太长，也会对输出进行分页，因此也可以翻页阅读。比 <code>more</code> 命令更好的一点是，<code>less</code> 支持向上翻页和向下翻页，也就是可以在整个文件中任意阅读。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/less-command-demo.gif\" alt=\"\"></p>\n<p>在使用功能方面，<code>less</code> 比 <code>more</code> 命令具有更多优点，以下列出其中几个：</p>\n<ul>\n<li>支持向上翻页和向下翻页</li>\n<li>支持向上搜索和向下搜索</li>\n<li>可以跳转到文件的末尾并立即从文件的开头开始阅读</li>\n<li>在编辑器中打开指定的文件</li>\n</ul>\n<p><strong>更多示例</strong></p>\n<p>打开文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ less ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>按空格键或回车键可以向下翻页，按 <code>b</code> 键可以向上翻页。</p>\n<p>如果需要向下搜索，在输入斜杠（<code>/</code>）之后接着输入需要搜索的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>n</code> 键可以跳转到下一个匹配的字符串，如果需要跳转到上一个匹配的字符串，可以按 <code>N</code> 键。</p>\n<p>如果需要向上搜索，在输入问号（<code>?</code>）之后接着输入需要搜索的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?linux</span><br></pre></td></tr></table></figure>\n<p>同样是按 <code>n</code> 键或 <code>N</code> 键跳转到下一个或上一个匹配的字符串。</p>\n<p>只需要按 <code>v</code> 键，就会将正在阅读的文件在默认编辑器中打开，然后就可以对文件进行各种编辑操作了。</p>\n<p>按 <code>h</code> 键可以查看 <code>less</code> 工具的选项和对应的按键。</p>\n<p>按 <code>q</code> 键可以退出阅读。</p>\n<p>要查看 <code>less</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man less</span><br></pre></td></tr></table></figure>\n<h3 id=\"most-命令\"><a href=\"#most-命令\" class=\"headerlink\" title=\"most 命令\"></a>most 命令</h3><p><code>most</code> 同样是一个终端阅读工具，而且比 <code>more</code> 和 <code>less</code> 的功能更为丰富。<code>most</code> 支持同时打开多个文件。你可以在打开的文件之间切换、编辑当前打开的文件、迅速跳转到文件中的某一行、分屏阅读、同时锁定或滚动多个屏幕等等功能。在默认情况下，对于较长的行，<code>most</code> 不会将其截断成多行显示，而是提供了左右滚动功能以在同一行内显示。</p>\n<p><strong>更多示例</strong></p>\n<p>打开文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most ostechnix1.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/most-command.png\" alt=\"\"></p>\n<p>按 <code>e</code> 键可以编辑当前文件。</p>\n<p>如果需要向下搜索，在斜杠（<code>/</code>）或 <code>S</code> 或 <code>f</code> 之后输入需要搜索的内容，按 <code>n</code> 键就可以跳转到下一个匹配的字符串。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/most-1-1.gif\" alt=\"\"></p>\n<p>如果需要向上搜索，在问号（<code>?</code>）之后输入需要搜索的内容，也是通过按 <code>n</code> 键跳转到下一个匹配的字符串。</p>\n<p>同时打开多个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most ostechnix1.txt ostechnix2.txt ostechnix3.txt</span><br></pre></td></tr></table></figure>\n<p>在打开了多个文件的状态下，可以输入 <code>:n</code> 切换到下一个文件，使用 <code>↑</code> 或 <code>↓</code> 键选择需要切换到的文件，按回车键就可以查看对应的文件。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/most-2.gif\" alt=\"\"></p>\n<p>要打开文件并跳转到某个字符串首次出现的位置（例如 linux），可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most file +/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>h</code> 键可以查看帮助。</p>\n<p><strong>按键操作列表</strong></p>\n<p>移动：</p>\n<ul>\n<li>空格键或 <code>D</code> 键 – 向下滚动一屏</li>\n<li><code>DELETE</code> 键或 <code>U</code> 键 – 向上滚动一屏</li>\n<li><code>↓</code> 键 – 向下移动一行</li>\n<li><code>↑</code> 键 – 向上移动一行</li>\n<li><code>T</code> 键 – 移动到文件开头</li>\n<li><code>B</code> 键 – 移动到文件末尾</li>\n<li><code>&gt;</code> 键或 <code>TAB</code> 键 – 向右滚动屏幕</li>\n<li><code>&lt;</code> 键 – 向左滚动屏幕</li>\n<li><code>→</code> 键 – 向右移动一列</li>\n<li><code>←</code> 键 – 向左移动一列</li>\n<li><code>J</code> 键或 <code>G</code> 键 – 移动到某一行，例如 <code>10j</code> 可以移动到第 10 行</li>\n<li><code>%</code> 键 – 移动到文件长度某个百分比的位置</li>\n</ul>\n<p>窗口命令：</p>\n<ul>\n<li><code>Ctrl-X 2</code>、<code>Ctrl-W 2</code> – 分屏</li>\n<li><code>Ctrl-X 1</code>、<code>Ctrl-W 1</code> – 只显示一个窗口</li>\n<li><code>O</code> 键、<code>Ctrl-X O</code> – 切换到另一个窗口</li>\n<li><code>Ctrl-X 0</code> – 删除窗口</li>\n</ul>\n<p>文件内搜索：</p>\n<ul>\n<li><code>S</code> 键或 <code>f</code> 键或 <code>/</code> 键 – 向下搜索</li>\n<li><code>?</code> 键 – 向上搜索</li>\n<li><code>n</code> 键 – 跳转到下一个匹配的字符串</li>\n</ul>\n<p>退出：</p>\n<ul>\n<li><code>q</code> 键 – 退出 <code>most</code> ，且所有打开的文件都会被关闭</li>\n<li><code>:N</code>、<code>:n</code> – 退出当前文件并查看下一个文件（使用 <code>↑</code> 键、<code>↓</code> 键选择下一个文件）</li>\n</ul>\n<p>要查看 <code>most</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man most</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>more</code> – 传统且基础的分页阅读工具，仅支持向下翻页和有限次数的向上翻页。</p>\n<p><code>less</code> – 比 <code>more</code> 功能丰富，支持向下翻页和向上翻页，也支持文本搜索。在打开大文件的时候，比 <code>vi</code> 这类文本编辑器启动得更快。</p>\n<p><code>most</code> – 在上述两个工具功能的基础上，还加入了同时打开多个文件、同时锁定或滚动多个屏幕、分屏等等大量功能。</p>\n<p>以上就是我的介绍，希望能让你通过我的文章对这三个工具有一定的认识。如果想了解这篇文章以外的关于这几个工具的详细功能，请参阅它们的 <code>man</code> 手册。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/more-less-and-most-commands-720x340.png\" alt=\"\"></p>\n<p>如果你是一个 Linux 方面的新手，你可能会在 <code>more</code>、<code>less</code>、<code>most</code> 这三个命令行工具之间产生疑惑。在本文当中，我会对这三个命令行工具进行对比，以及展示它们各自在 Linux 中的一些使用例子。总的来说，这几个命令行工具之间都有相通和差异，而且它们在大部分 Linux 发行版上都有自带。</p>\n<p>我们首先来看看 <code>more</code> 命令。</p>\n<h3 id=\"more-命令\"><a href=\"#more-命令\" class=\"headerlink\" title=\"more 命令\"></a>more 命令</h3><p><code>more</code> 是一个老式的、基础的终端分页阅读器，它可以用于打开指定的文件并进行交互式阅读。如果文件的内容太长，在一屏以内无法完整显示，就会逐页显示文件内容。使用回车键或者空格键可以滚动浏览文件的内容，但有一个限制，就是只能够单向滚动。也就是说只能按顺序往下翻页，而不能进行回看。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/more-command-demo.gif\" alt=\"\"></p>\n<p><strong>更正</strong></p>\n<p>有的 Linux 用户向我指出，在 <code>more</code> 当中是可以向上翻页的。不过，最原始版本的 <code>more</code> 确实只允许向下翻页，在后续出现的较新的版本中也允许了有限次数的向上翻页，只需要在浏览过程中按 <code>b</code> 键即可向上翻页。唯一的限制是 <code>more</code> 不能搭配管道使用（如 <code>ls | more</code>）。（LCTT 译注：此处原作者疑似有误，译者使用 <code>more</code> 是可以搭配管道使用的，或许与不同 <code>more</code> 版本有关）</p>\n<p>按 <code>q</code> 即可退出 <code>more</code>。</p>\n<p><strong>更多示例</strong></p>\n<p>打开 <code>ostechnix.txt</code> 文件进行交互式阅读，可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>在阅读过程中，如果需要查找某个字符串，只需要像下面这样输入斜杠（<code>/</code>）之后接着输入需要查找的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>n</code> 键可以跳转到下一个匹配的字符串。</p>\n<p>如果需要在文件的第 <code>10</code> 行开始阅读，只需要执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more +10 file</span><br></pre></td></tr></table></figure>\n<p>就可以从文件的第 <code>10</code> 行开始显示文件的内容了。</p>\n<p>如果你需要让 <code>more</code> 提示你按空格键来翻页，可以加上 <code>-d</code> 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ more -d ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/more-1.png\" alt=\"\"></p>\n<p>如上图所示，<code>more</code> 会提示你可以按空格键翻页。</p>\n<p>如果需要查看所有选项以及对应的按键，可以按 <code>h</code> 键。</p>\n<p>要查看 <code>more</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man more</span><br></pre></td></tr></table></figure>\n<h3 id=\"less-命令\"><a href=\"#less-命令\" class=\"headerlink\" title=\"less 命令\"></a>less 命令</h3><p><code>less</code> 命令也是用于打开指定的文件并进行交互式阅读，它也支持翻页和搜索。如果文件的内容太长，也会对输出进行分页，因此也可以翻页阅读。比 <code>more</code> 命令更好的一点是，<code>less</code> 支持向上翻页和向下翻页，也就是可以在整个文件中任意阅读。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/less-command-demo.gif\" alt=\"\"></p>\n<p>在使用功能方面，<code>less</code> 比 <code>more</code> 命令具有更多优点，以下列出其中几个：</p>\n<ul>\n<li>支持向上翻页和向下翻页</li>\n<li>支持向上搜索和向下搜索</li>\n<li>可以跳转到文件的末尾并立即从文件的开头开始阅读</li>\n<li>在编辑器中打开指定的文件</li>\n</ul>\n<p><strong>更多示例</strong></p>\n<p>打开文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ less ostechnix.txt</span><br></pre></td></tr></table></figure>\n<p>按空格键或回车键可以向下翻页，按 <code>b</code> 键可以向上翻页。</p>\n<p>如果需要向下搜索，在输入斜杠（<code>/</code>）之后接着输入需要搜索的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>n</code> 键可以跳转到下一个匹配的字符串，如果需要跳转到上一个匹配的字符串，可以按 <code>N</code> 键。</p>\n<p>如果需要向上搜索，在输入问号（<code>?</code>）之后接着输入需要搜索的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?linux</span><br></pre></td></tr></table></figure>\n<p>同样是按 <code>n</code> 键或 <code>N</code> 键跳转到下一个或上一个匹配的字符串。</p>\n<p>只需要按 <code>v</code> 键，就会将正在阅读的文件在默认编辑器中打开，然后就可以对文件进行各种编辑操作了。</p>\n<p>按 <code>h</code> 键可以查看 <code>less</code> 工具的选项和对应的按键。</p>\n<p>按 <code>q</code> 键可以退出阅读。</p>\n<p>要查看 <code>less</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man less</span><br></pre></td></tr></table></figure>\n<h3 id=\"most-命令\"><a href=\"#most-命令\" class=\"headerlink\" title=\"most 命令\"></a>most 命令</h3><p><code>most</code> 同样是一个终端阅读工具，而且比 <code>more</code> 和 <code>less</code> 的功能更为丰富。<code>most</code> 支持同时打开多个文件。你可以在打开的文件之间切换、编辑当前打开的文件、迅速跳转到文件中的某一行、分屏阅读、同时锁定或滚动多个屏幕等等功能。在默认情况下，对于较长的行，<code>most</code> 不会将其截断成多行显示，而是提供了左右滚动功能以在同一行内显示。</p>\n<p><strong>更多示例</strong></p>\n<p>打开文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most ostechnix1.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/most-command.png\" alt=\"\"></p>\n<p>按 <code>e</code> 键可以编辑当前文件。</p>\n<p>如果需要向下搜索，在斜杠（<code>/</code>）或 <code>S</code> 或 <code>f</code> 之后输入需要搜索的内容，按 <code>n</code> 键就可以跳转到下一个匹配的字符串。</p>\n<p><img src=\"http://www.ostechnix.com/wp-content/uploads/2018/11/most-1-1.gif\" alt=\"\"></p>\n<p>如果需要向上搜索，在问号（<code>?</code>）之后输入需要搜索的内容，也是通过按 <code>n</code> 键跳转到下一个匹配的字符串。</p>\n<p>同时打开多个文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most ostechnix1.txt ostechnix2.txt ostechnix3.txt</span><br></pre></td></tr></table></figure>\n<p>在打开了多个文件的状态下，可以输入 <code>:n</code> 切换到下一个文件，使用 <code>↑</code> 或 <code>↓</code> 键选择需要切换到的文件，按回车键就可以查看对应的文件。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/11/most-2.gif\" alt=\"\"></p>\n<p>要打开文件并跳转到某个字符串首次出现的位置（例如 linux），可以执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ most file +/linux</span><br></pre></td></tr></table></figure>\n<p>按 <code>h</code> 键可以查看帮助。</p>\n<p><strong>按键操作列表</strong></p>\n<p>移动：</p>\n<ul>\n<li>空格键或 <code>D</code> 键 – 向下滚动一屏</li>\n<li><code>DELETE</code> 键或 <code>U</code> 键 – 向上滚动一屏</li>\n<li><code>↓</code> 键 – 向下移动一行</li>\n<li><code>↑</code> 键 – 向上移动一行</li>\n<li><code>T</code> 键 – 移动到文件开头</li>\n<li><code>B</code> 键 – 移动到文件末尾</li>\n<li><code>&gt;</code> 键或 <code>TAB</code> 键 – 向右滚动屏幕</li>\n<li><code>&lt;</code> 键 – 向左滚动屏幕</li>\n<li><code>→</code> 键 – 向右移动一列</li>\n<li><code>←</code> 键 – 向左移动一列</li>\n<li><code>J</code> 键或 <code>G</code> 键 – 移动到某一行，例如 <code>10j</code> 可以移动到第 10 行</li>\n<li><code>%</code> 键 – 移动到文件长度某个百分比的位置</li>\n</ul>\n<p>窗口命令：</p>\n<ul>\n<li><code>Ctrl-X 2</code>、<code>Ctrl-W 2</code> – 分屏</li>\n<li><code>Ctrl-X 1</code>、<code>Ctrl-W 1</code> – 只显示一个窗口</li>\n<li><code>O</code> 键、<code>Ctrl-X O</code> – 切换到另一个窗口</li>\n<li><code>Ctrl-X 0</code> – 删除窗口</li>\n</ul>\n<p>文件内搜索：</p>\n<ul>\n<li><code>S</code> 键或 <code>f</code> 键或 <code>/</code> 键 – 向下搜索</li>\n<li><code>?</code> 键 – 向上搜索</li>\n<li><code>n</code> 键 – 跳转到下一个匹配的字符串</li>\n</ul>\n<p>退出：</p>\n<ul>\n<li><code>q</code> 键 – 退出 <code>most</code> ，且所有打开的文件都会被关闭</li>\n<li><code>:N</code>、<code>:n</code> – 退出当前文件并查看下一个文件（使用 <code>↑</code> 键、<code>↓</code> 键选择下一个文件）</li>\n</ul>\n<p>要查看 <code>most</code> 的更多详细信息，可以参考手册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man most</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>more</code> – 传统且基础的分页阅读工具，仅支持向下翻页和有限次数的向上翻页。</p>\n<p><code>less</code> – 比 <code>more</code> 功能丰富，支持向下翻页和向上翻页，也支持文本搜索。在打开大文件的时候，比 <code>vi</code> 这类文本编辑器启动得更快。</p>\n<p><code>most</code> – 在上述两个工具功能的基础上，还加入了同时打开多个文件、同时锁定或滚动多个屏幕、分屏等等大量功能。</p>\n<p>以上就是我的介绍，希望能让你通过我的文章对这三个工具有一定的认识。如果想了解这篇文章以外的关于这几个工具的详细功能，请参阅它们的 <code>man</code> 手册。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/the-difference-between-more-less-and-most-commands/</a></p>\n"},{"title":"使用 Ultimate Plumber 即时预览管道命令结果","date":"2018-11-08T13:27:19.000Z","_content":"\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber-720x340.jpg)\n\n管道命令的作用是将一个命令/程序/进程的输出发送给另一个命令/程序/进程，以便将输出结果进行进一步的处理。我们可以通过使用管道命令把多个命令组合起来，使一个命令的标准输入或输出重定向到另一个命令。两个或多个 Linux 命令之间的竖线字符（`|`）表示在命令之间使用管道命令。管道命令的一般语法如下所示：\n\n```\nCommand-1 | Command-2 | Command-3 | …| Command-N\n```\n\nUltimate Plumber（简称 UP）是一个命令行工具，它可以用于即时预览管道命令结果。如果你在使用 Linux 时经常会用到管道命令，就可以通过它更好地运用管道命令了。它可以预先显示执行管道命令后的结果，而且是即时滚动地显示，让你可以轻松构建复杂的管道。\n\n下文将会介绍如何安装 UP 并用它将复杂管道命令的编写变得简单。\n\n\n**重要警告：**\n\n在生产环境中请谨慎使用 UP！在使用它的过程中，有可能会在无意中删除重要数据，尤其是搭配 `rm` 或 `dd` 命令时需要更加小心。勿谓言之不预。\n\n### 使用 Ultimate Plumber 即时预览管道命令\n\n下面给出一个简单的例子介绍 `up` 的使用方法。如果需要将 `lshw` 命令的输出传递给 `up`，只需要在终端中输入以下命令，然后回车：\n\n```\n$ lshw |& up\n```\n\n你会在屏幕顶部看到一个输入框，如下图所示。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber.png)\n\n在输入命令的过程中，输入管道符号并回车，就可以立即执行已经输入了的命令。Ultimate Plumber 会在下方的可滚动窗口中即时显示管道命令的输出。在这种状态下，你可以通过 `PgUp`/`PgDn` 键或 `ctrl + ←`/`ctrl + →` 组合键来查看结果。\n\n当你满意执行结果之后，可以使用 `ctrl + x` 组合键退出 `UP`。而退出前编写的管道命令则会保存在当前工作目录的文件中，并命名为 `up1.sh`。如果这个文件名已经被占用，就会命名为 `up2.sh`、`up3.sh` 等等以此类推，直到第 1000 个文件。如果你不需要将管道命令保存输出，只需要使用 `ctrl + c` 组合键退出即可。\n\n通过 `cat` 命令可以查看 `upX.sh` 文件的内容。例如以下是我的 `up2.sh` 文件的输出内容：\n\n```\n$ cat up2.sh\n#!/bin/bash\ngrep network -A5 | grep : | cut -d: -f2- | paste - -\n```\n\n如果通过管道发送到 `up` 的命令运行时间太长，终端窗口的左上角会显示一个波浪号（~）字符，这就表示 `up` 在等待前一个命令的输出结果作为输入。在这种情况下，你可能需要使用 `ctrl + s` 组合键暂时冻结 `up` 的输入缓冲区大小。在需要解冻的时候，使用 `ctrl + q` 组合键即可。Ultimate Plumber 的输入缓冲区大小一般为 40 MB，到达这个限制之后，屏幕的左上角会显示一个加号。\n\n以下是 `up` 命令的一个简单演示：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/up.gif)\n\n### 安装 Ultimate Plumber\n\n喜欢这个工具的话，你可以在你的 Linux 系统上安装使用。安装过程也相当简单，只需要在终端里执行以下两个命令就可以安装 `up` 了。\n\n首先从 Ultimate Plumber 的[发布页面][1]下载最新的二进制文件，并将放在你系统的某个路径下，例如 `/usr/local/bin/`。\n\n```\n$ sudo wget -O /usr/local/bin/up wget https://github.com/akavel/up/releases/download/v0.2.1/up\n```\n\n然后向 `up` 二进制文件赋予可执行权限：\n\n```\n$ sudo chmod a+x /usr/local/bin/up\n```\n\n至此，你已经完成了 `up` 的安装，可以开始编写你的管道命令了。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://github.com/akavel/up/releases\n\n","source":"_posts/Ultimate-Plumber-Writing-Linux-Pipes-With-Instant-Live-Preview.md","raw":"---\ntitle: 使用 Ultimate Plumber 即时预览管道命令结果\ndate: 2018-11-08 21:27:19\ntags:\n  - Linux\n  - 管道\n  - LCTT 翻译\n---\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber-720x340.jpg)\n\n管道命令的作用是将一个命令/程序/进程的输出发送给另一个命令/程序/进程，以便将输出结果进行进一步的处理。我们可以通过使用管道命令把多个命令组合起来，使一个命令的标准输入或输出重定向到另一个命令。两个或多个 Linux 命令之间的竖线字符（`|`）表示在命令之间使用管道命令。管道命令的一般语法如下所示：\n\n```\nCommand-1 | Command-2 | Command-3 | …| Command-N\n```\n\nUltimate Plumber（简称 UP）是一个命令行工具，它可以用于即时预览管道命令结果。如果你在使用 Linux 时经常会用到管道命令，就可以通过它更好地运用管道命令了。它可以预先显示执行管道命令后的结果，而且是即时滚动地显示，让你可以轻松构建复杂的管道。\n\n下文将会介绍如何安装 UP 并用它将复杂管道命令的编写变得简单。\n\n\n**重要警告：**\n\n在生产环境中请谨慎使用 UP！在使用它的过程中，有可能会在无意中删除重要数据，尤其是搭配 `rm` 或 `dd` 命令时需要更加小心。勿谓言之不预。\n\n### 使用 Ultimate Plumber 即时预览管道命令\n\n下面给出一个简单的例子介绍 `up` 的使用方法。如果需要将 `lshw` 命令的输出传递给 `up`，只需要在终端中输入以下命令，然后回车：\n\n```\n$ lshw |& up\n```\n\n你会在屏幕顶部看到一个输入框，如下图所示。\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber.png)\n\n在输入命令的过程中，输入管道符号并回车，就可以立即执行已经输入了的命令。Ultimate Plumber 会在下方的可滚动窗口中即时显示管道命令的输出。在这种状态下，你可以通过 `PgUp`/`PgDn` 键或 `ctrl + ←`/`ctrl + →` 组合键来查看结果。\n\n当你满意执行结果之后，可以使用 `ctrl + x` 组合键退出 `UP`。而退出前编写的管道命令则会保存在当前工作目录的文件中，并命名为 `up1.sh`。如果这个文件名已经被占用，就会命名为 `up2.sh`、`up3.sh` 等等以此类推，直到第 1000 个文件。如果你不需要将管道命令保存输出，只需要使用 `ctrl + c` 组合键退出即可。\n\n通过 `cat` 命令可以查看 `upX.sh` 文件的内容。例如以下是我的 `up2.sh` 文件的输出内容：\n\n```\n$ cat up2.sh\n#!/bin/bash\ngrep network -A5 | grep : | cut -d: -f2- | paste - -\n```\n\n如果通过管道发送到 `up` 的命令运行时间太长，终端窗口的左上角会显示一个波浪号（~）字符，这就表示 `up` 在等待前一个命令的输出结果作为输入。在这种情况下，你可能需要使用 `ctrl + s` 组合键暂时冻结 `up` 的输入缓冲区大小。在需要解冻的时候，使用 `ctrl + q` 组合键即可。Ultimate Plumber 的输入缓冲区大小一般为 40 MB，到达这个限制之后，屏幕的左上角会显示一个加号。\n\n以下是 `up` 命令的一个简单演示：\n\n![](https://www.ostechnix.com/wp-content/uploads/2018/10/up.gif)\n\n### 安装 Ultimate Plumber\n\n喜欢这个工具的话，你可以在你的 Linux 系统上安装使用。安装过程也相当简单，只需要在终端里执行以下两个命令就可以安装 `up` 了。\n\n首先从 Ultimate Plumber 的[发布页面][1]下载最新的二进制文件，并将放在你系统的某个路径下，例如 `/usr/local/bin/`。\n\n```\n$ sudo wget -O /usr/local/bin/up wget https://github.com/akavel/up/releases/download/v0.2.1/up\n```\n\n然后向 `up` 二进制文件赋予可执行权限：\n\n```\n$ sudo chmod a+x /usr/local/bin/up\n```\n\n至此，你已经完成了 `up` 的安装，可以开始编写你的管道命令了。\n\n\n--------------------------------------------------------------------------------\n\nvia: https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/\n\n[a]: https://www.ostechnix.com/author/sk/\n[b]: https://github.com/lujun9972\n[1]: https://github.com/akavel/up/releases\n\n","slug":"Ultimate-Plumber-Writing-Linux-Pipes-With-Instant-Live-Preview","published":1,"updated":"2019-03-28T12:33:39.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0df001zlixu6ms5v6lp","content":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber-720x340.jpg\" alt=\"\"></p>\n<p>管道命令的作用是将一个命令/程序/进程的输出发送给另一个命令/程序/进程，以便将输出结果进行进一步的处理。我们可以通过使用管道命令把多个命令组合起来，使一个命令的标准输入或输出重定向到另一个命令。两个或多个 Linux 命令之间的竖线字符（<code>|</code>）表示在命令之间使用管道命令。管道命令的一般语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Command-1 | Command-2 | Command-3 | …| Command-N</span><br></pre></td></tr></table></figure>\n<p>Ultimate Plumber（简称 UP）是一个命令行工具，它可以用于即时预览管道命令结果。如果你在使用 Linux 时经常会用到管道命令，就可以通过它更好地运用管道命令了。它可以预先显示执行管道命令后的结果，而且是即时滚动地显示，让你可以轻松构建复杂的管道。</p>\n<p>下文将会介绍如何安装 UP 并用它将复杂管道命令的编写变得简单。</p>\n<p><strong>重要警告：</strong></p>\n<p>在生产环境中请谨慎使用 UP！在使用它的过程中，有可能会在无意中删除重要数据，尤其是搭配 <code>rm</code> 或 <code>dd</code> 命令时需要更加小心。勿谓言之不预。</p>\n<h3 id=\"使用-Ultimate-Plumber-即时预览管道命令\"><a href=\"#使用-Ultimate-Plumber-即时预览管道命令\" class=\"headerlink\" title=\"使用 Ultimate Plumber 即时预览管道命令\"></a>使用 Ultimate Plumber 即时预览管道命令</h3><p>下面给出一个简单的例子介绍 <code>up</code> 的使用方法。如果需要将 <code>lshw</code> 命令的输出传递给 <code>up</code>，只需要在终端中输入以下命令，然后回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lshw |&amp; up</span><br></pre></td></tr></table></figure>\n<p>你会在屏幕顶部看到一个输入框，如下图所示。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber.png\" alt=\"\"></p>\n<p>在输入命令的过程中，输入管道符号并回车，就可以立即执行已经输入了的命令。Ultimate Plumber 会在下方的可滚动窗口中即时显示管道命令的输出。在这种状态下，你可以通过 <code>PgUp</code>/<code>PgDn</code> 键或 <code>ctrl + ←</code>/<code>ctrl + →</code> 组合键来查看结果。</p>\n<p>当你满意执行结果之后，可以使用 <code>ctrl + x</code> 组合键退出 <code>UP</code>。而退出前编写的管道命令则会保存在当前工作目录的文件中，并命名为 <code>up1.sh</code>。如果这个文件名已经被占用，就会命名为 <code>up2.sh</code>、<code>up3.sh</code> 等等以此类推，直到第 1000 个文件。如果你不需要将管道命令保存输出，只需要使用 <code>ctrl + c</code> 组合键退出即可。</p>\n<p>通过 <code>cat</code> 命令可以查看 <code>upX.sh</code> 文件的内容。例如以下是我的 <code>up2.sh</code> 文件的输出内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat up2.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">grep network -A5 | grep : | cut -d: -f2- | paste - -</span><br></pre></td></tr></table></figure>\n<p>如果通过管道发送到 <code>up</code> 的命令运行时间太长，终端窗口的左上角会显示一个波浪号（~）字符，这就表示 <code>up</code> 在等待前一个命令的输出结果作为输入。在这种情况下，你可能需要使用 <code>ctrl + s</code> 组合键暂时冻结 <code>up</code> 的输入缓冲区大小。在需要解冻的时候，使用 <code>ctrl + q</code> 组合键即可。Ultimate Plumber 的输入缓冲区大小一般为 40 MB，到达这个限制之后，屏幕的左上角会显示一个加号。</p>\n<p>以下是 <code>up</code> 命令的一个简单演示：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/up.gif\" alt=\"\"></p>\n<h3 id=\"安装-Ultimate-Plumber\"><a href=\"#安装-Ultimate-Plumber\" class=\"headerlink\" title=\"安装 Ultimate Plumber\"></a>安装 Ultimate Plumber</h3><p>喜欢这个工具的话，你可以在你的 Linux 系统上安装使用。安装过程也相当简单，只需要在终端里执行以下两个命令就可以安装 <code>up</code> 了。</p>\n<p>首先从 Ultimate Plumber 的<a href=\"https://github.com/akavel/up/releases\" target=\"_blank\" rel=\"noopener\">发布页面</a>下载最新的二进制文件，并将放在你系统的某个路径下，例如 <code>/usr/local/bin/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wget -O /usr/local/bin/up wget https://github.com/akavel/up/releases/download/v0.2.1/up</span><br></pre></td></tr></table></figure>\n<p>然后向 <code>up</code> 二进制文件赋予可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chmod a+x /usr/local/bin/up</span><br></pre></td></tr></table></figure>\n<p>至此，你已经完成了 <code>up</code> 的安装，可以开始编写你的管道命令了。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber-720x340.jpg\" alt=\"\"></p>\n<p>管道命令的作用是将一个命令/程序/进程的输出发送给另一个命令/程序/进程，以便将输出结果进行进一步的处理。我们可以通过使用管道命令把多个命令组合起来，使一个命令的标准输入或输出重定向到另一个命令。两个或多个 Linux 命令之间的竖线字符（<code>|</code>）表示在命令之间使用管道命令。管道命令的一般语法如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Command-1 | Command-2 | Command-3 | …| Command-N</span><br></pre></td></tr></table></figure>\n<p>Ultimate Plumber（简称 UP）是一个命令行工具，它可以用于即时预览管道命令结果。如果你在使用 Linux 时经常会用到管道命令，就可以通过它更好地运用管道命令了。它可以预先显示执行管道命令后的结果，而且是即时滚动地显示，让你可以轻松构建复杂的管道。</p>\n<p>下文将会介绍如何安装 UP 并用它将复杂管道命令的编写变得简单。</p>\n<p><strong>重要警告：</strong></p>\n<p>在生产环境中请谨慎使用 UP！在使用它的过程中，有可能会在无意中删除重要数据，尤其是搭配 <code>rm</code> 或 <code>dd</code> 命令时需要更加小心。勿谓言之不预。</p>\n<h3 id=\"使用-Ultimate-Plumber-即时预览管道命令\"><a href=\"#使用-Ultimate-Plumber-即时预览管道命令\" class=\"headerlink\" title=\"使用 Ultimate Plumber 即时预览管道命令\"></a>使用 Ultimate Plumber 即时预览管道命令</h3><p>下面给出一个简单的例子介绍 <code>up</code> 的使用方法。如果需要将 <code>lshw</code> 命令的输出传递给 <code>up</code>，只需要在终端中输入以下命令，然后回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lshw |&amp; up</span><br></pre></td></tr></table></figure>\n<p>你会在屏幕顶部看到一个输入框，如下图所示。</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/Ultimate-Plumber.png\" alt=\"\"></p>\n<p>在输入命令的过程中，输入管道符号并回车，就可以立即执行已经输入了的命令。Ultimate Plumber 会在下方的可滚动窗口中即时显示管道命令的输出。在这种状态下，你可以通过 <code>PgUp</code>/<code>PgDn</code> 键或 <code>ctrl + ←</code>/<code>ctrl + →</code> 组合键来查看结果。</p>\n<p>当你满意执行结果之后，可以使用 <code>ctrl + x</code> 组合键退出 <code>UP</code>。而退出前编写的管道命令则会保存在当前工作目录的文件中，并命名为 <code>up1.sh</code>。如果这个文件名已经被占用，就会命名为 <code>up2.sh</code>、<code>up3.sh</code> 等等以此类推，直到第 1000 个文件。如果你不需要将管道命令保存输出，只需要使用 <code>ctrl + c</code> 组合键退出即可。</p>\n<p>通过 <code>cat</code> 命令可以查看 <code>upX.sh</code> 文件的内容。例如以下是我的 <code>up2.sh</code> 文件的输出内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat up2.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">grep network -A5 | grep : | cut -d: -f2- | paste - -</span><br></pre></td></tr></table></figure>\n<p>如果通过管道发送到 <code>up</code> 的命令运行时间太长，终端窗口的左上角会显示一个波浪号（~）字符，这就表示 <code>up</code> 在等待前一个命令的输出结果作为输入。在这种情况下，你可能需要使用 <code>ctrl + s</code> 组合键暂时冻结 <code>up</code> 的输入缓冲区大小。在需要解冻的时候，使用 <code>ctrl + q</code> 组合键即可。Ultimate Plumber 的输入缓冲区大小一般为 40 MB，到达这个限制之后，屏幕的左上角会显示一个加号。</p>\n<p>以下是 <code>up</code> 命令的一个简单演示：</p>\n<p><img src=\"https://www.ostechnix.com/wp-content/uploads/2018/10/up.gif\" alt=\"\"></p>\n<h3 id=\"安装-Ultimate-Plumber\"><a href=\"#安装-Ultimate-Plumber\" class=\"headerlink\" title=\"安装 Ultimate Plumber\"></a>安装 Ultimate Plumber</h3><p>喜欢这个工具的话，你可以在你的 Linux 系统上安装使用。安装过程也相当简单，只需要在终端里执行以下两个命令就可以安装 <code>up</code> 了。</p>\n<p>首先从 Ultimate Plumber 的<a href=\"https://github.com/akavel/up/releases\" target=\"_blank\" rel=\"noopener\">发布页面</a>下载最新的二进制文件，并将放在你系统的某个路径下，例如 <code>/usr/local/bin/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo wget -O /usr/local/bin/up wget https://github.com/akavel/up/releases/download/v0.2.1/up</span><br></pre></td></tr></table></figure>\n<p>然后向 <code>up</code> 二进制文件赋予可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo chmod a+x /usr/local/bin/up</span><br></pre></td></tr></table></figure>\n<p>至此，你已经完成了 <code>up</code> 的安装，可以开始编写你的管道命令了。</p>\n<hr>\n<p>via: <a href=\"https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/\" target=\"_blank\" rel=\"noopener\">https://www.ostechnix.com/ultimate-plumber-writing-linux-pipes-with-instant-live-preview/</a></p>\n"},{"title":"使用 top 命令了解 Fedora 的内存使用情况","date":"2018-09-26T02:15:57.000Z","_content":"\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/memory-top-816x345.jpg)\n\n如果你使用过 `top` 命令来查看 Fedora 系统中的内存使用情况，你可能会惊讶，看起来消耗的数量比系统可用的内存更多。下面会详细介绍内存使用情况以及如何理解这些数据。\n\n### 内存实际使用情况\n\n操作系统对内存的使用方式并不是太通俗易懂。事实上，其背后有很多不为人知的巧妙技术在发挥着作用。通过这些方式，可以在无需用户干预的情况下，让操作系统更有效地使用内存。\n\n大多数应用程序都不是系统自带的，但每个应用程序都依赖于安装在系统中的库中的一些函数集。在 Fedora 中，RPM 包管理系统能够确保在安装应用程序时也会安装所依赖的库。\n\n当应用程序运行时，操作系统并不需要将它要用到的所有信息都加载到物理内存中。而是会为存放代码的存储空间构建一个映射，称为虚拟内存。操作系统只把需要的部分加载到内存中，当某一个部分不再需要后，这一部分内存就会被释放掉。\n\n这意味着应用程序可以映射大量的虚拟内存，而使用较少的系统物理内存。特殊情况下，映射的虚拟内存甚至可以比系统实际可用的物理内存更多！而且在操作系统中这种情况也并不少见。\n\n另外，不同的应用程序可能会对同一个库都有依赖。Fedora 中的 Linux 内核通常会在各个应用程序之间共享内存，而不需要为不同应用分别加载同一个库的多个副本。类似地，对于同一个应用程序的不同实例也是采用这种方式共享内存。\n\n如果不首先了解这些细节，`top` 命令显示的数据可能会让人摸不着头脑。下面就举例说明如何正确查看内存使用量。\n\n### 使用 `top` 命令查看内存使用量\n\n如果你还没有使用过 `top` 命令，可以打开终端直接执行查看。使用 `Shift + M` 可以按照内存使用量来进行排序。下图是在 Fedora Workstation 中执行的结果，在你的机器上显示的结果可能会略有不同：\n\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/Screenshot-from-2018-09-17-14-23-17.png)\n\n主要通过以下三列来查看内存使用情况：`VIRT`、`RES` 和 `SHR`。目前以 KB 为单位显示相关数值。\n\n`VIRT` 列代表该进程映射的<ruby>虚拟<rt>virtual</rt></ruby>内存。如上所述，虚拟内存不是实际消耗的物理内存。例如， GNOME Shell 进程 `gnome-shell` 实际上没有消耗超过 3.1 GB 的物理内存，但它对很多更低或更高级的库都有依赖，系统必须对每个库都进行映射，以确保在有需要时可以加载这些库。\n\n`RES` 列代表应用程序消耗了多少实际（<ruby>驻留<rt>resident</rt></ruby>）内存。对于 GNOME Shell 大约是 180788 KB。例子中的系统拥有大约 7704 MB 的物理内存，因此内存使用率显示为 2.3％。\n\n但根据 `SHR` 列显示，其中至少有 88212 KB 是<ruby>共享<rt>shared</rt></ruby>内存，这部分内存可能是其它应用程序也在使用的库函数。这意味着 GNOME Shell 本身大约有 92 MB 内存不与其他进程共享。需要注意的是，上述例子中的其它程序也共享了很多内存。在某些应用程序中，共享内存在内存使用量中会占很大的比例。\n\n值得一提的是，有时进程之间通过内存通信，这些内存也是共享的，但 `top` 这样的工具却不一定能检测到，所以以上的说明也不一定准确。\n\n### 关于交换分区\n\n系统还可以通过交换分区来存储数据（例如硬盘），但读写的速度相对较慢。当物理内存渐渐用满，操作系统就会查找内存中暂时不会使用的部分，将其写出到交换区域等待需要的时候使用。\n\n因此，如果交换内存的使用量一直偏高，表明系统的物理内存已经供不应求了。有时候一个不正常的应用也有可能导致出现这种情况，但如果这种现象经常出现，就需要考虑提升物理内存或者限制某些程序的运行了。\n\n感谢 [Stig Nygaard][1] 在 [Flickr][2] 上提供的图片（CC BY 2.0）。\n\n--------------------------------------------------------------------------------\n\nvia: https://fedoramagazine.org/understand-fedora-memory-usage-top/\n\n[a]: https://fedoramagazine.org/author/pfrields/\n[1]: https://www.flickr.com/photos/stignygaard/\n[2]: https://www.flickr.com/photos/stignygaard/3138001676/\n\n","source":"_posts/Understand-Fedora-memory-usage-with-top.md","raw":"---\ntitle: 使用 top 命令了解 Fedora 的内存使用情况\ndate: 2018-09-26 10:15:57\ntags:\n  - top\n  - 内存\n  - LCTT 翻译\n---\n\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/memory-top-816x345.jpg)\n\n如果你使用过 `top` 命令来查看 Fedora 系统中的内存使用情况，你可能会惊讶，看起来消耗的数量比系统可用的内存更多。下面会详细介绍内存使用情况以及如何理解这些数据。\n\n### 内存实际使用情况\n\n操作系统对内存的使用方式并不是太通俗易懂。事实上，其背后有很多不为人知的巧妙技术在发挥着作用。通过这些方式，可以在无需用户干预的情况下，让操作系统更有效地使用内存。\n\n大多数应用程序都不是系统自带的，但每个应用程序都依赖于安装在系统中的库中的一些函数集。在 Fedora 中，RPM 包管理系统能够确保在安装应用程序时也会安装所依赖的库。\n\n当应用程序运行时，操作系统并不需要将它要用到的所有信息都加载到物理内存中。而是会为存放代码的存储空间构建一个映射，称为虚拟内存。操作系统只把需要的部分加载到内存中，当某一个部分不再需要后，这一部分内存就会被释放掉。\n\n这意味着应用程序可以映射大量的虚拟内存，而使用较少的系统物理内存。特殊情况下，映射的虚拟内存甚至可以比系统实际可用的物理内存更多！而且在操作系统中这种情况也并不少见。\n\n另外，不同的应用程序可能会对同一个库都有依赖。Fedora 中的 Linux 内核通常会在各个应用程序之间共享内存，而不需要为不同应用分别加载同一个库的多个副本。类似地，对于同一个应用程序的不同实例也是采用这种方式共享内存。\n\n如果不首先了解这些细节，`top` 命令显示的数据可能会让人摸不着头脑。下面就举例说明如何正确查看内存使用量。\n\n### 使用 `top` 命令查看内存使用量\n\n如果你还没有使用过 `top` 命令，可以打开终端直接执行查看。使用 `Shift + M` 可以按照内存使用量来进行排序。下图是在 Fedora Workstation 中执行的结果，在你的机器上显示的结果可能会略有不同：\n\n![](https://fedoramagazine.org/wp-content/uploads/2018/09/Screenshot-from-2018-09-17-14-23-17.png)\n\n主要通过以下三列来查看内存使用情况：`VIRT`、`RES` 和 `SHR`。目前以 KB 为单位显示相关数值。\n\n`VIRT` 列代表该进程映射的<ruby>虚拟<rt>virtual</rt></ruby>内存。如上所述，虚拟内存不是实际消耗的物理内存。例如， GNOME Shell 进程 `gnome-shell` 实际上没有消耗超过 3.1 GB 的物理内存，但它对很多更低或更高级的库都有依赖，系统必须对每个库都进行映射，以确保在有需要时可以加载这些库。\n\n`RES` 列代表应用程序消耗了多少实际（<ruby>驻留<rt>resident</rt></ruby>）内存。对于 GNOME Shell 大约是 180788 KB。例子中的系统拥有大约 7704 MB 的物理内存，因此内存使用率显示为 2.3％。\n\n但根据 `SHR` 列显示，其中至少有 88212 KB 是<ruby>共享<rt>shared</rt></ruby>内存，这部分内存可能是其它应用程序也在使用的库函数。这意味着 GNOME Shell 本身大约有 92 MB 内存不与其他进程共享。需要注意的是，上述例子中的其它程序也共享了很多内存。在某些应用程序中，共享内存在内存使用量中会占很大的比例。\n\n值得一提的是，有时进程之间通过内存通信，这些内存也是共享的，但 `top` 这样的工具却不一定能检测到，所以以上的说明也不一定准确。\n\n### 关于交换分区\n\n系统还可以通过交换分区来存储数据（例如硬盘），但读写的速度相对较慢。当物理内存渐渐用满，操作系统就会查找内存中暂时不会使用的部分，将其写出到交换区域等待需要的时候使用。\n\n因此，如果交换内存的使用量一直偏高，表明系统的物理内存已经供不应求了。有时候一个不正常的应用也有可能导致出现这种情况，但如果这种现象经常出现，就需要考虑提升物理内存或者限制某些程序的运行了。\n\n感谢 [Stig Nygaard][1] 在 [Flickr][2] 上提供的图片（CC BY 2.0）。\n\n--------------------------------------------------------------------------------\n\nvia: https://fedoramagazine.org/understand-fedora-memory-usage-top/\n\n[a]: https://fedoramagazine.org/author/pfrields/\n[1]: https://www.flickr.com/photos/stignygaard/\n[2]: https://www.flickr.com/photos/stignygaard/3138001676/\n\n","slug":"Understand-Fedora-memory-usage-with-top","published":1,"updated":"2019-03-28T05:51:44.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0di0022lixunk03zojw","content":"<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/memory-top-816x345.jpg\" alt=\"\"></p>\n<p>如果你使用过 <code>top</code> 命令来查看 Fedora 系统中的内存使用情况，你可能会惊讶，看起来消耗的数量比系统可用的内存更多。下面会详细介绍内存使用情况以及如何理解这些数据。</p>\n<h3 id=\"内存实际使用情况\"><a href=\"#内存实际使用情况\" class=\"headerlink\" title=\"内存实际使用情况\"></a>内存实际使用情况</h3><p>操作系统对内存的使用方式并不是太通俗易懂。事实上，其背后有很多不为人知的巧妙技术在发挥着作用。通过这些方式，可以在无需用户干预的情况下，让操作系统更有效地使用内存。</p>\n<p>大多数应用程序都不是系统自带的，但每个应用程序都依赖于安装在系统中的库中的一些函数集。在 Fedora 中，RPM 包管理系统能够确保在安装应用程序时也会安装所依赖的库。</p>\n<p>当应用程序运行时，操作系统并不需要将它要用到的所有信息都加载到物理内存中。而是会为存放代码的存储空间构建一个映射，称为虚拟内存。操作系统只把需要的部分加载到内存中，当某一个部分不再需要后，这一部分内存就会被释放掉。</p>\n<p>这意味着应用程序可以映射大量的虚拟内存，而使用较少的系统物理内存。特殊情况下，映射的虚拟内存甚至可以比系统实际可用的物理内存更多！而且在操作系统中这种情况也并不少见。</p>\n<p>另外，不同的应用程序可能会对同一个库都有依赖。Fedora 中的 Linux 内核通常会在各个应用程序之间共享内存，而不需要为不同应用分别加载同一个库的多个副本。类似地，对于同一个应用程序的不同实例也是采用这种方式共享内存。</p>\n<p>如果不首先了解这些细节，<code>top</code> 命令显示的数据可能会让人摸不着头脑。下面就举例说明如何正确查看内存使用量。</p>\n<h3 id=\"使用-top-命令查看内存使用量\"><a href=\"#使用-top-命令查看内存使用量\" class=\"headerlink\" title=\"使用 top 命令查看内存使用量\"></a>使用 <code>top</code> 命令查看内存使用量</h3><p>如果你还没有使用过 <code>top</code> 命令，可以打开终端直接执行查看。使用 <code>Shift + M</code> 可以按照内存使用量来进行排序。下图是在 Fedora Workstation 中执行的结果，在你的机器上显示的结果可能会略有不同：</p>\n<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/Screenshot-from-2018-09-17-14-23-17.png\" alt=\"\"></p>\n<p>主要通过以下三列来查看内存使用情况：<code>VIRT</code>、<code>RES</code> 和 <code>SHR</code>。目前以 KB 为单位显示相关数值。</p>\n<p><code>VIRT</code> 列代表该进程映射的<ruby>虚拟<rt>virtual</rt></ruby>内存。如上所述，虚拟内存不是实际消耗的物理内存。例如， GNOME Shell 进程 <code>gnome-shell</code> 实际上没有消耗超过 3.1 GB 的物理内存，但它对很多更低或更高级的库都有依赖，系统必须对每个库都进行映射，以确保在有需要时可以加载这些库。</p>\n<p><code>RES</code> 列代表应用程序消耗了多少实际（<ruby>驻留<rt>resident</rt></ruby>）内存。对于 GNOME Shell 大约是 180788 KB。例子中的系统拥有大约 7704 MB 的物理内存，因此内存使用率显示为 2.3％。</p>\n<p>但根据 <code>SHR</code> 列显示，其中至少有 88212 KB 是<ruby>共享<rt>shared</rt></ruby>内存，这部分内存可能是其它应用程序也在使用的库函数。这意味着 GNOME Shell 本身大约有 92 MB 内存不与其他进程共享。需要注意的是，上述例子中的其它程序也共享了很多内存。在某些应用程序中，共享内存在内存使用量中会占很大的比例。</p>\n<p>值得一提的是，有时进程之间通过内存通信，这些内存也是共享的，但 <code>top</code> 这样的工具却不一定能检测到，所以以上的说明也不一定准确。</p>\n<h3 id=\"关于交换分区\"><a href=\"#关于交换分区\" class=\"headerlink\" title=\"关于交换分区\"></a>关于交换分区</h3><p>系统还可以通过交换分区来存储数据（例如硬盘），但读写的速度相对较慢。当物理内存渐渐用满，操作系统就会查找内存中暂时不会使用的部分，将其写出到交换区域等待需要的时候使用。</p>\n<p>因此，如果交换内存的使用量一直偏高，表明系统的物理内存已经供不应求了。有时候一个不正常的应用也有可能导致出现这种情况，但如果这种现象经常出现，就需要考虑提升物理内存或者限制某些程序的运行了。</p>\n<p>感谢 <a href=\"https://www.flickr.com/photos/stignygaard/\" target=\"_blank\" rel=\"noopener\">Stig Nygaard</a> 在 <a href=\"https://www.flickr.com/photos/stignygaard/3138001676/\" target=\"_blank\" rel=\"noopener\">Flickr</a> 上提供的图片（CC BY 2.0）。</p>\n<hr>\n<p>via: <a href=\"https://fedoramagazine.org/understand-fedora-memory-usage-top/\" target=\"_blank\" rel=\"noopener\">https://fedoramagazine.org/understand-fedora-memory-usage-top/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/memory-top-816x345.jpg\" alt=\"\"></p>\n<p>如果你使用过 <code>top</code> 命令来查看 Fedora 系统中的内存使用情况，你可能会惊讶，看起来消耗的数量比系统可用的内存更多。下面会详细介绍内存使用情况以及如何理解这些数据。</p>\n<h3 id=\"内存实际使用情况\"><a href=\"#内存实际使用情况\" class=\"headerlink\" title=\"内存实际使用情况\"></a>内存实际使用情况</h3><p>操作系统对内存的使用方式并不是太通俗易懂。事实上，其背后有很多不为人知的巧妙技术在发挥着作用。通过这些方式，可以在无需用户干预的情况下，让操作系统更有效地使用内存。</p>\n<p>大多数应用程序都不是系统自带的，但每个应用程序都依赖于安装在系统中的库中的一些函数集。在 Fedora 中，RPM 包管理系统能够确保在安装应用程序时也会安装所依赖的库。</p>\n<p>当应用程序运行时，操作系统并不需要将它要用到的所有信息都加载到物理内存中。而是会为存放代码的存储空间构建一个映射，称为虚拟内存。操作系统只把需要的部分加载到内存中，当某一个部分不再需要后，这一部分内存就会被释放掉。</p>\n<p>这意味着应用程序可以映射大量的虚拟内存，而使用较少的系统物理内存。特殊情况下，映射的虚拟内存甚至可以比系统实际可用的物理内存更多！而且在操作系统中这种情况也并不少见。</p>\n<p>另外，不同的应用程序可能会对同一个库都有依赖。Fedora 中的 Linux 内核通常会在各个应用程序之间共享内存，而不需要为不同应用分别加载同一个库的多个副本。类似地，对于同一个应用程序的不同实例也是采用这种方式共享内存。</p>\n<p>如果不首先了解这些细节，<code>top</code> 命令显示的数据可能会让人摸不着头脑。下面就举例说明如何正确查看内存使用量。</p>\n<h3 id=\"使用-top-命令查看内存使用量\"><a href=\"#使用-top-命令查看内存使用量\" class=\"headerlink\" title=\"使用 top 命令查看内存使用量\"></a>使用 <code>top</code> 命令查看内存使用量</h3><p>如果你还没有使用过 <code>top</code> 命令，可以打开终端直接执行查看。使用 <code>Shift + M</code> 可以按照内存使用量来进行排序。下图是在 Fedora Workstation 中执行的结果，在你的机器上显示的结果可能会略有不同：</p>\n<p><img src=\"https://fedoramagazine.org/wp-content/uploads/2018/09/Screenshot-from-2018-09-17-14-23-17.png\" alt=\"\"></p>\n<p>主要通过以下三列来查看内存使用情况：<code>VIRT</code>、<code>RES</code> 和 <code>SHR</code>。目前以 KB 为单位显示相关数值。</p>\n<p><code>VIRT</code> 列代表该进程映射的<ruby>虚拟<rt>virtual</rt></ruby>内存。如上所述，虚拟内存不是实际消耗的物理内存。例如， GNOME Shell 进程 <code>gnome-shell</code> 实际上没有消耗超过 3.1 GB 的物理内存，但它对很多更低或更高级的库都有依赖，系统必须对每个库都进行映射，以确保在有需要时可以加载这些库。</p>\n<p><code>RES</code> 列代表应用程序消耗了多少实际（<ruby>驻留<rt>resident</rt></ruby>）内存。对于 GNOME Shell 大约是 180788 KB。例子中的系统拥有大约 7704 MB 的物理内存，因此内存使用率显示为 2.3％。</p>\n<p>但根据 <code>SHR</code> 列显示，其中至少有 88212 KB 是<ruby>共享<rt>shared</rt></ruby>内存，这部分内存可能是其它应用程序也在使用的库函数。这意味着 GNOME Shell 本身大约有 92 MB 内存不与其他进程共享。需要注意的是，上述例子中的其它程序也共享了很多内存。在某些应用程序中，共享内存在内存使用量中会占很大的比例。</p>\n<p>值得一提的是，有时进程之间通过内存通信，这些内存也是共享的，但 <code>top</code> 这样的工具却不一定能检测到，所以以上的说明也不一定准确。</p>\n<h3 id=\"关于交换分区\"><a href=\"#关于交换分区\" class=\"headerlink\" title=\"关于交换分区\"></a>关于交换分区</h3><p>系统还可以通过交换分区来存储数据（例如硬盘），但读写的速度相对较慢。当物理内存渐渐用满，操作系统就会查找内存中暂时不会使用的部分，将其写出到交换区域等待需要的时候使用。</p>\n<p>因此，如果交换内存的使用量一直偏高，表明系统的物理内存已经供不应求了。有时候一个不正常的应用也有可能导致出现这种情况，但如果这种现象经常出现，就需要考虑提升物理内存或者限制某些程序的运行了。</p>\n<p>感谢 <a href=\"https://www.flickr.com/photos/stignygaard/\" target=\"_blank\" rel=\"noopener\">Stig Nygaard</a> 在 <a href=\"https://www.flickr.com/photos/stignygaard/3138001676/\" target=\"_blank\" rel=\"noopener\">Flickr</a> 上提供的图片（CC BY 2.0）。</p>\n<hr>\n<p>via: <a href=\"https://fedoramagazine.org/understand-fedora-memory-usage-top/\" target=\"_blank\" rel=\"noopener\">https://fedoramagazine.org/understand-fedora-memory-usage-top/</a></p>\n"},{"title":"GPL 合作承诺的发展历程","date":"2018-11-28T02:18:21.000Z","_content":"\n> <ruby>GPL 合作承诺<rt>GPL Cooperation Commitment</rt></ruby>消除了开发者对许可证失效的顾虑，从而达到促进技术创新的目的。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Law_balance_open_source.png?itok=5c4JhuEY)\n\n假如能免于顾虑，技术创新和发展将会让世界发生天翻地覆的改变。<ruby>[GPL 合作承诺][1]<rt>GPL Cooperation Commitment</rt></ruby>就这样应运而生，只为通过公平、一致、可预测的许可证来让科技创新无后顾之忧。\n\n去年，我曾经写过一篇文章，讨论了许可证对开源软件下游用户的影响。在进行研究的时候，我就发现许可证的约束力并不强，而且很多情况下是不可预测的。因此，我在文章中提出了一个能使开源许可证具有一致性和可预测性的潜在解决方案。但我只考虑到了诸如通过法律系统立法的“传统”方法。\n\n2017 年 11 月，RedHat、IBM、Google 和 Facebook 提出了这种我从未考虑过的非传统的解决方案：GPL 合作承诺。GPL 合作承诺规定了 GPL 公平一致执行的方式。我认为，GPL 合作承诺之所以有这么深刻的意义，有以下两个原因：一是许可证的公平性和一致性对于开源社区的发展来说至关重要，二是法律对不可预测性并不容忍。\n\n### 了解 GPL\n\n要了解 GPL 合作承诺，首先要了解什么是 GPL。GPL 是 <ruby>[GNU 通用许可证][2]<rt>GNU General Public License</rt></ruby>的缩写，它是一个公共版权的开源许可证，这就意味着开源软件的分发者必须向下游用户公开源代码。GPL 还禁止对下游的使用作出限制，要求个人用户不得拒绝他人对开源软件的使用自由、研究自由、共享自由和改进自由。GPL 规定，只要下游用户满足了许可证的要求和条件，就可以使用该许可证。如果被许可人出现了不符合许可证的情况，则视为违规。\n\n按照第二版 GPL（GPLv2）的描述，许可证会在任何违规的情况下自动终止，这就导致了部分开发者对 GPL 有所抗拒。而在第三版 GPL（GPLv3）中则引入了“<ruby>[治愈条款][3]<rt>cure provision</rt></ruby>”，这一条款规定，被许可人可以在 30 天内对违反 GPL 的行为进行改正，如果在这个缓冲期内改正完成，许可证就不会被终止。\n\n这一规定消除了许可证被无故终止的顾虑，从而让软件的开发者和用户专注于开发和创新。\n\n### GPL 合作承诺做了什么\n\nGPL 合作承诺将 GPLv3 的治愈条款应用于使用 GPLv2 的软件上，让使用 GPLv2 许可证的开发者避免许可证无故终止的窘境，并与 GPLv3 许可证保持一致。\n\n很多软件开发者都希望正确合规地做好一件事情，但有时候却不了解具体的实施细节。因此，GPL 合作承诺的重要性就在于能够对软件开发者们做出一些引导，让他们避免因一些简单的错误导致许可证违规终止。\n\nLinux 基金会技术顾问委员会在 2017 年宣布，Linux 内核项目将会[采用 GPLv3 的治愈条款][4]。在 GPL 合作承诺的推动下，很多大型科技公司和个人开发者都做出了相同的承诺，会将该条款扩展应用于他们采用 GPLv2（或 LGPLv2.1）许可证的所有软件，而不仅仅是对 Linux 内核的贡献。\n\nGPL 合作承诺的广泛采用将会对开源社区产生非常积极的影响。如果更多的公司和个人开始采用 GPL 合作承诺，就能让大量正在使用 GPLv2 或 LGPLv2.1 许可证的软件以更公平和更可预测的形式履行许可证中的条款。\n\n截至 2018 年 11 月，包括 IBM、Google、亚马逊、微软、腾讯、英特尔、RedHat 在内的 40 余家行业巨头公司都已经[签署了 GPL 合作承诺][5]，以期为开源社区创立公平的标准以及提供可预测的执行力。GPL 合作承诺是开源社区齐心协力引领开源未来发展方向的一个成功例子。\n\nGPL 合作承诺能够让下游用户了解到开发者对他们的尊重，同时也表示了开发者使用了 GPLv2 许可证的代码是安全的。如果你想查阅更多信息，包括如何将自己的名字添加到 GPL 合作承诺中，可以访问 [GPL 合作承诺的网站][6]。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/gpl-cooperation-commitment\n\n[a]: https://opensource.com/users/bdriver\n[b]: https://github.com/lujun9972\n[1]: https://gplcc.github.io/gplcc/\n[2]: https://www.gnu.org/licenses/licenses.en.html\n[3]: https://opensource.com/article/18/6/gplv3-anniversary\n[4]: https://www.kernel.org/doc/html/v4.16/process/kernel-enforcement-statement.html\n[5]: https://gplcc.github.io/gplcc/Company/Company-List.html\n[6]: http://gplcc.github.io/gplcc\n\n","source":"_posts/What-you-need-to-know-about-the-GPL-Cooperation-Commitment.md","raw":"---\ntitle: GPL 合作承诺的发展历程\ndate: 2018-11-28 10:18:21\ntags:\n  - GPL\n  - LCTT 翻译\n---\n\n> <ruby>GPL 合作承诺<rt>GPL Cooperation Commitment</rt></ruby>消除了开发者对许可证失效的顾虑，从而达到促进技术创新的目的。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Law_balance_open_source.png?itok=5c4JhuEY)\n\n假如能免于顾虑，技术创新和发展将会让世界发生天翻地覆的改变。<ruby>[GPL 合作承诺][1]<rt>GPL Cooperation Commitment</rt></ruby>就这样应运而生，只为通过公平、一致、可预测的许可证来让科技创新无后顾之忧。\n\n去年，我曾经写过一篇文章，讨论了许可证对开源软件下游用户的影响。在进行研究的时候，我就发现许可证的约束力并不强，而且很多情况下是不可预测的。因此，我在文章中提出了一个能使开源许可证具有一致性和可预测性的潜在解决方案。但我只考虑到了诸如通过法律系统立法的“传统”方法。\n\n2017 年 11 月，RedHat、IBM、Google 和 Facebook 提出了这种我从未考虑过的非传统的解决方案：GPL 合作承诺。GPL 合作承诺规定了 GPL 公平一致执行的方式。我认为，GPL 合作承诺之所以有这么深刻的意义，有以下两个原因：一是许可证的公平性和一致性对于开源社区的发展来说至关重要，二是法律对不可预测性并不容忍。\n\n### 了解 GPL\n\n要了解 GPL 合作承诺，首先要了解什么是 GPL。GPL 是 <ruby>[GNU 通用许可证][2]<rt>GNU General Public License</rt></ruby>的缩写，它是一个公共版权的开源许可证，这就意味着开源软件的分发者必须向下游用户公开源代码。GPL 还禁止对下游的使用作出限制，要求个人用户不得拒绝他人对开源软件的使用自由、研究自由、共享自由和改进自由。GPL 规定，只要下游用户满足了许可证的要求和条件，就可以使用该许可证。如果被许可人出现了不符合许可证的情况，则视为违规。\n\n按照第二版 GPL（GPLv2）的描述，许可证会在任何违规的情况下自动终止，这就导致了部分开发者对 GPL 有所抗拒。而在第三版 GPL（GPLv3）中则引入了“<ruby>[治愈条款][3]<rt>cure provision</rt></ruby>”，这一条款规定，被许可人可以在 30 天内对违反 GPL 的行为进行改正，如果在这个缓冲期内改正完成，许可证就不会被终止。\n\n这一规定消除了许可证被无故终止的顾虑，从而让软件的开发者和用户专注于开发和创新。\n\n### GPL 合作承诺做了什么\n\nGPL 合作承诺将 GPLv3 的治愈条款应用于使用 GPLv2 的软件上，让使用 GPLv2 许可证的开发者避免许可证无故终止的窘境，并与 GPLv3 许可证保持一致。\n\n很多软件开发者都希望正确合规地做好一件事情，但有时候却不了解具体的实施细节。因此，GPL 合作承诺的重要性就在于能够对软件开发者们做出一些引导，让他们避免因一些简单的错误导致许可证违规终止。\n\nLinux 基金会技术顾问委员会在 2017 年宣布，Linux 内核项目将会[采用 GPLv3 的治愈条款][4]。在 GPL 合作承诺的推动下，很多大型科技公司和个人开发者都做出了相同的承诺，会将该条款扩展应用于他们采用 GPLv2（或 LGPLv2.1）许可证的所有软件，而不仅仅是对 Linux 内核的贡献。\n\nGPL 合作承诺的广泛采用将会对开源社区产生非常积极的影响。如果更多的公司和个人开始采用 GPL 合作承诺，就能让大量正在使用 GPLv2 或 LGPLv2.1 许可证的软件以更公平和更可预测的形式履行许可证中的条款。\n\n截至 2018 年 11 月，包括 IBM、Google、亚马逊、微软、腾讯、英特尔、RedHat 在内的 40 余家行业巨头公司都已经[签署了 GPL 合作承诺][5]，以期为开源社区创立公平的标准以及提供可预测的执行力。GPL 合作承诺是开源社区齐心协力引领开源未来发展方向的一个成功例子。\n\nGPL 合作承诺能够让下游用户了解到开发者对他们的尊重，同时也表示了开发者使用了 GPLv2 许可证的代码是安全的。如果你想查阅更多信息，包括如何将自己的名字添加到 GPL 合作承诺中，可以访问 [GPL 合作承诺的网站][6]。\n\n--------------------------------------------------------------------------------\n\nvia: https://opensource.com/article/18/11/gpl-cooperation-commitment\n\n[a]: https://opensource.com/users/bdriver\n[b]: https://github.com/lujun9972\n[1]: https://gplcc.github.io/gplcc/\n[2]: https://www.gnu.org/licenses/licenses.en.html\n[3]: https://opensource.com/article/18/6/gplv3-anniversary\n[4]: https://www.kernel.org/doc/html/v4.16/process/kernel-enforcement-statement.html\n[5]: https://gplcc.github.io/gplcc/Company/Company-List.html\n[6]: http://gplcc.github.io/gplcc\n\n","slug":"What-you-need-to-know-about-the-GPL-Cooperation-Commitment","published":1,"updated":"2019-03-28T13:04:24.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dj0024lixuqhh11j0a","content":"<blockquote>\n<p><ruby>GPL 合作承诺<rt>GPL Cooperation Commitment</rt></ruby>消除了开发者对许可证失效的顾虑，从而达到促进技术创新的目的。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Law_balance_open_source.png?itok=5c4JhuEY\" alt=\"\"></p>\n<p>假如能免于顾虑，技术创新和发展将会让世界发生天翻地覆的改变。<ruby><a href=\"https://gplcc.github.io/gplcc/\" target=\"_blank\" rel=\"noopener\">GPL 合作承诺</a><rt>GPL Cooperation Commitment</rt></ruby>就这样应运而生，只为通过公平、一致、可预测的许可证来让科技创新无后顾之忧。</p>\n<p>去年，我曾经写过一篇文章，讨论了许可证对开源软件下游用户的影响。在进行研究的时候，我就发现许可证的约束力并不强，而且很多情况下是不可预测的。因此，我在文章中提出了一个能使开源许可证具有一致性和可预测性的潜在解决方案。但我只考虑到了诸如通过法律系统立法的“传统”方法。</p>\n<p>2017 年 11 月，RedHat、IBM、Google 和 Facebook 提出了这种我从未考虑过的非传统的解决方案：GPL 合作承诺。GPL 合作承诺规定了 GPL 公平一致执行的方式。我认为，GPL 合作承诺之所以有这么深刻的意义，有以下两个原因：一是许可证的公平性和一致性对于开源社区的发展来说至关重要，二是法律对不可预测性并不容忍。</p>\n<h3 id=\"了解-GPL\"><a href=\"#了解-GPL\" class=\"headerlink\" title=\"了解 GPL\"></a>了解 GPL</h3><p>要了解 GPL 合作承诺，首先要了解什么是 GPL。GPL 是 <ruby><a href=\"https://www.gnu.org/licenses/licenses.en.html\" target=\"_blank\" rel=\"noopener\">GNU 通用许可证</a><rt>GNU General Public License</rt></ruby>的缩写，它是一个公共版权的开源许可证，这就意味着开源软件的分发者必须向下游用户公开源代码。GPL 还禁止对下游的使用作出限制，要求个人用户不得拒绝他人对开源软件的使用自由、研究自由、共享自由和改进自由。GPL 规定，只要下游用户满足了许可证的要求和条件，就可以使用该许可证。如果被许可人出现了不符合许可证的情况，则视为违规。</p>\n<p>按照第二版 GPL（GPLv2）的描述，许可证会在任何违规的情况下自动终止，这就导致了部分开发者对 GPL 有所抗拒。而在第三版 GPL（GPLv3）中则引入了“<ruby><a href=\"https://opensource.com/article/18/6/gplv3-anniversary\" target=\"_blank\" rel=\"noopener\">治愈条款</a><rt>cure provision</rt></ruby>”，这一条款规定，被许可人可以在 30 天内对违反 GPL 的行为进行改正，如果在这个缓冲期内改正完成，许可证就不会被终止。</p>\n<p>这一规定消除了许可证被无故终止的顾虑，从而让软件的开发者和用户专注于开发和创新。</p>\n<h3 id=\"GPL-合作承诺做了什么\"><a href=\"#GPL-合作承诺做了什么\" class=\"headerlink\" title=\"GPL 合作承诺做了什么\"></a>GPL 合作承诺做了什么</h3><p>GPL 合作承诺将 GPLv3 的治愈条款应用于使用 GPLv2 的软件上，让使用 GPLv2 许可证的开发者避免许可证无故终止的窘境，并与 GPLv3 许可证保持一致。</p>\n<p>很多软件开发者都希望正确合规地做好一件事情，但有时候却不了解具体的实施细节。因此，GPL 合作承诺的重要性就在于能够对软件开发者们做出一些引导，让他们避免因一些简单的错误导致许可证违规终止。</p>\n<p>Linux 基金会技术顾问委员会在 2017 年宣布，Linux 内核项目将会<a href=\"https://www.kernel.org/doc/html/v4.16/process/kernel-enforcement-statement.html\" target=\"_blank\" rel=\"noopener\">采用 GPLv3 的治愈条款</a>。在 GPL 合作承诺的推动下，很多大型科技公司和个人开发者都做出了相同的承诺，会将该条款扩展应用于他们采用 GPLv2（或 LGPLv2.1）许可证的所有软件，而不仅仅是对 Linux 内核的贡献。</p>\n<p>GPL 合作承诺的广泛采用将会对开源社区产生非常积极的影响。如果更多的公司和个人开始采用 GPL 合作承诺，就能让大量正在使用 GPLv2 或 LGPLv2.1 许可证的软件以更公平和更可预测的形式履行许可证中的条款。</p>\n<p>截至 2018 年 11 月，包括 IBM、Google、亚马逊、微软、腾讯、英特尔、RedHat 在内的 40 余家行业巨头公司都已经<a href=\"https://gplcc.github.io/gplcc/Company/Company-List.html\" target=\"_blank\" rel=\"noopener\">签署了 GPL 合作承诺</a>，以期为开源社区创立公平的标准以及提供可预测的执行力。GPL 合作承诺是开源社区齐心协力引领开源未来发展方向的一个成功例子。</p>\n<p>GPL 合作承诺能够让下游用户了解到开发者对他们的尊重，同时也表示了开发者使用了 GPLv2 许可证的代码是安全的。如果你想查阅更多信息，包括如何将自己的名字添加到 GPL 合作承诺中，可以访问 <a href=\"http://gplcc.github.io/gplcc\" target=\"_blank\" rel=\"noopener\">GPL 合作承诺的网站</a>。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/gpl-cooperation-commitment\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/gpl-cooperation-commitment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><ruby>GPL 合作承诺<rt>GPL Cooperation Commitment</rt></ruby>消除了开发者对许可证失效的顾虑，从而达到促进技术创新的目的。</p>\n</blockquote>\n<p><img src=\"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Law_balance_open_source.png?itok=5c4JhuEY\" alt=\"\"></p>\n<p>假如能免于顾虑，技术创新和发展将会让世界发生天翻地覆的改变。<ruby><a href=\"https://gplcc.github.io/gplcc/\" target=\"_blank\" rel=\"noopener\">GPL 合作承诺</a><rt>GPL Cooperation Commitment</rt></ruby>就这样应运而生，只为通过公平、一致、可预测的许可证来让科技创新无后顾之忧。</p>\n<p>去年，我曾经写过一篇文章，讨论了许可证对开源软件下游用户的影响。在进行研究的时候，我就发现许可证的约束力并不强，而且很多情况下是不可预测的。因此，我在文章中提出了一个能使开源许可证具有一致性和可预测性的潜在解决方案。但我只考虑到了诸如通过法律系统立法的“传统”方法。</p>\n<p>2017 年 11 月，RedHat、IBM、Google 和 Facebook 提出了这种我从未考虑过的非传统的解决方案：GPL 合作承诺。GPL 合作承诺规定了 GPL 公平一致执行的方式。我认为，GPL 合作承诺之所以有这么深刻的意义，有以下两个原因：一是许可证的公平性和一致性对于开源社区的发展来说至关重要，二是法律对不可预测性并不容忍。</p>\n<h3 id=\"了解-GPL\"><a href=\"#了解-GPL\" class=\"headerlink\" title=\"了解 GPL\"></a>了解 GPL</h3><p>要了解 GPL 合作承诺，首先要了解什么是 GPL。GPL 是 <ruby><a href=\"https://www.gnu.org/licenses/licenses.en.html\" target=\"_blank\" rel=\"noopener\">GNU 通用许可证</a><rt>GNU General Public License</rt></ruby>的缩写，它是一个公共版权的开源许可证，这就意味着开源软件的分发者必须向下游用户公开源代码。GPL 还禁止对下游的使用作出限制，要求个人用户不得拒绝他人对开源软件的使用自由、研究自由、共享自由和改进自由。GPL 规定，只要下游用户满足了许可证的要求和条件，就可以使用该许可证。如果被许可人出现了不符合许可证的情况，则视为违规。</p>\n<p>按照第二版 GPL（GPLv2）的描述，许可证会在任何违规的情况下自动终止，这就导致了部分开发者对 GPL 有所抗拒。而在第三版 GPL（GPLv3）中则引入了“<ruby><a href=\"https://opensource.com/article/18/6/gplv3-anniversary\" target=\"_blank\" rel=\"noopener\">治愈条款</a><rt>cure provision</rt></ruby>”，这一条款规定，被许可人可以在 30 天内对违反 GPL 的行为进行改正，如果在这个缓冲期内改正完成，许可证就不会被终止。</p>\n<p>这一规定消除了许可证被无故终止的顾虑，从而让软件的开发者和用户专注于开发和创新。</p>\n<h3 id=\"GPL-合作承诺做了什么\"><a href=\"#GPL-合作承诺做了什么\" class=\"headerlink\" title=\"GPL 合作承诺做了什么\"></a>GPL 合作承诺做了什么</h3><p>GPL 合作承诺将 GPLv3 的治愈条款应用于使用 GPLv2 的软件上，让使用 GPLv2 许可证的开发者避免许可证无故终止的窘境，并与 GPLv3 许可证保持一致。</p>\n<p>很多软件开发者都希望正确合规地做好一件事情，但有时候却不了解具体的实施细节。因此，GPL 合作承诺的重要性就在于能够对软件开发者们做出一些引导，让他们避免因一些简单的错误导致许可证违规终止。</p>\n<p>Linux 基金会技术顾问委员会在 2017 年宣布，Linux 内核项目将会<a href=\"https://www.kernel.org/doc/html/v4.16/process/kernel-enforcement-statement.html\" target=\"_blank\" rel=\"noopener\">采用 GPLv3 的治愈条款</a>。在 GPL 合作承诺的推动下，很多大型科技公司和个人开发者都做出了相同的承诺，会将该条款扩展应用于他们采用 GPLv2（或 LGPLv2.1）许可证的所有软件，而不仅仅是对 Linux 内核的贡献。</p>\n<p>GPL 合作承诺的广泛采用将会对开源社区产生非常积极的影响。如果更多的公司和个人开始采用 GPL 合作承诺，就能让大量正在使用 GPLv2 或 LGPLv2.1 许可证的软件以更公平和更可预测的形式履行许可证中的条款。</p>\n<p>截至 2018 年 11 月，包括 IBM、Google、亚马逊、微软、腾讯、英特尔、RedHat 在内的 40 余家行业巨头公司都已经<a href=\"https://gplcc.github.io/gplcc/Company/Company-List.html\" target=\"_blank\" rel=\"noopener\">签署了 GPL 合作承诺</a>，以期为开源社区创立公平的标准以及提供可预测的执行力。GPL 合作承诺是开源社区齐心协力引领开源未来发展方向的一个成功例子。</p>\n<p>GPL 合作承诺能够让下游用户了解到开发者对他们的尊重，同时也表示了开发者使用了 GPLv2 许可证的代码是安全的。如果你想查阅更多信息，包括如何将自己的名字添加到 GPL 合作承诺中，可以访问 <a href=\"http://gplcc.github.io/gplcc\" target=\"_blank\" rel=\"noopener\">GPL 合作承诺的网站</a>。</p>\n<hr>\n<p>via: <a href=\"https://opensource.com/article/18/11/gpl-cooperation-commitment\" target=\"_blank\" rel=\"noopener\">https://opensource.com/article/18/11/gpl-cooperation-commitment</a></p>\n"},{"title":"为什么 Python 这么慢？","date":"2018-10-27T03:41:48.000Z","_content":"\nPython 现在越来越火，已经迅速扩张到包括 DevOps、数据科学、Web 开发、信息安全等各个领域当中。\n\n然而，相比起 Python 扩张的速度，Python 代码的运行速度就显得有点逊色了。\n\n![](https://cdn-images-1.medium.com/max/1200/0*M2qZQsVnDS-4i5zc.jpg)\n\n> 在代码运行速度方面，Java、C、C++、C# 和 Python 要如何进行比较呢？并没有一个放之四海而皆准的标准，因为具体结果很大程度上取决于运行的程序类型，而<ruby>语言基准测试<rt>Computer Language Benchmarks Games</rt></ruby>可以作为[衡量的一个方面][5]。\n\n根据我这些年来进行语言基准测试的经验来看，Python 比很多语言运行起来都要慢。无论是使用 [JIT][7] 编译器的 C＃、Java，还是使用 [AOT][8] 编译器的 C、C++，又或者是 JavaScript 这些解释型语言，Python 都[比它们运行得慢][6]。\n\n注意：对于文中的 “Python” ，一般指 CPython 这个官方的实现。当然我也会在本文中提到其它语言的 Python 实现。\n\n> 我要回答的是这个问题：对于一个类似的程序，Python 要比其它语言慢 2 到 10 倍不等，这其中的原因是什么？又有没有改善的方法呢？\n\n主流的说法有这些：\n\n*   “是<ruby>全局解释器锁<rt>Global Interpreter Lock</rt></ruby>（GIL）的原因”\n*   “是因为 Python 是解释型语言而不是编译型语言”\n*   “是因为 Python 是一种动态类型的语言”\n\n哪一个才是是影响 Python 运行效率的主要原因呢？\n\n### 是全局解释器锁的原因吗？\n\n现在很多计算机都配备了具有多个核的 CPU ，有时甚至还会有多个处理器。为了更充分利用它们的处理能力，操作系统定义了一个称为线程的低级结构。某一个进程（例如 Chrome 浏览器）可以建立多个线程，在系统内执行不同的操作。在这种情况下，CPU 密集型进程就可以跨核心分担负载了，这样的做法可以大大提高应用程序的运行效率。\n\n例如在我写这篇文章时，我的 Chrome 浏览器打开了 44 个线程。需要提及的是，基于 POSIX 的操作系统（例如 Mac OS、Linux）和 Windows 操作系统的线程结构、API 都是不同的，因此操作系统还负责对各个线程的调度。\n\n如果你还没有写过多线程执行的代码，你就需要了解一下线程锁的概念了。多线程进程比单线程进程更为复杂，是因为需要使用线程锁来确保同一个内存地址中的数据不会被多个线程同时访问或更改。\n\nCPython 解释器在创建变量时，首先会分配内存，然后对该变量的引用进行计数，这称为<ruby>引用计数<rt>reference counting</rt></ruby>。如果变量的引用数变为 0，这个变量就会从内存中释放掉。这就是在 for 循环代码块内创建临时变量不会增加内存消耗的原因。\n\n而当多个线程内共享一个变量时，CPython 锁定引用计数的关键就在于使用了 GIL，它会谨慎地控制线程的执行情况，无论同时存在多少个线程，解释器每次只允许一个线程进行操作。\n\n#### 这会对 Python 程序的性能有什么影响？\n\n如果你的程序只有单线程、单进程，代码的速度和性能不会受到全局解释器锁的影响。\n\n但如果你通过在单进程中使用多线程实现并发，并且是 IO 密集型（例如网络 IO 或磁盘 IO）的线程，GIL 竞争的效果就很明显了。\n\n![](https://cdn-images-1.medium.com/max/1600/0*S_iSksY5oM5H1Qf_.png)\n\n*由 David Beazley 提供的 GIL 竞争情况图[http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html][1]*\n\n对于一个 web 应用（例如 Django），同时还使用了 WSGI，那么对这个 web 应用的每一个请求都运行一个**单独**的 Python 解释器，而且每个请求只有一个锁。同时因为 Python 解释器的启动比较慢，某些 WSGI 实现还具有“守护进程模式”，[可以使 Python 进程一直就绪][9]。\n\n#### 其它的 Python 解释器表现如何？\n\n[PyPy 也是一种带有 GIL 的解释器][10]，但通常比 CPython 要快 3 倍以上。\n\n[Jython 则是一种没有 GIL 的解释器][11]，这是因为 Jython 中的 Python 线程使用 Java 线程来实现，并且由 JVM 内存管理系统来进行管理。\n\n#### JavaScript 在这方面又是怎样做的呢？\n\n所有的 Javascript 引擎使用的都是 [mark-and-sweep 垃圾收集算法][12]，而 GIL 使用的则是 CPython 的内存管理算法。\n\nJavaScript 没有 GIL，而且它是单线程的，也不需要用到 GIL， JavaScript 的事件循环和 Promise/Callback 模式实现了以异步编程的方式代替并发。在 Python 当中也有一个类似的 asyncio 事件循环。\n\n### 是因为 Python 是解释型语言吗？\n\n我经常会听到这个说法，但是这过于粗陋地简化了 Python 所实际做的工作了。其实当终端上执行 `python myscript.py` 之后，CPython 会对代码进行一系列的读取、语法分析、解析、编译、解释和执行的操作。\n\n如果你对这一系列过程感兴趣，也可以阅读一下我之前的文章：[在 6 分钟内修改 Python 语言][13] 。 \n\n`.pyc` 文件的创建是这个过程的重点。在代码编译阶段，Python 3 会将字节码序列写入 `__pycache__/` 下的文件中，而 Python 2 则会将字节码序列写入当前目录的 `.pyc` 文件中。对于你编写的脚本、导入的所有代码以及第三方模块都是如此。\n\n因此，绝大多数情况下（除非你的代码是一次性的……），Python 都会解释字节码并本地执行。与 Java、C#.NET 相比：\n\n> Java 代码会被编译为“中间语言”，由 Java 虚拟机读取字节码，并将其即时编译为机器码。.NET CIL 也是如此，.NET CLR（Common-Language-Runtime）将字节码即时编译为机器码。\n\n既然 Python 像 Java 和 C# 那样都使用虚拟机或某种字节码，为什么 Python 在基准测试中仍然比 Java 和 C# 慢得多呢？首要原因是，.NET 和 Java 都是 JIT 编译的。\n\n<ruby>即时<rt>Just-in-time</rt></ruby>（JIT）编译需要一种中间语言，以便将代码拆分为多个块（或多个帧）。而<ruby>提前<rt>ahead of time</rt></ruby>（AOT）编译器则需要确保 CPU 在任何交互发生之前理解每一行代码。\n\nJIT 本身不会使执行速度加快，因为它执行的仍然是同样的字节码序列。但是 JIT 会允许在运行时进行优化。一个优秀的 JIT 优化器会分析出程序的哪些部分会被多次执行，这就是程序中的“热点”，然后优化器会将这些代码替换为更有效率的版本以实现优化。\n\n这就意味着如果你的程序是多次重复相同的操作时，有可能会被优化器优化得更快。而且，Java 和 C# 是强类型语言，因此优化器对代码的判断可以更为准确。\n\nPyPy 使用了明显快于 CPython 的 JIT。更详细的结果可以在这篇性能基准测试文章中看到：[哪一个 Python 版本最快?][15]。\n\n#### 那为什么 CPython 不使用 JIT 呢？\n\nJIT 也不是完美的，它的一个显著缺点就在于启动时间。 CPython 的启动时间已经相对比较慢，而 PyPy 比 CPython 启动还要慢 2 到 3 倍。Java 虚拟机启动速度也是出了名的慢。.NET CLR 则通过在系统启动时启动来优化体验，而 CLR 的开发者也是在 CLR 上开发该操作系统。\n\n因此如果你有个长时间运行的单一 Python 进程，JIT 就比较有意义了，因为代码里有“热点”可以优化。\n\n不过，CPython 是个通用的实现。设想如果使用 Python 开发命令行程序，但每次调用 CLI 时都必须等待 JIT 缓慢启动，这种体验就相当不好了。\n\nCPython 试图用于各种使用情况。有可能实现[将 JIT 插入到 CPython 中][17]，但这个改进工作的进度基本处于停滞不前的状态。\n\n> 如果你想充分发挥 JIT 的优势，请使用 PyPy。\n\n### 是因为 Python 是一种动态类型的语言吗？\n\n在 C、C++、Java、C#、Go 这些静态类型语言中，必须在声明变量时指定变量的类型。而在动态类型语言中，虽然也有类型的概念，但变量的类型是可改变的。\n\n```\na = 1\na = \"foo\"\n```\n\n在上面这个示例里，Python 将变量 `a` 一开始存储整数类型变量的内存空间释放了，并创建了一个新的存储字符串类型的内存空间，并且和原来的变量同名。\n\n静态类型语言这样的设计并不是为了为难你，而是为了方便 CPU 运行而这样设计的。因为最终都需要将所有操作都对应为简单的二进制操作，因此必须将对象、类型这些高级的数据结构转换为低级数据结构。\n\nPython 也实现了这样的转换，但用户看不到这些转换，也不需要关心这些转换。\n\n不用必须声明类型并不是为了使 Python 运行慢，Python 的设计是让用户可以让各种东西变得动态：可以在运行时更改对象上的方法，也可以在运行时动态添加底层系统调用到值的声明上，几乎可以做到任何事。\n\n但也正是这种设计使得 Python 的优化异常的难。\n\n为了证明我的观点，我使用了一个 Mac OS 上的系统调用跟踪工具  DTrace。CPython 发布版本中没有内置 DTrace，因此必须重新对 CPython 进行编译。以下以 Python 3.6.6 为例：\n\n```\nwget https://github.com/python/cpython/archive/v3.6.6.zip\nunzip v3.6.6.zip\ncd v3.6.6\n./configure --with-dtrace\nmake\n```\n\n这样 `python.exe` 将使用 DTrace 追踪所有代码。[Paul Ross 也作过关于 DTrace 的闪电演讲][19]。你可以下载 Python 的 DTrace 启动文件来查看函数调用、执行时间、CPU 时间、系统调用，以及各种其它的内容。\n\n```\nsudo dtrace -s toolkit/<tracer>.d -c ‘../cpython/python.exe script.py’\n```\n\n`py_callflow` 追踪器[显示](https://cdn-images-1.medium.com/max/1600/1*Lz4UdUi4EwknJ0IcpSJ52g.gif)了程序里调用的所有函数。\n\n那么，Python 的动态类型会让它变慢吗？\n\n* 类型比较和类型转换消耗的资源是比较多的，每次读取、写入或引用变量时都会检查变量的类型\n* Python 的动态程度让它难以被优化，因此很多 Python 的替代品能够如此快都是为了提升速度而在灵活性方面作出了妥协\n* 而 [Cython][2] 结合了 C 的静态类型和 Python 来优化已知类型的代码，它[可以将][3]性能提升 **84 倍**。\n\n### 总结\n\n> 由于 Python 是一种动态、多功能的语言，因此运行起来会相对缓慢。对于不同的实际需求，可以使用各种不同的优化或替代方案。\n\n例如可以使用异步，引入分析工具或使用多种解释器来优化 Python 程序。\n\n对于不要求启动时间且代码可以充分利用 JIT 的程序，可以考虑使用 PyPy。\n\n而对于看重性能并且静态类型变量较多的程序，不妨使用 [Cython][4]。\n\n#### 延伸阅读\n\nJake VDP 的优秀文章（略微过时） [https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/][21]\n\nDave Beazley 关于 GIL 的演讲 [http://www.dabeaz.com/python/GIL.pdf][22]\n\nJIT 编译器的那些事 [https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/][23]\n\n--------------------------------------------------------------------------------\n\nvia: https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b\n\n[a]:https://hackernoon.com/@anthonypjshaw?source=post_header_lockup\n[b]:https://github.com/oska874\n[1]:http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html\n[2]:http://cython.org/\n[3]:http://notes-on-cython.readthedocs.io/en/latest/std_dev.html\n[4]:http://cython.org/\n[5]:http://algs4.cs.princeton.edu/faq/\n[6]:https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html\n[7]:https://en.wikipedia.org/wiki/Just-in-time_compilation\n[8]:https://en.wikipedia.org/wiki/Ahead-of-time_compilation\n[9]:https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master\n[10]:http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why\n[11]:http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock\n[12]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\n[13]:https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\n[14]:https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\n[15]:https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\n[16]:https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\n[17]:https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython\n[18]:https://github.com/python/cpython/archive/v3.6.6.zip\n[19]:https://github.com/paulross/dtrace-py#the-lightning-talk\n[20]:https://github.com/paulross/dtrace-py/tree/master/toolkit\n[21]:https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/\n[22]:http://www.dabeaz.com/python/GIL.pdf\n[23]:https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/\n\n","source":"_posts/Why-is-Python-so-slow.md","raw":"---\ntitle: 为什么 Python 这么慢？\ndate: 2018-10-27 11:41:48\ntags:\n  - Python\n  - LCTT 翻译\n---\n\nPython 现在越来越火，已经迅速扩张到包括 DevOps、数据科学、Web 开发、信息安全等各个领域当中。\n\n然而，相比起 Python 扩张的速度，Python 代码的运行速度就显得有点逊色了。\n\n![](https://cdn-images-1.medium.com/max/1200/0*M2qZQsVnDS-4i5zc.jpg)\n\n> 在代码运行速度方面，Java、C、C++、C# 和 Python 要如何进行比较呢？并没有一个放之四海而皆准的标准，因为具体结果很大程度上取决于运行的程序类型，而<ruby>语言基准测试<rt>Computer Language Benchmarks Games</rt></ruby>可以作为[衡量的一个方面][5]。\n\n根据我这些年来进行语言基准测试的经验来看，Python 比很多语言运行起来都要慢。无论是使用 [JIT][7] 编译器的 C＃、Java，还是使用 [AOT][8] 编译器的 C、C++，又或者是 JavaScript 这些解释型语言，Python 都[比它们运行得慢][6]。\n\n注意：对于文中的 “Python” ，一般指 CPython 这个官方的实现。当然我也会在本文中提到其它语言的 Python 实现。\n\n> 我要回答的是这个问题：对于一个类似的程序，Python 要比其它语言慢 2 到 10 倍不等，这其中的原因是什么？又有没有改善的方法呢？\n\n主流的说法有这些：\n\n*   “是<ruby>全局解释器锁<rt>Global Interpreter Lock</rt></ruby>（GIL）的原因”\n*   “是因为 Python 是解释型语言而不是编译型语言”\n*   “是因为 Python 是一种动态类型的语言”\n\n哪一个才是是影响 Python 运行效率的主要原因呢？\n\n### 是全局解释器锁的原因吗？\n\n现在很多计算机都配备了具有多个核的 CPU ，有时甚至还会有多个处理器。为了更充分利用它们的处理能力，操作系统定义了一个称为线程的低级结构。某一个进程（例如 Chrome 浏览器）可以建立多个线程，在系统内执行不同的操作。在这种情况下，CPU 密集型进程就可以跨核心分担负载了，这样的做法可以大大提高应用程序的运行效率。\n\n例如在我写这篇文章时，我的 Chrome 浏览器打开了 44 个线程。需要提及的是，基于 POSIX 的操作系统（例如 Mac OS、Linux）和 Windows 操作系统的线程结构、API 都是不同的，因此操作系统还负责对各个线程的调度。\n\n如果你还没有写过多线程执行的代码，你就需要了解一下线程锁的概念了。多线程进程比单线程进程更为复杂，是因为需要使用线程锁来确保同一个内存地址中的数据不会被多个线程同时访问或更改。\n\nCPython 解释器在创建变量时，首先会分配内存，然后对该变量的引用进行计数，这称为<ruby>引用计数<rt>reference counting</rt></ruby>。如果变量的引用数变为 0，这个变量就会从内存中释放掉。这就是在 for 循环代码块内创建临时变量不会增加内存消耗的原因。\n\n而当多个线程内共享一个变量时，CPython 锁定引用计数的关键就在于使用了 GIL，它会谨慎地控制线程的执行情况，无论同时存在多少个线程，解释器每次只允许一个线程进行操作。\n\n#### 这会对 Python 程序的性能有什么影响？\n\n如果你的程序只有单线程、单进程，代码的速度和性能不会受到全局解释器锁的影响。\n\n但如果你通过在单进程中使用多线程实现并发，并且是 IO 密集型（例如网络 IO 或磁盘 IO）的线程，GIL 竞争的效果就很明显了。\n\n![](https://cdn-images-1.medium.com/max/1600/0*S_iSksY5oM5H1Qf_.png)\n\n*由 David Beazley 提供的 GIL 竞争情况图[http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html][1]*\n\n对于一个 web 应用（例如 Django），同时还使用了 WSGI，那么对这个 web 应用的每一个请求都运行一个**单独**的 Python 解释器，而且每个请求只有一个锁。同时因为 Python 解释器的启动比较慢，某些 WSGI 实现还具有“守护进程模式”，[可以使 Python 进程一直就绪][9]。\n\n#### 其它的 Python 解释器表现如何？\n\n[PyPy 也是一种带有 GIL 的解释器][10]，但通常比 CPython 要快 3 倍以上。\n\n[Jython 则是一种没有 GIL 的解释器][11]，这是因为 Jython 中的 Python 线程使用 Java 线程来实现，并且由 JVM 内存管理系统来进行管理。\n\n#### JavaScript 在这方面又是怎样做的呢？\n\n所有的 Javascript 引擎使用的都是 [mark-and-sweep 垃圾收集算法][12]，而 GIL 使用的则是 CPython 的内存管理算法。\n\nJavaScript 没有 GIL，而且它是单线程的，也不需要用到 GIL， JavaScript 的事件循环和 Promise/Callback 模式实现了以异步编程的方式代替并发。在 Python 当中也有一个类似的 asyncio 事件循环。\n\n### 是因为 Python 是解释型语言吗？\n\n我经常会听到这个说法，但是这过于粗陋地简化了 Python 所实际做的工作了。其实当终端上执行 `python myscript.py` 之后，CPython 会对代码进行一系列的读取、语法分析、解析、编译、解释和执行的操作。\n\n如果你对这一系列过程感兴趣，也可以阅读一下我之前的文章：[在 6 分钟内修改 Python 语言][13] 。 \n\n`.pyc` 文件的创建是这个过程的重点。在代码编译阶段，Python 3 会将字节码序列写入 `__pycache__/` 下的文件中，而 Python 2 则会将字节码序列写入当前目录的 `.pyc` 文件中。对于你编写的脚本、导入的所有代码以及第三方模块都是如此。\n\n因此，绝大多数情况下（除非你的代码是一次性的……），Python 都会解释字节码并本地执行。与 Java、C#.NET 相比：\n\n> Java 代码会被编译为“中间语言”，由 Java 虚拟机读取字节码，并将其即时编译为机器码。.NET CIL 也是如此，.NET CLR（Common-Language-Runtime）将字节码即时编译为机器码。\n\n既然 Python 像 Java 和 C# 那样都使用虚拟机或某种字节码，为什么 Python 在基准测试中仍然比 Java 和 C# 慢得多呢？首要原因是，.NET 和 Java 都是 JIT 编译的。\n\n<ruby>即时<rt>Just-in-time</rt></ruby>（JIT）编译需要一种中间语言，以便将代码拆分为多个块（或多个帧）。而<ruby>提前<rt>ahead of time</rt></ruby>（AOT）编译器则需要确保 CPU 在任何交互发生之前理解每一行代码。\n\nJIT 本身不会使执行速度加快，因为它执行的仍然是同样的字节码序列。但是 JIT 会允许在运行时进行优化。一个优秀的 JIT 优化器会分析出程序的哪些部分会被多次执行，这就是程序中的“热点”，然后优化器会将这些代码替换为更有效率的版本以实现优化。\n\n这就意味着如果你的程序是多次重复相同的操作时，有可能会被优化器优化得更快。而且，Java 和 C# 是强类型语言，因此优化器对代码的判断可以更为准确。\n\nPyPy 使用了明显快于 CPython 的 JIT。更详细的结果可以在这篇性能基准测试文章中看到：[哪一个 Python 版本最快?][15]。\n\n#### 那为什么 CPython 不使用 JIT 呢？\n\nJIT 也不是完美的，它的一个显著缺点就在于启动时间。 CPython 的启动时间已经相对比较慢，而 PyPy 比 CPython 启动还要慢 2 到 3 倍。Java 虚拟机启动速度也是出了名的慢。.NET CLR 则通过在系统启动时启动来优化体验，而 CLR 的开发者也是在 CLR 上开发该操作系统。\n\n因此如果你有个长时间运行的单一 Python 进程，JIT 就比较有意义了，因为代码里有“热点”可以优化。\n\n不过，CPython 是个通用的实现。设想如果使用 Python 开发命令行程序，但每次调用 CLI 时都必须等待 JIT 缓慢启动，这种体验就相当不好了。\n\nCPython 试图用于各种使用情况。有可能实现[将 JIT 插入到 CPython 中][17]，但这个改进工作的进度基本处于停滞不前的状态。\n\n> 如果你想充分发挥 JIT 的优势，请使用 PyPy。\n\n### 是因为 Python 是一种动态类型的语言吗？\n\n在 C、C++、Java、C#、Go 这些静态类型语言中，必须在声明变量时指定变量的类型。而在动态类型语言中，虽然也有类型的概念，但变量的类型是可改变的。\n\n```\na = 1\na = \"foo\"\n```\n\n在上面这个示例里，Python 将变量 `a` 一开始存储整数类型变量的内存空间释放了，并创建了一个新的存储字符串类型的内存空间，并且和原来的变量同名。\n\n静态类型语言这样的设计并不是为了为难你，而是为了方便 CPU 运行而这样设计的。因为最终都需要将所有操作都对应为简单的二进制操作，因此必须将对象、类型这些高级的数据结构转换为低级数据结构。\n\nPython 也实现了这样的转换，但用户看不到这些转换，也不需要关心这些转换。\n\n不用必须声明类型并不是为了使 Python 运行慢，Python 的设计是让用户可以让各种东西变得动态：可以在运行时更改对象上的方法，也可以在运行时动态添加底层系统调用到值的声明上，几乎可以做到任何事。\n\n但也正是这种设计使得 Python 的优化异常的难。\n\n为了证明我的观点，我使用了一个 Mac OS 上的系统调用跟踪工具  DTrace。CPython 发布版本中没有内置 DTrace，因此必须重新对 CPython 进行编译。以下以 Python 3.6.6 为例：\n\n```\nwget https://github.com/python/cpython/archive/v3.6.6.zip\nunzip v3.6.6.zip\ncd v3.6.6\n./configure --with-dtrace\nmake\n```\n\n这样 `python.exe` 将使用 DTrace 追踪所有代码。[Paul Ross 也作过关于 DTrace 的闪电演讲][19]。你可以下载 Python 的 DTrace 启动文件来查看函数调用、执行时间、CPU 时间、系统调用，以及各种其它的内容。\n\n```\nsudo dtrace -s toolkit/<tracer>.d -c ‘../cpython/python.exe script.py’\n```\n\n`py_callflow` 追踪器[显示](https://cdn-images-1.medium.com/max/1600/1*Lz4UdUi4EwknJ0IcpSJ52g.gif)了程序里调用的所有函数。\n\n那么，Python 的动态类型会让它变慢吗？\n\n* 类型比较和类型转换消耗的资源是比较多的，每次读取、写入或引用变量时都会检查变量的类型\n* Python 的动态程度让它难以被优化，因此很多 Python 的替代品能够如此快都是为了提升速度而在灵活性方面作出了妥协\n* 而 [Cython][2] 结合了 C 的静态类型和 Python 来优化已知类型的代码，它[可以将][3]性能提升 **84 倍**。\n\n### 总结\n\n> 由于 Python 是一种动态、多功能的语言，因此运行起来会相对缓慢。对于不同的实际需求，可以使用各种不同的优化或替代方案。\n\n例如可以使用异步，引入分析工具或使用多种解释器来优化 Python 程序。\n\n对于不要求启动时间且代码可以充分利用 JIT 的程序，可以考虑使用 PyPy。\n\n而对于看重性能并且静态类型变量较多的程序，不妨使用 [Cython][4]。\n\n#### 延伸阅读\n\nJake VDP 的优秀文章（略微过时） [https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/][21]\n\nDave Beazley 关于 GIL 的演讲 [http://www.dabeaz.com/python/GIL.pdf][22]\n\nJIT 编译器的那些事 [https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/][23]\n\n--------------------------------------------------------------------------------\n\nvia: https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b\n\n[a]:https://hackernoon.com/@anthonypjshaw?source=post_header_lockup\n[b]:https://github.com/oska874\n[1]:http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html\n[2]:http://cython.org/\n[3]:http://notes-on-cython.readthedocs.io/en/latest/std_dev.html\n[4]:http://cython.org/\n[5]:http://algs4.cs.princeton.edu/faq/\n[6]:https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html\n[7]:https://en.wikipedia.org/wiki/Just-in-time_compilation\n[8]:https://en.wikipedia.org/wiki/Ahead-of-time_compilation\n[9]:https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master\n[10]:http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why\n[11]:http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock\n[12]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\n[13]:https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\n[14]:https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\n[15]:https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\n[16]:https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\n[17]:https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython\n[18]:https://github.com/python/cpython/archive/v3.6.6.zip\n[19]:https://github.com/paulross/dtrace-py#the-lightning-talk\n[20]:https://github.com/paulross/dtrace-py/tree/master/toolkit\n[21]:https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/\n[22]:http://www.dabeaz.com/python/GIL.pdf\n[23]:https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/\n\n","slug":"Why-is-Python-so-slow","published":1,"updated":"2019-03-28T12:09:02.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dl0027lixu90arvy6h","content":"<p>Python 现在越来越火，已经迅速扩张到包括 DevOps、数据科学、Web 开发、信息安全等各个领域当中。</p>\n<p>然而，相比起 Python 扩张的速度，Python 代码的运行速度就显得有点逊色了。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1200/0*M2qZQsVnDS-4i5zc.jpg\" alt=\"\"></p>\n<blockquote>\n<p>在代码运行速度方面，Java、C、C++、C# 和 Python 要如何进行比较呢？并没有一个放之四海而皆准的标准，因为具体结果很大程度上取决于运行的程序类型，而<ruby>语言基准测试<rt>Computer Language Benchmarks Games</rt></ruby>可以作为<a href=\"http://algs4.cs.princeton.edu/faq/\" target=\"_blank\" rel=\"noopener\">衡量的一个方面</a>。</p>\n</blockquote>\n<p>根据我这些年来进行语言基准测试的经验来看，Python 比很多语言运行起来都要慢。无论是使用 <a href=\"https://en.wikipedia.org/wiki/Just-in-time_compilation\" target=\"_blank\" rel=\"noopener\">JIT</a> 编译器的 C＃、Java，还是使用 <a href=\"https://en.wikipedia.org/wiki/Ahead-of-time_compilation\" target=\"_blank\" rel=\"noopener\">AOT</a> 编译器的 C、C++，又或者是 JavaScript 这些解释型语言，Python 都<a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html\" target=\"_blank\" rel=\"noopener\">比它们运行得慢</a>。</p>\n<p>注意：对于文中的 “Python” ，一般指 CPython 这个官方的实现。当然我也会在本文中提到其它语言的 Python 实现。</p>\n<blockquote>\n<p>我要回答的是这个问题：对于一个类似的程序，Python 要比其它语言慢 2 到 10 倍不等，这其中的原因是什么？又有没有改善的方法呢？</p>\n</blockquote>\n<p>主流的说法有这些：</p>\n<ul>\n<li>“是<ruby>全局解释器锁<rt>Global Interpreter Lock</rt></ruby>（GIL）的原因”</li>\n<li>“是因为 Python 是解释型语言而不是编译型语言”</li>\n<li>“是因为 Python 是一种动态类型的语言”</li>\n</ul>\n<p>哪一个才是是影响 Python 运行效率的主要原因呢？</p>\n<h3 id=\"是全局解释器锁的原因吗？\"><a href=\"#是全局解释器锁的原因吗？\" class=\"headerlink\" title=\"是全局解释器锁的原因吗？\"></a>是全局解释器锁的原因吗？</h3><p>现在很多计算机都配备了具有多个核的 CPU ，有时甚至还会有多个处理器。为了更充分利用它们的处理能力，操作系统定义了一个称为线程的低级结构。某一个进程（例如 Chrome 浏览器）可以建立多个线程，在系统内执行不同的操作。在这种情况下，CPU 密集型进程就可以跨核心分担负载了，这样的做法可以大大提高应用程序的运行效率。</p>\n<p>例如在我写这篇文章时，我的 Chrome 浏览器打开了 44 个线程。需要提及的是，基于 POSIX 的操作系统（例如 Mac OS、Linux）和 Windows 操作系统的线程结构、API 都是不同的，因此操作系统还负责对各个线程的调度。</p>\n<p>如果你还没有写过多线程执行的代码，你就需要了解一下线程锁的概念了。多线程进程比单线程进程更为复杂，是因为需要使用线程锁来确保同一个内存地址中的数据不会被多个线程同时访问或更改。</p>\n<p>CPython 解释器在创建变量时，首先会分配内存，然后对该变量的引用进行计数，这称为<ruby>引用计数<rt>reference counting</rt></ruby>。如果变量的引用数变为 0，这个变量就会从内存中释放掉。这就是在 for 循环代码块内创建临时变量不会增加内存消耗的原因。</p>\n<p>而当多个线程内共享一个变量时，CPython 锁定引用计数的关键就在于使用了 GIL，它会谨慎地控制线程的执行情况，无论同时存在多少个线程，解释器每次只允许一个线程进行操作。</p>\n<h4 id=\"这会对-Python-程序的性能有什么影响？\"><a href=\"#这会对-Python-程序的性能有什么影响？\" class=\"headerlink\" title=\"这会对 Python 程序的性能有什么影响？\"></a>这会对 Python 程序的性能有什么影响？</h4><p>如果你的程序只有单线程、单进程，代码的速度和性能不会受到全局解释器锁的影响。</p>\n<p>但如果你通过在单进程中使用多线程实现并发，并且是 IO 密集型（例如网络 IO 或磁盘 IO）的线程，GIL 竞争的效果就很明显了。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*S_iSksY5oM5H1Qf_.png\" alt=\"\"></p>\n<p><em>由 David Beazley 提供的 GIL 竞争情况图<a href=\"http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html\" target=\"_blank\" rel=\"noopener\">http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html</a></em></p>\n<p>对于一个 web 应用（例如 Django），同时还使用了 WSGI，那么对这个 web 应用的每一个请求都运行一个<strong>单独</strong>的 Python 解释器，而且每个请求只有一个锁。同时因为 Python 解释器的启动比较慢，某些 WSGI 实现还具有“守护进程模式”，<a href=\"https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master\" target=\"_blank\" rel=\"noopener\">可以使 Python 进程一直就绪</a>。</p>\n<h4 id=\"其它的-Python-解释器表现如何？\"><a href=\"#其它的-Python-解释器表现如何？\" class=\"headerlink\" title=\"其它的 Python 解释器表现如何？\"></a>其它的 Python 解释器表现如何？</h4><p><a href=\"http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why\" target=\"_blank\" rel=\"noopener\">PyPy 也是一种带有 GIL 的解释器</a>，但通常比 CPython 要快 3 倍以上。</p>\n<p><a href=\"http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock\" target=\"_blank\" rel=\"noopener\">Jython 则是一种没有 GIL 的解释器</a>，这是因为 Jython 中的 Python 线程使用 Java 线程来实现，并且由 JVM 内存管理系统来进行管理。</p>\n<h4 id=\"JavaScript-在这方面又是怎样做的呢？\"><a href=\"#JavaScript-在这方面又是怎样做的呢？\" class=\"headerlink\" title=\"JavaScript 在这方面又是怎样做的呢？\"></a>JavaScript 在这方面又是怎样做的呢？</h4><p>所有的 Javascript 引擎使用的都是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"noopener\">mark-and-sweep 垃圾收集算法</a>，而 GIL 使用的则是 CPython 的内存管理算法。</p>\n<p>JavaScript 没有 GIL，而且它是单线程的，也不需要用到 GIL， JavaScript 的事件循环和 Promise/Callback 模式实现了以异步编程的方式代替并发。在 Python 当中也有一个类似的 asyncio 事件循环。</p>\n<h3 id=\"是因为-Python-是解释型语言吗？\"><a href=\"#是因为-Python-是解释型语言吗？\" class=\"headerlink\" title=\"是因为 Python 是解释型语言吗？\"></a>是因为 Python 是解释型语言吗？</h3><p>我经常会听到这个说法，但是这过于粗陋地简化了 Python 所实际做的工作了。其实当终端上执行 <code>python myscript.py</code> 之后，CPython 会对代码进行一系列的读取、语法分析、解析、编译、解释和执行的操作。</p>\n<p>如果你对这一系列过程感兴趣，也可以阅读一下我之前的文章：<a href=\"https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\" target=\"_blank\" rel=\"noopener\">在 6 分钟内修改 Python 语言</a> 。 </p>\n<p><code>.pyc</code> 文件的创建是这个过程的重点。在代码编译阶段，Python 3 会将字节码序列写入 <code>__pycache__/</code> 下的文件中，而 Python 2 则会将字节码序列写入当前目录的 <code>.pyc</code> 文件中。对于你编写的脚本、导入的所有代码以及第三方模块都是如此。</p>\n<p>因此，绝大多数情况下（除非你的代码是一次性的……），Python 都会解释字节码并本地执行。与 Java、C#.NET 相比：</p>\n<blockquote>\n<p>Java 代码会被编译为“中间语言”，由 Java 虚拟机读取字节码，并将其即时编译为机器码。.NET CIL 也是如此，.NET CLR（Common-Language-Runtime）将字节码即时编译为机器码。</p>\n</blockquote>\n<p>既然 Python 像 Java 和 C# 那样都使用虚拟机或某种字节码，为什么 Python 在基准测试中仍然比 Java 和 C# 慢得多呢？首要原因是，.NET 和 Java 都是 JIT 编译的。</p>\n<p><ruby>即时<rt>Just-in-time</rt></ruby>（JIT）编译需要一种中间语言，以便将代码拆分为多个块（或多个帧）。而<ruby>提前<rt>ahead of time</rt></ruby>（AOT）编译器则需要确保 CPU 在任何交互发生之前理解每一行代码。</p>\n<p>JIT 本身不会使执行速度加快，因为它执行的仍然是同样的字节码序列。但是 JIT 会允许在运行时进行优化。一个优秀的 JIT 优化器会分析出程序的哪些部分会被多次执行，这就是程序中的“热点”，然后优化器会将这些代码替换为更有效率的版本以实现优化。</p>\n<p>这就意味着如果你的程序是多次重复相同的操作时，有可能会被优化器优化得更快。而且，Java 和 C# 是强类型语言，因此优化器对代码的判断可以更为准确。</p>\n<p>PyPy 使用了明显快于 CPython 的 JIT。更详细的结果可以在这篇性能基准测试文章中看到：<a href=\"https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\" target=\"_blank\" rel=\"noopener\">哪一个 Python 版本最快?</a>。</p>\n<h4 id=\"那为什么-CPython-不使用-JIT-呢？\"><a href=\"#那为什么-CPython-不使用-JIT-呢？\" class=\"headerlink\" title=\"那为什么 CPython 不使用 JIT 呢？\"></a>那为什么 CPython 不使用 JIT 呢？</h4><p>JIT 也不是完美的，它的一个显著缺点就在于启动时间。 CPython 的启动时间已经相对比较慢，而 PyPy 比 CPython 启动还要慢 2 到 3 倍。Java 虚拟机启动速度也是出了名的慢。.NET CLR 则通过在系统启动时启动来优化体验，而 CLR 的开发者也是在 CLR 上开发该操作系统。</p>\n<p>因此如果你有个长时间运行的单一 Python 进程，JIT 就比较有意义了，因为代码里有“热点”可以优化。</p>\n<p>不过，CPython 是个通用的实现。设想如果使用 Python 开发命令行程序，但每次调用 CLI 时都必须等待 JIT 缓慢启动，这种体验就相当不好了。</p>\n<p>CPython 试图用于各种使用情况。有可能实现<a href=\"https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython\" target=\"_blank\" rel=\"noopener\">将 JIT 插入到 CPython 中</a>，但这个改进工作的进度基本处于停滞不前的状态。</p>\n<blockquote>\n<p>如果你想充分发挥 JIT 的优势，请使用 PyPy。</p>\n</blockquote>\n<h3 id=\"是因为-Python-是一种动态类型的语言吗？\"><a href=\"#是因为-Python-是一种动态类型的语言吗？\" class=\"headerlink\" title=\"是因为 Python 是一种动态类型的语言吗？\"></a>是因为 Python 是一种动态类型的语言吗？</h3><p>在 C、C++、Java、C#、Go 这些静态类型语言中，必须在声明变量时指定变量的类型。而在动态类型语言中，虽然也有类型的概念，但变量的类型是可改变的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 1</span><br><span class=\"line\">a = &quot;foo&quot;</span><br></pre></td></tr></table></figure>\n<p>在上面这个示例里，Python 将变量 <code>a</code> 一开始存储整数类型变量的内存空间释放了，并创建了一个新的存储字符串类型的内存空间，并且和原来的变量同名。</p>\n<p>静态类型语言这样的设计并不是为了为难你，而是为了方便 CPU 运行而这样设计的。因为最终都需要将所有操作都对应为简单的二进制操作，因此必须将对象、类型这些高级的数据结构转换为低级数据结构。</p>\n<p>Python 也实现了这样的转换，但用户看不到这些转换，也不需要关心这些转换。</p>\n<p>不用必须声明类型并不是为了使 Python 运行慢，Python 的设计是让用户可以让各种东西变得动态：可以在运行时更改对象上的方法，也可以在运行时动态添加底层系统调用到值的声明上，几乎可以做到任何事。</p>\n<p>但也正是这种设计使得 Python 的优化异常的难。</p>\n<p>为了证明我的观点，我使用了一个 Mac OS 上的系统调用跟踪工具  DTrace。CPython 发布版本中没有内置 DTrace，因此必须重新对 CPython 进行编译。以下以 Python 3.6.6 为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/python/cpython/archive/v3.6.6.zip</span><br><span class=\"line\">unzip v3.6.6.zip</span><br><span class=\"line\">cd v3.6.6</span><br><span class=\"line\">./configure --with-dtrace</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>这样 <code>python.exe</code> 将使用 DTrace 追踪所有代码。<a href=\"https://github.com/paulross/dtrace-py#the-lightning-talk\" target=\"_blank\" rel=\"noopener\">Paul Ross 也作过关于 DTrace 的闪电演讲</a>。你可以下载 Python 的 DTrace 启动文件来查看函数调用、执行时间、CPU 时间、系统调用，以及各种其它的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dtrace -s toolkit/&lt;tracer&gt;.d -c ‘../cpython/python.exe script.py’</span><br></pre></td></tr></table></figure>\n<p><code>py_callflow</code> 追踪器<a href=\"https://cdn-images-1.medium.com/max/1600/1*Lz4UdUi4EwknJ0IcpSJ52g.gif\" target=\"_blank\" rel=\"noopener\">显示</a>了程序里调用的所有函数。</p>\n<p>那么，Python 的动态类型会让它变慢吗？</p>\n<ul>\n<li>类型比较和类型转换消耗的资源是比较多的，每次读取、写入或引用变量时都会检查变量的类型</li>\n<li>Python 的动态程度让它难以被优化，因此很多 Python 的替代品能够如此快都是为了提升速度而在灵活性方面作出了妥协</li>\n<li>而 <a href=\"http://cython.org/\" target=\"_blank\" rel=\"noopener\">Cython</a> 结合了 C 的静态类型和 Python 来优化已知类型的代码，它<a href=\"http://notes-on-cython.readthedocs.io/en/latest/std_dev.html\" target=\"_blank\" rel=\"noopener\">可以将</a>性能提升 <strong>84 倍</strong>。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>由于 Python 是一种动态、多功能的语言，因此运行起来会相对缓慢。对于不同的实际需求，可以使用各种不同的优化或替代方案。</p>\n</blockquote>\n<p>例如可以使用异步，引入分析工具或使用多种解释器来优化 Python 程序。</p>\n<p>对于不要求启动时间且代码可以充分利用 JIT 的程序，可以考虑使用 PyPy。</p>\n<p>而对于看重性能并且静态类型变量较多的程序，不妨使用 <a href=\"http://cython.org/\" target=\"_blank\" rel=\"noopener\">Cython</a>。</p>\n<h4 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><p>Jake VDP 的优秀文章（略微过时） <a href=\"https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/\" target=\"_blank\" rel=\"noopener\">https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/</a></p>\n<p>Dave Beazley 关于 GIL 的演讲 <a href=\"http://www.dabeaz.com/python/GIL.pdf\" target=\"_blank\" rel=\"noopener\">http://www.dabeaz.com/python/GIL.pdf</a></p>\n<p>JIT 编译器的那些事 <a href=\"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/\" target=\"_blank\" rel=\"noopener\">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a></p>\n<hr>\n<p>via: <a href=\"https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b\" target=\"_blank\" rel=\"noopener\">https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Python 现在越来越火，已经迅速扩张到包括 DevOps、数据科学、Web 开发、信息安全等各个领域当中。</p>\n<p>然而，相比起 Python 扩张的速度，Python 代码的运行速度就显得有点逊色了。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1200/0*M2qZQsVnDS-4i5zc.jpg\" alt=\"\"></p>\n<blockquote>\n<p>在代码运行速度方面，Java、C、C++、C# 和 Python 要如何进行比较呢？并没有一个放之四海而皆准的标准，因为具体结果很大程度上取决于运行的程序类型，而<ruby>语言基准测试<rt>Computer Language Benchmarks Games</rt></ruby>可以作为<a href=\"http://algs4.cs.princeton.edu/faq/\" target=\"_blank\" rel=\"noopener\">衡量的一个方面</a>。</p>\n</blockquote>\n<p>根据我这些年来进行语言基准测试的经验来看，Python 比很多语言运行起来都要慢。无论是使用 <a href=\"https://en.wikipedia.org/wiki/Just-in-time_compilation\" target=\"_blank\" rel=\"noopener\">JIT</a> 编译器的 C＃、Java，还是使用 <a href=\"https://en.wikipedia.org/wiki/Ahead-of-time_compilation\" target=\"_blank\" rel=\"noopener\">AOT</a> 编译器的 C、C++，又或者是 JavaScript 这些解释型语言，Python 都<a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html\" target=\"_blank\" rel=\"noopener\">比它们运行得慢</a>。</p>\n<p>注意：对于文中的 “Python” ，一般指 CPython 这个官方的实现。当然我也会在本文中提到其它语言的 Python 实现。</p>\n<blockquote>\n<p>我要回答的是这个问题：对于一个类似的程序，Python 要比其它语言慢 2 到 10 倍不等，这其中的原因是什么？又有没有改善的方法呢？</p>\n</blockquote>\n<p>主流的说法有这些：</p>\n<ul>\n<li>“是<ruby>全局解释器锁<rt>Global Interpreter Lock</rt></ruby>（GIL）的原因”</li>\n<li>“是因为 Python 是解释型语言而不是编译型语言”</li>\n<li>“是因为 Python 是一种动态类型的语言”</li>\n</ul>\n<p>哪一个才是是影响 Python 运行效率的主要原因呢？</p>\n<h3 id=\"是全局解释器锁的原因吗？\"><a href=\"#是全局解释器锁的原因吗？\" class=\"headerlink\" title=\"是全局解释器锁的原因吗？\"></a>是全局解释器锁的原因吗？</h3><p>现在很多计算机都配备了具有多个核的 CPU ，有时甚至还会有多个处理器。为了更充分利用它们的处理能力，操作系统定义了一个称为线程的低级结构。某一个进程（例如 Chrome 浏览器）可以建立多个线程，在系统内执行不同的操作。在这种情况下，CPU 密集型进程就可以跨核心分担负载了，这样的做法可以大大提高应用程序的运行效率。</p>\n<p>例如在我写这篇文章时，我的 Chrome 浏览器打开了 44 个线程。需要提及的是，基于 POSIX 的操作系统（例如 Mac OS、Linux）和 Windows 操作系统的线程结构、API 都是不同的，因此操作系统还负责对各个线程的调度。</p>\n<p>如果你还没有写过多线程执行的代码，你就需要了解一下线程锁的概念了。多线程进程比单线程进程更为复杂，是因为需要使用线程锁来确保同一个内存地址中的数据不会被多个线程同时访问或更改。</p>\n<p>CPython 解释器在创建变量时，首先会分配内存，然后对该变量的引用进行计数，这称为<ruby>引用计数<rt>reference counting</rt></ruby>。如果变量的引用数变为 0，这个变量就会从内存中释放掉。这就是在 for 循环代码块内创建临时变量不会增加内存消耗的原因。</p>\n<p>而当多个线程内共享一个变量时，CPython 锁定引用计数的关键就在于使用了 GIL，它会谨慎地控制线程的执行情况，无论同时存在多少个线程，解释器每次只允许一个线程进行操作。</p>\n<h4 id=\"这会对-Python-程序的性能有什么影响？\"><a href=\"#这会对-Python-程序的性能有什么影响？\" class=\"headerlink\" title=\"这会对 Python 程序的性能有什么影响？\"></a>这会对 Python 程序的性能有什么影响？</h4><p>如果你的程序只有单线程、单进程，代码的速度和性能不会受到全局解释器锁的影响。</p>\n<p>但如果你通过在单进程中使用多线程实现并发，并且是 IO 密集型（例如网络 IO 或磁盘 IO）的线程，GIL 竞争的效果就很明显了。</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/0*S_iSksY5oM5H1Qf_.png\" alt=\"\"></p>\n<p><em>由 David Beazley 提供的 GIL 竞争情况图<a href=\"http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html\" target=\"_blank\" rel=\"noopener\">http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html</a></em></p>\n<p>对于一个 web 应用（例如 Django），同时还使用了 WSGI，那么对这个 web 应用的每一个请求都运行一个<strong>单独</strong>的 Python 解释器，而且每个请求只有一个锁。同时因为 Python 解释器的启动比较慢，某些 WSGI 实现还具有“守护进程模式”，<a href=\"https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master\" target=\"_blank\" rel=\"noopener\">可以使 Python 进程一直就绪</a>。</p>\n<h4 id=\"其它的-Python-解释器表现如何？\"><a href=\"#其它的-Python-解释器表现如何？\" class=\"headerlink\" title=\"其它的 Python 解释器表现如何？\"></a>其它的 Python 解释器表现如何？</h4><p><a href=\"http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why\" target=\"_blank\" rel=\"noopener\">PyPy 也是一种带有 GIL 的解释器</a>，但通常比 CPython 要快 3 倍以上。</p>\n<p><a href=\"http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock\" target=\"_blank\" rel=\"noopener\">Jython 则是一种没有 GIL 的解释器</a>，这是因为 Jython 中的 Python 线程使用 Java 线程来实现，并且由 JVM 内存管理系统来进行管理。</p>\n<h4 id=\"JavaScript-在这方面又是怎样做的呢？\"><a href=\"#JavaScript-在这方面又是怎样做的呢？\" class=\"headerlink\" title=\"JavaScript 在这方面又是怎样做的呢？\"></a>JavaScript 在这方面又是怎样做的呢？</h4><p>所有的 Javascript 引擎使用的都是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"noopener\">mark-and-sweep 垃圾收集算法</a>，而 GIL 使用的则是 CPython 的内存管理算法。</p>\n<p>JavaScript 没有 GIL，而且它是单线程的，也不需要用到 GIL， JavaScript 的事件循环和 Promise/Callback 模式实现了以异步编程的方式代替并发。在 Python 当中也有一个类似的 asyncio 事件循环。</p>\n<h3 id=\"是因为-Python-是解释型语言吗？\"><a href=\"#是因为-Python-是解释型语言吗？\" class=\"headerlink\" title=\"是因为 Python 是解释型语言吗？\"></a>是因为 Python 是解释型语言吗？</h3><p>我经常会听到这个说法，但是这过于粗陋地简化了 Python 所实际做的工作了。其实当终端上执行 <code>python myscript.py</code> 之后，CPython 会对代码进行一系列的读取、语法分析、解析、编译、解释和执行的操作。</p>\n<p>如果你对这一系列过程感兴趣，也可以阅读一下我之前的文章：<a href=\"https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14\" target=\"_blank\" rel=\"noopener\">在 6 分钟内修改 Python 语言</a> 。 </p>\n<p><code>.pyc</code> 文件的创建是这个过程的重点。在代码编译阶段，Python 3 会将字节码序列写入 <code>__pycache__/</code> 下的文件中，而 Python 2 则会将字节码序列写入当前目录的 <code>.pyc</code> 文件中。对于你编写的脚本、导入的所有代码以及第三方模块都是如此。</p>\n<p>因此，绝大多数情况下（除非你的代码是一次性的……），Python 都会解释字节码并本地执行。与 Java、C#.NET 相比：</p>\n<blockquote>\n<p>Java 代码会被编译为“中间语言”，由 Java 虚拟机读取字节码，并将其即时编译为机器码。.NET CIL 也是如此，.NET CLR（Common-Language-Runtime）将字节码即时编译为机器码。</p>\n</blockquote>\n<p>既然 Python 像 Java 和 C# 那样都使用虚拟机或某种字节码，为什么 Python 在基准测试中仍然比 Java 和 C# 慢得多呢？首要原因是，.NET 和 Java 都是 JIT 编译的。</p>\n<p><ruby>即时<rt>Just-in-time</rt></ruby>（JIT）编译需要一种中间语言，以便将代码拆分为多个块（或多个帧）。而<ruby>提前<rt>ahead of time</rt></ruby>（AOT）编译器则需要确保 CPU 在任何交互发生之前理解每一行代码。</p>\n<p>JIT 本身不会使执行速度加快，因为它执行的仍然是同样的字节码序列。但是 JIT 会允许在运行时进行优化。一个优秀的 JIT 优化器会分析出程序的哪些部分会被多次执行，这就是程序中的“热点”，然后优化器会将这些代码替换为更有效率的版本以实现优化。</p>\n<p>这就意味着如果你的程序是多次重复相同的操作时，有可能会被优化器优化得更快。而且，Java 和 C# 是强类型语言，因此优化器对代码的判断可以更为准确。</p>\n<p>PyPy 使用了明显快于 CPython 的 JIT。更详细的结果可以在这篇性能基准测试文章中看到：<a href=\"https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b\" target=\"_blank\" rel=\"noopener\">哪一个 Python 版本最快?</a>。</p>\n<h4 id=\"那为什么-CPython-不使用-JIT-呢？\"><a href=\"#那为什么-CPython-不使用-JIT-呢？\" class=\"headerlink\" title=\"那为什么 CPython 不使用 JIT 呢？\"></a>那为什么 CPython 不使用 JIT 呢？</h4><p>JIT 也不是完美的，它的一个显著缺点就在于启动时间。 CPython 的启动时间已经相对比较慢，而 PyPy 比 CPython 启动还要慢 2 到 3 倍。Java 虚拟机启动速度也是出了名的慢。.NET CLR 则通过在系统启动时启动来优化体验，而 CLR 的开发者也是在 CLR 上开发该操作系统。</p>\n<p>因此如果你有个长时间运行的单一 Python 进程，JIT 就比较有意义了，因为代码里有“热点”可以优化。</p>\n<p>不过，CPython 是个通用的实现。设想如果使用 Python 开发命令行程序，但每次调用 CLI 时都必须等待 JIT 缓慢启动，这种体验就相当不好了。</p>\n<p>CPython 试图用于各种使用情况。有可能实现<a href=\"https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython\" target=\"_blank\" rel=\"noopener\">将 JIT 插入到 CPython 中</a>，但这个改进工作的进度基本处于停滞不前的状态。</p>\n<blockquote>\n<p>如果你想充分发挥 JIT 的优势，请使用 PyPy。</p>\n</blockquote>\n<h3 id=\"是因为-Python-是一种动态类型的语言吗？\"><a href=\"#是因为-Python-是一种动态类型的语言吗？\" class=\"headerlink\" title=\"是因为 Python 是一种动态类型的语言吗？\"></a>是因为 Python 是一种动态类型的语言吗？</h3><p>在 C、C++、Java、C#、Go 这些静态类型语言中，必须在声明变量时指定变量的类型。而在动态类型语言中，虽然也有类型的概念，但变量的类型是可改变的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 1</span><br><span class=\"line\">a = &quot;foo&quot;</span><br></pre></td></tr></table></figure>\n<p>在上面这个示例里，Python 将变量 <code>a</code> 一开始存储整数类型变量的内存空间释放了，并创建了一个新的存储字符串类型的内存空间，并且和原来的变量同名。</p>\n<p>静态类型语言这样的设计并不是为了为难你，而是为了方便 CPU 运行而这样设计的。因为最终都需要将所有操作都对应为简单的二进制操作，因此必须将对象、类型这些高级的数据结构转换为低级数据结构。</p>\n<p>Python 也实现了这样的转换，但用户看不到这些转换，也不需要关心这些转换。</p>\n<p>不用必须声明类型并不是为了使 Python 运行慢，Python 的设计是让用户可以让各种东西变得动态：可以在运行时更改对象上的方法，也可以在运行时动态添加底层系统调用到值的声明上，几乎可以做到任何事。</p>\n<p>但也正是这种设计使得 Python 的优化异常的难。</p>\n<p>为了证明我的观点，我使用了一个 Mac OS 上的系统调用跟踪工具  DTrace。CPython 发布版本中没有内置 DTrace，因此必须重新对 CPython 进行编译。以下以 Python 3.6.6 为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/python/cpython/archive/v3.6.6.zip</span><br><span class=\"line\">unzip v3.6.6.zip</span><br><span class=\"line\">cd v3.6.6</span><br><span class=\"line\">./configure --with-dtrace</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>这样 <code>python.exe</code> 将使用 DTrace 追踪所有代码。<a href=\"https://github.com/paulross/dtrace-py#the-lightning-talk\" target=\"_blank\" rel=\"noopener\">Paul Ross 也作过关于 DTrace 的闪电演讲</a>。你可以下载 Python 的 DTrace 启动文件来查看函数调用、执行时间、CPU 时间、系统调用，以及各种其它的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dtrace -s toolkit/&lt;tracer&gt;.d -c ‘../cpython/python.exe script.py’</span><br></pre></td></tr></table></figure>\n<p><code>py_callflow</code> 追踪器<a href=\"https://cdn-images-1.medium.com/max/1600/1*Lz4UdUi4EwknJ0IcpSJ52g.gif\" target=\"_blank\" rel=\"noopener\">显示</a>了程序里调用的所有函数。</p>\n<p>那么，Python 的动态类型会让它变慢吗？</p>\n<ul>\n<li>类型比较和类型转换消耗的资源是比较多的，每次读取、写入或引用变量时都会检查变量的类型</li>\n<li>Python 的动态程度让它难以被优化，因此很多 Python 的替代品能够如此快都是为了提升速度而在灵活性方面作出了妥协</li>\n<li>而 <a href=\"http://cython.org/\" target=\"_blank\" rel=\"noopener\">Cython</a> 结合了 C 的静态类型和 Python 来优化已知类型的代码，它<a href=\"http://notes-on-cython.readthedocs.io/en/latest/std_dev.html\" target=\"_blank\" rel=\"noopener\">可以将</a>性能提升 <strong>84 倍</strong>。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>由于 Python 是一种动态、多功能的语言，因此运行起来会相对缓慢。对于不同的实际需求，可以使用各种不同的优化或替代方案。</p>\n</blockquote>\n<p>例如可以使用异步，引入分析工具或使用多种解释器来优化 Python 程序。</p>\n<p>对于不要求启动时间且代码可以充分利用 JIT 的程序，可以考虑使用 PyPy。</p>\n<p>而对于看重性能并且静态类型变量较多的程序，不妨使用 <a href=\"http://cython.org/\" target=\"_blank\" rel=\"noopener\">Cython</a>。</p>\n<h4 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h4><p>Jake VDP 的优秀文章（略微过时） <a href=\"https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/\" target=\"_blank\" rel=\"noopener\">https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/</a></p>\n<p>Dave Beazley 关于 GIL 的演讲 <a href=\"http://www.dabeaz.com/python/GIL.pdf\" target=\"_blank\" rel=\"noopener\">http://www.dabeaz.com/python/GIL.pdf</a></p>\n<p>JIT 编译器的那些事 <a href=\"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/\" target=\"_blank\" rel=\"noopener\">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a></p>\n<hr>\n<p>via: <a href=\"https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b\" target=\"_blank\" rel=\"noopener\">https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b</a></p>\n"},{"title":"YAML 语法","date":"2016-07-20T02:07:35.000Z","_content":"\nYMAL：YMAL Ain’t Markup Language\n\n```yaml\n---\n# 一位职工记录\nname: Example Developer\njob: Developer\nskill: Elite\nemployed: True\nfoods:\n    - Apple\n    - Orange\n    - Strawberry\n    - Mango\nlanguages:\n    ruby: Elite\n    python: Elite\n    dotnet: Lame\n```\n\n\n* YAML 总是以 --- （三个横杠）作为文件的开始，这是 YAML 格式的一部分；\n* 普通的键值对直接以 key: value 的格式每行存储，冒号后面必须为一个空格；\n* 对于列表，列表中的每个元素都以 - （一个横杠 + 一个空格）开始，且每个元素的缩进相同；\n* 对于字典，字典中的每一个键值对和普通的键值对一样（其实整个文件存储的形式就是键值对），但同一个字典中每个键值对的缩进也要相同；\n* 在值中含有冒号等引起解析歧义的字符时，需要用双引号将整个值包住；\n* 使用 {{ var }} 来引用变量。\n","source":"_posts/YAML-grammar.md","raw":"---\ntitle: YAML 语法\ndate: 2016-07-20 10:07:35\ntags:\n  - YAML\n---\n\nYMAL：YMAL Ain’t Markup Language\n\n```yaml\n---\n# 一位职工记录\nname: Example Developer\njob: Developer\nskill: Elite\nemployed: True\nfoods:\n    - Apple\n    - Orange\n    - Strawberry\n    - Mango\nlanguages:\n    ruby: Elite\n    python: Elite\n    dotnet: Lame\n```\n\n\n* YAML 总是以 --- （三个横杠）作为文件的开始，这是 YAML 格式的一部分；\n* 普通的键值对直接以 key: value 的格式每行存储，冒号后面必须为一个空格；\n* 对于列表，列表中的每个元素都以 - （一个横杠 + 一个空格）开始，且每个元素的缩进相同；\n* 对于字典，字典中的每一个键值对和普通的键值对一样（其实整个文件存储的形式就是键值对），但同一个字典中每个键值对的缩进也要相同；\n* 在值中含有冒号等引起解析歧义的字符时，需要用双引号将整个值包住；\n* 使用 {{ var }} 来引用变量。\n","slug":"YAML-grammar","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dm0029lixu9wy6swlm","content":"<p>YMAL：YMAL Ain’t Markup Language</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\"># 一位职工记录</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Example</span> <span class=\"string\">Developer</span></span><br><span class=\"line\"><span class=\"attr\">job:</span> <span class=\"string\">Developer</span></span><br><span class=\"line\"><span class=\"attr\">skill:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">employed:</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"attr\">foods:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Apple</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Orange</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Strawberry</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Mango</span></span><br><span class=\"line\"><span class=\"attr\">languages:</span></span><br><span class=\"line\"><span class=\"attr\">    ruby:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">    python:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">    dotnet:</span> <span class=\"string\">Lame</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>YAML 总是以 — （三个横杠）作为文件的开始，这是 YAML 格式的一部分；</li>\n<li>普通的键值对直接以 key: value 的格式每行存储，冒号后面必须为一个空格；</li>\n<li>对于列表，列表中的每个元素都以 - （一个横杠 + 一个空格）开始，且每个元素的缩进相同；</li>\n<li>对于字典，字典中的每一个键值对和普通的键值对一样（其实整个文件存储的形式就是键值对），但同一个字典中每个键值对的缩进也要相同；</li>\n<li>在值中含有冒号等引起解析歧义的字符时，需要用双引号将整个值包住；</li>\n<li>使用  来引用变量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>YMAL：YMAL Ain’t Markup Language</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\"># 一位职工记录</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Example</span> <span class=\"string\">Developer</span></span><br><span class=\"line\"><span class=\"attr\">job:</span> <span class=\"string\">Developer</span></span><br><span class=\"line\"><span class=\"attr\">skill:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">employed:</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"attr\">foods:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Apple</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Orange</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Strawberry</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">Mango</span></span><br><span class=\"line\"><span class=\"attr\">languages:</span></span><br><span class=\"line\"><span class=\"attr\">    ruby:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">    python:</span> <span class=\"string\">Elite</span></span><br><span class=\"line\"><span class=\"attr\">    dotnet:</span> <span class=\"string\">Lame</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>YAML 总是以 — （三个横杠）作为文件的开始，这是 YAML 格式的一部分；</li>\n<li>普通的键值对直接以 key: value 的格式每行存储，冒号后面必须为一个空格；</li>\n<li>对于列表，列表中的每个元素都以 - （一个横杠 + 一个空格）开始，且每个元素的缩进相同；</li>\n<li>对于字典，字典中的每一个键值对和普通的键值对一样（其实整个文件存储的形式就是键值对），但同一个字典中每个键值对的缩进也要相同；</li>\n<li>在值中含有冒号等引起解析歧义的字符时，需要用双引号将整个值包住；</li>\n<li>使用  来引用变量。</li>\n</ul>\n"},{"title":"Docker 运行官方 MySQL 镜像无法远程连接的坑","date":"2018-11-21T06:28:52.000Z","_content":"\n使用 Docker 官方提供的 MySQL 镜像进行安装、建立容器（必须指定端口映射和 root 口令）。\n\n```shell\ndocker pull mysql:latest\ndocker run -p 9527:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql\n```\n\n但此时如果直接远程连接该容器中的 MySQL 并输入口令后，则会出现报错信息：\n\n```\nERROR 2059 (HY000): Authentication plugin 'caching_sha2_password' cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory\n```\n\n根据报错信息，连接失败原因为口令使用了 `caching_sha2_password` 方式进行加密，通过 `SELECT user, host, plugin, authentication_string FROM user WHERE user='root';` 查询可以看到 root 用户的口令确实是使用 `caching_sha2_password` 方式进行加密，而客户端找不到 `caching_sha2_password` 插件，因此连接失败。\n\n根据官方文档，可以将加密方式更改为 `mysql_native_password`。通过 `ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';` 将 root 用户的口令加密方式更改为 `mysql_native_password`，在远程即可正常连接 MySQL。\n","source":"_posts/a-pitfall-of-connecting-failure-to-mysql-in-docker.md","raw":"---\ntitle: Docker 运行官方 MySQL 镜像无法远程连接的坑\ndate: 2018-11-21 14:28:52\ntags:\n  - Docker\n  - MySQL\n  - 坑\n---\n\n使用 Docker 官方提供的 MySQL 镜像进行安装、建立容器（必须指定端口映射和 root 口令）。\n\n```shell\ndocker pull mysql:latest\ndocker run -p 9527:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql\n```\n\n但此时如果直接远程连接该容器中的 MySQL 并输入口令后，则会出现报错信息：\n\n```\nERROR 2059 (HY000): Authentication plugin 'caching_sha2_password' cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory\n```\n\n根据报错信息，连接失败原因为口令使用了 `caching_sha2_password` 方式进行加密，通过 `SELECT user, host, plugin, authentication_string FROM user WHERE user='root';` 查询可以看到 root 用户的口令确实是使用 `caching_sha2_password` 方式进行加密，而客户端找不到 `caching_sha2_password` 插件，因此连接失败。\n\n根据官方文档，可以将加密方式更改为 `mysql_native_password`。通过 `ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';` 将 root 用户的口令加密方式更改为 `mysql_native_password`，在远程即可正常连接 MySQL。\n","slug":"a-pitfall-of-connecting-failure-to-mysql-in-docker","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dn002clixu1s6iu6q3","content":"<p>使用 Docker 官方提供的 MySQL 镜像进行安装、建立容器（必须指定端口映射和 root 口令）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql:latest</span><br><span class=\"line\">docker run -p 9527:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure>\n<p>但此时如果直接远程连接该容器中的 MySQL 并输入口令后，则会出现报错信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 2059 (HY000): Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>根据报错信息，连接失败原因为口令使用了 <code>caching_sha2_password</code> 方式进行加密，通过 <code>SELECT user, host, plugin, authentication_string FROM user WHERE user=&#39;root&#39;;</code> 查询可以看到 root 用户的口令确实是使用 <code>caching_sha2_password</code> 方式进行加密，而客户端找不到 <code>caching_sha2_password</code> 插件，因此连接失败。</p>\n<p>根据官方文档，可以将加密方式更改为 <code>mysql_native_password</code>。通过 <code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;</code> 将 root 用户的口令加密方式更改为 <code>mysql_native_password</code>，在远程即可正常连接 MySQL。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 Docker 官方提供的 MySQL 镜像进行安装、建立容器（必须指定端口映射和 root 口令）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql:latest</span><br><span class=\"line\">docker run -p 9527:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure>\n<p>但此时如果直接远程连接该容器中的 MySQL 并输入口令后，则会出现报错信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 2059 (HY000): Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>根据报错信息，连接失败原因为口令使用了 <code>caching_sha2_password</code> 方式进行加密，通过 <code>SELECT user, host, plugin, authentication_string FROM user WHERE user=&#39;root&#39;;</code> 查询可以看到 root 用户的口令确实是使用 <code>caching_sha2_password</code> 方式进行加密，而客户端找不到 <code>caching_sha2_password</code> 插件，因此连接失败。</p>\n<p>根据官方文档，可以将加密方式更改为 <code>mysql_native_password</code>。通过 <code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;</code> 将 root 用户的口令加密方式更改为 <code>mysql_native_password</code>，在远程即可正常连接 MySQL。</p>\n"},{"title":"Python re.findall() 中的关于括号的坑","date":"2018-08-11T06:27:45.000Z","_content":"\n在 Python 中使用正则表达式进行匹配时，使用 `re.search()` 和 `re.findall()` 时对正则表达式的处理有所不同。\n\n例如使用正则表达式 `([0-9A-F]{2}:){5}[0-9A-F]{2}` 匹配一个 MAC 地址，待处理的字符串为 12:34:56:78:90:AB 。\n\n使用 `re.search()` 进行匹配：\n\n```python\nimport re\nmatch = re.search('([0-9A-F]{2}:){5}[0-9A-F]{2}', '12:34:56:78:90:AB').group()\nprint(match)\n```\n\n结果为 '12:34:56:78:90:AB' ，符合预期；\n\n使用 `re.findall()` 进行匹配：\n\n```python\nimport re\nmatch = re.findall('([0-9A-F]{2}:){5}[0-9A-F]{2}', '12:34:56:78:90:AB')\nprint(match)\n```\n\n结果为 ['90:']，不符合预期。\n\n主要原因是 `re.findall()` 在匹配的时候，返回的是括号所匹配到的结果，在这里是只返回 `[0-9A-F]{2}:` 的匹配结果，而且后面带有 `{5}` ，因此返回第五个符合的匹配；对于多个括号，则返回多个括号分别匹配到的结果；如果没有括号，则返回就返回整条语句所匹配到的结果。\n\n解决方案是使用括号将整个正则表达式括起来，这样 `re.findall()` 将会从外到内将每一组括号匹配到的结果列出。\n\n```python\nimport re\nmatch = re.findall('(([0-9A-F]{2}:){5}[0-9A-F]{2})', '12:34:56:78:90:AB')\nprint(match)\n```\n\n结果为 [('12:34:56:78:90:AB', '90:')] ，获取第一个元素即可。\n\n实际上这是正则表达式所特有的 ， 任何一门高级语言使用正则都满足这个特点：有括号时只能匹配到括号中的内容，没有括号（相当于在最外层增加了一个括号）。在正则表达式里面 “()” 代表的是分组的意思，一个括号代表一个分组，匹配是只能匹配到 ”()” 中的内容。\n","source":"_posts/a-pitfall-of-re-findall-with-brackets-in-Python.md","raw":"---\ntitle: Python re.findall() 中的关于括号的坑\ndate: 2018-08-11 14:27:45\ntags:\n  - Python\n  - 坑\n  - 正则表达式\n---\n\n在 Python 中使用正则表达式进行匹配时，使用 `re.search()` 和 `re.findall()` 时对正则表达式的处理有所不同。\n\n例如使用正则表达式 `([0-9A-F]{2}:){5}[0-9A-F]{2}` 匹配一个 MAC 地址，待处理的字符串为 12:34:56:78:90:AB 。\n\n使用 `re.search()` 进行匹配：\n\n```python\nimport re\nmatch = re.search('([0-9A-F]{2}:){5}[0-9A-F]{2}', '12:34:56:78:90:AB').group()\nprint(match)\n```\n\n结果为 '12:34:56:78:90:AB' ，符合预期；\n\n使用 `re.findall()` 进行匹配：\n\n```python\nimport re\nmatch = re.findall('([0-9A-F]{2}:){5}[0-9A-F]{2}', '12:34:56:78:90:AB')\nprint(match)\n```\n\n结果为 ['90:']，不符合预期。\n\n主要原因是 `re.findall()` 在匹配的时候，返回的是括号所匹配到的结果，在这里是只返回 `[0-9A-F]{2}:` 的匹配结果，而且后面带有 `{5}` ，因此返回第五个符合的匹配；对于多个括号，则返回多个括号分别匹配到的结果；如果没有括号，则返回就返回整条语句所匹配到的结果。\n\n解决方案是使用括号将整个正则表达式括起来，这样 `re.findall()` 将会从外到内将每一组括号匹配到的结果列出。\n\n```python\nimport re\nmatch = re.findall('(([0-9A-F]{2}:){5}[0-9A-F]{2})', '12:34:56:78:90:AB')\nprint(match)\n```\n\n结果为 [('12:34:56:78:90:AB', '90:')] ，获取第一个元素即可。\n\n实际上这是正则表达式所特有的 ， 任何一门高级语言使用正则都满足这个特点：有括号时只能匹配到括号中的内容，没有括号（相当于在最外层增加了一个括号）。在正则表达式里面 “()” 代表的是分组的意思，一个括号代表一个分组，匹配是只能匹配到 ”()” 中的内容。\n","slug":"a-pitfall-of-re-findall-with-brackets-in-Python","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0do002elixuueyme5vy","content":"<p>在 Python 中使用正则表达式进行匹配时，使用 <code>re.search()</code> 和 <code>re.findall()</code> 时对正则表达式的处理有所不同。</p>\n<p>例如使用正则表达式 <code>([0-9A-F]{2}:){5}[0-9A-F]{2}</code> 匹配一个 MAC 地址，待处理的字符串为 12:34:56:78:90:AB 。</p>\n<p>使用 <code>re.search()</code> 进行匹配：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.search(<span class=\"string\">'([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>).group()</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 ‘12:34:56:78:90:AB’ ，符合预期；</p>\n<p>使用 <code>re.findall()</code> 进行匹配：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.findall(<span class=\"string\">'([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>)</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 [‘90:’]，不符合预期。</p>\n<p>主要原因是 <code>re.findall()</code> 在匹配的时候，返回的是括号所匹配到的结果，在这里是只返回 <code>[0-9A-F]{2}:</code> 的匹配结果，而且后面带有 <code>{5}</code> ，因此返回第五个符合的匹配；对于多个括号，则返回多个括号分别匹配到的结果；如果没有括号，则返回就返回整条语句所匹配到的结果。</p>\n<p>解决方案是使用括号将整个正则表达式括起来，这样 <code>re.findall()</code> 将会从外到内将每一组括号匹配到的结果列出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.findall(<span class=\"string\">'(([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;)'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>)</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 [(‘12:34:56:78:90:AB’, ‘90:’)] ，获取第一个元素即可。</p>\n<p>实际上这是正则表达式所特有的 ， 任何一门高级语言使用正则都满足这个特点：有括号时只能匹配到括号中的内容，没有括号（相当于在最外层增加了一个括号）。在正则表达式里面 “()” 代表的是分组的意思，一个括号代表一个分组，匹配是只能匹配到 ”()” 中的内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Python 中使用正则表达式进行匹配时，使用 <code>re.search()</code> 和 <code>re.findall()</code> 时对正则表达式的处理有所不同。</p>\n<p>例如使用正则表达式 <code>([0-9A-F]{2}:){5}[0-9A-F]{2}</code> 匹配一个 MAC 地址，待处理的字符串为 12:34:56:78:90:AB 。</p>\n<p>使用 <code>re.search()</code> 进行匹配：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.search(<span class=\"string\">'([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>).group()</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 ‘12:34:56:78:90:AB’ ，符合预期；</p>\n<p>使用 <code>re.findall()</code> 进行匹配：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.findall(<span class=\"string\">'([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>)</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 [‘90:’]，不符合预期。</p>\n<p>主要原因是 <code>re.findall()</code> 在匹配的时候，返回的是括号所匹配到的结果，在这里是只返回 <code>[0-9A-F]{2}:</code> 的匹配结果，而且后面带有 <code>{5}</code> ，因此返回第五个符合的匹配；对于多个括号，则返回多个括号分别匹配到的结果；如果没有括号，则返回就返回整条语句所匹配到的结果。</p>\n<p>解决方案是使用括号将整个正则表达式括起来，这样 <code>re.findall()</code> 将会从外到内将每一组括号匹配到的结果列出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">match = re.findall(<span class=\"string\">'(([0-9A-F]&#123;2&#125;:)&#123;5&#125;[0-9A-F]&#123;2&#125;)'</span>, <span class=\"string\">'12:34:56:78:90:AB'</span>)</span><br><span class=\"line\">print(match)</span><br></pre></td></tr></table></figure>\n<p>结果为 [(‘12:34:56:78:90:AB’, ‘90:’)] ，获取第一个元素即可。</p>\n<p>实际上这是正则表达式所特有的 ， 任何一门高级语言使用正则都满足这个特点：有括号时只能匹配到括号中的内容，没有括号（相当于在最外层增加了一个括号）。在正则表达式里面 “()” 代表的是分组的意思，一个括号代表一个分组，匹配是只能匹配到 ”()” 中的内容。</p>\n"},{"title":"各种文档链接","date":"2016-03-01T05:56:01.000Z","_content":"\n[Ansible](http://www.ansible.com.cn/index.html)\n\n[BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/)\n\n[itchat](http://itchat.readthedocs.io/zh/latest/)\n\n[requests](http://cn.python-requests.org/zh_CN/latest/)\n\n[scrapy](http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html)\n","source":"_posts/docs.md","raw":"---\ntitle: 各种文档链接\ndate: 2016-03-01 13:56:01\ntags:\n  - 文档\n---\n\n[Ansible](http://www.ansible.com.cn/index.html)\n\n[BeautifulSoup](http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/)\n\n[itchat](http://itchat.readthedocs.io/zh/latest/)\n\n[requests](http://cn.python-requests.org/zh_CN/latest/)\n\n[scrapy](http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html)\n","slug":"docs","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dq002hlixuk3g64cbl","content":"<p><a href=\"http://www.ansible.com.cn/index.html\" target=\"_blank\" rel=\"noopener\">Ansible</a></p>\n<p><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a></p>\n<p><a href=\"http://itchat.readthedocs.io/zh/latest/\" target=\"_blank\" rel=\"noopener\">itchat</a></p>\n<p><a href=\"http://cn.python-requests.org/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">requests</a></p>\n<p><a href=\"http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html\" target=\"_blank\" rel=\"noopener\">scrapy</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.ansible.com.cn/index.html\" target=\"_blank\" rel=\"noopener\">Ansible</a></p>\n<p><a href=\"http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a></p>\n<p><a href=\"http://itchat.readthedocs.io/zh/latest/\" target=\"_blank\" rel=\"noopener\">itchat</a></p>\n<p><a href=\"http://cn.python-requests.org/zh_CN/latest/\" target=\"_blank\" rel=\"noopener\">requests</a></p>\n<p><a href=\"http://scrapy-chs.readthedocs.io/zh_CN/0.24/index.html\" target=\"_blank\" rel=\"noopener\">scrapy</a></p>\n"},{"title":"Python 在字典中根据条件筛选数据","date":"2018-07-11T06:26:51.000Z","_content":"\n首先创建一个字典\n\n```python\nimport random\n\nd = {str(x): random.randint(60, 100) for x in range(1, 21)}\nprint(d)\n```\n\n执行结果为\n\n```python\n{'1': 65, '2': 75, '3': 96, '4': 85, '5': 78, '6': 94, '7': 92, '8': 68, '9': 94, '10': 72, '11': 97, '12': 65, '13': 64, '14': 72, '15': 88, '16': 93, '17': 75, '18': 61, '19': 83, '20': 71}\n```\n\n如果需要在字典中筛选出值大于 90 的 id(key) 都有哪些，有以下四种实现方式：\n\n* 循环迭代\n\n```python\ndd = {}\nfor k in d:\n    if d[k] > 90:\n        dd[k] = d[k]\nprint(dd)\n```\n\n  结果为：\n\n```python\n{'3': 96, '6': 94, '7': 92, '9': 94, '11': 97, '16': 93}\n```\n\n* `filter()` 函数\n\n```python\ndd = list(filter(lambda x: d[x] > 90, d))\nprint(dd)\n```\n\n  结果为：\n\n```python\n['3', '6', '7', '9', '11', '16']\n```\n\n* 字典解析式\n\n```python\ndd = {k: v for k, v in d.items() if v > 90}\nprint(dd)\n```\n\n  结果为：\n\n```python\n{'3': 96, '6': 94, '7': 92, '9': 94, '11': 97, '16': 93}\n```\n\n* 生成器解析式\n\n```python\ndd = ({k: v} for k, v in d.items() if v > 90)\nfor i in dd:\n    print(i)\n```\n\n  结果为：\n\n```python\n{'3': 96}\n{'6': 94}\n{'7': 92}\n{'9': 94}\n{'11': 97}\n{'16': 93}\n```\n\n","source":"_posts/filting-data-in-dictionaries-in-Python.md","raw":"---\ntitle: Python 在字典中根据条件筛选数据\ndate: 2018-07-11 14:26:51\ntags:\n  - Python\n  - 奇技淫巧\n---\n\n首先创建一个字典\n\n```python\nimport random\n\nd = {str(x): random.randint(60, 100) for x in range(1, 21)}\nprint(d)\n```\n\n执行结果为\n\n```python\n{'1': 65, '2': 75, '3': 96, '4': 85, '5': 78, '6': 94, '7': 92, '8': 68, '9': 94, '10': 72, '11': 97, '12': 65, '13': 64, '14': 72, '15': 88, '16': 93, '17': 75, '18': 61, '19': 83, '20': 71}\n```\n\n如果需要在字典中筛选出值大于 90 的 id(key) 都有哪些，有以下四种实现方式：\n\n* 循环迭代\n\n```python\ndd = {}\nfor k in d:\n    if d[k] > 90:\n        dd[k] = d[k]\nprint(dd)\n```\n\n  结果为：\n\n```python\n{'3': 96, '6': 94, '7': 92, '9': 94, '11': 97, '16': 93}\n```\n\n* `filter()` 函数\n\n```python\ndd = list(filter(lambda x: d[x] > 90, d))\nprint(dd)\n```\n\n  结果为：\n\n```python\n['3', '6', '7', '9', '11', '16']\n```\n\n* 字典解析式\n\n```python\ndd = {k: v for k, v in d.items() if v > 90}\nprint(dd)\n```\n\n  结果为：\n\n```python\n{'3': 96, '6': 94, '7': 92, '9': 94, '11': 97, '16': 93}\n```\n\n* 生成器解析式\n\n```python\ndd = ({k: v} for k, v in d.items() if v > 90)\nfor i in dd:\n    print(i)\n```\n\n  结果为：\n\n```python\n{'3': 96}\n{'6': 94}\n{'7': 92}\n{'9': 94}\n{'11': 97}\n{'16': 93}\n```\n\n","slug":"filting-data-in-dictionaries-in-Python","published":1,"updated":"2019-03-27T16:25:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dr002jlixuledyxw1t","content":"<p>首先创建一个字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">d = &#123;str(x): random.randint(<span class=\"number\">60</span>, <span class=\"number\">100</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">21</span>)&#125;</span><br><span class=\"line\">print(d)</span><br></pre></td></tr></table></figure>\n<p>执行结果为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'1'</span>: <span class=\"number\">65</span>, <span class=\"string\">'2'</span>: <span class=\"number\">75</span>, <span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'4'</span>: <span class=\"number\">85</span>, <span class=\"string\">'5'</span>: <span class=\"number\">78</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'8'</span>: <span class=\"number\">68</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'10'</span>: <span class=\"number\">72</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'12'</span>: <span class=\"number\">65</span>, <span class=\"string\">'13'</span>: <span class=\"number\">64</span>, <span class=\"string\">'14'</span>: <span class=\"number\">72</span>, <span class=\"string\">'15'</span>: <span class=\"number\">88</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>, <span class=\"string\">'17'</span>: <span class=\"number\">75</span>, <span class=\"string\">'18'</span>: <span class=\"number\">61</span>, <span class=\"string\">'19'</span>: <span class=\"number\">83</span>, <span class=\"string\">'20'</span>: <span class=\"number\">71</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要在字典中筛选出值大于 90 的 id(key) 都有哪些，有以下四种实现方式：</p>\n<ul>\n<li>循环迭代</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> d[k] &gt; <span class=\"number\">90</span>:</span><br><span class=\"line\">        dd[k] = d[k]</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>filter()</code> 函数</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = list(filter(<span class=\"keyword\">lambda</span> x: d[x] &gt; <span class=\"number\">90</span>, d))</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'3'</span>, <span class=\"string\">'6'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'11'</span>, <span class=\"string\">'16'</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典解析式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = &#123;k: v <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items() <span class=\"keyword\">if</span> v &gt; <span class=\"number\">90</span>&#125;</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成器解析式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = (&#123;k: v&#125; <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items() <span class=\"keyword\">if</span> v &gt; <span class=\"number\">90</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> dd:</span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'6'</span>: <span class=\"number\">94</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'7'</span>: <span class=\"number\">92</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'9'</span>: <span class=\"number\">94</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'11'</span>: <span class=\"number\">97</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>首先创建一个字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">d = &#123;str(x): random.randint(<span class=\"number\">60</span>, <span class=\"number\">100</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">21</span>)&#125;</span><br><span class=\"line\">print(d)</span><br></pre></td></tr></table></figure>\n<p>执行结果为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'1'</span>: <span class=\"number\">65</span>, <span class=\"string\">'2'</span>: <span class=\"number\">75</span>, <span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'4'</span>: <span class=\"number\">85</span>, <span class=\"string\">'5'</span>: <span class=\"number\">78</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'8'</span>: <span class=\"number\">68</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'10'</span>: <span class=\"number\">72</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'12'</span>: <span class=\"number\">65</span>, <span class=\"string\">'13'</span>: <span class=\"number\">64</span>, <span class=\"string\">'14'</span>: <span class=\"number\">72</span>, <span class=\"string\">'15'</span>: <span class=\"number\">88</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>, <span class=\"string\">'17'</span>: <span class=\"number\">75</span>, <span class=\"string\">'18'</span>: <span class=\"number\">61</span>, <span class=\"string\">'19'</span>: <span class=\"number\">83</span>, <span class=\"string\">'20'</span>: <span class=\"number\">71</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要在字典中筛选出值大于 90 的 id(key) 都有哪些，有以下四种实现方式：</p>\n<ul>\n<li>循环迭代</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> d[k] &gt; <span class=\"number\">90</span>:</span><br><span class=\"line\">        dd[k] = d[k]</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>filter()</code> 函数</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = list(filter(<span class=\"keyword\">lambda</span> x: d[x] &gt; <span class=\"number\">90</span>, d))</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'3'</span>, <span class=\"string\">'6'</span>, <span class=\"string\">'7'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'11'</span>, <span class=\"string\">'16'</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>字典解析式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = &#123;k: v <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items() <span class=\"keyword\">if</span> v &gt; <span class=\"number\">90</span>&#125;</span><br><span class=\"line\">print(dd)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>, <span class=\"string\">'6'</span>: <span class=\"number\">94</span>, <span class=\"string\">'7'</span>: <span class=\"number\">92</span>, <span class=\"string\">'9'</span>: <span class=\"number\">94</span>, <span class=\"string\">'11'</span>: <span class=\"number\">97</span>, <span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成器解析式</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dd = (&#123;k: v&#125; <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items() <span class=\"keyword\">if</span> v &gt; <span class=\"number\">90</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> dd:</span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n<p>  结果为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'3'</span>: <span class=\"number\">96</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'6'</span>: <span class=\"number\">94</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'7'</span>: <span class=\"number\">92</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'9'</span>: <span class=\"number\">94</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'11'</span>: <span class=\"number\">97</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'16'</span>: <span class=\"number\">93</span>&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"使用 sshkey 实现免密码 ssh","date":"2015-03-15T03:41:27.000Z","_content":"\n在使用公有云的时候，可能会受到大量的扫描，其中大部分都是对常用用户（例如 root）的口令暴力猜测。虽说使用由各种字母、数字、符号混杂的口令能够大大提高安全性，但登录后看到那几万个 failed logins 总是有点碍眼。把 ssh 的端口从 22 改成其它不常见的端口也算是一个方法，但始终是治标不治本，毕竟这只能防一防那些随意乱扫的人，对于指定要 hack 某一台主机的，总能找到开放的 ssh 端口。\n\n从另一个角度来说，在自己反复连接远程主机的时候，每次都需要重新输入口令，也是一键比较烦的事情。\n\n使用 sshkey 来免口令 ssh 就可以避免以上两个问题。即使把 ssh 端口保持在 22，只要 sshkey 不符合，直接就拒绝连接了。同时，在ssh key 符合的情况下，能够不需要输入口令秒连接。\n\n首先在本地 ssh-keygen -t rsa 生成密钥，就会在 `~/.ssh` 目录下生成 `id_rsa` 和 `id_rsa.pub` 两个文件，分别是私钥和公钥。私钥是自己本地保存的，而公钥是可以公开分发的，因此将公钥文件 `id_rsa.pub` 通过能想到的各种方法放置到远程主机的 `~/.ssh` 下，并执行 `cat id_rsa.pub >> authorized_keys` 追加写入，这样就相当于让远程主机认识到本地主机，可以免口令登录了。\n\n然后修改 ssh 服务的配置文件 `/etc/ssh/sshd_config` ，把 `PasswordAuthentication` 字段的值改为 `no`，并重启 ssh 服务，就把 ssh 口令登录禁用了。\n\n","source":"_posts/how-to-SSH-with-sshekeys.md","raw":"---\ntitle: 使用 sshkey 实现免密码 ssh\ndate: 2015-03-15 11:41:27\ntags:\n  - Linux\n  - ssh\n---\n\n在使用公有云的时候，可能会受到大量的扫描，其中大部分都是对常用用户（例如 root）的口令暴力猜测。虽说使用由各种字母、数字、符号混杂的口令能够大大提高安全性，但登录后看到那几万个 failed logins 总是有点碍眼。把 ssh 的端口从 22 改成其它不常见的端口也算是一个方法，但始终是治标不治本，毕竟这只能防一防那些随意乱扫的人，对于指定要 hack 某一台主机的，总能找到开放的 ssh 端口。\n\n从另一个角度来说，在自己反复连接远程主机的时候，每次都需要重新输入口令，也是一键比较烦的事情。\n\n使用 sshkey 来免口令 ssh 就可以避免以上两个问题。即使把 ssh 端口保持在 22，只要 sshkey 不符合，直接就拒绝连接了。同时，在ssh key 符合的情况下，能够不需要输入口令秒连接。\n\n首先在本地 ssh-keygen -t rsa 生成密钥，就会在 `~/.ssh` 目录下生成 `id_rsa` 和 `id_rsa.pub` 两个文件，分别是私钥和公钥。私钥是自己本地保存的，而公钥是可以公开分发的，因此将公钥文件 `id_rsa.pub` 通过能想到的各种方法放置到远程主机的 `~/.ssh` 下，并执行 `cat id_rsa.pub >> authorized_keys` 追加写入，这样就相当于让远程主机认识到本地主机，可以免口令登录了。\n\n然后修改 ssh 服务的配置文件 `/etc/ssh/sshd_config` ，把 `PasswordAuthentication` 字段的值改为 `no`，并重启 ssh 服务，就把 ssh 口令登录禁用了。\n\n","slug":"how-to-SSH-with-sshekeys","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dt002llixu4jad54tc","content":"<p>在使用公有云的时候，可能会受到大量的扫描，其中大部分都是对常用用户（例如 root）的口令暴力猜测。虽说使用由各种字母、数字、符号混杂的口令能够大大提高安全性，但登录后看到那几万个 failed logins 总是有点碍眼。把 ssh 的端口从 22 改成其它不常见的端口也算是一个方法，但始终是治标不治本，毕竟这只能防一防那些随意乱扫的人，对于指定要 hack 某一台主机的，总能找到开放的 ssh 端口。</p>\n<p>从另一个角度来说，在自己反复连接远程主机的时候，每次都需要重新输入口令，也是一键比较烦的事情。</p>\n<p>使用 sshkey 来免口令 ssh 就可以避免以上两个问题。即使把 ssh 端口保持在 22，只要 sshkey 不符合，直接就拒绝连接了。同时，在ssh key 符合的情况下，能够不需要输入口令秒连接。</p>\n<p>首先在本地 ssh-keygen -t rsa 生成密钥，就会在 <code>~/.ssh</code> 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，分别是私钥和公钥。私钥是自己本地保存的，而公钥是可以公开分发的，因此将公钥文件 <code>id_rsa.pub</code> 通过能想到的各种方法放置到远程主机的 <code>~/.ssh</code> 下，并执行 <code>cat id_rsa.pub &gt;&gt; authorized_keys</code> 追加写入，这样就相当于让远程主机认识到本地主机，可以免口令登录了。</p>\n<p>然后修改 ssh 服务的配置文件 <code>/etc/ssh/sshd_config</code> ，把 <code>PasswordAuthentication</code> 字段的值改为 <code>no</code>，并重启 ssh 服务，就把 ssh 口令登录禁用了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用公有云的时候，可能会受到大量的扫描，其中大部分都是对常用用户（例如 root）的口令暴力猜测。虽说使用由各种字母、数字、符号混杂的口令能够大大提高安全性，但登录后看到那几万个 failed logins 总是有点碍眼。把 ssh 的端口从 22 改成其它不常见的端口也算是一个方法，但始终是治标不治本，毕竟这只能防一防那些随意乱扫的人，对于指定要 hack 某一台主机的，总能找到开放的 ssh 端口。</p>\n<p>从另一个角度来说，在自己反复连接远程主机的时候，每次都需要重新输入口令，也是一键比较烦的事情。</p>\n<p>使用 sshkey 来免口令 ssh 就可以避免以上两个问题。即使把 ssh 端口保持在 22，只要 sshkey 不符合，直接就拒绝连接了。同时，在ssh key 符合的情况下，能够不需要输入口令秒连接。</p>\n<p>首先在本地 ssh-keygen -t rsa 生成密钥，就会在 <code>~/.ssh</code> 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，分别是私钥和公钥。私钥是自己本地保存的，而公钥是可以公开分发的，因此将公钥文件 <code>id_rsa.pub</code> 通过能想到的各种方法放置到远程主机的 <code>~/.ssh</code> 下，并执行 <code>cat id_rsa.pub &gt;&gt; authorized_keys</code> 追加写入，这样就相当于让远程主机认识到本地主机，可以免口令登录了。</p>\n<p>然后修改 ssh 服务的配置文件 <code>/etc/ssh/sshd_config</code> ，把 <code>PasswordAuthentication</code> 字段的值改为 <code>no</code>，并重启 ssh 服务，就把 ssh 口令登录禁用了。</p>\n"},{"title":"如何在 CentOS 7 上手动搭建 LAMP 环境","date":"2014-11-29T02:00:58.000Z","_content":"\n拿到一台新的服务器之后，如果要搭 WordPress 之类的服务，就需要搭建一个 LAMP 环境。\n\n鉴于网上各种一键 LAMP 的质量稂莠不齐，自己搭一个还是比较妥当的做法，而且后续如果需要自定义配置的话更加方便，不至于发生太多关于包依赖的问题。\n\n```shell\n# 安装 Apache\nyum -y install httpd\n# 启动服务\nsystemctl start httpd.service\n# 设置开机自动启动\nsystemctl enable httpd.service\n \n# 安装 MySQL（在 CentOS 7 上其实是 MariaDB，但兼容 MySQL）\nyum -y install mariadb mariadb-server\n# 启动服务\nsystemctl start mariadb.service\n# 设置开机启动服务\nsystemctl enable mariadb.service\n# 设置数据库管理员密码\nmysql_secure_installation\n \n# 安装 PHP\nyum -y install php\n# 安装各种 PHP 的组件\nyum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-mysql\n# 重启一下\nsystemctl restart httpd.service\n```\n\n这样基本就可以直接安装 WordPress 了。\n","source":"_posts/how-to-build-LAMP-environment-on-CentOS-7.md","raw":"---\ntitle: 如何在 CentOS 7 上手动搭建 LAMP 环境\ndate: 2014-11-29 10:00:58\ntags: \n  - Apache\n  - LAMP\n  - MySQL\n  - PHP\n---\n\n拿到一台新的服务器之后，如果要搭 WordPress 之类的服务，就需要搭建一个 LAMP 环境。\n\n鉴于网上各种一键 LAMP 的质量稂莠不齐，自己搭一个还是比较妥当的做法，而且后续如果需要自定义配置的话更加方便，不至于发生太多关于包依赖的问题。\n\n```shell\n# 安装 Apache\nyum -y install httpd\n# 启动服务\nsystemctl start httpd.service\n# 设置开机自动启动\nsystemctl enable httpd.service\n \n# 安装 MySQL（在 CentOS 7 上其实是 MariaDB，但兼容 MySQL）\nyum -y install mariadb mariadb-server\n# 启动服务\nsystemctl start mariadb.service\n# 设置开机启动服务\nsystemctl enable mariadb.service\n# 设置数据库管理员密码\nmysql_secure_installation\n \n# 安装 PHP\nyum -y install php\n# 安装各种 PHP 的组件\nyum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-mysql\n# 重启一下\nsystemctl restart httpd.service\n```\n\n这样基本就可以直接安装 WordPress 了。\n","slug":"how-to-build-LAMP-environment-on-CentOS-7","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0du002olixung9o74h8","content":"<p>拿到一台新的服务器之后，如果要搭 WordPress 之类的服务，就需要搭建一个 LAMP 环境。</p>\n<p>鉴于网上各种一键 LAMP 的质量稂莠不齐，自己搭一个还是比较妥当的做法，而且后续如果需要自定义配置的话更加方便，不至于发生太多关于包依赖的问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 安装 Apache</span><br><span class=\"line\">yum -y install httpd</span><br><span class=\"line\"><span class=\"meta\">#</span> 启动服务</span><br><span class=\"line\">systemctl start httpd.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置开机自动启动</span><br><span class=\"line\">systemctl enable httpd.service</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 MySQL（在 CentOS 7 上其实是 MariaDB，但兼容 MySQL）</span><br><span class=\"line\">yum -y install mariadb mariadb-server</span><br><span class=\"line\"><span class=\"meta\">#</span> 启动服务</span><br><span class=\"line\">systemctl start mariadb.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置开机启动服务</span><br><span class=\"line\">systemctl enable mariadb.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置数据库管理员密码</span><br><span class=\"line\">mysql_secure_installation</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 PHP</span><br><span class=\"line\">yum -y install php</span><br><span class=\"line\"><span class=\"meta\">#</span> 安装各种 PHP 的组件</span><br><span class=\"line\">yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-mysql</span><br><span class=\"line\"><span class=\"meta\">#</span> 重启一下</span><br><span class=\"line\">systemctl restart httpd.service</span><br></pre></td></tr></table></figure>\n<p>这样基本就可以直接安装 WordPress 了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>拿到一台新的服务器之后，如果要搭 WordPress 之类的服务，就需要搭建一个 LAMP 环境。</p>\n<p>鉴于网上各种一键 LAMP 的质量稂莠不齐，自己搭一个还是比较妥当的做法，而且后续如果需要自定义配置的话更加方便，不至于发生太多关于包依赖的问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 安装 Apache</span><br><span class=\"line\">yum -y install httpd</span><br><span class=\"line\"><span class=\"meta\">#</span> 启动服务</span><br><span class=\"line\">systemctl start httpd.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置开机自动启动</span><br><span class=\"line\">systemctl enable httpd.service</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 MySQL（在 CentOS 7 上其实是 MariaDB，但兼容 MySQL）</span><br><span class=\"line\">yum -y install mariadb mariadb-server</span><br><span class=\"line\"><span class=\"meta\">#</span> 启动服务</span><br><span class=\"line\">systemctl start mariadb.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置开机启动服务</span><br><span class=\"line\">systemctl enable mariadb.service</span><br><span class=\"line\"><span class=\"meta\">#</span> 设置数据库管理员密码</span><br><span class=\"line\">mysql_secure_installation</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 PHP</span><br><span class=\"line\">yum -y install php</span><br><span class=\"line\"><span class=\"meta\">#</span> 安装各种 PHP 的组件</span><br><span class=\"line\">yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-mysql</span><br><span class=\"line\"><span class=\"meta\">#</span> 重启一下</span><br><span class=\"line\">systemctl restart httpd.service</span><br></pre></td></tr></table></figure>\n<p>这样基本就可以直接安装 WordPress 了。</p>\n"},{"title":"查看文件中的重复行","date":"2016-12-12T04:07:57.000Z","_content":"\n```shell\nsort <filename> | uniq -cd\n```\n\n`uniq` 命令用于报告重复的行，但只能用于相邻的两行，因此需要先用 `sort` 对文件中的个行进行排序。加入 `-d` 参数能把重复的行显示出来，加入 `-c` 参数能显示重复的行重复了多少次。\n","source":"_posts/how-to-find-duplicated-lines-in-files.md","raw":"---\ntitle: 查看文件中的重复行\ndate: 2016-12-12 12:07:57\ntags:\n  - Linux\n---\n\n```shell\nsort <filename> | uniq -cd\n```\n\n`uniq` 命令用于报告重复的行，但只能用于相邻的两行，因此需要先用 `sort` 对文件中的个行进行排序。加入 `-d` 参数能把重复的行显示出来，加入 `-c` 参数能显示重复的行重复了多少次。\n","slug":"how-to-find-duplicated-lines-in-files","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dv002qlixu7rrbv8jn","content":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort &lt;filename&gt; | uniq -cd</span><br></pre></td></tr></table></figure>\n<p><code>uniq</code> 命令用于报告重复的行，但只能用于相邻的两行，因此需要先用 <code>sort</code> 对文件中的个行进行排序。加入 <code>-d</code> 参数能把重复的行显示出来，加入 <code>-c</code> 参数能显示重复的行重复了多少次。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort &lt;filename&gt; | uniq -cd</span><br></pre></td></tr></table></figure>\n<p><code>uniq</code> 命令用于报告重复的行，但只能用于相邻的两行，因此需要先用 <code>sort</code> 对文件中的个行进行排序。加入 <code>-d</code> 参数能把重复的行显示出来，加入 <code>-c</code> 参数能显示重复的行重复了多少次。</p>\n"},{"title":"Windows 下 Python 字符编码异常解决方案","date":"2015-06-28T03:47:43.000Z","_content":"\n在中文 Windows 系统中，文件的默认字符编码为 GBK，如果将一段编码为 UTF-8 的数据流在 Windows 下写入文件，就可能会解析失败并抛出 UnicodeEncodeError 异常。\n\n解决方案是在打开要写入的文件时在 `encoding` 参数中指定数据流的编码，这样就能在先从数据流的编码转换为目的编码，然后写入文件。\n\n```python\nf = open('something.txt', 'w', encoding='utf-8')\n```\n\n对于一些编码不规范的文件，在读取是可能会遇到 UnicodeDecodeError 异常，因为在文件中有可能夹杂了一些非法编码的字符。这种情况下 `open()` 可以接受一个 `errors` 参数，来指定如果遇到编码错误时应该如何处理。这个参数有两个枚举值，分别是 `strict` 和 `ignore`，前者在遇到异常的时候直接抛出异常并退出，后者为直接忽略。\n\n```python\nf = open('something.txt', 'w', encoding='utf-8', errors='ignore')\n```\n","source":"_posts/how-to-fix-Python-UnicodeEncodeError-on-Windows.md","raw":"---\ntitle: Windows 下 Python 字符编码异常解决方案\ndate: 2015-06-28 11:47:43\ntags:\n  - Windows\n  - Python\n  - 编码\n---\n\n在中文 Windows 系统中，文件的默认字符编码为 GBK，如果将一段编码为 UTF-8 的数据流在 Windows 下写入文件，就可能会解析失败并抛出 UnicodeEncodeError 异常。\n\n解决方案是在打开要写入的文件时在 `encoding` 参数中指定数据流的编码，这样就能在先从数据流的编码转换为目的编码，然后写入文件。\n\n```python\nf = open('something.txt', 'w', encoding='utf-8')\n```\n\n对于一些编码不规范的文件，在读取是可能会遇到 UnicodeDecodeError 异常，因为在文件中有可能夹杂了一些非法编码的字符。这种情况下 `open()` 可以接受一个 `errors` 参数，来指定如果遇到编码错误时应该如何处理。这个参数有两个枚举值，分别是 `strict` 和 `ignore`，前者在遇到异常的时候直接抛出异常并退出，后者为直接忽略。\n\n```python\nf = open('something.txt', 'w', encoding='utf-8', errors='ignore')\n```\n","slug":"how-to-fix-Python-UnicodeEncodeError-on-Windows","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dx002tlixu6rtbeodm","content":"<p>在中文 Windows 系统中，文件的默认字符编码为 GBK，如果将一段编码为 UTF-8 的数据流在 Windows 下写入文件，就可能会解析失败并抛出 UnicodeEncodeError 异常。</p>\n<p>解决方案是在打开要写入的文件时在 <code>encoding</code> 参数中指定数据流的编码，这样就能在先从数据流的编码转换为目的编码，然后写入文件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(<span class=\"string\">'something.txt'</span>, <span class=\"string\">'w'</span>, encoding=<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>\n<p>对于一些编码不规范的文件，在读取是可能会遇到 UnicodeDecodeError 异常，因为在文件中有可能夹杂了一些非法编码的字符。这种情况下 <code>open()</code> 可以接受一个 <code>errors</code> 参数，来指定如果遇到编码错误时应该如何处理。这个参数有两个枚举值，分别是 <code>strict</code> 和 <code>ignore</code>，前者在遇到异常的时候直接抛出异常并退出，后者为直接忽略。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(<span class=\"string\">'something.txt'</span>, <span class=\"string\">'w'</span>, encoding=<span class=\"string\">'utf-8'</span>, errors=<span class=\"string\">'ignore'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在中文 Windows 系统中，文件的默认字符编码为 GBK，如果将一段编码为 UTF-8 的数据流在 Windows 下写入文件，就可能会解析失败并抛出 UnicodeEncodeError 异常。</p>\n<p>解决方案是在打开要写入的文件时在 <code>encoding</code> 参数中指定数据流的编码，这样就能在先从数据流的编码转换为目的编码，然后写入文件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(<span class=\"string\">'something.txt'</span>, <span class=\"string\">'w'</span>, encoding=<span class=\"string\">'utf-8'</span>)</span><br></pre></td></tr></table></figure>\n<p>对于一些编码不规范的文件，在读取是可能会遇到 UnicodeDecodeError 异常，因为在文件中有可能夹杂了一些非法编码的字符。这种情况下 <code>open()</code> 可以接受一个 <code>errors</code> 参数，来指定如果遇到编码错误时应该如何处理。这个参数有两个枚举值，分别是 <code>strict</code> 和 <code>ignore</code>，前者在遇到异常的时候直接抛出异常并退出，后者为直接忽略。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = open(<span class=\"string\">'something.txt'</span>, <span class=\"string\">'w'</span>, encoding=<span class=\"string\">'utf-8'</span>, errors=<span class=\"string\">'ignore'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"Linux 下普通用户获取 sudo 权限的方法","date":"2017-04-01T04:09:55.000Z","_content":"\n在 Linux 创建新用户后，如果需要使该用户能以 `sudo` 方式执行命令，需要把用户添加到 `sudoers` 文件中，否则在使用 `sudo` 的时候会报“{user} is not in the sudoers file”错误。此时需要将用户添加到 `sudoers` 文件中，并使其获得相应权限。\n\n首先需要使用 root 用户，执行命令：\n\n```shell\nvisudo\n```\n\n打开 `sudoers` 文件，然后在其中添加\n\n```\n{user} ALL=(ALL:ALL) ALL\n%{user} ALL=(ALL) NOPASSWD: ALL # 设置{user}组下面的用户使用 sudo 不需要输入密码\n```\n\n保存后，该用户即可使用 `sudo` 命令。\n\n4个 ALL 之中，第 1 个 ALL 是用户(user)，第 2 个 ALL 是机器，第 3 个 ALL 是新用户身分(run_as_user, 如 root, oracle)，第 4 个ALL 是命令。\n","source":"_posts/how-to-grant-sudo-privilege-to-a-normal-user.md","raw":"---\ntitle: Linux 下普通用户获取 sudo 权限的方法\ndate: 2017-04-01 12:09:55\ntags:\n  - Linux\n---\n\n在 Linux 创建新用户后，如果需要使该用户能以 `sudo` 方式执行命令，需要把用户添加到 `sudoers` 文件中，否则在使用 `sudo` 的时候会报“{user} is not in the sudoers file”错误。此时需要将用户添加到 `sudoers` 文件中，并使其获得相应权限。\n\n首先需要使用 root 用户，执行命令：\n\n```shell\nvisudo\n```\n\n打开 `sudoers` 文件，然后在其中添加\n\n```\n{user} ALL=(ALL:ALL) ALL\n%{user} ALL=(ALL) NOPASSWD: ALL # 设置{user}组下面的用户使用 sudo 不需要输入密码\n```\n\n保存后，该用户即可使用 `sudo` 命令。\n\n4个 ALL 之中，第 1 个 ALL 是用户(user)，第 2 个 ALL 是机器，第 3 个 ALL 是新用户身分(run_as_user, 如 root, oracle)，第 4 个ALL 是命令。\n","slug":"how-to-grant-sudo-privilege-to-a-normal-user","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dy002vlixu53jbc5n8","content":"<p>在 Linux 创建新用户后，如果需要使该用户能以 <code>sudo</code> 方式执行命令，需要把用户添加到 <code>sudoers</code> 文件中，否则在使用 <code>sudo</code> 的时候会报“{user} is not in the sudoers file”错误。此时需要将用户添加到 <code>sudoers</code> 文件中，并使其获得相应权限。</p>\n<p>首先需要使用 root 用户，执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visudo</span><br></pre></td></tr></table></figure>\n<p>打开 <code>sudoers</code> 文件，然后在其中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;user&#125; ALL=(ALL:ALL) ALL</span><br><span class=\"line\">%&#123;user&#125; ALL=(ALL) NOPASSWD: ALL # 设置&#123;user&#125;组下面的用户使用 sudo 不需要输入密码</span><br></pre></td></tr></table></figure>\n<p>保存后，该用户即可使用 <code>sudo</code> 命令。</p>\n<p>4个 ALL 之中，第 1 个 ALL 是用户(user)，第 2 个 ALL 是机器，第 3 个 ALL 是新用户身分(run_as_user, 如 root, oracle)，第 4 个ALL 是命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Linux 创建新用户后，如果需要使该用户能以 <code>sudo</code> 方式执行命令，需要把用户添加到 <code>sudoers</code> 文件中，否则在使用 <code>sudo</code> 的时候会报“{user} is not in the sudoers file”错误。此时需要将用户添加到 <code>sudoers</code> 文件中，并使其获得相应权限。</p>\n<p>首先需要使用 root 用户，执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visudo</span><br></pre></td></tr></table></figure>\n<p>打开 <code>sudoers</code> 文件，然后在其中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;user&#125; ALL=(ALL:ALL) ALL</span><br><span class=\"line\">%&#123;user&#125; ALL=(ALL) NOPASSWD: ALL # 设置&#123;user&#125;组下面的用户使用 sudo 不需要输入密码</span><br></pre></td></tr></table></figure>\n<p>保存后，该用户即可使用 <code>sudo</code> 命令。</p>\n<p>4个 ALL 之中，第 1 个 ALL 是用户(user)，第 2 个 ALL 是机器，第 3 个 ALL 是新用户身分(run_as_user, 如 root, oracle)，第 4 个ALL 是命令。</p>\n"},{"title":"在新机器上快速安装 Python 3","date":"2016-02-14T05:55:31.000Z","_content":"\n对于以 Python 3 为主力开发语言的人来说，在一台新的机器上必须尽早安装上 Python 3。而对于绝大多数 Linux 发行版来说，都只默认安装了 Python 2 而没有 Python 3，而且有一些 Linux 自带的命令（例如 `yum`）会依赖 Python 2，这就需要在安装 Python 3 的同时保留 Python 2，并且使两者区分开来。\n\n快速安装如下：\n\n```shell\n# 版本号\nversion=\"3.6.2\"\n\n# 安装依赖包\nyum -y groupinstall \"Development tools\"\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n\n# 下载 Python 3 源码，版本号可改\nwhich wget || yum -y install wget\nwget https://www.python.org/ftp/python/$version/Python-$version.tar.xz\n\n# 解包、编译、安装\nmkdir /usr/local/python3\nmv ./Python-$version.tar.xz /usr/local/python3\ncd /usr/local/python3\ntar -xvJf  Python-$version.tar.xz\ncd Python-$version\nwhich gcc || yum install -y gcc\n./configure --prefix=/usr/local/python3\nmake && make install\n\n# 设定 Python 3 和 pip3 的软连接\nln -s /usr/local/python3/bin/python3 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3 /usr/bin/pip3\n```\n","source":"_posts/how-to-install-Python-3-quickly.md","raw":"---\ntitle: 在新机器上快速安装 Python 3\ndate: 2016-02-14 13:55:31\ntags:\n  - Linux\n  - Python\n  - 快速安装\n---\n\n对于以 Python 3 为主力开发语言的人来说，在一台新的机器上必须尽早安装上 Python 3。而对于绝大多数 Linux 发行版来说，都只默认安装了 Python 2 而没有 Python 3，而且有一些 Linux 自带的命令（例如 `yum`）会依赖 Python 2，这就需要在安装 Python 3 的同时保留 Python 2，并且使两者区分开来。\n\n快速安装如下：\n\n```shell\n# 版本号\nversion=\"3.6.2\"\n\n# 安装依赖包\nyum -y groupinstall \"Development tools\"\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n\n# 下载 Python 3 源码，版本号可改\nwhich wget || yum -y install wget\nwget https://www.python.org/ftp/python/$version/Python-$version.tar.xz\n\n# 解包、编译、安装\nmkdir /usr/local/python3\nmv ./Python-$version.tar.xz /usr/local/python3\ncd /usr/local/python3\ntar -xvJf  Python-$version.tar.xz\ncd Python-$version\nwhich gcc || yum install -y gcc\n./configure --prefix=/usr/local/python3\nmake && make install\n\n# 设定 Python 3 和 pip3 的软连接\nln -s /usr/local/python3/bin/python3 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3 /usr/bin/pip3\n```\n","slug":"how-to-install-Python-3-quickly","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0dz002ylixu3pwj7iew","content":"<p>对于以 Python 3 为主力开发语言的人来说，在一台新的机器上必须尽早安装上 Python 3。而对于绝大多数 Linux 发行版来说，都只默认安装了 Python 2 而没有 Python 3，而且有一些 Linux 自带的命令（例如 <code>yum</code>）会依赖 Python 2，这就需要在安装 Python 3 的同时保留 Python 2，并且使两者区分开来。</p>\n<p>快速安装如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 版本号</span><br><span class=\"line\">version=\"3.6.2\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装依赖包</span><br><span class=\"line\">yum -y groupinstall \"Development tools\"</span><br><span class=\"line\">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 下载 Python 3 源码，版本号可改</span><br><span class=\"line\">which wget || yum -y install wget</span><br><span class=\"line\">wget https://www.python.org/ftp/python/$version/Python-$version.tar.xz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 解包、编译、安装</span><br><span class=\"line\">mkdir /usr/local/python3</span><br><span class=\"line\">mv ./Python-$version.tar.xz /usr/local/python3</span><br><span class=\"line\">cd /usr/local/python3</span><br><span class=\"line\">tar -xvJf  Python-$version.tar.xz</span><br><span class=\"line\">cd Python-$version</span><br><span class=\"line\">which gcc || yum install -y gcc</span><br><span class=\"line\">./configure --prefix=/usr/local/python3</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 设定 Python 3 和 pip3 的软连接</span><br><span class=\"line\">ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class=\"line\">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>对于以 Python 3 为主力开发语言的人来说，在一台新的机器上必须尽早安装上 Python 3。而对于绝大多数 Linux 发行版来说，都只默认安装了 Python 2 而没有 Python 3，而且有一些 Linux 自带的命令（例如 <code>yum</code>）会依赖 Python 2，这就需要在安装 Python 3 的同时保留 Python 2，并且使两者区分开来。</p>\n<p>快速安装如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 版本号</span><br><span class=\"line\">version=\"3.6.2\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装依赖包</span><br><span class=\"line\">yum -y groupinstall \"Development tools\"</span><br><span class=\"line\">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 下载 Python 3 源码，版本号可改</span><br><span class=\"line\">which wget || yum -y install wget</span><br><span class=\"line\">wget https://www.python.org/ftp/python/$version/Python-$version.tar.xz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 解包、编译、安装</span><br><span class=\"line\">mkdir /usr/local/python3</span><br><span class=\"line\">mv ./Python-$version.tar.xz /usr/local/python3</span><br><span class=\"line\">cd /usr/local/python3</span><br><span class=\"line\">tar -xvJf  Python-$version.tar.xz</span><br><span class=\"line\">cd Python-$version</span><br><span class=\"line\">which gcc || yum install -y gcc</span><br><span class=\"line\">./configure --prefix=/usr/local/python3</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 设定 Python 3 和 pip3 的软连接</span><br><span class=\"line\">ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class=\"line\">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>\n"},{"title":"如何安装及管理 Ruby","date":"2018-12-25T17:55:06.000Z","_content":"\n可以使用 rvm 管理 Ruby 及其软件包。\n\n预先安装 Ruby 需要使用到的软件包：\n\n```\nyum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel\n```\n\n使用 rvm 官方提供的脚本安装 rvm：\n\n```\ncurl -L get.rvm.io | sh -s stable\n```\n\n如果按照以上命令安装 rvm 失败，需要使用以下方式更新相关证书：\n\n```\ncurl -sSL https://rvm.io/mpapis.asc | gpg2 --import -\ncurl -sSL https://rvm.io/pkuczynski.asc | gpg2 --import -\n```\n\n证书更新之后再次执行 `curl -L get.rvm.io | sh -s stable` 安装 rvm。安装完成时候可以设置 `rvm` 命令：\n\n```\nsource /etc/profile.d/rvm.sh\n```\n\n查看当前 Ruby 版本：\n\n```\nruby -v\n```\n\n使用 rvm 安装指定版本的 Ruby：\n\n```\nrvm install {ruby_version}\n```\n\n如果安装过程太慢，可以考虑切换到其它安装源镜像，在 `/usr/local.rvm/user/db` 文件中加入：\n\n```\nruby_url={ruby_source_url}\n```\n\n即可。\n","source":"_posts/how-to-install-and-manage-ruby.md","raw":"---\ntitle: 如何安装及管理 Ruby\ndate: 2018-12-26 01:55:06\ntags:\n  - Ruby\n---\n\n可以使用 rvm 管理 Ruby 及其软件包。\n\n预先安装 Ruby 需要使用到的软件包：\n\n```\nyum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel\n```\n\n使用 rvm 官方提供的脚本安装 rvm：\n\n```\ncurl -L get.rvm.io | sh -s stable\n```\n\n如果按照以上命令安装 rvm 失败，需要使用以下方式更新相关证书：\n\n```\ncurl -sSL https://rvm.io/mpapis.asc | gpg2 --import -\ncurl -sSL https://rvm.io/pkuczynski.asc | gpg2 --import -\n```\n\n证书更新之后再次执行 `curl -L get.rvm.io | sh -s stable` 安装 rvm。安装完成时候可以设置 `rvm` 命令：\n\n```\nsource /etc/profile.d/rvm.sh\n```\n\n查看当前 Ruby 版本：\n\n```\nruby -v\n```\n\n使用 rvm 安装指定版本的 Ruby：\n\n```\nrvm install {ruby_version}\n```\n\n如果安装过程太慢，可以考虑切换到其它安装源镜像，在 `/usr/local.rvm/user/db` 文件中加入：\n\n```\nruby_url={ruby_source_url}\n```\n\n即可。\n","slug":"how-to-install-and-manage-ruby","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0e20030lixuohw3f5o6","content":"<p>可以使用 rvm 管理 Ruby 及其软件包。</p>\n<p>预先安装 Ruby 需要使用到的软件包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel</span><br></pre></td></tr></table></figure>\n<p>使用 rvm 官方提供的脚本安装 rvm：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L get.rvm.io | sh -s stable</span><br></pre></td></tr></table></figure>\n<p>如果按照以上命令安装 rvm 失败，需要使用以下方式更新相关证书：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL https://rvm.io/mpapis.asc | gpg2 --import -</span><br><span class=\"line\">curl -sSL https://rvm.io/pkuczynski.asc | gpg2 --import -</span><br></pre></td></tr></table></figure>\n<p>证书更新之后再次执行 <code>curl -L get.rvm.io | sh -s stable</code> 安装 rvm。安装完成时候可以设置 <code>rvm</code> 命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile.d/rvm.sh</span><br></pre></td></tr></table></figure>\n<p>查看当前 Ruby 版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -v</span><br></pre></td></tr></table></figure>\n<p>使用 rvm 安装指定版本的 Ruby：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install &#123;ruby_version&#125;</span><br></pre></td></tr></table></figure>\n<p>如果安装过程太慢，可以考虑切换到其它安装源镜像，在 <code>/usr/local.rvm/user/db</code> 文件中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby_url=&#123;ruby_source_url&#125;</span><br></pre></td></tr></table></figure>\n<p>即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>可以使用 rvm 管理 Ruby 及其软件包。</p>\n<p>预先安装 Ruby 需要使用到的软件包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel</span><br></pre></td></tr></table></figure>\n<p>使用 rvm 官方提供的脚本安装 rvm：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L get.rvm.io | sh -s stable</span><br></pre></td></tr></table></figure>\n<p>如果按照以上命令安装 rvm 失败，需要使用以下方式更新相关证书：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sSL https://rvm.io/mpapis.asc | gpg2 --import -</span><br><span class=\"line\">curl -sSL https://rvm.io/pkuczynski.asc | gpg2 --import -</span><br></pre></td></tr></table></figure>\n<p>证书更新之后再次执行 <code>curl -L get.rvm.io | sh -s stable</code> 安装 rvm。安装完成时候可以设置 <code>rvm</code> 命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /etc/profile.d/rvm.sh</span><br></pre></td></tr></table></figure>\n<p>查看当前 Ruby 版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -v</span><br></pre></td></tr></table></figure>\n<p>使用 rvm 安装指定版本的 Ruby：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install &#123;ruby_version&#125;</span><br></pre></td></tr></table></figure>\n<p>如果安装过程太慢，可以考虑切换到其它安装源镜像，在 <code>/usr/local.rvm/user/db</code> 文件中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby_url=&#123;ruby_source_url&#125;</span><br></pre></td></tr></table></figure>\n<p>即可。</p>\n"},{"title":"快速安装 zsh","date":"2017-04-28T04:10:27.000Z","_content":"\n在新机器上快速安装比 bash 不知道高到哪里去了的 zsh。\n\n```shell\n# 安装 zsh\nyum -y install zsh\n# 把默认 shell 替换为 zsh\nchsh -s /bin/zsh\n\n# 安装 oh-my-zsh\nwhich curl || yum -y install curl\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh\n```\n","source":"_posts/how-to-install-zsh-quickly.md","raw":"---\ntitle: 快速安装 zsh\ndate: 2017-04-28 12:10:27\ntags:\n  - zsh\n---\n\n在新机器上快速安装比 bash 不知道高到哪里去了的 zsh。\n\n```shell\n# 安装 zsh\nyum -y install zsh\n# 把默认 shell 替换为 zsh\nchsh -s /bin/zsh\n\n# 安装 oh-my-zsh\nwhich curl || yum -y install curl\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh\n```\n","slug":"how-to-install-zsh-quickly","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0e80033lixupfurrrno","content":"<p>在新机器上快速安装比 bash 不知道高到哪里去了的 zsh。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 安装 zsh</span><br><span class=\"line\">yum -y install zsh</span><br><span class=\"line\"><span class=\"meta\">#</span> 把默认 shell 替换为 zsh</span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 oh-my-zsh</span><br><span class=\"line\">which curl || yum -y install curl</span><br><span class=\"line\">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在新机器上快速安装比 bash 不知道高到哪里去了的 zsh。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 安装 zsh</span><br><span class=\"line\">yum -y install zsh</span><br><span class=\"line\"><span class=\"meta\">#</span> 把默认 shell 替换为 zsh</span><br><span class=\"line\">chsh -s /bin/zsh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 安装 oh-my-zsh</span><br><span class=\"line\">which curl || yum -y install curl</span><br><span class=\"line\">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>\n"},{"title":"使用 pymysql 模块时查询返回字典的方法","date":"2016-12-01T02:10:14.000Z","_content":"\n使用 `pymysql` 模块在 MySQL 中进行查询时，如果是使用以下这种默认的查询方法时，调用 `fetchone()` 和 `fetchall()` 返回的查询结果将会分别是元组和嵌套元组，只能使用下标去访问查询出来的每个字段的值，相当不方便，也不灵活。\n\n```python\nimport pymysql\n\nconnection = {\n    \"host\": \"\",\n    \"user\": \"\",\n    \"passwd\": \"\",\n    \"db\": \"\",\n    \"charset\": \"utf8\"\n}\n\nconn = pymysql.connect(**connection)\ncursor = conn.cursor()\nsql = \"blabla\"\ncursor.execute(sql)\nresult = cursor.fetchall()\n```\n\n最方便的返回莫过于字典了，字段名作为键名，查询出来的值作为键值，与字段的顺序无关。需要在查询的时候返回字典，只需要在连接参数中指定一个 `cursorclass` 参数为 `pymysql.cursors.DictCursor` 即可，使用 `fetchone()` 和 `fetchall()` 返回的查询结果分别为字典和以每一行为一个字典组成的列表。\n\n```python\nimport pymysql\n\nconnection = {\n    \"host\": \"\",\n    \"user\": \"\",\n    \"passwd\": \"\",\n    \"db\": \"\",\n    \"charset\": \"utf8\",\n    \"cursorclass\": pymysql.cursors.DictCursor\n}\nconn = pymysql.connect(**connection)\ncursor = conn.cursor()\nsql = \"blabla\"\ncursor.execute(sql)\nresult = cursor.fetchall()\n```\n","source":"_posts/how-to-return-dictionary-when-using-pymysql-module-for-querying.md","raw":"---\ntitle: 使用 pymysql 模块时查询返回字典的方法\ndate: 2016-12-01 10:10:14\ntags:\n  - MySQL\n  - Python\n  - 奇技淫巧\n---\n\n使用 `pymysql` 模块在 MySQL 中进行查询时，如果是使用以下这种默认的查询方法时，调用 `fetchone()` 和 `fetchall()` 返回的查询结果将会分别是元组和嵌套元组，只能使用下标去访问查询出来的每个字段的值，相当不方便，也不灵活。\n\n```python\nimport pymysql\n\nconnection = {\n    \"host\": \"\",\n    \"user\": \"\",\n    \"passwd\": \"\",\n    \"db\": \"\",\n    \"charset\": \"utf8\"\n}\n\nconn = pymysql.connect(**connection)\ncursor = conn.cursor()\nsql = \"blabla\"\ncursor.execute(sql)\nresult = cursor.fetchall()\n```\n\n最方便的返回莫过于字典了，字段名作为键名，查询出来的值作为键值，与字段的顺序无关。需要在查询的时候返回字典，只需要在连接参数中指定一个 `cursorclass` 参数为 `pymysql.cursors.DictCursor` 即可，使用 `fetchone()` 和 `fetchall()` 返回的查询结果分别为字典和以每一行为一个字典组成的列表。\n\n```python\nimport pymysql\n\nconnection = {\n    \"host\": \"\",\n    \"user\": \"\",\n    \"passwd\": \"\",\n    \"db\": \"\",\n    \"charset\": \"utf8\",\n    \"cursorclass\": pymysql.cursors.DictCursor\n}\nconn = pymysql.connect(**connection)\ncursor = conn.cursor()\nsql = \"blabla\"\ncursor.execute(sql)\nresult = cursor.fetchall()\n```\n","slug":"how-to-return-dictionary-when-using-pymysql-module-for-querying","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ea0035lixue0f6ul20","content":"<p>使用 <code>pymysql</code> 模块在 MySQL 中进行查询时，如果是使用以下这种默认的查询方法时，调用 <code>fetchone()</code> 和 <code>fetchall()</code> 返回的查询结果将会分别是元组和嵌套元组，只能使用下标去访问查询出来的每个字段的值，相当不方便，也不灵活。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"></span><br><span class=\"line\">connection = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"host\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"passwd\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"db\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charset\"</span>: <span class=\"string\">\"utf8\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">conn = pymysql.connect(**connection)</span><br><span class=\"line\">cursor = conn.cursor()</span><br><span class=\"line\">sql = <span class=\"string\">\"blabla\"</span></span><br><span class=\"line\">cursor.execute(sql)</span><br><span class=\"line\">result = cursor.fetchall()</span><br></pre></td></tr></table></figure>\n<p>最方便的返回莫过于字典了，字段名作为键名，查询出来的值作为键值，与字段的顺序无关。需要在查询的时候返回字典，只需要在连接参数中指定一个 <code>cursorclass</code> 参数为 <code>pymysql.cursors.DictCursor</code> 即可，使用 <code>fetchone()</code> 和 <code>fetchall()</code> 返回的查询结果分别为字典和以每一行为一个字典组成的列表。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"></span><br><span class=\"line\">connection = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"host\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"passwd\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"db\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charset\"</span>: <span class=\"string\">\"utf8\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"cursorclass\"</span>: pymysql.cursors.DictCursor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">conn = pymysql.connect(**connection)</span><br><span class=\"line\">cursor = conn.cursor()</span><br><span class=\"line\">sql = <span class=\"string\">\"blabla\"</span></span><br><span class=\"line\">cursor.execute(sql)</span><br><span class=\"line\">result = cursor.fetchall()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 <code>pymysql</code> 模块在 MySQL 中进行查询时，如果是使用以下这种默认的查询方法时，调用 <code>fetchone()</code> 和 <code>fetchall()</code> 返回的查询结果将会分别是元组和嵌套元组，只能使用下标去访问查询出来的每个字段的值，相当不方便，也不灵活。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"></span><br><span class=\"line\">connection = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"host\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"passwd\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"db\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charset\"</span>: <span class=\"string\">\"utf8\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">conn = pymysql.connect(**connection)</span><br><span class=\"line\">cursor = conn.cursor()</span><br><span class=\"line\">sql = <span class=\"string\">\"blabla\"</span></span><br><span class=\"line\">cursor.execute(sql)</span><br><span class=\"line\">result = cursor.fetchall()</span><br></pre></td></tr></table></figure>\n<p>最方便的返回莫过于字典了，字段名作为键名，查询出来的值作为键值，与字段的顺序无关。需要在查询的时候返回字典，只需要在连接参数中指定一个 <code>cursorclass</code> 参数为 <code>pymysql.cursors.DictCursor</code> 即可，使用 <code>fetchone()</code> 和 <code>fetchall()</code> 返回的查询结果分别为字典和以每一行为一个字典组成的列表。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"></span><br><span class=\"line\">connection = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"host\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"passwd\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"db\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"charset\"</span>: <span class=\"string\">\"utf8\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"cursorclass\"</span>: pymysql.cursors.DictCursor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">conn = pymysql.connect(**connection)</span><br><span class=\"line\">cursor = conn.cursor()</span><br><span class=\"line\">sql = <span class=\"string\">\"blabla\"</span></span><br><span class=\"line\">cursor.execute(sql)</span><br><span class=\"line\">result = cursor.fetchall()</span><br></pre></td></tr></table></figure>\n"},{"title":"在 Vim 内 sudo 保存文件","date":"2016-01-29T05:54:59.000Z","_content":"\n有时候未使用 root 用户在一些较为重要的目录下使用 Vim 编辑文件时，往往会因为权限不足而无法保存，而退出去 `sudo` 后重新编辑又比较浪费时间。这个时候需要在 Vim 中执行下面这个命令，就可以在不退出 Vim 的前提下 `sudo` 保存文件。\n\n```\n:w !sudo tee %\n```\n\n:w 在 Vim 中是保存文件，这是毫无疑问的。\n\n！后面跟一个命令，表示让 Vim 执行一个外部命令。\n\ntee 是一个把 stdin 保存到文件的小工具，具体用法是：\n\n```\ntee {filename}\n```\n\n就能将 stdin 流保存到指定的文件中。\n\n% 是 Vim 当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。\n","source":"_posts/how-to-save-files-using-sudo-without-quitting-vim.md","raw":"---\ntitle: 在 Vim 内 sudo 保存文件\ndate: 2016-01-29 13:54:59\ntags:\n  - vim\n  - 奇技淫巧\n---\n\n有时候未使用 root 用户在一些较为重要的目录下使用 Vim 编辑文件时，往往会因为权限不足而无法保存，而退出去 `sudo` 后重新编辑又比较浪费时间。这个时候需要在 Vim 中执行下面这个命令，就可以在不退出 Vim 的前提下 `sudo` 保存文件。\n\n```\n:w !sudo tee %\n```\n\n:w 在 Vim 中是保存文件，这是毫无疑问的。\n\n！后面跟一个命令，表示让 Vim 执行一个外部命令。\n\ntee 是一个把 stdin 保存到文件的小工具，具体用法是：\n\n```\ntee {filename}\n```\n\n就能将 stdin 流保存到指定的文件中。\n\n% 是 Vim 当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。\n","slug":"how-to-save-files-using-sudo-without-quitting-vim","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0eb0036lixu2ipiyd2e","content":"<p>有时候未使用 root 用户在一些较为重要的目录下使用 Vim 编辑文件时，往往会因为权限不足而无法保存，而退出去 <code>sudo</code> 后重新编辑又比较浪费时间。这个时候需要在 Vim 中执行下面这个命令，就可以在不退出 Vim 的前提下 <code>sudo</code> 保存文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:w !sudo tee %</span><br></pre></td></tr></table></figure>\n<p>:w 在 Vim 中是保存文件，这是毫无疑问的。</p>\n<p>！后面跟一个命令，表示让 Vim 执行一个外部命令。</p>\n<p>tee 是一个把 stdin 保存到文件的小工具，具体用法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tee &#123;filename&#125;</span><br></pre></td></tr></table></figure>\n<p>就能将 stdin 流保存到指定的文件中。</p>\n<p>% 是 Vim 当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有时候未使用 root 用户在一些较为重要的目录下使用 Vim 编辑文件时，往往会因为权限不足而无法保存，而退出去 <code>sudo</code> 后重新编辑又比较浪费时间。这个时候需要在 Vim 中执行下面这个命令，就可以在不退出 Vim 的前提下 <code>sudo</code> 保存文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:w !sudo tee %</span><br></pre></td></tr></table></figure>\n<p>:w 在 Vim 中是保存文件，这是毫无疑问的。</p>\n<p>！后面跟一个命令，表示让 Vim 执行一个外部命令。</p>\n<p>tee 是一个把 stdin 保存到文件的小工具，具体用法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tee &#123;filename&#125;</span><br></pre></td></tr></table></figure>\n<p>就能将 stdin 流保存到指定的文件中。</p>\n<p>% 是 Vim 当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。</p>\n"},{"title":"Selenium 使用 Firefox 无头浏览器","date":"2017-03-04T04:08:59.000Z","_content":"\n目前 Selenium 已经停止对 PhantomJS 的支持。虽然 `webdriver.PhantomJS()` 仍然可以使用，但最佳选择应该是 Firefox 或者 Chrome 对应的无头浏览器，如果需要使用 Firefox 无头浏览器，可以按照以下方式开启：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.firefox.options import Options\n\noptions = Options()\noptions.add_argument(\"-headless\")\ndriver = Firefox(firefox_options=options)\n```\n\n此时建立的 `webdriver` 对象就是一个 Firefox 的无头浏览器，如果需要使用 Chrome 无头浏览器，建立方法与 Firefox 差异不大。与 PhantomJS 无头浏览器相比，Firefox 无头浏览器建立对象的速度比较慢。\n","source":"_posts/how-to-use-headless-browser-of-firefox.md","raw":"---\ntitle: Selenium 使用 Firefox 无头浏览器\ndate: 2017-03-04 12:08:59\ntags:\n  - Firefox\n  - PhantomJS\n  - Python\n  - Selenium\n---\n\n目前 Selenium 已经停止对 PhantomJS 的支持。虽然 `webdriver.PhantomJS()` 仍然可以使用，但最佳选择应该是 Firefox 或者 Chrome 对应的无头浏览器，如果需要使用 Firefox 无头浏览器，可以按照以下方式开启：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.firefox.options import Options\n\noptions = Options()\noptions.add_argument(\"-headless\")\ndriver = Firefox(firefox_options=options)\n```\n\n此时建立的 `webdriver` 对象就是一个 Firefox 的无头浏览器，如果需要使用 Chrome 无头浏览器，建立方法与 Firefox 差异不大。与 PhantomJS 无头浏览器相比，Firefox 无头浏览器建立对象的速度比较慢。\n","slug":"how-to-use-headless-browser-of-firefox","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ec0039lixua0t5xcn9","content":"<p>目前 Selenium 已经停止对 PhantomJS 的支持。虽然 <code>webdriver.PhantomJS()</code> 仍然可以使用，但最佳选择应该是 Firefox 或者 Chrome 对应的无头浏览器，如果需要使用 Firefox 无头浏览器，可以按照以下方式开启：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.firefox.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"></span><br><span class=\"line\">options = Options()</span><br><span class=\"line\">options.add_argument(<span class=\"string\">\"-headless\"</span>)</span><br><span class=\"line\">driver = Firefox(firefox_options=options)</span><br></pre></td></tr></table></figure>\n<p>此时建立的 <code>webdriver</code> 对象就是一个 Firefox 的无头浏览器，如果需要使用 Chrome 无头浏览器，建立方法与 Firefox 差异不大。与 PhantomJS 无头浏览器相比，Firefox 无头浏览器建立对象的速度比较慢。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>目前 Selenium 已经停止对 PhantomJS 的支持。虽然 <code>webdriver.PhantomJS()</code> 仍然可以使用，但最佳选择应该是 Firefox 或者 Chrome 对应的无头浏览器，如果需要使用 Firefox 无头浏览器，可以按照以下方式开启：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.firefox.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"></span><br><span class=\"line\">options = Options()</span><br><span class=\"line\">options.add_argument(<span class=\"string\">\"-headless\"</span>)</span><br><span class=\"line\">driver = Firefox(firefox_options=options)</span><br></pre></td></tr></table></figure>\n<p>此时建立的 <code>webdriver</code> 对象就是一个 Firefox 的无头浏览器，如果需要使用 Chrome 无头浏览器，建立方法与 Firefox 差异不大。与 PhantomJS 无头浏览器相比，Firefox 无头浏览器建立对象的速度比较慢。</p>\n"},{"title":"MySQL 5.6 无口令 dump","date":"2018-04-09T03:44:33.000Z","_content":"\n为了提高安全性，MySQL 5.6 开始在 `mysql` 和 `mysqldump` 命令中明文输入口令时报 Warning: Using apassword on the command line interface can be insecure. 的警告。\n\n在使用 shell 脚本来导出数据的时候，还是不要使用明文口令为妙。对于 MySQL 5.6+，可以在配置文件（CentOS 7 中为 `/etc/my.cnf`）中加入以下内容，再使用 `mysqldump` 就不需要使用口令了。\n\n```\n[mysqldump]\nuser={MySQL 用户名}\npassword={口令}\n```\n","source":"_posts/how-to-use-mysqldump-without-password.md","raw":"---\ntitle: MySQL 5.6 无口令 dump\ndate: 2018-04-09 11:44:33\ntags:\n  - Linux\n  - MySQL\n---\n\n为了提高安全性，MySQL 5.6 开始在 `mysql` 和 `mysqldump` 命令中明文输入口令时报 Warning: Using apassword on the command line interface can be insecure. 的警告。\n\n在使用 shell 脚本来导出数据的时候，还是不要使用明文口令为妙。对于 MySQL 5.6+，可以在配置文件（CentOS 7 中为 `/etc/my.cnf`）中加入以下内容，再使用 `mysqldump` 就不需要使用口令了。\n\n```\n[mysqldump]\nuser={MySQL 用户名}\npassword={口令}\n```\n","slug":"how-to-use-mysqldump-without-password","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ee003blixuz6xkp0ff","content":"<p>为了提高安全性，MySQL 5.6 开始在 <code>mysql</code> 和 <code>mysqldump</code> 命令中明文输入口令时报 Warning: Using apassword on the command line interface can be insecure. 的警告。</p>\n<p>在使用 shell 脚本来导出数据的时候，还是不要使用明文口令为妙。对于 MySQL 5.6+，可以在配置文件（CentOS 7 中为 <code>/etc/my.cnf</code>）中加入以下内容，再使用 <code>mysqldump</code> 就不需要使用口令了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqldump]</span><br><span class=\"line\">user=&#123;MySQL 用户名&#125;</span><br><span class=\"line\">password=&#123;口令&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>为了提高安全性，MySQL 5.6 开始在 <code>mysql</code> 和 <code>mysqldump</code> 命令中明文输入口令时报 Warning: Using apassword on the command line interface can be insecure. 的警告。</p>\n<p>在使用 shell 脚本来导出数据的时候，还是不要使用明文口令为妙。对于 MySQL 5.6+，可以在配置文件（CentOS 7 中为 <code>/etc/my.cnf</code>）中加入以下内容，再使用 <code>mysqldump</code> 就不需要使用口令了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqldump]</span><br><span class=\"line\">user=&#123;MySQL 用户名&#125;</span><br><span class=\"line\">password=&#123;口令&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Saltstack 初始化部署","date":"2018-07-10T06:26:12.000Z","_content":"\n主控端安装 salt-master：\n\n```shell\nyum install -y salt-master\nsystemctl enable salt-master.service\nsystemctl start salt-master.service\n```\n\n被控端安装 salt-minion：\n\n```shell\nyum install -y salt-minion\nsystemctl enable salt-minion.service\nsystemctl start salt-minion.service\n```\n\n在主控端添加 TCP 4505、TCP 4506 的规则，在被控端无需配置防火墙。原理是被控端直接与主控端的 zeroMQ 建立长连接，接受广播到的任务信息并执行。\n\n```shell\niptables -I INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT\niptables -I INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT\n```\n\n在主控端进行角色配置，修改主控端配置文件 `/etc/salt/master`：\n\n```\ninterface: {主控端 IP 地址}\n\n# 自动认证，如果不打开，需要通过 `salt-key -a {id}` 进行 key 的认证\nauto_accept: true\n\n# 指定 Saltstack 文件根目录位置\nfile_roots:\n    base:\n        - /srv/salt\n```\n\n然后重启主控端的 Saltstack 服务。\n\n在被控端进行角色配置，修改被控端配置文件 `/etc/salt/minion`：\n\n```\nmaster: {主控端 IP 地址}\n\n# 修改被控端主机识别 id\nid: {id}\n```\n\n然后重启被控端的 Saltstack 服务。\n","source":"_posts/initiation-of-saltstack.md","raw":"---\ntitle: Saltstack 初始化部署\ndate: 2018-07-10 14:26:12\ntags:\n  - Linux\n  - Python\n  - Saltstack\n---\n\n主控端安装 salt-master：\n\n```shell\nyum install -y salt-master\nsystemctl enable salt-master.service\nsystemctl start salt-master.service\n```\n\n被控端安装 salt-minion：\n\n```shell\nyum install -y salt-minion\nsystemctl enable salt-minion.service\nsystemctl start salt-minion.service\n```\n\n在主控端添加 TCP 4505、TCP 4506 的规则，在被控端无需配置防火墙。原理是被控端直接与主控端的 zeroMQ 建立长连接，接受广播到的任务信息并执行。\n\n```shell\niptables -I INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT\niptables -I INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT\n```\n\n在主控端进行角色配置，修改主控端配置文件 `/etc/salt/master`：\n\n```\ninterface: {主控端 IP 地址}\n\n# 自动认证，如果不打开，需要通过 `salt-key -a {id}` 进行 key 的认证\nauto_accept: true\n\n# 指定 Saltstack 文件根目录位置\nfile_roots:\n    base:\n        - /srv/salt\n```\n\n然后重启主控端的 Saltstack 服务。\n\n在被控端进行角色配置，修改被控端配置文件 `/etc/salt/minion`：\n\n```\nmaster: {主控端 IP 地址}\n\n# 修改被控端主机识别 id\nid: {id}\n```\n\n然后重启被控端的 Saltstack 服务。\n","slug":"initiation-of-saltstack","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0eh003elixucxwvru9n","content":"<p>主控端安装 salt-master：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y salt-master</span><br><span class=\"line\">systemctl enable salt-master.service</span><br><span class=\"line\">systemctl start salt-master.service</span><br></pre></td></tr></table></figure>\n<p>被控端安装 salt-minion：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y salt-minion</span><br><span class=\"line\">systemctl enable salt-minion.service</span><br><span class=\"line\">systemctl start salt-minion.service</span><br></pre></td></tr></table></figure>\n<p>在主控端添加 TCP 4505、TCP 4506 的规则，在被控端无需配置防火墙。原理是被控端直接与主控端的 zeroMQ 建立长连接，接受广播到的任务信息并执行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT</span><br><span class=\"line\">iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>在主控端进行角色配置，修改主控端配置文件 <code>/etc/salt/master</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface: &#123;主控端 IP 地址&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 自动认证，如果不打开，需要通过 `salt-key -a &#123;id&#125;` 进行 key 的认证</span><br><span class=\"line\">auto_accept: true</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定 Saltstack 文件根目录位置</span><br><span class=\"line\">file_roots:</span><br><span class=\"line\">    base:</span><br><span class=\"line\">        - /srv/salt</span><br></pre></td></tr></table></figure>\n<p>然后重启主控端的 Saltstack 服务。</p>\n<p>在被控端进行角色配置，修改被控端配置文件 <code>/etc/salt/minion</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master: &#123;主控端 IP 地址&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改被控端主机识别 id</span><br><span class=\"line\">id: &#123;id&#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启被控端的 Saltstack 服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>主控端安装 salt-master：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y salt-master</span><br><span class=\"line\">systemctl enable salt-master.service</span><br><span class=\"line\">systemctl start salt-master.service</span><br></pre></td></tr></table></figure>\n<p>被控端安装 salt-minion：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y salt-minion</span><br><span class=\"line\">systemctl enable salt-minion.service</span><br><span class=\"line\">systemctl start salt-minion.service</span><br></pre></td></tr></table></figure>\n<p>在主控端添加 TCP 4505、TCP 4506 的规则，在被控端无需配置防火墙。原理是被控端直接与主控端的 zeroMQ 建立长连接，接受广播到的任务信息并执行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT</span><br><span class=\"line\">iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>在主控端进行角色配置，修改主控端配置文件 <code>/etc/salt/master</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface: &#123;主控端 IP 地址&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 自动认证，如果不打开，需要通过 `salt-key -a &#123;id&#125;` 进行 key 的认证</span><br><span class=\"line\">auto_accept: true</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定 Saltstack 文件根目录位置</span><br><span class=\"line\">file_roots:</span><br><span class=\"line\">    base:</span><br><span class=\"line\">        - /srv/salt</span><br></pre></td></tr></table></figure>\n<p>然后重启主控端的 Saltstack 服务。</p>\n<p>在被控端进行角色配置，修改被控端配置文件 <code>/etc/salt/minion</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master: &#123;主控端 IP 地址&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改被控端主机识别 id</span><br><span class=\"line\">id: &#123;id&#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启被控端的 Saltstack 服务。</p>\n"},{"title":"Python 中的列表去重","date":"2015-10-13T04:01:38.000Z","_content":"\n在 Python 中，普通列表可以使用 `set()` 来进行去重，这是使用了集合的唯一性，把列表转换为集合之后保证没有重复的元素，然后再使用 `list()` 把集合转换为列表。但这种方法并不保证元素之间的顺序，而且如果原列表之中含有不能被 hash 的元素（如字典、集合之类），原列表更无法转换为集合类型。\n\n这种情况下应该保持列表的类型，使用 lambda 表达式进行去重：\n\n```python\nimport functools.reduce\nlst = [2, 3, 3, 1]\nfunc = lambda x, y: x if y in x else x + [y]\nfunctools.reduce(func, [[], ] + lst)\n```\n\n这个时候列表 lst 就是 [2, 3, 1] 了。\n","source":"_posts/list-deduplication-in-Python.md","raw":"---\ntitle: Python 中的列表去重\ndate: 2015-10-13 12:01:38\ntags:\n  - Python\n---\n\n在 Python 中，普通列表可以使用 `set()` 来进行去重，这是使用了集合的唯一性，把列表转换为集合之后保证没有重复的元素，然后再使用 `list()` 把集合转换为列表。但这种方法并不保证元素之间的顺序，而且如果原列表之中含有不能被 hash 的元素（如字典、集合之类），原列表更无法转换为集合类型。\n\n这种情况下应该保持列表的类型，使用 lambda 表达式进行去重：\n\n```python\nimport functools.reduce\nlst = [2, 3, 3, 1]\nfunc = lambda x, y: x if y in x else x + [y]\nfunctools.reduce(func, [[], ] + lst)\n```\n\n这个时候列表 lst 就是 [2, 3, 1] 了。\n","slug":"list-deduplication-in-Python","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ei003glixusqcxuksk","content":"<p>在 Python 中，普通列表可以使用 <code>set()</code> 来进行去重，这是使用了集合的唯一性，把列表转换为集合之后保证没有重复的元素，然后再使用 <code>list()</code> 把集合转换为列表。但这种方法并不保证元素之间的顺序，而且如果原列表之中含有不能被 hash 的元素（如字典、集合之类），原列表更无法转换为集合类型。</p>\n<p>这种情况下应该保持列表的类型，使用 lambda 表达式进行去重：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools.reduce</span><br><span class=\"line\">lst = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">func = <span class=\"keyword\">lambda</span> x, y: x <span class=\"keyword\">if</span> y <span class=\"keyword\">in</span> x <span class=\"keyword\">else</span> x + [y]</span><br><span class=\"line\">functools.reduce(func, [[], ] + lst)</span><br></pre></td></tr></table></figure>\n<p>这个时候列表 lst 就是 [2, 3, 1] 了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Python 中，普通列表可以使用 <code>set()</code> 来进行去重，这是使用了集合的唯一性，把列表转换为集合之后保证没有重复的元素，然后再使用 <code>list()</code> 把集合转换为列表。但这种方法并不保证元素之间的顺序，而且如果原列表之中含有不能被 hash 的元素（如字典、集合之类），原列表更无法转换为集合类型。</p>\n<p>这种情况下应该保持列表的类型，使用 lambda 表达式进行去重：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools.reduce</span><br><span class=\"line\">lst = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">func = <span class=\"keyword\">lambda</span> x, y: x <span class=\"keyword\">if</span> y <span class=\"keyword\">in</span> x <span class=\"keyword\">else</span> x + [y]</span><br><span class=\"line\">functools.reduce(func, [[], ] + lst)</span><br></pre></td></tr></table></figure>\n<p>这个时候列表 lst 就是 [2, 3, 1] 了。</p>\n"},{"title":"在不同机器上维护 hexo github blog 的方法和坑","date":"2019-03-27T07:28:04.000Z","_content":"\n常规的更新文章或者更新主题之类的方法就不写了。由于是托管在 GitHub 上的 hexo 博客，不像是一般部署在一台固定机器上的 WordPress 那样从哪里都可以 ssh 上去管理。因此有必要记录一下摸索出来的过程。\n\n## 方法\n\n主要是因为 hexo 实现 github blog 是通过 `source/` 下一系列的 markdown 文件用于记录文章内容，再通过 `hexo g` 命令生成美观的静态页面在浏览器中显示，两者是缺一不可的：如果只有 markdown 文件，也不是不能读，但这样和读 `README.md` 没什么区别了，起不到博客的作用；如果只有静态页面文件，倒是像个博客了，但是如果要更新，改一次就累死人了。按照我的理解，前者相当于源码，后者相当于由源码编译出来的二进制文件，因此要两手抓，两手都要硬，通过两个分支来对整个 hexo github blog 进行管理就可以了。\n\n在写完 markdown 文件之后，执行一下 `hexo clean`，把已经生成的静态页面文件都清理掉（据我理解实际上是把 `public/` 删掉了，但不确定除此以外还有没有清理其它内容）。这个时候目录下的内容基本都是“源码”了，将这个状态下的整个目录 `git push` 到项目的某个次要分支。之后都是通过这个次要分支来维护每次更新，只要在 `git clone` 下来之后 `git checkout` 到这个分支就可以了。\n\n维护完次要分支之后，就可以使用 `hexo g` 来生成静态页面文件了，这个过程视机器性能而定，快则几秒钟，慢则几分钟，在我的 VPS 上甚至有可能被 kill……在生成完静态页面文件之后，就可以直接部署到 GitHub 上了。前提是要有 hexo-deployer-git 这一个插件并且在配置文件里已经配置好 GitHub 的用户名和分支（这里需要用 master 分支），执行 `hexo d` 就可以直接部署上去了。这个过程的实质是把 `public/` 里面的内容 push 到 master 分支了。\n\n这样，静态页面文件通过 master 分支维护，访问者访问 foo.github.io 时访问的也是 master 分支的静态页面文件，而 markdown 文件则隐藏在次要分支的 `source/` 中。\n\n## 坑\n\n* 主题目录文件丢失：如果是使用 next 之类的从 GitHub 上 clone 下来的主题，那么主题目录下就会有 `.git` 目录，而整个项目根目录也有一个 `.git` 目录，这就会导致在 push 到 GitHub 的时候会忽略掉整个主题目录的文件，下一次 clone 下来的时候主题目录就是空的了。解决方法：移除主题目录中的 `.git*` 目录/文件，避免出现嵌套 git 的情况。\n\n* `hexo d` 将整个项目根目录 push 到 master 分支：这种情况一般是在不同的位置（包括不同机器，或者同一台机器的不同目录）clone 项目导致的。在项目根目录下会有 `.deploy_git/`，这个目录下的内容和 `public/` 一样，在这种情况下会产生混乱。解决方法：在 `hexo clean` 之前把 `.deploy_git/` 目录删除，余下步骤照常执行。\n\n* 更新内容后成功部署，但刷新页面不更新：由于是静态页面，因此浏览器会使用缓存。解决方法：ctrl + F5 刷新即可。\n","source":"_posts/methods-and-pitfalls-on-maintaining-hexo-github-blog-from-multiple-devices.md","raw":"---\ntitle: 在不同机器上维护 hexo github blog 的方法和坑\ndate: 2019-03-27 15:28:04\ntags:\n  - 坑\n  - git\n  - GitHub\n  - hexo\n---\n\n常规的更新文章或者更新主题之类的方法就不写了。由于是托管在 GitHub 上的 hexo 博客，不像是一般部署在一台固定机器上的 WordPress 那样从哪里都可以 ssh 上去管理。因此有必要记录一下摸索出来的过程。\n\n## 方法\n\n主要是因为 hexo 实现 github blog 是通过 `source/` 下一系列的 markdown 文件用于记录文章内容，再通过 `hexo g` 命令生成美观的静态页面在浏览器中显示，两者是缺一不可的：如果只有 markdown 文件，也不是不能读，但这样和读 `README.md` 没什么区别了，起不到博客的作用；如果只有静态页面文件，倒是像个博客了，但是如果要更新，改一次就累死人了。按照我的理解，前者相当于源码，后者相当于由源码编译出来的二进制文件，因此要两手抓，两手都要硬，通过两个分支来对整个 hexo github blog 进行管理就可以了。\n\n在写完 markdown 文件之后，执行一下 `hexo clean`，把已经生成的静态页面文件都清理掉（据我理解实际上是把 `public/` 删掉了，但不确定除此以外还有没有清理其它内容）。这个时候目录下的内容基本都是“源码”了，将这个状态下的整个目录 `git push` 到项目的某个次要分支。之后都是通过这个次要分支来维护每次更新，只要在 `git clone` 下来之后 `git checkout` 到这个分支就可以了。\n\n维护完次要分支之后，就可以使用 `hexo g` 来生成静态页面文件了，这个过程视机器性能而定，快则几秒钟，慢则几分钟，在我的 VPS 上甚至有可能被 kill……在生成完静态页面文件之后，就可以直接部署到 GitHub 上了。前提是要有 hexo-deployer-git 这一个插件并且在配置文件里已经配置好 GitHub 的用户名和分支（这里需要用 master 分支），执行 `hexo d` 就可以直接部署上去了。这个过程的实质是把 `public/` 里面的内容 push 到 master 分支了。\n\n这样，静态页面文件通过 master 分支维护，访问者访问 foo.github.io 时访问的也是 master 分支的静态页面文件，而 markdown 文件则隐藏在次要分支的 `source/` 中。\n\n## 坑\n\n* 主题目录文件丢失：如果是使用 next 之类的从 GitHub 上 clone 下来的主题，那么主题目录下就会有 `.git` 目录，而整个项目根目录也有一个 `.git` 目录，这就会导致在 push 到 GitHub 的时候会忽略掉整个主题目录的文件，下一次 clone 下来的时候主题目录就是空的了。解决方法：移除主题目录中的 `.git*` 目录/文件，避免出现嵌套 git 的情况。\n\n* `hexo d` 将整个项目根目录 push 到 master 分支：这种情况一般是在不同的位置（包括不同机器，或者同一台机器的不同目录）clone 项目导致的。在项目根目录下会有 `.deploy_git/`，这个目录下的内容和 `public/` 一样，在这种情况下会产生混乱。解决方法：在 `hexo clean` 之前把 `.deploy_git/` 目录删除，余下步骤照常执行。\n\n* 更新内容后成功部署，但刷新页面不更新：由于是静态页面，因此浏览器会使用缓存。解决方法：ctrl + F5 刷新即可。\n","slug":"methods-and-pitfalls-on-maintaining-hexo-github-blog-from-multiple-devices","published":1,"updated":"2019-03-27T16:25:10.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ek003jlixu06zp9kkw","content":"<p>常规的更新文章或者更新主题之类的方法就不写了。由于是托管在 GitHub 上的 hexo 博客，不像是一般部署在一台固定机器上的 WordPress 那样从哪里都可以 ssh 上去管理。因此有必要记录一下摸索出来的过程。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>主要是因为 hexo 实现 github blog 是通过 <code>source/</code> 下一系列的 markdown 文件用于记录文章内容，再通过 <code>hexo g</code> 命令生成美观的静态页面在浏览器中显示，两者是缺一不可的：如果只有 markdown 文件，也不是不能读，但这样和读 <code>README.md</code> 没什么区别了，起不到博客的作用；如果只有静态页面文件，倒是像个博客了，但是如果要更新，改一次就累死人了。按照我的理解，前者相当于源码，后者相当于由源码编译出来的二进制文件，因此要两手抓，两手都要硬，通过两个分支来对整个 hexo github blog 进行管理就可以了。</p>\n<p>在写完 markdown 文件之后，执行一下 <code>hexo clean</code>，把已经生成的静态页面文件都清理掉（据我理解实际上是把 <code>public/</code> 删掉了，但不确定除此以外还有没有清理其它内容）。这个时候目录下的内容基本都是“源码”了，将这个状态下的整个目录 <code>git push</code> 到项目的某个次要分支。之后都是通过这个次要分支来维护每次更新，只要在 <code>git clone</code> 下来之后 <code>git checkout</code> 到这个分支就可以了。</p>\n<p>维护完次要分支之后，就可以使用 <code>hexo g</code> 来生成静态页面文件了，这个过程视机器性能而定，快则几秒钟，慢则几分钟，在我的 VPS 上甚至有可能被 kill……在生成完静态页面文件之后，就可以直接部署到 GitHub 上了。前提是要有 hexo-deployer-git 这一个插件并且在配置文件里已经配置好 GitHub 的用户名和分支（这里需要用 master 分支），执行 <code>hexo d</code> 就可以直接部署上去了。这个过程的实质是把 <code>public/</code> 里面的内容 push 到 master 分支了。</p>\n<p>这样，静态页面文件通过 master 分支维护，访问者访问 foo.github.io 时访问的也是 master 分支的静态页面文件，而 markdown 文件则隐藏在次要分支的 <code>source/</code> 中。</p>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ul>\n<li><p>主题目录文件丢失：如果是使用 next 之类的从 GitHub 上 clone 下来的主题，那么主题目录下就会有 <code>.git</code> 目录，而整个项目根目录也有一个 <code>.git</code> 目录，这就会导致在 push 到 GitHub 的时候会忽略掉整个主题目录的文件，下一次 clone 下来的时候主题目录就是空的了。解决方法：移除主题目录中的 <code>.git*</code> 目录/文件，避免出现嵌套 git 的情况。</p>\n</li>\n<li><p><code>hexo d</code> 将整个项目根目录 push 到 master 分支：这种情况一般是在不同的位置（包括不同机器，或者同一台机器的不同目录）clone 项目导致的。在项目根目录下会有 <code>.deploy_git/</code>，这个目录下的内容和 <code>public/</code> 一样，在这种情况下会产生混乱。解决方法：在 <code>hexo clean</code> 之前把 <code>.deploy_git/</code> 目录删除，余下步骤照常执行。</p>\n</li>\n<li><p>更新内容后成功部署，但刷新页面不更新：由于是静态页面，因此浏览器会使用缓存。解决方法：ctrl + F5 刷新即可。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>常规的更新文章或者更新主题之类的方法就不写了。由于是托管在 GitHub 上的 hexo 博客，不像是一般部署在一台固定机器上的 WordPress 那样从哪里都可以 ssh 上去管理。因此有必要记录一下摸索出来的过程。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>主要是因为 hexo 实现 github blog 是通过 <code>source/</code> 下一系列的 markdown 文件用于记录文章内容，再通过 <code>hexo g</code> 命令生成美观的静态页面在浏览器中显示，两者是缺一不可的：如果只有 markdown 文件，也不是不能读，但这样和读 <code>README.md</code> 没什么区别了，起不到博客的作用；如果只有静态页面文件，倒是像个博客了，但是如果要更新，改一次就累死人了。按照我的理解，前者相当于源码，后者相当于由源码编译出来的二进制文件，因此要两手抓，两手都要硬，通过两个分支来对整个 hexo github blog 进行管理就可以了。</p>\n<p>在写完 markdown 文件之后，执行一下 <code>hexo clean</code>，把已经生成的静态页面文件都清理掉（据我理解实际上是把 <code>public/</code> 删掉了，但不确定除此以外还有没有清理其它内容）。这个时候目录下的内容基本都是“源码”了，将这个状态下的整个目录 <code>git push</code> 到项目的某个次要分支。之后都是通过这个次要分支来维护每次更新，只要在 <code>git clone</code> 下来之后 <code>git checkout</code> 到这个分支就可以了。</p>\n<p>维护完次要分支之后，就可以使用 <code>hexo g</code> 来生成静态页面文件了，这个过程视机器性能而定，快则几秒钟，慢则几分钟，在我的 VPS 上甚至有可能被 kill……在生成完静态页面文件之后，就可以直接部署到 GitHub 上了。前提是要有 hexo-deployer-git 这一个插件并且在配置文件里已经配置好 GitHub 的用户名和分支（这里需要用 master 分支），执行 <code>hexo d</code> 就可以直接部署上去了。这个过程的实质是把 <code>public/</code> 里面的内容 push 到 master 分支了。</p>\n<p>这样，静态页面文件通过 master 分支维护，访问者访问 foo.github.io 时访问的也是 master 分支的静态页面文件，而 markdown 文件则隐藏在次要分支的 <code>source/</code> 中。</p>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ul>\n<li><p>主题目录文件丢失：如果是使用 next 之类的从 GitHub 上 clone 下来的主题，那么主题目录下就会有 <code>.git</code> 目录，而整个项目根目录也有一个 <code>.git</code> 目录，这就会导致在 push 到 GitHub 的时候会忽略掉整个主题目录的文件，下一次 clone 下来的时候主题目录就是空的了。解决方法：移除主题目录中的 <code>.git*</code> 目录/文件，避免出现嵌套 git 的情况。</p>\n</li>\n<li><p><code>hexo d</code> 将整个项目根目录 push 到 master 分支：这种情况一般是在不同的位置（包括不同机器，或者同一台机器的不同目录）clone 项目导致的。在项目根目录下会有 <code>.deploy_git/</code>，这个目录下的内容和 <code>public/</code> 一样，在这种情况下会产生混乱。解决方法：在 <code>hexo clean</code> 之前把 <code>.deploy_git/</code> 目录删除，余下步骤照常执行。</p>\n</li>\n<li><p>更新内容后成功部署，但刷新页面不更新：由于是静态页面，因此浏览器会使用缓存。解决方法：ctrl + F5 刷新即可。</p>\n</li>\n</ul>\n"},{"title":"Python 的新式类和经典类","date":"2015-08-19T03:50:09.000Z","_content":"\n在 Python 中声明一个类的时候，如果这个类继承 `object` 类，这个类就是新式类；如果这个类没有继承任何类，这个类就是经典类。\n\n```python\n# 声明一个新式类\nclass new_class(object)：\n    pass\n\n# 声明一个经典类\nclass classic_class(object):\n    pass\n```\n\nPython 的新式类已经兼容经典类，而且新式类已经解决了经典类中关于多继承的缺陷，因此在 Python 中推荐使用新式类。\n\n```python\nclass A:\n    def foo(self):\n        print('called A.foo()')\n\nclass B(A):\n    pass\n\nclass C(A):\n    def foo(self):\n        print('called C.foo()')\n\nclass D(B, C):\n    pass\n\nif __name__ == '__main__':\n    d = D()\n    d.foo()\n```\n\nB、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 `foo()` 方法。\n\n如果 A 是经典类，当调用 D 的实例的 `foo()` 方法时，Python 会按照深度优先的方法去搜索 `foo()` ，路径是 B-A-C ，执行的是 A 中的 `foo()`；\n\n如果 A 是新式类，当调用 D 的实例的 `foo()` 方法时，Python 会按照广度优先的方法去搜索 `foo()` ，路径是 B-C-A ，执行的是 C 中的 `foo()`。\n\n因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 `foo()` 更加合理，因此新式类对多继承的处理更为合乎逻辑。\n\n在 Python 3.x 中的新式类已经兼容了经典类，无论 A 是否继承 `object` 类， D 实例中的 `foo()` 都会执行 C 中的 `foo()`。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 `object` 类。\n","source":"_posts/new-class-and-classic-class-in-Python.md","raw":"---\ntitle: Python 的新式类和经典类\ndate: 2015-08-19 11:50:09\ntags:\n  - Python\n  - 类\n---\n\n在 Python 中声明一个类的时候，如果这个类继承 `object` 类，这个类就是新式类；如果这个类没有继承任何类，这个类就是经典类。\n\n```python\n# 声明一个新式类\nclass new_class(object)：\n    pass\n\n# 声明一个经典类\nclass classic_class(object):\n    pass\n```\n\nPython 的新式类已经兼容经典类，而且新式类已经解决了经典类中关于多继承的缺陷，因此在 Python 中推荐使用新式类。\n\n```python\nclass A:\n    def foo(self):\n        print('called A.foo()')\n\nclass B(A):\n    pass\n\nclass C(A):\n    def foo(self):\n        print('called C.foo()')\n\nclass D(B, C):\n    pass\n\nif __name__ == '__main__':\n    d = D()\n    d.foo()\n```\n\nB、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 `foo()` 方法。\n\n如果 A 是经典类，当调用 D 的实例的 `foo()` 方法时，Python 会按照深度优先的方法去搜索 `foo()` ，路径是 B-A-C ，执行的是 A 中的 `foo()`；\n\n如果 A 是新式类，当调用 D 的实例的 `foo()` 方法时，Python 会按照广度优先的方法去搜索 `foo()` ，路径是 B-C-A ，执行的是 C 中的 `foo()`。\n\n因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 `foo()` 更加合理，因此新式类对多继承的处理更为合乎逻辑。\n\n在 Python 3.x 中的新式类已经兼容了经典类，无论 A 是否继承 `object` 类， D 实例中的 `foo()` 都会执行 C 中的 `foo()`。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 `object` 类。\n","slug":"new-class-and-classic-class-in-Python","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0en003llixu4texq9qc","content":"<p>在 Python 中声明一个类的时候，如果这个类继承 <code>object</code> 类，这个类就是新式类；如果这个类没有继承任何类，这个类就是经典类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 声明一个新式类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">new_class</span><span class=\"params\">(object)</span>：</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">pass</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"># 声明一个经典类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">classic_class</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>Python 的新式类已经兼容经典类，而且新式类已经解决了经典类中关于多继承的缺陷，因此在 Python 中推荐使用新式类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'called A.foo()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'called C.foo()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(B, C)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    d = D()</span><br><span class=\"line\">    d.foo()</span><br></pre></td></tr></table></figure>\n<p>B、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 <code>foo()</code> 方法。</p>\n<p>如果 A 是经典类，当调用 D 的实例的 <code>foo()</code> 方法时，Python 会按照深度优先的方法去搜索 <code>foo()</code> ，路径是 B-A-C ，执行的是 A 中的 <code>foo()</code>；</p>\n<p>如果 A 是新式类，当调用 D 的实例的 <code>foo()</code> 方法时，Python 会按照广度优先的方法去搜索 <code>foo()</code> ，路径是 B-C-A ，执行的是 C 中的 <code>foo()</code>。</p>\n<p>因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 <code>foo()</code> 更加合理，因此新式类对多继承的处理更为合乎逻辑。</p>\n<p>在 Python 3.x 中的新式类已经兼容了经典类，无论 A 是否继承 <code>object</code> 类， D 实例中的 <code>foo()</code> 都会执行 C 中的 <code>foo()</code>。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 <code>object</code> 类。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Python 中声明一个类的时候，如果这个类继承 <code>object</code> 类，这个类就是新式类；如果这个类没有继承任何类，这个类就是经典类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 声明一个新式类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">new_class</span><span class=\"params\">(object)</span>：</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">pass</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"># 声明一个经典类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">classic_class</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>Python 的新式类已经兼容经典类，而且新式类已经解决了经典类中关于多继承的缺陷，因此在 Python 中推荐使用新式类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'called A.foo()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'called C.foo()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(B, C)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    d = D()</span><br><span class=\"line\">    d.foo()</span><br></pre></td></tr></table></figure>\n<p>B、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 <code>foo()</code> 方法。</p>\n<p>如果 A 是经典类，当调用 D 的实例的 <code>foo()</code> 方法时，Python 会按照深度优先的方法去搜索 <code>foo()</code> ，路径是 B-A-C ，执行的是 A 中的 <code>foo()</code>；</p>\n<p>如果 A 是新式类，当调用 D 的实例的 <code>foo()</code> 方法时，Python 会按照广度优先的方法去搜索 <code>foo()</code> ，路径是 B-C-A ，执行的是 C 中的 <code>foo()</code>。</p>\n<p>因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 <code>foo()</code> 更加合理，因此新式类对多继承的处理更为合乎逻辑。</p>\n<p>在 Python 3.x 中的新式类已经兼容了经典类，无论 A 是否继承 <code>object</code> 类， D 实例中的 <code>foo()</code> 都会执行 C 中的 <code>foo()</code>。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 <code>object</code> 类。</p>\n"},{"title":"在 WordPress 上在线安装插件的坑","date":"2015-02-13T02:38:25.000Z","_content":"\n通过 WordPress 在线安装插件，目前遇到过两个坑：\n\n* 如果通过 WordPress 在线安装插件，可能会遇到“无法连接到文件系统，请确认您的凭据”的提示。这种情况下一般不是 FTP 账号密码错误，而是安装插件所需要的操作权限不够。需要把 `wordpress/`、`wordpress/wp-content/`、`wordpress/wp-content/plugins/` 这三个目录的权限设置为 777，并且在配置文件 `wp-config.php` 中加入以下几行：\n\n```php\ndefine(\"FS_METHOD\",\"direct\");\ndefine(\"FS_CHMOD_DIR\", 0777);\ndefine(\"FS_CHMOD_FILE\", 0777);\n```\n\n* 开始安装后，可能会提示安装失败。这种情况下很可能是 DNS 被封的原因导致，把系统配置文件 `/etc/resolv.conf` 中的两个 `nameserver` 值改为 Google 的 8.8.8.8 和 8.8.4.4 后保存即可。\n","source":"_posts/pitfalls-of-online-installing-plugin-in-WordPress.md","raw":"---\ntitle: 在 WordPress 上在线安装插件的坑\ndate: 2015-02-13 10:38:25\ntags:\n  - PHP\n  - WordPress\n  - 坑\n---\n\n通过 WordPress 在线安装插件，目前遇到过两个坑：\n\n* 如果通过 WordPress 在线安装插件，可能会遇到“无法连接到文件系统，请确认您的凭据”的提示。这种情况下一般不是 FTP 账号密码错误，而是安装插件所需要的操作权限不够。需要把 `wordpress/`、`wordpress/wp-content/`、`wordpress/wp-content/plugins/` 这三个目录的权限设置为 777，并且在配置文件 `wp-config.php` 中加入以下几行：\n\n```php\ndefine(\"FS_METHOD\",\"direct\");\ndefine(\"FS_CHMOD_DIR\", 0777);\ndefine(\"FS_CHMOD_FILE\", 0777);\n```\n\n* 开始安装后，可能会提示安装失败。这种情况下很可能是 DNS 被封的原因导致，把系统配置文件 `/etc/resolv.conf` 中的两个 `nameserver` 值改为 Google 的 8.8.8.8 和 8.8.4.4 后保存即可。\n","slug":"pitfalls-of-online-installing-plugin-in-WordPress","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ep003nlixuefrz6szh","content":"<p>通过 WordPress 在线安装插件，目前遇到过两个坑：</p>\n<ul>\n<li>如果通过 WordPress 在线安装插件，可能会遇到“无法连接到文件系统，请确认您的凭据”的提示。这种情况下一般不是 FTP 账号密码错误，而是安装插件所需要的操作权限不够。需要把 <code>wordpress/</code>、<code>wordpress/wp-content/</code>、<code>wordpress/wp-content/plugins/</code> 这三个目录的权限设置为 777，并且在配置文件 <code>wp-config.php</code> 中加入以下几行：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"FS_METHOD\"</span>,<span class=\"string\">\"direct\"</span>);</span><br><span class=\"line\">define(<span class=\"string\">\"FS_CHMOD_DIR\"</span>, <span class=\"number\">0777</span>);</span><br><span class=\"line\">define(<span class=\"string\">\"FS_CHMOD_FILE\"</span>, <span class=\"number\">0777</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开始安装后，可能会提示安装失败。这种情况下很可能是 DNS 被封的原因导致，把系统配置文件 <code>/etc/resolv.conf</code> 中的两个 <code>nameserver</code> 值改为 Google 的 8.8.8.8 和 8.8.4.4 后保存即可。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>通过 WordPress 在线安装插件，目前遇到过两个坑：</p>\n<ul>\n<li>如果通过 WordPress 在线安装插件，可能会遇到“无法连接到文件系统，请确认您的凭据”的提示。这种情况下一般不是 FTP 账号密码错误，而是安装插件所需要的操作权限不够。需要把 <code>wordpress/</code>、<code>wordpress/wp-content/</code>、<code>wordpress/wp-content/plugins/</code> 这三个目录的权限设置为 777，并且在配置文件 <code>wp-config.php</code> 中加入以下几行：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"FS_METHOD\"</span>,<span class=\"string\">\"direct\"</span>);</span><br><span class=\"line\">define(<span class=\"string\">\"FS_CHMOD_DIR\"</span>, <span class=\"number\">0777</span>);</span><br><span class=\"line\">define(<span class=\"string\">\"FS_CHMOD_FILE\"</span>, <span class=\"number\">0777</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开始安装后，可能会提示安装失败。这种情况下很可能是 DNS 被封的原因导致，把系统配置文件 <code>/etc/resolv.conf</code> 中的两个 <code>nameserver</code> 值改为 Google 的 8.8.8.8 和 8.8.4.4 后保存即可。</li>\n</ul>\n"},{"title":"为远程主机设置别名","date":"2015-03-01T03:38:55.000Z","_content":"\n在进行 `ssh` 或者 `scp` 的时候，为了减少输入量和降低输入错误的概率，可以为常用的远程主机设置别名。\n\n方法是修改 `~/.ssh/config` 文件（如果不存在这个文件则创建），指定以下几个字段值即可：\n\n```\nhost {自定义的主机别名}\nhostname {主机的 IP}\nport {连接主机的端口}\nuser {连接主机的用户名}\n```\n","source":"_posts/set-alias-for-remote-hosts.md","raw":"---\ntitle: 为远程主机设置别名\ndate: 2015-03-01 11:38:55\ntags:\n  - Linux\n  - ssh\n---\n\n在进行 `ssh` 或者 `scp` 的时候，为了减少输入量和降低输入错误的概率，可以为常用的远程主机设置别名。\n\n方法是修改 `~/.ssh/config` 文件（如果不存在这个文件则创建），指定以下几个字段值即可：\n\n```\nhost {自定义的主机别名}\nhostname {主机的 IP}\nport {连接主机的端口}\nuser {连接主机的用户名}\n```\n","slug":"set-alias-for-remote-hosts","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0eq003plixuywbp2tl4","content":"<p>在进行 <code>ssh</code> 或者 <code>scp</code> 的时候，为了减少输入量和降低输入错误的概率，可以为常用的远程主机设置别名。</p>\n<p>方法是修改 <code>~/.ssh/config</code> 文件（如果不存在这个文件则创建），指定以下几个字段值即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host &#123;自定义的主机别名&#125;</span><br><span class=\"line\">hostname &#123;主机的 IP&#125;</span><br><span class=\"line\">port &#123;连接主机的端口&#125;</span><br><span class=\"line\">user &#123;连接主机的用户名&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在进行 <code>ssh</code> 或者 <code>scp</code> 的时候，为了减少输入量和降低输入错误的概率，可以为常用的远程主机设置别名。</p>\n<p>方法是修改 <code>~/.ssh/config</code> 文件（如果不存在这个文件则创建），指定以下几个字段值即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host &#123;自定义的主机别名&#125;</span><br><span class=\"line\">hostname &#123;主机的 IP&#125;</span><br><span class=\"line\">port &#123;连接主机的端口&#125;</span><br><span class=\"line\">user &#123;连接主机的用户名&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Ansible 的各个模块及相关参数","date":"2017-02-16T04:08:32.000Z","_content":"\n* command：在被控节点上执行命令\n  * command 是 Ansible 的默认模块，可以不通过 -m 指明使用该模块\n  * 可以直接执行 -a 中的命令，但由于不通过 shell 执行，所以与 shell 有关的变量、重定向、管道等功能无法使用\n  * kwargs：\n    * chdir：目录名。首先跳转到该目录后再执行命令\n* shell：在被控节点上通过 shell 执行命令\n  * 与 command 模块基本相同，而且由于通过 shell 执行，所以可以使用变量、重定向、管道等功能，并且使用所选用户的默认 shell\n  * kwargs：\n    * chdir：目录名。首先跳转到该目录后再执行命令\n* script：在被控节点上执行主控节点上的脚本\n  * 直接在 -a 中指明主控节点上的脚本位置即可，且这个脚本需要有 x 权限\n* ping：检测某个目的节点是否响应\n  * 这个检测过程并不向目的节点发送 ping 包，只是反映目的节点是否可控，目的节点即使在可达的情况下也不一定可控\n  * 不指定 -a\n* yum：在被控节点上通过 yum 管理软件\n  * kwargs：\n    * name：软件包名称。如果为 * ，则执行 yum -y updtae；名称前面加 @ 为安装软件包组；名称前面加 @^ 为安装环境组；这个参数也可以是 url，此时通过指定的 rpm 文件进行安装\n    * state：软件安装状态。如果为 present、latest 或 installed 则执行安装软件；如果为 absent 或 removed 则执行移除软件\n* copy：从主控节点向被控节点复制文件\n  * kwargs：\n    * src：主控节点的文件位置。可以是绝对路径或相对路径，如果是一个目录，将会进行递归复制\n    * dest：被控节点的文件位置。必须为绝对路径，且如果 src 是一个目录，dest 也必须为一个目录\n    * directory_mode：递归设定目录的权限。默认为系统默认权限\n    * force：是否覆盖。默认为 yes，即当目标文件和源文件不同时，强制覆盖文件，如果为 no 则只有在目标文件不存在时才复制\n* fetch：从被控节点向主控节点复制文件\n  * 与 copy 模块并不仅仅是方向相反，copy 可以复制文件和目录，而 fetch 模块只能复制文件\n  * kwargs：\n    * src：被控节点的文件位置。\n    * dest：文件在主控节点中的保存位置。真实的保存目录需要注意，如果指定了 dest 参数为 /foo，被控节点为 bar，则文件将会保存在 /foo/bar/ 下\n    * fail_on_missing：被控节点中的文件不存在时是否报错。默认为 no，当为 no 时即使文件不存在也不会报错，此时主控节点也不会创建相应的目录\n* synchronize：通过 rsync 传输文件\n  * kwargs：\n    * src：源文件的位置。\n    * dest：目标文件的位置。\n    * mode：推送模式或拉取模式。默认为推送模式 push，从主控节点向被控节点传输文件\n    * delete：是否删除文件使两方一致。两方的一致性以推送方为准，默认为 no\n* service：用于管理服务\n  * kwargs：\n    * name：服务名称。\n    * state：对服务的操作。包括启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded)\n    * enabled：是否开机启动。且 state 和 enabled 两个参数中至少要有一个\n    * sleep：在 state=restarted 的时候，指定在 stop 和 start 之间暂停的秒数\n* get_url：通过 http/https/ftp 下载文件\n  * kwargs：\n    * url：下载的 uri\n    * dest：文件下载目标位置。如果 dest 为目录，则使用服务器提供的文件名，或者如果没有提供，将使用远程服务器上的 url 的基本名称。\n    * timeout：设置超时时间。默认为 10s\n    * headers：指定访问时的请求头。以 key: value 的格式填写\n\n","source":"_posts/some-modules-and-related-parameters-in-Ansible.md","raw":"---\ntitle: Ansible 的各个模块及相关参数\ndate: 2017-02-16 12:08:32\ntags:\n  - Ansible\n---\n\n* command：在被控节点上执行命令\n  * command 是 Ansible 的默认模块，可以不通过 -m 指明使用该模块\n  * 可以直接执行 -a 中的命令，但由于不通过 shell 执行，所以与 shell 有关的变量、重定向、管道等功能无法使用\n  * kwargs：\n    * chdir：目录名。首先跳转到该目录后再执行命令\n* shell：在被控节点上通过 shell 执行命令\n  * 与 command 模块基本相同，而且由于通过 shell 执行，所以可以使用变量、重定向、管道等功能，并且使用所选用户的默认 shell\n  * kwargs：\n    * chdir：目录名。首先跳转到该目录后再执行命令\n* script：在被控节点上执行主控节点上的脚本\n  * 直接在 -a 中指明主控节点上的脚本位置即可，且这个脚本需要有 x 权限\n* ping：检测某个目的节点是否响应\n  * 这个检测过程并不向目的节点发送 ping 包，只是反映目的节点是否可控，目的节点即使在可达的情况下也不一定可控\n  * 不指定 -a\n* yum：在被控节点上通过 yum 管理软件\n  * kwargs：\n    * name：软件包名称。如果为 * ，则执行 yum -y updtae；名称前面加 @ 为安装软件包组；名称前面加 @^ 为安装环境组；这个参数也可以是 url，此时通过指定的 rpm 文件进行安装\n    * state：软件安装状态。如果为 present、latest 或 installed 则执行安装软件；如果为 absent 或 removed 则执行移除软件\n* copy：从主控节点向被控节点复制文件\n  * kwargs：\n    * src：主控节点的文件位置。可以是绝对路径或相对路径，如果是一个目录，将会进行递归复制\n    * dest：被控节点的文件位置。必须为绝对路径，且如果 src 是一个目录，dest 也必须为一个目录\n    * directory_mode：递归设定目录的权限。默认为系统默认权限\n    * force：是否覆盖。默认为 yes，即当目标文件和源文件不同时，强制覆盖文件，如果为 no 则只有在目标文件不存在时才复制\n* fetch：从被控节点向主控节点复制文件\n  * 与 copy 模块并不仅仅是方向相反，copy 可以复制文件和目录，而 fetch 模块只能复制文件\n  * kwargs：\n    * src：被控节点的文件位置。\n    * dest：文件在主控节点中的保存位置。真实的保存目录需要注意，如果指定了 dest 参数为 /foo，被控节点为 bar，则文件将会保存在 /foo/bar/ 下\n    * fail_on_missing：被控节点中的文件不存在时是否报错。默认为 no，当为 no 时即使文件不存在也不会报错，此时主控节点也不会创建相应的目录\n* synchronize：通过 rsync 传输文件\n  * kwargs：\n    * src：源文件的位置。\n    * dest：目标文件的位置。\n    * mode：推送模式或拉取模式。默认为推送模式 push，从主控节点向被控节点传输文件\n    * delete：是否删除文件使两方一致。两方的一致性以推送方为准，默认为 no\n* service：用于管理服务\n  * kwargs：\n    * name：服务名称。\n    * state：对服务的操作。包括启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded)\n    * enabled：是否开机启动。且 state 和 enabled 两个参数中至少要有一个\n    * sleep：在 state=restarted 的时候，指定在 stop 和 start 之间暂停的秒数\n* get_url：通过 http/https/ftp 下载文件\n  * kwargs：\n    * url：下载的 uri\n    * dest：文件下载目标位置。如果 dest 为目录，则使用服务器提供的文件名，或者如果没有提供，将使用远程服务器上的 url 的基本名称。\n    * timeout：设置超时时间。默认为 10s\n    * headers：指定访问时的请求头。以 key: value 的格式填写\n\n","slug":"some-modules-and-related-parameters-in-Ansible","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0er003slixuoano1u6n","content":"<ul>\n<li>command：在被控节点上执行命令<ul>\n<li>command 是 Ansible 的默认模块，可以不通过 -m 指明使用该模块</li>\n<li>可以直接执行 -a 中的命令，但由于不通过 shell 执行，所以与 shell 有关的变量、重定向、管道等功能无法使用</li>\n<li>kwargs：<ul>\n<li>chdir：目录名。首先跳转到该目录后再执行命令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>shell：在被控节点上通过 shell 执行命令<ul>\n<li>与 command 模块基本相同，而且由于通过 shell 执行，所以可以使用变量、重定向、管道等功能，并且使用所选用户的默认 shell</li>\n<li>kwargs：<ul>\n<li>chdir：目录名。首先跳转到该目录后再执行命令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>script：在被控节点上执行主控节点上的脚本<ul>\n<li>直接在 -a 中指明主控节点上的脚本位置即可，且这个脚本需要有 x 权限</li>\n</ul>\n</li>\n<li>ping：检测某个目的节点是否响应<ul>\n<li>这个检测过程并不向目的节点发送 ping 包，只是反映目的节点是否可控，目的节点即使在可达的情况下也不一定可控</li>\n<li>不指定 -a</li>\n</ul>\n</li>\n<li>yum：在被控节点上通过 yum 管理软件<ul>\n<li>kwargs：<ul>\n<li>name：软件包名称。如果为 * ，则执行 yum -y updtae；名称前面加 @ 为安装软件包组；名称前面加 @^ 为安装环境组；这个参数也可以是 url，此时通过指定的 rpm 文件进行安装</li>\n<li>state：软件安装状态。如果为 present、latest 或 installed 则执行安装软件；如果为 absent 或 removed 则执行移除软件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>copy：从主控节点向被控节点复制文件<ul>\n<li>kwargs：<ul>\n<li>src：主控节点的文件位置。可以是绝对路径或相对路径，如果是一个目录，将会进行递归复制</li>\n<li>dest：被控节点的文件位置。必须为绝对路径，且如果 src 是一个目录，dest 也必须为一个目录</li>\n<li>directory_mode：递归设定目录的权限。默认为系统默认权限</li>\n<li>force：是否覆盖。默认为 yes，即当目标文件和源文件不同时，强制覆盖文件，如果为 no 则只有在目标文件不存在时才复制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>fetch：从被控节点向主控节点复制文件<ul>\n<li>与 copy 模块并不仅仅是方向相反，copy 可以复制文件和目录，而 fetch 模块只能复制文件</li>\n<li>kwargs：<ul>\n<li>src：被控节点的文件位置。</li>\n<li>dest：文件在主控节点中的保存位置。真实的保存目录需要注意，如果指定了 dest 参数为 /foo，被控节点为 bar，则文件将会保存在 /foo/bar/ 下</li>\n<li>fail_on_missing：被控节点中的文件不存在时是否报错。默认为 no，当为 no 时即使文件不存在也不会报错，此时主控节点也不会创建相应的目录</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>synchronize：通过 rsync 传输文件<ul>\n<li>kwargs：<ul>\n<li>src：源文件的位置。</li>\n<li>dest：目标文件的位置。</li>\n<li>mode：推送模式或拉取模式。默认为推送模式 push，从主控节点向被控节点传输文件</li>\n<li>delete：是否删除文件使两方一致。两方的一致性以推送方为准，默认为 no</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>service：用于管理服务<ul>\n<li>kwargs：<ul>\n<li>name：服务名称。</li>\n<li>state：对服务的操作。包括启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded)</li>\n<li>enabled：是否开机启动。且 state 和 enabled 两个参数中至少要有一个</li>\n<li>sleep：在 state=restarted 的时候，指定在 stop 和 start 之间暂停的秒数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>get_url：通过 http/https/ftp 下载文件<ul>\n<li>kwargs：<ul>\n<li>url：下载的 uri</li>\n<li>dest：文件下载目标位置。如果 dest 为目录，则使用服务器提供的文件名，或者如果没有提供，将使用远程服务器上的 url 的基本名称。</li>\n<li>timeout：设置超时时间。默认为 10s</li>\n<li>headers：指定访问时的请求头。以 key: value 的格式填写</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>command：在被控节点上执行命令<ul>\n<li>command 是 Ansible 的默认模块，可以不通过 -m 指明使用该模块</li>\n<li>可以直接执行 -a 中的命令，但由于不通过 shell 执行，所以与 shell 有关的变量、重定向、管道等功能无法使用</li>\n<li>kwargs：<ul>\n<li>chdir：目录名。首先跳转到该目录后再执行命令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>shell：在被控节点上通过 shell 执行命令<ul>\n<li>与 command 模块基本相同，而且由于通过 shell 执行，所以可以使用变量、重定向、管道等功能，并且使用所选用户的默认 shell</li>\n<li>kwargs：<ul>\n<li>chdir：目录名。首先跳转到该目录后再执行命令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>script：在被控节点上执行主控节点上的脚本<ul>\n<li>直接在 -a 中指明主控节点上的脚本位置即可，且这个脚本需要有 x 权限</li>\n</ul>\n</li>\n<li>ping：检测某个目的节点是否响应<ul>\n<li>这个检测过程并不向目的节点发送 ping 包，只是反映目的节点是否可控，目的节点即使在可达的情况下也不一定可控</li>\n<li>不指定 -a</li>\n</ul>\n</li>\n<li>yum：在被控节点上通过 yum 管理软件<ul>\n<li>kwargs：<ul>\n<li>name：软件包名称。如果为 * ，则执行 yum -y updtae；名称前面加 @ 为安装软件包组；名称前面加 @^ 为安装环境组；这个参数也可以是 url，此时通过指定的 rpm 文件进行安装</li>\n<li>state：软件安装状态。如果为 present、latest 或 installed 则执行安装软件；如果为 absent 或 removed 则执行移除软件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>copy：从主控节点向被控节点复制文件<ul>\n<li>kwargs：<ul>\n<li>src：主控节点的文件位置。可以是绝对路径或相对路径，如果是一个目录，将会进行递归复制</li>\n<li>dest：被控节点的文件位置。必须为绝对路径，且如果 src 是一个目录，dest 也必须为一个目录</li>\n<li>directory_mode：递归设定目录的权限。默认为系统默认权限</li>\n<li>force：是否覆盖。默认为 yes，即当目标文件和源文件不同时，强制覆盖文件，如果为 no 则只有在目标文件不存在时才复制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>fetch：从被控节点向主控节点复制文件<ul>\n<li>与 copy 模块并不仅仅是方向相反，copy 可以复制文件和目录，而 fetch 模块只能复制文件</li>\n<li>kwargs：<ul>\n<li>src：被控节点的文件位置。</li>\n<li>dest：文件在主控节点中的保存位置。真实的保存目录需要注意，如果指定了 dest 参数为 /foo，被控节点为 bar，则文件将会保存在 /foo/bar/ 下</li>\n<li>fail_on_missing：被控节点中的文件不存在时是否报错。默认为 no，当为 no 时即使文件不存在也不会报错，此时主控节点也不会创建相应的目录</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>synchronize：通过 rsync 传输文件<ul>\n<li>kwargs：<ul>\n<li>src：源文件的位置。</li>\n<li>dest：目标文件的位置。</li>\n<li>mode：推送模式或拉取模式。默认为推送模式 push，从主控节点向被控节点传输文件</li>\n<li>delete：是否删除文件使两方一致。两方的一致性以推送方为准，默认为 no</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>service：用于管理服务<ul>\n<li>kwargs：<ul>\n<li>name：服务名称。</li>\n<li>state：对服务的操作。包括启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded)</li>\n<li>enabled：是否开机启动。且 state 和 enabled 两个参数中至少要有一个</li>\n<li>sleep：在 state=restarted 的时候，指定在 stop 和 start 之间暂停的秒数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>get_url：通过 http/https/ftp 下载文件<ul>\n<li>kwargs：<ul>\n<li>url：下载的 uri</li>\n<li>dest：文件下载目标位置。如果 dest 为目录，则使用服务器提供的文件名，或者如果没有提供，将使用远程服务器上的 url 的基本名称。</li>\n<li>timeout：设置超时时间。默认为 10s</li>\n<li>headers：指定访问时的请求头。以 key: value 的格式填写</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Python 按照多个键进行排序","date":"2017-08-16T06:25:44.000Z","_content":"\n在 Python 中，可以使用 `list.sort()` 或 `sorted(list)` 对列表进行排序，而且可以使用 `key` 参数使列表按照一定的键值来排序。\n\n有一些情况下，需要首先对列表按照键值1来进行排序，排序后有多个元素的键值1相等，在每批键值1相等的元素当中，需要再按照键值2进行排序，甚至后续还有更多用以排序的键值。此时可以把 `key` 参数中 lambda 表达式的返回值修改为一个元组，其中元组的每个元素依次是需要依据排序的键值。\n\n```python\nfrom pprint import pprint\n \nlst = [\n    (2, 1),\n    (1, 2),\n    (1, 3), \n    (1, 1) \n]\n \npprint(sorted(lst), key=lambda x: x[0])\n# 此时仅对第一个元素进行排序\n# [\n#     (1, 2),\n#     (1, 3), \n#     (1, 1), \n#     (2, 1) \n# ]\n \npprint(sorted(lst), key=lambda x: (x[0], x[1]))\n# 此时先对第一个元素进行排序，在第一个元素相同的情况下，按第二个元素进行排序\n# [\n#     (1, 1),\n#     (1, 2), \n#     (1, 3), \n#     (2, 1) \n# ]\n```\n","source":"_posts/sorting-with-multi-keys-in-Python.md","raw":"---\ntitle: Python 按照多个键进行排序\ndate: 2017-08-16 14:25:44\ntags:\n  - Python\n---\n\n在 Python 中，可以使用 `list.sort()` 或 `sorted(list)` 对列表进行排序，而且可以使用 `key` 参数使列表按照一定的键值来排序。\n\n有一些情况下，需要首先对列表按照键值1来进行排序，排序后有多个元素的键值1相等，在每批键值1相等的元素当中，需要再按照键值2进行排序，甚至后续还有更多用以排序的键值。此时可以把 `key` 参数中 lambda 表达式的返回值修改为一个元组，其中元组的每个元素依次是需要依据排序的键值。\n\n```python\nfrom pprint import pprint\n \nlst = [\n    (2, 1),\n    (1, 2),\n    (1, 3), \n    (1, 1) \n]\n \npprint(sorted(lst), key=lambda x: x[0])\n# 此时仅对第一个元素进行排序\n# [\n#     (1, 2),\n#     (1, 3), \n#     (1, 1), \n#     (2, 1) \n# ]\n \npprint(sorted(lst), key=lambda x: (x[0], x[1]))\n# 此时先对第一个元素进行排序，在第一个元素相同的情况下，按第二个元素进行排序\n# [\n#     (1, 1),\n#     (1, 2), \n#     (1, 3), \n#     (2, 1) \n# ]\n```\n","slug":"sorting-with-multi-keys-in-Python","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0et003ulixuerwh7myn","content":"<p>在 Python 中，可以使用 <code>list.sort()</code> 或 <code>sorted(list)</code> 对列表进行排序，而且可以使用 <code>key</code> 参数使列表按照一定的键值来排序。</p>\n<p>有一些情况下，需要首先对列表按照键值1来进行排序，排序后有多个元素的键值1相等，在每批键值1相等的元素当中，需要再按照键值2进行排序，甚至后续还有更多用以排序的键值。此时可以把 <code>key</code> 参数中 lambda 表达式的返回值修改为一个元组，其中元组的每个元素依次是需要依据排序的键值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pprint <span class=\"keyword\">import</span> pprint</span><br><span class=\"line\"> </span><br><span class=\"line\">lst = [</span><br><span class=\"line\">    (<span class=\"number\">2</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">3</span>), </span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">1</span>) </span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">pprint(sorted(lst), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\"># 此时仅对第一个元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 2),</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 3), </span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 1), </span></span><br><span class=\"line\"><span class=\"comment\">#     (2, 1) </span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">pprint(sorted(lst), key=<span class=\"keyword\">lambda</span> x: (x[<span class=\"number\">0</span>], x[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 此时先对第一个元素进行排序，在第一个元素相同的情况下，按第二个元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 1),</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 2), </span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 3), </span></span><br><span class=\"line\"><span class=\"comment\">#     (2, 1) </span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Python 中，可以使用 <code>list.sort()</code> 或 <code>sorted(list)</code> 对列表进行排序，而且可以使用 <code>key</code> 参数使列表按照一定的键值来排序。</p>\n<p>有一些情况下，需要首先对列表按照键值1来进行排序，排序后有多个元素的键值1相等，在每批键值1相等的元素当中，需要再按照键值2进行排序，甚至后续还有更多用以排序的键值。此时可以把 <code>key</code> 参数中 lambda 表达式的返回值修改为一个元组，其中元组的每个元素依次是需要依据排序的键值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pprint <span class=\"keyword\">import</span> pprint</span><br><span class=\"line\"> </span><br><span class=\"line\">lst = [</span><br><span class=\"line\">    (<span class=\"number\">2</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">3</span>), </span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"number\">1</span>) </span><br><span class=\"line\">]</span><br><span class=\"line\"> </span><br><span class=\"line\">pprint(sorted(lst), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\"># 此时仅对第一个元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 2),</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 3), </span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 1), </span></span><br><span class=\"line\"><span class=\"comment\">#     (2, 1) </span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">pprint(sorted(lst), key=<span class=\"keyword\">lambda</span> x: (x[<span class=\"number\">0</span>], x[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 此时先对第一个元素进行排序，在第一个元素相同的情况下，按第二个元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\"># [</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 1),</span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 2), </span></span><br><span class=\"line\"><span class=\"comment\">#     (1, 3), </span></span><br><span class=\"line\"><span class=\"comment\">#     (2, 1) </span></span><br><span class=\"line\"><span class=\"comment\"># ]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"CentOS 7 上的 systemctl 配置","date":"2016-09-09T02:07:54.000Z","_content":"\nCentOS 7 的服务 `systemctl` 脚本存放在目录 `/usr/lib/systemd/` 下，有系统（system）和用户（user）之分，需要开机不登陆就能运行的程序，存在系统服务即 `/usr/lib/systemd/system/` 目录下。\n\nCentOS 7 的每一个服务以 .service 结尾，一般会分为 3 部分：[Unit]、[Service] 和 [Install]。\n\n[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别\n\n[Service]部分是服务的关键，是服务的一些具体运行参数的设置。\nType=forking 是后台运行的形式，\nUser=users 是设置服务运行的用户,\nGroup=users 是设置服务运行的用户组,\nPIDFile 为存放 PID 的文件路径，\nExecStart 为服务的具体运行命令,\nExecReload 为重启命令，\nExecStop 为停止命令，\nPrivateTmp=True 表示给服务分配独立的临时空间。\n\n[Install]部分是服务安装的相关设置，可设置为多用户的。\n\n注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错。\n","source":"_posts/systemctl-configurations-on-CentOS-7.md","raw":"---\ntitle: CentOS 7 上的 systemctl 配置\ndate: 2016-09-09 10:07:54\ntags:\n  - Linux\n---\n\nCentOS 7 的服务 `systemctl` 脚本存放在目录 `/usr/lib/systemd/` 下，有系统（system）和用户（user）之分，需要开机不登陆就能运行的程序，存在系统服务即 `/usr/lib/systemd/system/` 目录下。\n\nCentOS 7 的每一个服务以 .service 结尾，一般会分为 3 部分：[Unit]、[Service] 和 [Install]。\n\n[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别\n\n[Service]部分是服务的关键，是服务的一些具体运行参数的设置。\nType=forking 是后台运行的形式，\nUser=users 是设置服务运行的用户,\nGroup=users 是设置服务运行的用户组,\nPIDFile 为存放 PID 的文件路径，\nExecStart 为服务的具体运行命令,\nExecReload 为重启命令，\nExecStop 为停止命令，\nPrivateTmp=True 表示给服务分配独立的临时空间。\n\n[Install]部分是服务安装的相关设置，可设置为多用户的。\n\n注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错。\n","slug":"systemctl-configurations-on-CentOS-7","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0eu003wlixusj9fxp0h","content":"<p>CentOS 7 的服务 <code>systemctl</code> 脚本存放在目录 <code>/usr/lib/systemd/</code> 下，有系统（system）和用户（user）之分，需要开机不登陆就能运行的程序，存在系统服务即 <code>/usr/lib/systemd/system/</code> 目录下。</p>\n<p>CentOS 7 的每一个服务以 .service 结尾，一般会分为 3 部分：[Unit]、[Service] 和 [Install]。</p>\n<p>[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别</p>\n<p>[Service]部分是服务的关键，是服务的一些具体运行参数的设置。<br>Type=forking 是后台运行的形式，<br>User=users 是设置服务运行的用户,<br>Group=users 是设置服务运行的用户组,<br>PIDFile 为存放 PID 的文件路径，<br>ExecStart 为服务的具体运行命令,<br>ExecReload 为重启命令，<br>ExecStop 为停止命令，<br>PrivateTmp=True 表示给服务分配独立的临时空间。</p>\n<p>[Install]部分是服务安装的相关设置，可设置为多用户的。</p>\n<p>注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CentOS 7 的服务 <code>systemctl</code> 脚本存放在目录 <code>/usr/lib/systemd/</code> 下，有系统（system）和用户（user）之分，需要开机不登陆就能运行的程序，存在系统服务即 <code>/usr/lib/systemd/system/</code> 目录下。</p>\n<p>CentOS 7 的每一个服务以 .service 结尾，一般会分为 3 部分：[Unit]、[Service] 和 [Install]。</p>\n<p>[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别</p>\n<p>[Service]部分是服务的关键，是服务的一些具体运行参数的设置。<br>Type=forking 是后台运行的形式，<br>User=users 是设置服务运行的用户,<br>Group=users 是设置服务运行的用户组,<br>PIDFile 为存放 PID 的文件路径，<br>ExecStart 为服务的具体运行命令,<br>ExecReload 为重启命令，<br>ExecStop 为停止命令，<br>PrivateTmp=True 表示给服务分配独立的临时空间。</p>\n<p>[Install]部分是服务安装的相关设置，可设置为多用户的。</p>\n<p>注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错。</p>\n"},{"title":"MySQL 引擎 MyISAM 和 InnoDB 的区别","date":"2015-12-13T05:53:33.000Z","_content":"\nMySQL 5.5 开始 InnoDB 成为 MySQL 的默认引擎（之前是 MyISAM）。\n\n1. MyISAM 不支持事务，InnoDB 支持事务。对于 InnoDB 每一条 SQL 语句都默认封装成事务自动提交，但会影响速度。所以最好把多条 SQL 语句放在 begin 和 commit 之间组成一个事务。\n2. MyISAM 不支持外键，InnoDB 支持外键。如果一个 InnoDB 表包含外键，这个表转为 MyISAM 表的时候会失败。\n3. MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。InnoDB 是聚集索引，数据文件和索引绑定在一起，因此必须要有主键，且通过主键索引的效率很高。但辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。\n4. MyISAM 用一个变量保存了整个表的行数，执行 `SELECT COUNT(*)` 的时候直接读出该变量即可，速度很快。InnoDB 不保存表的具体行数，执行 `SELECT COUNT(*)` 的时候需要全表扫描。\n5. MyISAM 支持全文索引，查询效率较高。InnoDB 不支持全文索引。\n6. MyISAM 更强调性能，更适用于执行 SELECT 较多的情况。InnoDB 更适用于 INSERT 和 UPDATE 较多的情况。\n7. MyISAM 在 DELETE 操作时会重新建立一个表，InnoDB 会一行一行地删除记录。\n8. MyISAM 不支持行锁，只支持表锁。MyISAM 同一个表上的读锁和写锁是互斥的，MyISAM 并发读写时如果等待队列中同时有读和写请求，默认写请求的优先级高，但 MyISAM 的写操作性能较低，会导致进程阻塞。InnoDB 支持行锁。\n\n","source":"_posts/the-difference-between-MyISAM-and-InnoDB-in-MySQL.md","raw":"---\ntitle: MySQL 引擎 MyISAM 和 InnoDB 的区别\ndate: 2015-12-13 13:53:33\ntags:\n  - MySQL\n---\n\nMySQL 5.5 开始 InnoDB 成为 MySQL 的默认引擎（之前是 MyISAM）。\n\n1. MyISAM 不支持事务，InnoDB 支持事务。对于 InnoDB 每一条 SQL 语句都默认封装成事务自动提交，但会影响速度。所以最好把多条 SQL 语句放在 begin 和 commit 之间组成一个事务。\n2. MyISAM 不支持外键，InnoDB 支持外键。如果一个 InnoDB 表包含外键，这个表转为 MyISAM 表的时候会失败。\n3. MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。InnoDB 是聚集索引，数据文件和索引绑定在一起，因此必须要有主键，且通过主键索引的效率很高。但辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。\n4. MyISAM 用一个变量保存了整个表的行数，执行 `SELECT COUNT(*)` 的时候直接读出该变量即可，速度很快。InnoDB 不保存表的具体行数，执行 `SELECT COUNT(*)` 的时候需要全表扫描。\n5. MyISAM 支持全文索引，查询效率较高。InnoDB 不支持全文索引。\n6. MyISAM 更强调性能，更适用于执行 SELECT 较多的情况。InnoDB 更适用于 INSERT 和 UPDATE 较多的情况。\n7. MyISAM 在 DELETE 操作时会重新建立一个表，InnoDB 会一行一行地删除记录。\n8. MyISAM 不支持行锁，只支持表锁。MyISAM 同一个表上的读锁和写锁是互斥的，MyISAM 并发读写时如果等待队列中同时有读和写请求，默认写请求的优先级高，但 MyISAM 的写操作性能较低，会导致进程阻塞。InnoDB 支持行锁。\n\n","slug":"the-difference-between-MyISAM-and-InnoDB-in-MySQL","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ew003zlixusacojhyz","content":"<p>MySQL 5.5 开始 InnoDB 成为 MySQL 的默认引擎（之前是 MyISAM）。</p>\n<ol>\n<li>MyISAM 不支持事务，InnoDB 支持事务。对于 InnoDB 每一条 SQL 语句都默认封装成事务自动提交，但会影响速度。所以最好把多条 SQL 语句放在 begin 和 commit 之间组成一个事务。</li>\n<li>MyISAM 不支持外键，InnoDB 支持外键。如果一个 InnoDB 表包含外键，这个表转为 MyISAM 表的时候会失败。</li>\n<li>MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。InnoDB 是聚集索引，数据文件和索引绑定在一起，因此必须要有主键，且通过主键索引的效率很高。但辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。</li>\n<li>MyISAM 用一个变量保存了整个表的行数，执行 <code>SELECT COUNT(*)</code> 的时候直接读出该变量即可，速度很快。InnoDB 不保存表的具体行数，执行 <code>SELECT COUNT(*)</code> 的时候需要全表扫描。</li>\n<li>MyISAM 支持全文索引，查询效率较高。InnoDB 不支持全文索引。</li>\n<li>MyISAM 更强调性能，更适用于执行 SELECT 较多的情况。InnoDB 更适用于 INSERT 和 UPDATE 较多的情况。</li>\n<li>MyISAM 在 DELETE 操作时会重新建立一个表，InnoDB 会一行一行地删除记录。</li>\n<li>MyISAM 不支持行锁，只支持表锁。MyISAM 同一个表上的读锁和写锁是互斥的，MyISAM 并发读写时如果等待队列中同时有读和写请求，默认写请求的优先级高，但 MyISAM 的写操作性能较低，会导致进程阻塞。InnoDB 支持行锁。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL 5.5 开始 InnoDB 成为 MySQL 的默认引擎（之前是 MyISAM）。</p>\n<ol>\n<li>MyISAM 不支持事务，InnoDB 支持事务。对于 InnoDB 每一条 SQL 语句都默认封装成事务自动提交，但会影响速度。所以最好把多条 SQL 语句放在 begin 和 commit 之间组成一个事务。</li>\n<li>MyISAM 不支持外键，InnoDB 支持外键。如果一个 InnoDB 表包含外键，这个表转为 MyISAM 表的时候会失败。</li>\n<li>MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。InnoDB 是聚集索引，数据文件和索引绑定在一起，因此必须要有主键，且通过主键索引的效率很高。但辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。</li>\n<li>MyISAM 用一个变量保存了整个表的行数，执行 <code>SELECT COUNT(*)</code> 的时候直接读出该变量即可，速度很快。InnoDB 不保存表的具体行数，执行 <code>SELECT COUNT(*)</code> 的时候需要全表扫描。</li>\n<li>MyISAM 支持全文索引，查询效率较高。InnoDB 不支持全文索引。</li>\n<li>MyISAM 更强调性能，更适用于执行 SELECT 较多的情况。InnoDB 更适用于 INSERT 和 UPDATE 较多的情况。</li>\n<li>MyISAM 在 DELETE 操作时会重新建立一个表，InnoDB 会一行一行地删除记录。</li>\n<li>MyISAM 不支持行锁，只支持表锁。MyISAM 同一个表上的读锁和写锁是互斥的，MyISAM 并发读写时如果等待队列中同时有读和写请求，默认写请求的优先级高，但 MyISAM 的写操作性能较低，会导致进程阻塞。InnoDB 支持行锁。</li>\n</ol>\n"},{"title":"json.dumps() 中的 ensure_ascii 参数","date":"2018-10-20T02:08:37.000Z","_content":"\n在使用 `json.dumps()` 的时候，如果数据中包含中文，需要指定一个参数 `ensure_ascii` 的值为 `False`。\n\n这是因为 `json.dumps()` 在序列化时，对中文默认使用 ASCII 编码。\n\n```python\nimport json\n\nprint(json.dumps(\"中\"))\n# \"\\u4e2d\"\n\nprint(json.dumps(\"中\", ensure_ascii=False))\n# \"中\"\n```\n","source":"_posts/the-parameter-ensure-ascii-in-json-dumps.md","raw":"---\ntitle: json.dumps() 中的 ensure_ascii 参数\ndate: 2018-10-20 10:08:37\ntags:\n  - Python\n---\n\n在使用 `json.dumps()` 的时候，如果数据中包含中文，需要指定一个参数 `ensure_ascii` 的值为 `False`。\n\n这是因为 `json.dumps()` 在序列化时，对中文默认使用 ASCII 编码。\n\n```python\nimport json\n\nprint(json.dumps(\"中\"))\n# \"\\u4e2d\"\n\nprint(json.dumps(\"中\", ensure_ascii=False))\n# \"中\"\n```\n","slug":"the-parameter-ensure-ascii-in-json-dumps","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ex0041lixuyblvw728","content":"<p>在使用 <code>json.dumps()</code> 的时候，如果数据中包含中文，需要指定一个参数 <code>ensure_ascii</code> 的值为 <code>False</code>。</p>\n<p>这是因为 <code>json.dumps()</code> 在序列化时，对中文默认使用 ASCII 编码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(<span class=\"string\">\"中\"</span>))</span><br><span class=\"line\"><span class=\"comment\"># \"\\u4e2d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(<span class=\"string\">\"中\"</span>, ensure_ascii=<span class=\"keyword\">False</span>))</span><br><span class=\"line\"><span class=\"comment\"># \"中\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用 <code>json.dumps()</code> 的时候，如果数据中包含中文，需要指定一个参数 <code>ensure_ascii</code> 的值为 <code>False</code>。</p>\n<p>这是因为 <code>json.dumps()</code> 在序列化时，对中文默认使用 ASCII 编码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(<span class=\"string\">\"中\"</span>))</span><br><span class=\"line\"><span class=\"comment\"># \"\\u4e2d\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(<span class=\"string\">\"中\"</span>, ensure_ascii=<span class=\"keyword\">False</span>))</span><br><span class=\"line\"><span class=\"comment\"># \"中\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Python 中时间戳、格式化时间、时间数组、datetime 之间的转换","date":"2014-12-03T02:12:33.000Z","_content":"\n```python\nimport time\nfrom datetime import datetime\n \n# 获得时间戳\ntimestamp = time.time()\n \n# 时间戳转为时间数组\ntime_array = time.localtime(timestamp)\n \n# 时间数组转为时间戳\ntimestamp = time.mktime(time_array())\n \n# 格式化时间转为时间数组\ntime_array = time.strptime(format_time, '%Y-%m-%d %H:%M:%S')\n \n# 时间数组转为格式化时间\nformat_time = time.strftime('%Y-%m-%d %H:%M:%S', time_array)\n \n# datetime 转为时间戳\nts = dt.timestamp()\n \n# 时间戳转为 datetime\ndt = datetime.fromtimestamp(ts)\n \n# 直接输出当前的格式化时间\ntime.strftime('%Y-%m-%d %H:%M:%S')\n```\n","source":"_posts/the-transformation-among-timestamp-formatted-time-datetime-and-time-tuple-in-Python.md","raw":"---\ntitle: Python 中时间戳、格式化时间、时间数组、datetime 之间的转换\ndate: 2014-12-03 10:12:33\ntags: \n  - Python\n---\n\n```python\nimport time\nfrom datetime import datetime\n \n# 获得时间戳\ntimestamp = time.time()\n \n# 时间戳转为时间数组\ntime_array = time.localtime(timestamp)\n \n# 时间数组转为时间戳\ntimestamp = time.mktime(time_array())\n \n# 格式化时间转为时间数组\ntime_array = time.strptime(format_time, '%Y-%m-%d %H:%M:%S')\n \n# 时间数组转为格式化时间\nformat_time = time.strftime('%Y-%m-%d %H:%M:%S', time_array)\n \n# datetime 转为时间戳\nts = dt.timestamp()\n \n# 时间戳转为 datetime\ndt = datetime.fromtimestamp(ts)\n \n# 直接输出当前的格式化时间\ntime.strftime('%Y-%m-%d %H:%M:%S')\n```\n","slug":"the-transformation-among-timestamp-formatted-time-datetime-and-time-tuple-in-Python","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0ez0044lixuxu09pjck","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 获得时间戳</span></span><br><span class=\"line\">timestamp = time.time()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间戳转为时间数组</span></span><br><span class=\"line\">time_array = time.localtime(timestamp)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间数组转为时间戳</span></span><br><span class=\"line\">timestamp = time.mktime(time_array())</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 格式化时间转为时间数组</span></span><br><span class=\"line\">time_array = time.strptime(format_time, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间数组转为格式化时间</span></span><br><span class=\"line\">format_time = time.strftime(<span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>, time_array)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># datetime 转为时间戳</span></span><br><span class=\"line\">ts = dt.timestamp()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间戳转为 datetime</span></span><br><span class=\"line\">dt = datetime.fromtimestamp(ts)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 直接输出当前的格式化时间</span></span><br><span class=\"line\">time.strftime(<span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 获得时间戳</span></span><br><span class=\"line\">timestamp = time.time()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间戳转为时间数组</span></span><br><span class=\"line\">time_array = time.localtime(timestamp)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间数组转为时间戳</span></span><br><span class=\"line\">timestamp = time.mktime(time_array())</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 格式化时间转为时间数组</span></span><br><span class=\"line\">time_array = time.strptime(format_time, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间数组转为格式化时间</span></span><br><span class=\"line\">format_time = time.strftime(<span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>, time_array)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># datetime 转为时间戳</span></span><br><span class=\"line\">ts = dt.timestamp()</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 时间戳转为 datetime</span></span><br><span class=\"line\">dt = datetime.fromtimestamp(ts)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 直接输出当前的格式化时间</span></span><br><span class=\"line\">time.strftime(<span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"为什么读写文件推荐使用 with 语句块？","date":"2015-10-11T03:56:17.000Z","_content":"\n```python\nwith open('file_name') as f:\n    data = f.read()\n```\n\n能够使用 with 语句块的条件是 with 所求值的对象必须有一个 `__enter__()` 方法，一个 `__exit__()` 方法。\n\n而紧跟在 with 关键字后面的语句被求值后，返回对象的 `__enter__()` 方法被调用，这个方法的返回值将被赋值给 `as` 后面的变量。当 with 语句块中的全部语句被执行完之后，将调用前面返回对象的 `__exit__()` 方法。\n\n对于读写文件来说，使用 with 语句块一般较为保险。在读文件时，如果使用了 with 语句块，在代码块结束后，由于自动执行了 `__exit__()` 方法，因此不需要手动使用 `close()` 方法来关闭被读的文件；当写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存中缓存起来，空闲的时候再进行写入，只有调用 `close()` 方法时，操作系统才保证把没有写入的数据全部写入磁盘，忘记调用 `close()` 的后果是数据可能只写了一部分到磁盘，剩下的丢失了，而使用 with语句块就有效避免了这个问题。\n","source":"_posts/why-WITH-block-is-recommended-for-reading-and-writing-files.md","raw":"---\ntitle: 为什么读写文件推荐使用 with 语句块？\ndate: 2015-10-11 11:56:17\ntags:\n  - Python\n---\n\n```python\nwith open('file_name') as f:\n    data = f.read()\n```\n\n能够使用 with 语句块的条件是 with 所求值的对象必须有一个 `__enter__()` 方法，一个 `__exit__()` 方法。\n\n而紧跟在 with 关键字后面的语句被求值后，返回对象的 `__enter__()` 方法被调用，这个方法的返回值将被赋值给 `as` 后面的变量。当 with 语句块中的全部语句被执行完之后，将调用前面返回对象的 `__exit__()` 方法。\n\n对于读写文件来说，使用 with 语句块一般较为保险。在读文件时，如果使用了 with 语句块，在代码块结束后，由于自动执行了 `__exit__()` 方法，因此不需要手动使用 `close()` 方法来关闭被读的文件；当写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存中缓存起来，空闲的时候再进行写入，只有调用 `close()` 方法时，操作系统才保证把没有写入的数据全部写入磁盘，忘记调用 `close()` 的后果是数据可能只写了一部分到磁盘，剩下的丢失了，而使用 with语句块就有效避免了这个问题。\n","slug":"why-WITH-block-is-recommended-for-reading-and-writing-files","published":1,"updated":"2019-03-27T16:25:10.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsnz0f00046lixue6mqre2z","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'file_name'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data = f.read()</span><br></pre></td></tr></table></figure>\n<p>能够使用 with 语句块的条件是 with 所求值的对象必须有一个 <code>__enter__()</code> 方法，一个 <code>__exit__()</code> 方法。</p>\n<p>而紧跟在 with 关键字后面的语句被求值后，返回对象的 <code>__enter__()</code> 方法被调用，这个方法的返回值将被赋值给 <code>as</code> 后面的变量。当 with 语句块中的全部语句被执行完之后，将调用前面返回对象的 <code>__exit__()</code> 方法。</p>\n<p>对于读写文件来说，使用 with 语句块一般较为保险。在读文件时，如果使用了 with 语句块，在代码块结束后，由于自动执行了 <code>__exit__()</code> 方法，因此不需要手动使用 <code>close()</code> 方法来关闭被读的文件；当写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存中缓存起来，空闲的时候再进行写入，只有调用 <code>close()</code> 方法时，操作系统才保证把没有写入的数据全部写入磁盘，忘记调用 <code>close()</code> 的后果是数据可能只写了一部分到磁盘，剩下的丢失了，而使用 with语句块就有效避免了这个问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'file_name'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data = f.read()</span><br></pre></td></tr></table></figure>\n<p>能够使用 with 语句块的条件是 with 所求值的对象必须有一个 <code>__enter__()</code> 方法，一个 <code>__exit__()</code> 方法。</p>\n<p>而紧跟在 with 关键字后面的语句被求值后，返回对象的 <code>__enter__()</code> 方法被调用，这个方法的返回值将被赋值给 <code>as</code> 后面的变量。当 with 语句块中的全部语句被执行完之后，将调用前面返回对象的 <code>__exit__()</code> 方法。</p>\n<p>对于读写文件来说，使用 with 语句块一般较为保险。在读文件时，如果使用了 with 语句块，在代码块结束后，由于自动执行了 <code>__exit__()</code> 方法，因此不需要手动使用 <code>close()</code> 方法来关闭被读的文件；当写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存中缓存起来，空闲的时候再进行写入，只有调用 <code>close()</code> 方法时，操作系统才保证把没有写入的数据全部写入磁盘，忘记调用 <code>close()</code> 的后果是数据可能只写了一部分到磁盘，剩下的丢失了，而使用 with语句块就有效避免了这个问题。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjtsnz0b70000lixu8l7x7npn","tag_id":"cjtsnz0bm0004lixu6j2e8q8c","_id":"cjtsnz0c4000dlixufap50q9u"},{"post_id":"cjtsnz0b70000lixu8l7x7npn","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0c6000flixu2l5sya2f"},{"post_id":"cjtsnz0bi0002lixubrqjoyhx","tag_id":"cjtsnz0c3000blixugx94jnlq","_id":"cjtsnz0cd000llixucznwhd3q"},{"post_id":"cjtsnz0bi0002lixubrqjoyhx","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0cf000nlixu4xn21c92"},{"post_id":"cjtsnz0bo0005lixuhqmt7u71","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0cp0010lixucayko72r"},{"post_id":"cjtsnz0bo0005lixuhqmt7u71","tag_id":"cjtsnz0cf000olixusd3knwf3","_id":"cjtsnz0ct0012lixujv8c71yn"},{"post_id":"cjtsnz0bo0005lixuhqmt7u71","tag_id":"cjtsnz0ci000slixuuv3j9vt0","_id":"cjtsnz0cu0015lixuc2zy5cb4"},{"post_id":"cjtsnz0bo0005lixuhqmt7u71","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0cw0017lixue9rt34n5"},{"post_id":"cjtsnz0bq0006lixuab5ul2az","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0cx001alixuon60n5rc"},{"post_id":"cjtsnz0bq0006lixuab5ul2az","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0cy001clixu6j16iabg"},{"post_id":"cjtsnz0cz001elixurg4circ6","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0d1001hlixuov42mina"},{"post_id":"cjtsnz0cz001elixurg4circ6","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0d3001jlixu4hy0ak84"},{"post_id":"cjtsnz0bs0007lixud2nne756","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0d8001nlixufdrus1vo"},{"post_id":"cjtsnz0bs0007lixud2nne756","tag_id":"cjtsnz0cz001dlixue6lx9ad3","_id":"cjtsnz0da001plixuzrwmd7k5"},{"post_id":"cjtsnz0bs0007lixud2nne756","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0db001slixum4e4a5qt"},{"post_id":"cjtsnz0bu0009lixuautnamci","tag_id":"cjtsnz0d7001llixuglzr2mqc","_id":"cjtsnz0dd001wlixun6ipysfd"},{"post_id":"cjtsnz0bu0009lixuautnamci","tag_id":"cjtsnz0da001qlixuk9t8jhp8","_id":"cjtsnz0df001ylixuty5jd79g"},{"post_id":"cjtsnz0bu0009lixuautnamci","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0di0021lixumrmfmqeh"},{"post_id":"cjtsnz0c1000alixuh7xywqzm","tag_id":"cjtsnz0dd001vlixujomzk2y9","_id":"cjtsnz0dj0023lixu58o3rue2"},{"post_id":"cjtsnz0c1000alixuh7xywqzm","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0dl0026lixuzfusbg90"},{"post_id":"cjtsnz0c4000clixuel5wgwlw","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0dm0028lixubkfihbop"},{"post_id":"cjtsnz0c4000clixuel5wgwlw","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0dn002blixu9qt1806c"},{"post_id":"cjtsnz0dl0027lixu90arvy6h","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0do002dlixuws270x53"},{"post_id":"cjtsnz0dl0027lixu90arvy6h","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0dp002glixu8i51bjsa"},{"post_id":"cjtsnz0c5000elixuojv49b1j","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0dr002ilixuy20vtcy5"},{"post_id":"cjtsnz0c5000elixuojv49b1j","tag_id":"cjtsnz0dn002alixugx82vqjx","_id":"cjtsnz0dt002klixu090nwxk5"},{"post_id":"cjtsnz0c5000elixuojv49b1j","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0du002nlixuroxq8jn6"},{"post_id":"cjtsnz0c8000hlixuqpadi4n2","tag_id":"cjtsnz0dp002flixul16kr0y9","_id":"cjtsnz0dv002plixuzjmktfi5"},{"post_id":"cjtsnz0c8000hlixuqpadi4n2","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0dw002slixu9qki7ygz"},{"post_id":"cjtsnz0ca000ilixucksn2bwj","tag_id":"cjtsnz0dt002mlixuqn4zrllm","_id":"cjtsnz0dx002ulixumvmug9yx"},{"post_id":"cjtsnz0ca000ilixucksn2bwj","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0dz002xlixux6gyjjyn"},{"post_id":"cjtsnz0dv002qlixu7rrbv8jn","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0e1002zlixu5q6qy3rf"},{"post_id":"cjtsnz0cc000klixu6lhn9i1v","tag_id":"cjtsnz0dw002rlixutxfh8ivy","_id":"cjtsnz0e30032lixug684pyeh"},{"post_id":"cjtsnz0dy002vlixu53jbc5n8","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0e90034lixu7fx28nad"},{"post_id":"cjtsnz0ce000mlixu4nnf2o52","tag_id":"cjtsnz0dz002wlixuj4wwmzkm","_id":"cjtsnz0ec0038lixuu3xe8wmi"},{"post_id":"cjtsnz0ce000mlixu4nnf2o52","tag_id":"cjtsnz0e30031lixud4ifi35p","_id":"cjtsnz0ed003alixu0vm0x9le"},{"post_id":"cjtsnz0ce000mlixu4nnf2o52","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0eh003dlixu02l68ycs"},{"post_id":"cjtsnz0cf000plixualpdrhwq","tag_id":"cjtsnz0cf000olixusd3knwf3","_id":"cjtsnz0ei003flixu1b6v1gg7"},{"post_id":"cjtsnz0cf000plixualpdrhwq","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0ek003ilixua2bl1hgg"},{"post_id":"cjtsnz0ei003glixusqcxuksk","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0en003klixuwwi7zyd8"},{"post_id":"cjtsnz0cg000qlixu68zynbjl","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0eq003olixud53tiu1f"},{"post_id":"cjtsnz0cg000qlixu68zynbjl","tag_id":"cjtsnz0eg003clixu8kgi1wkb","_id":"cjtsnz0er003qlixu2pczxboh"},{"post_id":"cjtsnz0cg000qlixu68zynbjl","tag_id":"cjtsnz0ej003hlixu3lup14cl","_id":"cjtsnz0et003tlixua7fd18wq"},{"post_id":"cjtsnz0cg000qlixu68zynbjl","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0eu003vlixutsi6k2ec"},{"post_id":"cjtsnz0er003slixuoano1u6n","tag_id":"cjtsnz0dw002rlixutxfh8ivy","_id":"cjtsnz0ev003ylixunbbnlfin"},{"post_id":"cjtsnz0et003ulixuerwh7myn","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0ex0040lixuysg6rv6y"},{"post_id":"cjtsnz0ci000rlixub30v0dpr","tag_id":"cjtsnz0eo003mlixujtkgtux2","_id":"cjtsnz0ez0043lixux53tbi3p"},{"post_id":"cjtsnz0ci000rlixub30v0dpr","tag_id":"cjtsnz0er003rlixuhvnngwm7","_id":"cjtsnz0f00045lixuxi3erk32"},{"post_id":"cjtsnz0ci000rlixub30v0dpr","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0f10048lixuw9ppwuyt"},{"post_id":"cjtsnz0eu003wlixusj9fxp0h","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0f20049lixuwve1690q"},{"post_id":"cjtsnz0cj000tlixuac4ctgtj","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0f2004alixu6l4tg1gl"},{"post_id":"cjtsnz0cj000tlixuac4ctgtj","tag_id":"cjtsnz0dz002wlixuj4wwmzkm","_id":"cjtsnz0f2004clixuc86w3v44"},{"post_id":"cjtsnz0cj000tlixuac4ctgtj","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0f2004dlixuqky2pn2i"},{"post_id":"cjtsnz0ex0041lixuyblvw728","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0f3004flixusaqi1s8k"},{"post_id":"cjtsnz0ez0044lixuxu09pjck","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0f3004glixuqyrockgs"},{"post_id":"cjtsnz0ck000ulixu8tkavlke","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0f4004ilixuf11g6qn8"},{"post_id":"cjtsnz0ck000ulixu8tkavlke","tag_id":"cjtsnz0ey0042lixu4zqoh8kk","_id":"cjtsnz0f4004jlixuy7dza9po"},{"post_id":"cjtsnz0ck000ulixu8tkavlke","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0f4004llixufkp7qjnn"},{"post_id":"cjtsnz0f00046lixue6mqre2z","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0f4004mlixuptv74uix"},{"post_id":"cjtsnz0cm000wlixuckcucfmg","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0f4004nlixu0fj6fl4y"},{"post_id":"cjtsnz0cm000wlixuckcucfmg","tag_id":"cjtsnz0f10047lixuduw84bk5","_id":"cjtsnz0f7004plixuld7f3mof"},{"post_id":"cjtsnz0cm000wlixuckcucfmg","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0f7004qlixu7mngkdzt"},{"post_id":"cjtsnz0cn000xlixu9ap949ky","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0f8004slixufnito8ml"},{"post_id":"cjtsnz0cn000xlixu9ap949ky","tag_id":"cjtsnz0f2004blixufsll2kp2","_id":"cjtsnz0fj004tlixuhsw4cpqr"},{"post_id":"cjtsnz0cn000xlixu9ap949ky","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fk004vlixuxeqhti3p"},{"post_id":"cjtsnz0cp000zlixuvkol28oa","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0fk004wlixuibr11wzs"},{"post_id":"cjtsnz0cp000zlixuvkol28oa","tag_id":"cjtsnz0f3004elixudgb56kcj","_id":"cjtsnz0fl004ylixux1yab1kz"},{"post_id":"cjtsnz0cp000zlixuvkol28oa","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fl004zlixum8d77dhr"},{"post_id":"cjtsnz0cq0011lixuj6sjr57g","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0fm0051lixuoc52k2iv"},{"post_id":"cjtsnz0cq0011lixuj6sjr57g","tag_id":"cjtsnz0f3004hlixum60judeq","_id":"cjtsnz0fm0052lixuuxbc929w"},{"post_id":"cjtsnz0cq0011lixuj6sjr57g","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fm0054lixuqx4glx91"},{"post_id":"cjtsnz0cu0014lixu44033qke","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0fn0055lixuuwn7whhd"},{"post_id":"cjtsnz0cu0014lixu44033qke","tag_id":"cjtsnz0f4004klixuxlz3zftc","_id":"cjtsnz0fn0057lixub7s4jxyt"},{"post_id":"cjtsnz0cu0014lixu44033qke","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fn0058lixuqojrvoow"},{"post_id":"cjtsnz0cv0016lixu5pot2ugp","tag_id":"cjtsnz0f4004olixu2fpux0yx","_id":"cjtsnz0fn005alixurmrtmqcs"},{"post_id":"cjtsnz0cv0016lixu5pot2ugp","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fo005blixubcodphjm"},{"post_id":"cjtsnz0cw0019lixu2s2fmh1u","tag_id":"cjtsnz0dw002rlixutxfh8ivy","_id":"cjtsnz0fo005clixupz1tt9hn"},{"post_id":"cjtsnz0cw0019lixu2s2fmh1u","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fo005elixudjvtmx9p"},{"post_id":"cjtsnz0cy001blixumr9uieo4","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0fo005flixu1yqxb94n"},{"post_id":"cjtsnz0cy001blixumr9uieo4","tag_id":"cjtsnz0dd001vlixujomzk2y9","_id":"cjtsnz0fp005hlixus864v33g"},{"post_id":"cjtsnz0cy001blixumr9uieo4","tag_id":"cjtsnz0fl0050lixu3iuneb9n","_id":"cjtsnz0fp005ilixu1x4qngvs"},{"post_id":"cjtsnz0cy001blixumr9uieo4","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fq005klixujmmgk1e9"},{"post_id":"cjtsnz0d0001flixugqnd53qe","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0fq005llixut7difp52"},{"post_id":"cjtsnz0d0001flixugqnd53qe","tag_id":"cjtsnz0fn0056lixubxs6v9n1","_id":"cjtsnz0fq005nlixuho7vbyyx"},{"post_id":"cjtsnz0d0001flixugqnd53qe","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fr005olixubfk870q8"},{"post_id":"cjtsnz0d1001ilixuv61icszg","tag_id":"cjtsnz0fn0059lixu0g7sbwkf","_id":"cjtsnz0fr005qlixu1sbfmfcm"},{"post_id":"cjtsnz0d1001ilixuv61icszg","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fr005rlixuqprbx2nh"},{"post_id":"cjtsnz0d3001klixu86a1wkeb","tag_id":"cjtsnz0fo005dlixutb33x6v3","_id":"cjtsnz0fs005tlixubda34rwe"},{"post_id":"cjtsnz0d3001klixu86a1wkeb","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fs005ulixujpp60dqk"},{"post_id":"cjtsnz0d7001mlixuf3t72kco","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0fs005vlixu12e7oxq4"},{"post_id":"cjtsnz0d7001mlixuf3t72kco","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0ft005xlixutayn5ha7"},{"post_id":"cjtsnz0d8001olixuk6nnqmpo","tag_id":"cjtsnz0fp005jlixulltyrmr7","_id":"cjtsnz0ft005ylixu7yy7a270"},{"post_id":"cjtsnz0d8001olixuk6nnqmpo","tag_id":"cjtsnz0fq005mlixuh9bpgdut","_id":"cjtsnz0ft0060lixujd03cali"},{"post_id":"cjtsnz0d8001olixuk6nnqmpo","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fu0061lixuoy1x2w2n"},{"post_id":"cjtsnz0da001rlixuie6v8sz4","tag_id":"cjtsnz0f4004olixu2fpux0yx","_id":"cjtsnz0fv0063lixu4gb3udta"},{"post_id":"cjtsnz0da001rlixuie6v8sz4","tag_id":"cjtsnz0fs005slixuo3zwthkj","_id":"cjtsnz0fv0064lixutwzq2bqv"},{"post_id":"cjtsnz0da001rlixuie6v8sz4","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fw0066lixur8bmeqhd"},{"post_id":"cjtsnz0db001tlixusctoq59b","tag_id":"cjtsnz0fs005wlixu5uqcr9it","_id":"cjtsnz0fw0067lixu09hswgvb"},{"post_id":"cjtsnz0db001tlixusctoq59b","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fx0069lixu0m5fcq8p"},{"post_id":"cjtsnz0dc001ulixujl14ixfi","tag_id":"cjtsnz0dp002flixul16kr0y9","_id":"cjtsnz0fx006alixuidfrfsvu"},{"post_id":"cjtsnz0dc001ulixujl14ixfi","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fx006clixui6xxl352"},{"post_id":"cjtsnz0de001xlixug1x4osod","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0fx006dlixupgleoyrr"},{"post_id":"cjtsnz0de001xlixug1x4osod","tag_id":"cjtsnz0dp002flixul16kr0y9","_id":"cjtsnz0fy006flixubl9gqkmt"},{"post_id":"cjtsnz0de001xlixug1x4osod","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fy006glixuhq4d1pyp"},{"post_id":"cjtsnz0df001zlixu6ms5v6lp","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0fy006hlixucrpz99fe"},{"post_id":"cjtsnz0df001zlixu6ms5v6lp","tag_id":"cjtsnz0fv0065lixu73nmeewe","_id":"cjtsnz0fz006jlixutz675ezs"},{"post_id":"cjtsnz0df001zlixu6ms5v6lp","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0fz006klixu8p9enmdu"},{"post_id":"cjtsnz0di0022lixunk03zojw","tag_id":"cjtsnz0fs005wlixu5uqcr9it","_id":"cjtsnz0fz006mlixufy53zy6x"},{"post_id":"cjtsnz0di0022lixunk03zojw","tag_id":"cjtsnz0fx006blixu2dqr3nil","_id":"cjtsnz0fz006nlixugaupo5oz"},{"post_id":"cjtsnz0di0022lixunk03zojw","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0g0006plixu65j2p9vm"},{"post_id":"cjtsnz0dj0024lixuqhh11j0a","tag_id":"cjtsnz0fy006elixuh5ises1e","_id":"cjtsnz0g0006qlixuegcnalol"},{"post_id":"cjtsnz0dj0024lixuqhh11j0a","tag_id":"cjtsnz0bt0008lixuizdcm7yz","_id":"cjtsnz0g0006slixulsutus72"},{"post_id":"cjtsnz0dm0029lixu9wy6swlm","tag_id":"cjtsnz0fy006ilixunksrig92","_id":"cjtsnz0g0006tlixulpx6qbzt"},{"post_id":"cjtsnz0dn002clixu1s6iu6q3","tag_id":"cjtsnz0fz006llixu01qpbcco","_id":"cjtsnz0g1006vlixubbanslnd"},{"post_id":"cjtsnz0dn002clixu1s6iu6q3","tag_id":"cjtsnz0fz006olixu76bnd32n","_id":"cjtsnz0g1006wlixua3clnb68"},{"post_id":"cjtsnz0dn002clixu1s6iu6q3","tag_id":"cjtsnz0g0006rlixurc33yika","_id":"cjtsnz0g2006ylixuzatvwgg4"},{"post_id":"cjtsnz0do002elixuueyme5vy","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0g20070lixuu3y1n5l8"},{"post_id":"cjtsnz0do002elixuueyme5vy","tag_id":"cjtsnz0g0006rlixurc33yika","_id":"cjtsnz0g20071lixuo5wzyu3p"},{"post_id":"cjtsnz0do002elixuueyme5vy","tag_id":"cjtsnz0g1006xlixudjo60wg7","_id":"cjtsnz0g30073lixull8g7pic"},{"post_id":"cjtsnz0dq002hlixuk3g64cbl","tag_id":"cjtsnz0g2006zlixuaf2zol6r","_id":"cjtsnz0g30074lixusdw1bakl"},{"post_id":"cjtsnz0dr002jlixuledyxw1t","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0g30076lixu9su5jmlg"},{"post_id":"cjtsnz0dr002jlixuledyxw1t","tag_id":"cjtsnz0g20072lixuy3enve80","_id":"cjtsnz0g40077lixuyqn1gzo5"},{"post_id":"cjtsnz0dt002llixu4jad54tc","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0g40079lixuintnnpt0"},{"post_id":"cjtsnz0dt002llixu4jad54tc","tag_id":"cjtsnz0g30075lixuihe10rnx","_id":"cjtsnz0g4007alixueqfvaqyk"},{"post_id":"cjtsnz0du002olixung9o74h8","tag_id":"cjtsnz0g40078lixuprk2voxd","_id":"cjtsnz0g6007flixueoxicld4"},{"post_id":"cjtsnz0du002olixung9o74h8","tag_id":"cjtsnz0g4007blixuva2oyofz","_id":"cjtsnz0g6007glixuf2l317sr"},{"post_id":"cjtsnz0du002olixung9o74h8","tag_id":"cjtsnz0fz006olixu76bnd32n","_id":"cjtsnz0g6007ilixuc2cotxkz"},{"post_id":"cjtsnz0du002olixung9o74h8","tag_id":"cjtsnz0g5007dlixu01vj3yrk","_id":"cjtsnz0g7007jlixu3rl9nnir"},{"post_id":"cjtsnz0dx002tlixu6rtbeodm","tag_id":"cjtsnz0g5007elixuhrzh9os1","_id":"cjtsnz0g8007llixupxjwct4c"},{"post_id":"cjtsnz0dx002tlixu6rtbeodm","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0g8007mlixurprtq966"},{"post_id":"cjtsnz0dx002tlixu6rtbeodm","tag_id":"cjtsnz0g6007hlixuoum0mek4","_id":"cjtsnz0g9007olixuocjjy5bx"},{"post_id":"cjtsnz0dz002ylixu3pwj7iew","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0g9007plixufis6ao4w"},{"post_id":"cjtsnz0dz002ylixu3pwj7iew","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0g9007rlixujp40vwwj"},{"post_id":"cjtsnz0dz002ylixu3pwj7iew","tag_id":"cjtsnz0g7007klixulowdwt30","_id":"cjtsnz0g9007slixum3abs6fj"},{"post_id":"cjtsnz0e20030lixuohw3f5o6","tag_id":"cjtsnz0g8007nlixuw9srdyi6","_id":"cjtsnz0ga007ulixulgow90zp"},{"post_id":"cjtsnz0e80033lixupfurrrno","tag_id":"cjtsnz0g9007qlixup4nyo4vz","_id":"cjtsnz0ga007vlixu26fk4c1o"},{"post_id":"cjtsnz0ea0035lixue0f6ul20","tag_id":"cjtsnz0fz006olixu76bnd32n","_id":"cjtsnz0gc007ylixu3r14x97k"},{"post_id":"cjtsnz0ea0035lixue0f6ul20","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0gc007zlixu89izilp0"},{"post_id":"cjtsnz0ea0035lixue0f6ul20","tag_id":"cjtsnz0g20072lixuy3enve80","_id":"cjtsnz0gc0081lixuyp87kloj"},{"post_id":"cjtsnz0eb0036lixu2ipiyd2e","tag_id":"cjtsnz0gb007xlixuems2ofzw","_id":"cjtsnz0gd0083lixuecv89ljp"},{"post_id":"cjtsnz0eb0036lixu2ipiyd2e","tag_id":"cjtsnz0g20072lixuy3enve80","_id":"cjtsnz0gd0084lixu1ej0fy1l"},{"post_id":"cjtsnz0ec0039lixua0t5xcn9","tag_id":"cjtsnz0gd0082lixu156pk81k","_id":"cjtsnz0gf0088lixuw6hfn8zq"},{"post_id":"cjtsnz0ec0039lixua0t5xcn9","tag_id":"cjtsnz0gd0085lixumhopb8x5","_id":"cjtsnz0gf0089lixu2ca7y3xf"},{"post_id":"cjtsnz0ec0039lixua0t5xcn9","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0gf008blixuqkuq6n3j"},{"post_id":"cjtsnz0ec0039lixua0t5xcn9","tag_id":"cjtsnz0ge0086lixu6v4qw4mx","_id":"cjtsnz0gf008clixu5m30r4na"},{"post_id":"cjtsnz0ee003blixuz6xkp0ff","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0gg008elixummqca8lk"},{"post_id":"cjtsnz0ee003blixuz6xkp0ff","tag_id":"cjtsnz0fz006olixu76bnd32n","_id":"cjtsnz0gg008flixuroq61em0"},{"post_id":"cjtsnz0eh003elixucxwvru9n","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0gh008hlixufjxs1xkc"},{"post_id":"cjtsnz0eh003elixucxwvru9n","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0gh008ilixubzjt0039"},{"post_id":"cjtsnz0eh003elixucxwvru9n","tag_id":"cjtsnz0gf008alixuclxqkii5","_id":"cjtsnz0gi008klixu6yyif9a4"},{"post_id":"cjtsnz0ek003jlixu06zp9kkw","tag_id":"cjtsnz0g0006rlixurc33yika","_id":"cjtsnz0gk008nlixukkjfn8xb"},{"post_id":"cjtsnz0ek003jlixu06zp9kkw","tag_id":"cjtsnz0eo003mlixujtkgtux2","_id":"cjtsnz0gk008olixuok6ejraq"},{"post_id":"cjtsnz0ek003jlixu06zp9kkw","tag_id":"cjtsnz0gh008jlixut0y73i47","_id":"cjtsnz0gl008qlixucxjbpz7i"},{"post_id":"cjtsnz0ek003jlixu06zp9kkw","tag_id":"cjtsnz0gi008llixujsytstg9","_id":"cjtsnz0gl008rlixu7jcyksqy"},{"post_id":"cjtsnz0en003llixu4texq9qc","tag_id":"cjtsnz0dg0020lixuor418vun","_id":"cjtsnz0gl008tlixuqwzz12ew"},{"post_id":"cjtsnz0en003llixu4texq9qc","tag_id":"cjtsnz0gj008mlixuhs1gzkyo","_id":"cjtsnz0gl008ulixur29hw9u3"},{"post_id":"cjtsnz0ep003nlixuefrz6szh","tag_id":"cjtsnz0g5007dlixu01vj3yrk","_id":"cjtsnz0gn008xlixuebl1ri8y"},{"post_id":"cjtsnz0ep003nlixuefrz6szh","tag_id":"cjtsnz0gl008slixuvp314se3","_id":"cjtsnz0gn008ylixuw9e7q299"},{"post_id":"cjtsnz0ep003nlixuefrz6szh","tag_id":"cjtsnz0g0006rlixurc33yika","_id":"cjtsnz0gn0090lixuf76xsyu6"},{"post_id":"cjtsnz0eq003plixuywbp2tl4","tag_id":"cjtsnz0cb000jlixuahmhwudy","_id":"cjtsnz0go0091lixujsfem7pi"},{"post_id":"cjtsnz0eq003plixuywbp2tl4","tag_id":"cjtsnz0g30075lixuihe10rnx","_id":"cjtsnz0go0092lixu0s4zaz6j"},{"post_id":"cjtsnz0ew003zlixusacojhyz","tag_id":"cjtsnz0fz006olixu76bnd32n","_id":"cjtsnz0go0093lixuj635vd6u"}],"Tag":[{"name":"DevOps","_id":"cjtsnz0bm0004lixu6j2e8q8c"},{"name":"LCTT 翻译","_id":"cjtsnz0bt0008lixuizdcm7yz"},{"name":"无服务器架构","_id":"cjtsnz0c3000blixugx94jnlq"},{"name":"Linux","_id":"cjtsnz0cb000jlixuahmhwudy"},{"name":"浏览器","_id":"cjtsnz0cf000olixusd3knwf3"},{"name":"安全","_id":"cjtsnz0ci000slixuuv3j9vt0"},{"name":"截屏","_id":"cjtsnz0cz001dlixue6lx9ad3"},{"name":"可视化","_id":"cjtsnz0d7001llixuglzr2mqc"},{"name":"告警","_id":"cjtsnz0da001qlixuk9t8jhp8"},{"name":"数据库","_id":"cjtsnz0dd001vlixujomzk2y9"},{"name":"Python","_id":"cjtsnz0dg0020lixuor418vun"},{"name":"应用","_id":"cjtsnz0dn002alixugx82vqjx"},{"name":"命令","_id":"cjtsnz0dp002flixul16kr0y9"},{"name":"Android","_id":"cjtsnz0dt002mlixuqn4zrllm"},{"name":"Ansible","_id":"cjtsnz0dw002rlixutxfh8ivy"},{"name":"Bash","_id":"cjtsnz0dz002wlixuj4wwmzkm"},{"name":"环境变量","_id":"cjtsnz0e30031lixud4ifi35p"},{"name":"版本","_id":"cjtsnz0eg003clixu8kgi1wkb"},{"name":"发行版","_id":"cjtsnz0ej003hlixu3lup14cl"},{"name":"git","_id":"cjtsnz0eo003mlixujtkgtux2"},{"name":"SQL","_id":"cjtsnz0er003rlixuhvnngwm7"},{"name":"cron","_id":"cjtsnz0ey0042lixu4zqoh8kk"},{"name":"端口","_id":"cjtsnz0f10047lixuduw84bk5"},{"name":"网络","_id":"cjtsnz0f2004blixufsll2kp2"},{"name":"软件包","_id":"cjtsnz0f3004elixudgb56kcj"},{"name":"双系统","_id":"cjtsnz0f3004hlixum60judeq"},{"name":"rar","_id":"cjtsnz0f4004klixuxlz3zftc"},{"name":"树莓派","_id":"cjtsnz0f4004olixu2fpux0yx"},{"name":"随机","_id":"cjtsnz0fl0050lixu3iuneb9n"},{"name":"机器学习","_id":"cjtsnz0fn0056lixubxs6v9n1"},{"name":"ping","_id":"cjtsnz0fn0059lixu0g7sbwkf"},{"name":"加密","_id":"cjtsnz0fo005dlixutb33x6v3"},{"name":"Mac","_id":"cjtsnz0fp005jlixulltyrmr7"},{"name":"Wi-Fi","_id":"cjtsnz0fq005mlixuh9bpgdut"},{"name":"DoS","_id":"cjtsnz0fs005slixuo3zwthkj"},{"name":"top","_id":"cjtsnz0fs005wlixu5uqcr9it"},{"name":"管道","_id":"cjtsnz0fv0065lixu73nmeewe"},{"name":"内存","_id":"cjtsnz0fx006blixu2dqr3nil"},{"name":"GPL","_id":"cjtsnz0fy006elixuh5ises1e"},{"name":"YAML","_id":"cjtsnz0fy006ilixunksrig92"},{"name":"Docker","_id":"cjtsnz0fz006llixu01qpbcco"},{"name":"MySQL","_id":"cjtsnz0fz006olixu76bnd32n"},{"name":"坑","_id":"cjtsnz0g0006rlixurc33yika"},{"name":"正则表达式","_id":"cjtsnz0g1006xlixudjo60wg7"},{"name":"文档","_id":"cjtsnz0g2006zlixuaf2zol6r"},{"name":"奇技淫巧","_id":"cjtsnz0g20072lixuy3enve80"},{"name":"ssh","_id":"cjtsnz0g30075lixuihe10rnx"},{"name":"Apache","_id":"cjtsnz0g40078lixuprk2voxd"},{"name":"LAMP","_id":"cjtsnz0g4007blixuva2oyofz"},{"name":"PHP","_id":"cjtsnz0g5007dlixu01vj3yrk"},{"name":"Windows","_id":"cjtsnz0g5007elixuhrzh9os1"},{"name":"编码","_id":"cjtsnz0g6007hlixuoum0mek4"},{"name":"快速安装","_id":"cjtsnz0g7007klixulowdwt30"},{"name":"Ruby","_id":"cjtsnz0g8007nlixuw9srdyi6"},{"name":"zsh","_id":"cjtsnz0g9007qlixup4nyo4vz"},{"name":"vim","_id":"cjtsnz0gb007xlixuems2ofzw"},{"name":"Firefox","_id":"cjtsnz0gd0082lixu156pk81k"},{"name":"PhantomJS","_id":"cjtsnz0gd0085lixumhopb8x5"},{"name":"Selenium","_id":"cjtsnz0ge0086lixu6v4qw4mx"},{"name":"Saltstack","_id":"cjtsnz0gf008alixuclxqkii5"},{"name":"GitHub","_id":"cjtsnz0gh008jlixut0y73i47"},{"name":"hexo","_id":"cjtsnz0gi008llixujsytstg9"},{"name":"类","_id":"cjtsnz0gj008mlixuhs1gzkyo"},{"name":"WordPress","_id":"cjtsnz0gl008slixuvp314se3"}]}}